
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model WelcomeLeaveImageData
 * 
 */
export type WelcomeLeaveImageData = $Result.DefaultSelection<Prisma.$WelcomeLeaveImageDataPayload>
/**
 * Model PermissionData
 * 
 */
export type PermissionData = $Result.DefaultSelection<Prisma.$PermissionDataPayload>
/**
 * Model ReactionRoleSelectmenu
 * 
 */
export type ReactionRoleSelectmenu = $Result.DefaultSelection<Prisma.$ReactionRoleSelectmenuPayload>
/**
 * Model ReactionRoleButton
 * 
 */
export type ReactionRoleButton = $Result.DefaultSelection<Prisma.$ReactionRoleButtonPayload>
/**
 * Model BotStatus
 * 
 */
export type BotStatus = $Result.DefaultSelection<Prisma.$BotStatusPayload>
/**
 * Model DisbotsLogs
 * 
 */
export type DisbotsLogs = $Result.DefaultSelection<Prisma.$DisbotsLogsPayload>
/**
 * Model Guilds
 * 
 */
export type Guilds = $Result.DefaultSelection<Prisma.$GuildsPayload>
/**
 * Model AutoDeletes
 * 
 */
export type AutoDeletes = $Result.DefaultSelection<Prisma.$AutoDeletesPayload>
/**
 * Model AutoPublish
 * 
 */
export type AutoPublish = $Result.DefaultSelection<Prisma.$AutoPublishPayload>
/**
 * Model AutoReacts
 * 
 */
export type AutoReacts = $Result.DefaultSelection<Prisma.$AutoReactsPayload>
/**
 * Model AutoRoles
 * 
 */
export type AutoRoles = $Result.DefaultSelection<Prisma.$AutoRolesPayload>
/**
 * Model GuildBans
 * 
 */
export type GuildBans = $Result.DefaultSelection<Prisma.$GuildBansPayload>
/**
 * Model ChatModerations
 * 
 */
export type ChatModerations = $Result.DefaultSelection<Prisma.$ChatModerationsPayload>
/**
 * Model ChannelLinks
 * 
 */
export type ChannelLinks = $Result.DefaultSelection<Prisma.$ChannelLinksPayload>
/**
 * Model SyncedChannelLinkMessages
 * 
 */
export type SyncedChannelLinkMessages = $Result.DefaultSelection<Prisma.$SyncedChannelLinkMessagesPayload>
/**
 * Model DiscordAddons
 * 
 */
export type DiscordAddons = $Result.DefaultSelection<Prisma.$DiscordAddonsPayload>
/**
 * Model Giveaways
 * 
 */
export type Giveaways = $Result.DefaultSelection<Prisma.$GiveawaysPayload>
/**
 * Model TempVoices
 * 
 */
export type TempVoices = $Result.DefaultSelection<Prisma.$TempVoicesPayload>
/**
 * Model TempVoiceChannels
 * 
 */
export type TempVoiceChannels = $Result.DefaultSelection<Prisma.$TempVoiceChannelsPayload>
/**
 * Model GuildLeaveSetups
 * 
 */
export type GuildLeaveSetups = $Result.DefaultSelection<Prisma.$GuildLeaveSetupsPayload>
/**
 * Model GuildWelcomeSetups
 * 
 */
export type GuildWelcomeSetups = $Result.DefaultSelection<Prisma.$GuildWelcomeSetupsPayload>
/**
 * Model GuildLoggings
 * 
 */
export type GuildLoggings = $Result.DefaultSelection<Prisma.$GuildLoggingsPayload>
/**
 * Model GuildLoggers
 * 
 */
export type GuildLoggers = $Result.DefaultSelection<Prisma.$GuildLoggersPayload>
/**
 * Model MessageTemplates
 * 
 */
export type MessageTemplates = $Result.DefaultSelection<Prisma.$MessageTemplatesPayload>
/**
 * Model Permissions
 * 
 */
export type Permissions = $Result.DefaultSelection<Prisma.$PermissionsPayload>
/**
 * Model ReactionRoles
 * 
 */
export type ReactionRoles = $Result.DefaultSelection<Prisma.$ReactionRolesPayload>
/**
 * Model Securitys
 * 
 */
export type Securitys = $Result.DefaultSelection<Prisma.$SecuritysPayload>
/**
 * Model VerificationGates
 * 
 */
export type VerificationGates = $Result.DefaultSelection<Prisma.$VerificationGatesPayload>
/**
 * Model VerificationGatesPermission
 * 
 */
export type VerificationGatesPermission = $Result.DefaultSelection<Prisma.$VerificationGatesPermissionPayload>
/**
 * Model SpotifyNotifications
 * 
 */
export type SpotifyNotifications = $Result.DefaultSelection<Prisma.$SpotifyNotificationsPayload>
/**
 * Model Tags
 * 
 */
export type Tags = $Result.DefaultSelection<Prisma.$TagsPayload>
/**
 * Model TicketSetups
 * 
 */
export type TicketSetups = $Result.DefaultSelection<Prisma.$TicketSetupsPayload>
/**
 * Model TicketModalData
 * 
 */
export type TicketModalData = $Result.DefaultSelection<Prisma.$TicketModalDataPayload>
/**
 * Model TicketHandlers
 * 
 */
export type TicketHandlers = $Result.DefaultSelection<Prisma.$TicketHandlersPayload>
/**
 * Model Tickets
 * 
 */
export type Tickets = $Result.DefaultSelection<Prisma.$TicketsPayload>
/**
 * Model TicketFeedback
 * 
 */
export type TicketFeedback = $Result.DefaultSelection<Prisma.$TicketFeedbackPayload>
/**
 * Model GuildFeatureToggles
 * 
 */
export type GuildFeatureToggles = $Result.DefaultSelection<Prisma.$GuildFeatureTogglesPayload>
/**
 * Model TwitchNotifications
 * 
 */
export type TwitchNotifications = $Result.DefaultSelection<Prisma.$TwitchNotificationsPayload>
/**
 * Model YoutubeNotifications
 * 
 */
export type YoutubeNotifications = $Result.DefaultSelection<Prisma.$YoutubeNotificationsPayload>
/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model Apis
 * 
 */
export type Apis = $Result.DefaultSelection<Prisma.$ApisPayload>
/**
 * Model GuildBackups
 * 
 */
export type GuildBackups = $Result.DefaultSelection<Prisma.$GuildBackupsPayload>
/**
 * Model Customers
 * 
 */
export type Customers = $Result.DefaultSelection<Prisma.$CustomersPayload>
/**
 * Model Vanitys
 * 
 */
export type Vanitys = $Result.DefaultSelection<Prisma.$VanitysPayload>
/**
 * Model VanityEmbeds
 * 
 */
export type VanityEmbeds = $Result.DefaultSelection<Prisma.$VanityEmbedsPayload>
/**
 * Model VanityEmbedAuthors
 * 
 */
export type VanityEmbedAuthors = $Result.DefaultSelection<Prisma.$VanityEmbedAuthorsPayload>
/**
 * Model VanityAnalytics
 * 
 */
export type VanityAnalytics = $Result.DefaultSelection<Prisma.$VanityAnalyticsPayload>
/**
 * Model AnalyticsLatest30Days
 * 
 */
export type AnalyticsLatest30Days = $Result.DefaultSelection<Prisma.$AnalyticsLatest30DaysPayload>
/**
 * Model DisBotUserNotifications
 * 
 */
export type DisBotUserNotifications = $Result.DefaultSelection<Prisma.$DisBotUserNotificationsPayload>
/**
 * Model DisBot
 * 
 */
export type DisBot = $Result.DefaultSelection<Prisma.$DisBotPayload>
/**
 * Model ImageApis
 * 
 */
export type ImageApis = $Result.DefaultSelection<Prisma.$ImageApisPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Guilds
 * const guilds = await prisma.guilds.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Guilds
   * const guilds = await prisma.guilds.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.guilds`: Exposes CRUD operations for the **Guilds** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guilds
    * const guilds = await prisma.guilds.findMany()
    * ```
    */
  get guilds(): Prisma.GuildsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.autoDeletes`: Exposes CRUD operations for the **AutoDeletes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutoDeletes
    * const autoDeletes = await prisma.autoDeletes.findMany()
    * ```
    */
  get autoDeletes(): Prisma.AutoDeletesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.autoPublish`: Exposes CRUD operations for the **AutoPublish** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutoPublishes
    * const autoPublishes = await prisma.autoPublish.findMany()
    * ```
    */
  get autoPublish(): Prisma.AutoPublishDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.autoReacts`: Exposes CRUD operations for the **AutoReacts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutoReacts
    * const autoReacts = await prisma.autoReacts.findMany()
    * ```
    */
  get autoReacts(): Prisma.AutoReactsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.autoRoles`: Exposes CRUD operations for the **AutoRoles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutoRoles
    * const autoRoles = await prisma.autoRoles.findMany()
    * ```
    */
  get autoRoles(): Prisma.AutoRolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guildBans`: Exposes CRUD operations for the **GuildBans** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuildBans
    * const guildBans = await prisma.guildBans.findMany()
    * ```
    */
  get guildBans(): Prisma.GuildBansDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatModerations`: Exposes CRUD operations for the **ChatModerations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatModerations
    * const chatModerations = await prisma.chatModerations.findMany()
    * ```
    */
  get chatModerations(): Prisma.ChatModerationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.channelLinks`: Exposes CRUD operations for the **ChannelLinks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChannelLinks
    * const channelLinks = await prisma.channelLinks.findMany()
    * ```
    */
  get channelLinks(): Prisma.ChannelLinksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.syncedChannelLinkMessages`: Exposes CRUD operations for the **SyncedChannelLinkMessages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncedChannelLinkMessages
    * const syncedChannelLinkMessages = await prisma.syncedChannelLinkMessages.findMany()
    * ```
    */
  get syncedChannelLinkMessages(): Prisma.SyncedChannelLinkMessagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.discordAddons`: Exposes CRUD operations for the **DiscordAddons** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiscordAddons
    * const discordAddons = await prisma.discordAddons.findMany()
    * ```
    */
  get discordAddons(): Prisma.DiscordAddonsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.giveaways`: Exposes CRUD operations for the **Giveaways** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Giveaways
    * const giveaways = await prisma.giveaways.findMany()
    * ```
    */
  get giveaways(): Prisma.GiveawaysDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tempVoices`: Exposes CRUD operations for the **TempVoices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TempVoices
    * const tempVoices = await prisma.tempVoices.findMany()
    * ```
    */
  get tempVoices(): Prisma.TempVoicesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tempVoiceChannels`: Exposes CRUD operations for the **TempVoiceChannels** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TempVoiceChannels
    * const tempVoiceChannels = await prisma.tempVoiceChannels.findMany()
    * ```
    */
  get tempVoiceChannels(): Prisma.TempVoiceChannelsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guildLeaveSetups`: Exposes CRUD operations for the **GuildLeaveSetups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuildLeaveSetups
    * const guildLeaveSetups = await prisma.guildLeaveSetups.findMany()
    * ```
    */
  get guildLeaveSetups(): Prisma.GuildLeaveSetupsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guildWelcomeSetups`: Exposes CRUD operations for the **GuildWelcomeSetups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuildWelcomeSetups
    * const guildWelcomeSetups = await prisma.guildWelcomeSetups.findMany()
    * ```
    */
  get guildWelcomeSetups(): Prisma.GuildWelcomeSetupsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guildLoggings`: Exposes CRUD operations for the **GuildLoggings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuildLoggings
    * const guildLoggings = await prisma.guildLoggings.findMany()
    * ```
    */
  get guildLoggings(): Prisma.GuildLoggingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guildLoggers`: Exposes CRUD operations for the **GuildLoggers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuildLoggers
    * const guildLoggers = await prisma.guildLoggers.findMany()
    * ```
    */
  get guildLoggers(): Prisma.GuildLoggersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageTemplates`: Exposes CRUD operations for the **MessageTemplates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageTemplates
    * const messageTemplates = await prisma.messageTemplates.findMany()
    * ```
    */
  get messageTemplates(): Prisma.MessageTemplatesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permissions`: Exposes CRUD operations for the **Permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permissions.findMany()
    * ```
    */
  get permissions(): Prisma.PermissionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reactionRoles`: Exposes CRUD operations for the **ReactionRoles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReactionRoles
    * const reactionRoles = await prisma.reactionRoles.findMany()
    * ```
    */
  get reactionRoles(): Prisma.ReactionRolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.securitys`: Exposes CRUD operations for the **Securitys** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Securitys
    * const securitys = await prisma.securitys.findMany()
    * ```
    */
  get securitys(): Prisma.SecuritysDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationGates`: Exposes CRUD operations for the **VerificationGates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationGates
    * const verificationGates = await prisma.verificationGates.findMany()
    * ```
    */
  get verificationGates(): Prisma.VerificationGatesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationGatesPermission`: Exposes CRUD operations for the **VerificationGatesPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationGatesPermissions
    * const verificationGatesPermissions = await prisma.verificationGatesPermission.findMany()
    * ```
    */
  get verificationGatesPermission(): Prisma.VerificationGatesPermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.spotifyNotifications`: Exposes CRUD operations for the **SpotifyNotifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpotifyNotifications
    * const spotifyNotifications = await prisma.spotifyNotifications.findMany()
    * ```
    */
  get spotifyNotifications(): Prisma.SpotifyNotificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tags`: Exposes CRUD operations for the **Tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tags.findMany()
    * ```
    */
  get tags(): Prisma.TagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketSetups`: Exposes CRUD operations for the **TicketSetups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketSetups
    * const ticketSetups = await prisma.ticketSetups.findMany()
    * ```
    */
  get ticketSetups(): Prisma.TicketSetupsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketModalData`: Exposes CRUD operations for the **TicketModalData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketModalData
    * const ticketModalData = await prisma.ticketModalData.findMany()
    * ```
    */
  get ticketModalData(): Prisma.TicketModalDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketHandlers`: Exposes CRUD operations for the **TicketHandlers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketHandlers
    * const ticketHandlers = await prisma.ticketHandlers.findMany()
    * ```
    */
  get ticketHandlers(): Prisma.TicketHandlersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tickets`: Exposes CRUD operations for the **Tickets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.tickets.findMany()
    * ```
    */
  get tickets(): Prisma.TicketsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketFeedback`: Exposes CRUD operations for the **TicketFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketFeedbacks
    * const ticketFeedbacks = await prisma.ticketFeedback.findMany()
    * ```
    */
  get ticketFeedback(): Prisma.TicketFeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guildFeatureToggles`: Exposes CRUD operations for the **GuildFeatureToggles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuildFeatureToggles
    * const guildFeatureToggles = await prisma.guildFeatureToggles.findMany()
    * ```
    */
  get guildFeatureToggles(): Prisma.GuildFeatureTogglesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.twitchNotifications`: Exposes CRUD operations for the **TwitchNotifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitchNotifications
    * const twitchNotifications = await prisma.twitchNotifications.findMany()
    * ```
    */
  get twitchNotifications(): Prisma.TwitchNotificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.youtubeNotifications`: Exposes CRUD operations for the **YoutubeNotifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeNotifications
    * const youtubeNotifications = await prisma.youtubeNotifications.findMany()
    * ```
    */
  get youtubeNotifications(): Prisma.YoutubeNotificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apis`: Exposes CRUD operations for the **Apis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Apis
    * const apis = await prisma.apis.findMany()
    * ```
    */
  get apis(): Prisma.ApisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guildBackups`: Exposes CRUD operations for the **GuildBackups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuildBackups
    * const guildBackups = await prisma.guildBackups.findMany()
    * ```
    */
  get guildBackups(): Prisma.GuildBackupsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customers`: Exposes CRUD operations for the **Customers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customers.findMany()
    * ```
    */
  get customers(): Prisma.CustomersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vanitys`: Exposes CRUD operations for the **Vanitys** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vanitys
    * const vanitys = await prisma.vanitys.findMany()
    * ```
    */
  get vanitys(): Prisma.VanitysDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vanityEmbeds`: Exposes CRUD operations for the **VanityEmbeds** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VanityEmbeds
    * const vanityEmbeds = await prisma.vanityEmbeds.findMany()
    * ```
    */
  get vanityEmbeds(): Prisma.VanityEmbedsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vanityEmbedAuthors`: Exposes CRUD operations for the **VanityEmbedAuthors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VanityEmbedAuthors
    * const vanityEmbedAuthors = await prisma.vanityEmbedAuthors.findMany()
    * ```
    */
  get vanityEmbedAuthors(): Prisma.VanityEmbedAuthorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vanityAnalytics`: Exposes CRUD operations for the **VanityAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VanityAnalytics
    * const vanityAnalytics = await prisma.vanityAnalytics.findMany()
    * ```
    */
  get vanityAnalytics(): Prisma.VanityAnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analyticsLatest30Days`: Exposes CRUD operations for the **AnalyticsLatest30Days** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsLatest30Days
    * const analyticsLatest30Days = await prisma.analyticsLatest30Days.findMany()
    * ```
    */
  get analyticsLatest30Days(): Prisma.AnalyticsLatest30DaysDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.disBotUserNotifications`: Exposes CRUD operations for the **DisBotUserNotifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DisBotUserNotifications
    * const disBotUserNotifications = await prisma.disBotUserNotifications.findMany()
    * ```
    */
  get disBotUserNotifications(): Prisma.DisBotUserNotificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.disBot`: Exposes CRUD operations for the **DisBot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DisBots
    * const disBots = await prisma.disBot.findMany()
    * ```
    */
  get disBot(): Prisma.DisBotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.imageApis`: Exposes CRUD operations for the **ImageApis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImageApis
    * const imageApis = await prisma.imageApis.findMany()
    * ```
    */
  get imageApis(): Prisma.ImageApisDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Guilds: 'Guilds',
    AutoDeletes: 'AutoDeletes',
    AutoPublish: 'AutoPublish',
    AutoReacts: 'AutoReacts',
    AutoRoles: 'AutoRoles',
    GuildBans: 'GuildBans',
    ChatModerations: 'ChatModerations',
    ChannelLinks: 'ChannelLinks',
    SyncedChannelLinkMessages: 'SyncedChannelLinkMessages',
    DiscordAddons: 'DiscordAddons',
    Giveaways: 'Giveaways',
    TempVoices: 'TempVoices',
    TempVoiceChannels: 'TempVoiceChannels',
    GuildLeaveSetups: 'GuildLeaveSetups',
    GuildWelcomeSetups: 'GuildWelcomeSetups',
    GuildLoggings: 'GuildLoggings',
    GuildLoggers: 'GuildLoggers',
    MessageTemplates: 'MessageTemplates',
    Permissions: 'Permissions',
    ReactionRoles: 'ReactionRoles',
    Securitys: 'Securitys',
    VerificationGates: 'VerificationGates',
    VerificationGatesPermission: 'VerificationGatesPermission',
    SpotifyNotifications: 'SpotifyNotifications',
    Tags: 'Tags',
    TicketSetups: 'TicketSetups',
    TicketModalData: 'TicketModalData',
    TicketHandlers: 'TicketHandlers',
    Tickets: 'Tickets',
    TicketFeedback: 'TicketFeedback',
    GuildFeatureToggles: 'GuildFeatureToggles',
    TwitchNotifications: 'TwitchNotifications',
    YoutubeNotifications: 'YoutubeNotifications',
    Users: 'Users',
    Apis: 'Apis',
    GuildBackups: 'GuildBackups',
    Customers: 'Customers',
    Vanitys: 'Vanitys',
    VanityEmbeds: 'VanityEmbeds',
    VanityEmbedAuthors: 'VanityEmbedAuthors',
    VanityAnalytics: 'VanityAnalytics',
    AnalyticsLatest30Days: 'AnalyticsLatest30Days',
    DisBotUserNotifications: 'DisBotUserNotifications',
    DisBot: 'DisBot',
    ImageApis: 'ImageApis'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "guilds" | "autoDeletes" | "autoPublish" | "autoReacts" | "autoRoles" | "guildBans" | "chatModerations" | "channelLinks" | "syncedChannelLinkMessages" | "discordAddons" | "giveaways" | "tempVoices" | "tempVoiceChannels" | "guildLeaveSetups" | "guildWelcomeSetups" | "guildLoggings" | "guildLoggers" | "messageTemplates" | "permissions" | "reactionRoles" | "securitys" | "verificationGates" | "verificationGatesPermission" | "spotifyNotifications" | "tags" | "ticketSetups" | "ticketModalData" | "ticketHandlers" | "tickets" | "ticketFeedback" | "guildFeatureToggles" | "twitchNotifications" | "youtubeNotifications" | "users" | "apis" | "guildBackups" | "customers" | "vanitys" | "vanityEmbeds" | "vanityEmbedAuthors" | "vanityAnalytics" | "analyticsLatest30Days" | "disBotUserNotifications" | "disBot" | "imageApis"
      txIsolationLevel: never
    }
    model: {
      Guilds: {
        payload: Prisma.$GuildsPayload<ExtArgs>
        fields: Prisma.GuildsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuildsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuildsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildsPayload>
          }
          findFirst: {
            args: Prisma.GuildsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuildsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildsPayload>
          }
          findMany: {
            args: Prisma.GuildsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildsPayload>[]
          }
          create: {
            args: Prisma.GuildsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildsPayload>
          }
          createMany: {
            args: Prisma.GuildsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GuildsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildsPayload>
          }
          update: {
            args: Prisma.GuildsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildsPayload>
          }
          deleteMany: {
            args: Prisma.GuildsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuildsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GuildsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildsPayload>
          }
          aggregate: {
            args: Prisma.GuildsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuilds>
          }
          groupBy: {
            args: Prisma.GuildsGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuildsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.GuildsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.GuildsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.GuildsCountArgs<ExtArgs>
            result: $Utils.Optional<GuildsCountAggregateOutputType> | number
          }
        }
      }
      AutoDeletes: {
        payload: Prisma.$AutoDeletesPayload<ExtArgs>
        fields: Prisma.AutoDeletesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutoDeletesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoDeletesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutoDeletesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoDeletesPayload>
          }
          findFirst: {
            args: Prisma.AutoDeletesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoDeletesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutoDeletesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoDeletesPayload>
          }
          findMany: {
            args: Prisma.AutoDeletesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoDeletesPayload>[]
          }
          create: {
            args: Prisma.AutoDeletesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoDeletesPayload>
          }
          createMany: {
            args: Prisma.AutoDeletesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AutoDeletesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoDeletesPayload>
          }
          update: {
            args: Prisma.AutoDeletesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoDeletesPayload>
          }
          deleteMany: {
            args: Prisma.AutoDeletesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutoDeletesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutoDeletesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoDeletesPayload>
          }
          aggregate: {
            args: Prisma.AutoDeletesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutoDeletes>
          }
          groupBy: {
            args: Prisma.AutoDeletesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutoDeletesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AutoDeletesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AutoDeletesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AutoDeletesCountArgs<ExtArgs>
            result: $Utils.Optional<AutoDeletesCountAggregateOutputType> | number
          }
        }
      }
      AutoPublish: {
        payload: Prisma.$AutoPublishPayload<ExtArgs>
        fields: Prisma.AutoPublishFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutoPublishFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoPublishPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutoPublishFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoPublishPayload>
          }
          findFirst: {
            args: Prisma.AutoPublishFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoPublishPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutoPublishFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoPublishPayload>
          }
          findMany: {
            args: Prisma.AutoPublishFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoPublishPayload>[]
          }
          create: {
            args: Prisma.AutoPublishCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoPublishPayload>
          }
          createMany: {
            args: Prisma.AutoPublishCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AutoPublishDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoPublishPayload>
          }
          update: {
            args: Prisma.AutoPublishUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoPublishPayload>
          }
          deleteMany: {
            args: Prisma.AutoPublishDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutoPublishUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutoPublishUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoPublishPayload>
          }
          aggregate: {
            args: Prisma.AutoPublishAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutoPublish>
          }
          groupBy: {
            args: Prisma.AutoPublishGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutoPublishGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AutoPublishFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AutoPublishAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AutoPublishCountArgs<ExtArgs>
            result: $Utils.Optional<AutoPublishCountAggregateOutputType> | number
          }
        }
      }
      AutoReacts: {
        payload: Prisma.$AutoReactsPayload<ExtArgs>
        fields: Prisma.AutoReactsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutoReactsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoReactsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutoReactsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoReactsPayload>
          }
          findFirst: {
            args: Prisma.AutoReactsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoReactsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutoReactsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoReactsPayload>
          }
          findMany: {
            args: Prisma.AutoReactsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoReactsPayload>[]
          }
          create: {
            args: Prisma.AutoReactsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoReactsPayload>
          }
          createMany: {
            args: Prisma.AutoReactsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AutoReactsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoReactsPayload>
          }
          update: {
            args: Prisma.AutoReactsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoReactsPayload>
          }
          deleteMany: {
            args: Prisma.AutoReactsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutoReactsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutoReactsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoReactsPayload>
          }
          aggregate: {
            args: Prisma.AutoReactsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutoReacts>
          }
          groupBy: {
            args: Prisma.AutoReactsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutoReactsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AutoReactsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AutoReactsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AutoReactsCountArgs<ExtArgs>
            result: $Utils.Optional<AutoReactsCountAggregateOutputType> | number
          }
        }
      }
      AutoRoles: {
        payload: Prisma.$AutoRolesPayload<ExtArgs>
        fields: Prisma.AutoRolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutoRolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoRolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutoRolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoRolesPayload>
          }
          findFirst: {
            args: Prisma.AutoRolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoRolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutoRolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoRolesPayload>
          }
          findMany: {
            args: Prisma.AutoRolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoRolesPayload>[]
          }
          create: {
            args: Prisma.AutoRolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoRolesPayload>
          }
          createMany: {
            args: Prisma.AutoRolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AutoRolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoRolesPayload>
          }
          update: {
            args: Prisma.AutoRolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoRolesPayload>
          }
          deleteMany: {
            args: Prisma.AutoRolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutoRolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutoRolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoRolesPayload>
          }
          aggregate: {
            args: Prisma.AutoRolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutoRoles>
          }
          groupBy: {
            args: Prisma.AutoRolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutoRolesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AutoRolesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AutoRolesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AutoRolesCountArgs<ExtArgs>
            result: $Utils.Optional<AutoRolesCountAggregateOutputType> | number
          }
        }
      }
      GuildBans: {
        payload: Prisma.$GuildBansPayload<ExtArgs>
        fields: Prisma.GuildBansFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuildBansFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBansPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuildBansFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBansPayload>
          }
          findFirst: {
            args: Prisma.GuildBansFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBansPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuildBansFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBansPayload>
          }
          findMany: {
            args: Prisma.GuildBansFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBansPayload>[]
          }
          create: {
            args: Prisma.GuildBansCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBansPayload>
          }
          createMany: {
            args: Prisma.GuildBansCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GuildBansDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBansPayload>
          }
          update: {
            args: Prisma.GuildBansUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBansPayload>
          }
          deleteMany: {
            args: Prisma.GuildBansDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuildBansUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GuildBansUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBansPayload>
          }
          aggregate: {
            args: Prisma.GuildBansAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuildBans>
          }
          groupBy: {
            args: Prisma.GuildBansGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuildBansGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.GuildBansFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.GuildBansAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.GuildBansCountArgs<ExtArgs>
            result: $Utils.Optional<GuildBansCountAggregateOutputType> | number
          }
        }
      }
      ChatModerations: {
        payload: Prisma.$ChatModerationsPayload<ExtArgs>
        fields: Prisma.ChatModerationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatModerationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatModerationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatModerationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatModerationsPayload>
          }
          findFirst: {
            args: Prisma.ChatModerationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatModerationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatModerationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatModerationsPayload>
          }
          findMany: {
            args: Prisma.ChatModerationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatModerationsPayload>[]
          }
          create: {
            args: Prisma.ChatModerationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatModerationsPayload>
          }
          createMany: {
            args: Prisma.ChatModerationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChatModerationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatModerationsPayload>
          }
          update: {
            args: Prisma.ChatModerationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatModerationsPayload>
          }
          deleteMany: {
            args: Prisma.ChatModerationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatModerationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatModerationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatModerationsPayload>
          }
          aggregate: {
            args: Prisma.ChatModerationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatModerations>
          }
          groupBy: {
            args: Prisma.ChatModerationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatModerationsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ChatModerationsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ChatModerationsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ChatModerationsCountArgs<ExtArgs>
            result: $Utils.Optional<ChatModerationsCountAggregateOutputType> | number
          }
        }
      }
      ChannelLinks: {
        payload: Prisma.$ChannelLinksPayload<ExtArgs>
        fields: Prisma.ChannelLinksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelLinksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelLinksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelLinksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelLinksPayload>
          }
          findFirst: {
            args: Prisma.ChannelLinksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelLinksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelLinksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelLinksPayload>
          }
          findMany: {
            args: Prisma.ChannelLinksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelLinksPayload>[]
          }
          create: {
            args: Prisma.ChannelLinksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelLinksPayload>
          }
          createMany: {
            args: Prisma.ChannelLinksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChannelLinksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelLinksPayload>
          }
          update: {
            args: Prisma.ChannelLinksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelLinksPayload>
          }
          deleteMany: {
            args: Prisma.ChannelLinksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelLinksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChannelLinksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelLinksPayload>
          }
          aggregate: {
            args: Prisma.ChannelLinksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannelLinks>
          }
          groupBy: {
            args: Prisma.ChannelLinksGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelLinksGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ChannelLinksFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ChannelLinksAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ChannelLinksCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelLinksCountAggregateOutputType> | number
          }
        }
      }
      SyncedChannelLinkMessages: {
        payload: Prisma.$SyncedChannelLinkMessagesPayload<ExtArgs>
        fields: Prisma.SyncedChannelLinkMessagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyncedChannelLinkMessagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncedChannelLinkMessagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyncedChannelLinkMessagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncedChannelLinkMessagesPayload>
          }
          findFirst: {
            args: Prisma.SyncedChannelLinkMessagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncedChannelLinkMessagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyncedChannelLinkMessagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncedChannelLinkMessagesPayload>
          }
          findMany: {
            args: Prisma.SyncedChannelLinkMessagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncedChannelLinkMessagesPayload>[]
          }
          create: {
            args: Prisma.SyncedChannelLinkMessagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncedChannelLinkMessagesPayload>
          }
          createMany: {
            args: Prisma.SyncedChannelLinkMessagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SyncedChannelLinkMessagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncedChannelLinkMessagesPayload>
          }
          update: {
            args: Prisma.SyncedChannelLinkMessagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncedChannelLinkMessagesPayload>
          }
          deleteMany: {
            args: Prisma.SyncedChannelLinkMessagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyncedChannelLinkMessagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SyncedChannelLinkMessagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncedChannelLinkMessagesPayload>
          }
          aggregate: {
            args: Prisma.SyncedChannelLinkMessagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyncedChannelLinkMessages>
          }
          groupBy: {
            args: Prisma.SyncedChannelLinkMessagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyncedChannelLinkMessagesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SyncedChannelLinkMessagesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SyncedChannelLinkMessagesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SyncedChannelLinkMessagesCountArgs<ExtArgs>
            result: $Utils.Optional<SyncedChannelLinkMessagesCountAggregateOutputType> | number
          }
        }
      }
      DiscordAddons: {
        payload: Prisma.$DiscordAddonsPayload<ExtArgs>
        fields: Prisma.DiscordAddonsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiscordAddonsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAddonsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiscordAddonsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAddonsPayload>
          }
          findFirst: {
            args: Prisma.DiscordAddonsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAddonsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiscordAddonsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAddonsPayload>
          }
          findMany: {
            args: Prisma.DiscordAddonsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAddonsPayload>[]
          }
          create: {
            args: Prisma.DiscordAddonsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAddonsPayload>
          }
          createMany: {
            args: Prisma.DiscordAddonsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DiscordAddonsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAddonsPayload>
          }
          update: {
            args: Prisma.DiscordAddonsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAddonsPayload>
          }
          deleteMany: {
            args: Prisma.DiscordAddonsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiscordAddonsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DiscordAddonsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAddonsPayload>
          }
          aggregate: {
            args: Prisma.DiscordAddonsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiscordAddons>
          }
          groupBy: {
            args: Prisma.DiscordAddonsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiscordAddonsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DiscordAddonsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DiscordAddonsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DiscordAddonsCountArgs<ExtArgs>
            result: $Utils.Optional<DiscordAddonsCountAggregateOutputType> | number
          }
        }
      }
      Giveaways: {
        payload: Prisma.$GiveawaysPayload<ExtArgs>
        fields: Prisma.GiveawaysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GiveawaysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiveawaysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GiveawaysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiveawaysPayload>
          }
          findFirst: {
            args: Prisma.GiveawaysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiveawaysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GiveawaysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiveawaysPayload>
          }
          findMany: {
            args: Prisma.GiveawaysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiveawaysPayload>[]
          }
          create: {
            args: Prisma.GiveawaysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiveawaysPayload>
          }
          createMany: {
            args: Prisma.GiveawaysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GiveawaysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiveawaysPayload>
          }
          update: {
            args: Prisma.GiveawaysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiveawaysPayload>
          }
          deleteMany: {
            args: Prisma.GiveawaysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GiveawaysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GiveawaysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiveawaysPayload>
          }
          aggregate: {
            args: Prisma.GiveawaysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGiveaways>
          }
          groupBy: {
            args: Prisma.GiveawaysGroupByArgs<ExtArgs>
            result: $Utils.Optional<GiveawaysGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.GiveawaysFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.GiveawaysAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.GiveawaysCountArgs<ExtArgs>
            result: $Utils.Optional<GiveawaysCountAggregateOutputType> | number
          }
        }
      }
      TempVoices: {
        payload: Prisma.$TempVoicesPayload<ExtArgs>
        fields: Prisma.TempVoicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TempVoicesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempVoicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TempVoicesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempVoicesPayload>
          }
          findFirst: {
            args: Prisma.TempVoicesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempVoicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TempVoicesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempVoicesPayload>
          }
          findMany: {
            args: Prisma.TempVoicesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempVoicesPayload>[]
          }
          create: {
            args: Prisma.TempVoicesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempVoicesPayload>
          }
          createMany: {
            args: Prisma.TempVoicesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TempVoicesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempVoicesPayload>
          }
          update: {
            args: Prisma.TempVoicesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempVoicesPayload>
          }
          deleteMany: {
            args: Prisma.TempVoicesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TempVoicesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TempVoicesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempVoicesPayload>
          }
          aggregate: {
            args: Prisma.TempVoicesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTempVoices>
          }
          groupBy: {
            args: Prisma.TempVoicesGroupByArgs<ExtArgs>
            result: $Utils.Optional<TempVoicesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TempVoicesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TempVoicesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TempVoicesCountArgs<ExtArgs>
            result: $Utils.Optional<TempVoicesCountAggregateOutputType> | number
          }
        }
      }
      TempVoiceChannels: {
        payload: Prisma.$TempVoiceChannelsPayload<ExtArgs>
        fields: Prisma.TempVoiceChannelsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TempVoiceChannelsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempVoiceChannelsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TempVoiceChannelsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempVoiceChannelsPayload>
          }
          findFirst: {
            args: Prisma.TempVoiceChannelsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempVoiceChannelsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TempVoiceChannelsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempVoiceChannelsPayload>
          }
          findMany: {
            args: Prisma.TempVoiceChannelsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempVoiceChannelsPayload>[]
          }
          create: {
            args: Prisma.TempVoiceChannelsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempVoiceChannelsPayload>
          }
          createMany: {
            args: Prisma.TempVoiceChannelsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TempVoiceChannelsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempVoiceChannelsPayload>
          }
          update: {
            args: Prisma.TempVoiceChannelsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempVoiceChannelsPayload>
          }
          deleteMany: {
            args: Prisma.TempVoiceChannelsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TempVoiceChannelsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TempVoiceChannelsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempVoiceChannelsPayload>
          }
          aggregate: {
            args: Prisma.TempVoiceChannelsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTempVoiceChannels>
          }
          groupBy: {
            args: Prisma.TempVoiceChannelsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TempVoiceChannelsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TempVoiceChannelsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TempVoiceChannelsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TempVoiceChannelsCountArgs<ExtArgs>
            result: $Utils.Optional<TempVoiceChannelsCountAggregateOutputType> | number
          }
        }
      }
      GuildLeaveSetups: {
        payload: Prisma.$GuildLeaveSetupsPayload<ExtArgs>
        fields: Prisma.GuildLeaveSetupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuildLeaveSetupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLeaveSetupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuildLeaveSetupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLeaveSetupsPayload>
          }
          findFirst: {
            args: Prisma.GuildLeaveSetupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLeaveSetupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuildLeaveSetupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLeaveSetupsPayload>
          }
          findMany: {
            args: Prisma.GuildLeaveSetupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLeaveSetupsPayload>[]
          }
          create: {
            args: Prisma.GuildLeaveSetupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLeaveSetupsPayload>
          }
          createMany: {
            args: Prisma.GuildLeaveSetupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GuildLeaveSetupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLeaveSetupsPayload>
          }
          update: {
            args: Prisma.GuildLeaveSetupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLeaveSetupsPayload>
          }
          deleteMany: {
            args: Prisma.GuildLeaveSetupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuildLeaveSetupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GuildLeaveSetupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLeaveSetupsPayload>
          }
          aggregate: {
            args: Prisma.GuildLeaveSetupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuildLeaveSetups>
          }
          groupBy: {
            args: Prisma.GuildLeaveSetupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuildLeaveSetupsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.GuildLeaveSetupsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.GuildLeaveSetupsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.GuildLeaveSetupsCountArgs<ExtArgs>
            result: $Utils.Optional<GuildLeaveSetupsCountAggregateOutputType> | number
          }
        }
      }
      GuildWelcomeSetups: {
        payload: Prisma.$GuildWelcomeSetupsPayload<ExtArgs>
        fields: Prisma.GuildWelcomeSetupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuildWelcomeSetupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildWelcomeSetupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuildWelcomeSetupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildWelcomeSetupsPayload>
          }
          findFirst: {
            args: Prisma.GuildWelcomeSetupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildWelcomeSetupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuildWelcomeSetupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildWelcomeSetupsPayload>
          }
          findMany: {
            args: Prisma.GuildWelcomeSetupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildWelcomeSetupsPayload>[]
          }
          create: {
            args: Prisma.GuildWelcomeSetupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildWelcomeSetupsPayload>
          }
          createMany: {
            args: Prisma.GuildWelcomeSetupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GuildWelcomeSetupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildWelcomeSetupsPayload>
          }
          update: {
            args: Prisma.GuildWelcomeSetupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildWelcomeSetupsPayload>
          }
          deleteMany: {
            args: Prisma.GuildWelcomeSetupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuildWelcomeSetupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GuildWelcomeSetupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildWelcomeSetupsPayload>
          }
          aggregate: {
            args: Prisma.GuildWelcomeSetupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuildWelcomeSetups>
          }
          groupBy: {
            args: Prisma.GuildWelcomeSetupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuildWelcomeSetupsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.GuildWelcomeSetupsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.GuildWelcomeSetupsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.GuildWelcomeSetupsCountArgs<ExtArgs>
            result: $Utils.Optional<GuildWelcomeSetupsCountAggregateOutputType> | number
          }
        }
      }
      GuildLoggings: {
        payload: Prisma.$GuildLoggingsPayload<ExtArgs>
        fields: Prisma.GuildLoggingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuildLoggingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLoggingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuildLoggingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLoggingsPayload>
          }
          findFirst: {
            args: Prisma.GuildLoggingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLoggingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuildLoggingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLoggingsPayload>
          }
          findMany: {
            args: Prisma.GuildLoggingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLoggingsPayload>[]
          }
          create: {
            args: Prisma.GuildLoggingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLoggingsPayload>
          }
          createMany: {
            args: Prisma.GuildLoggingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GuildLoggingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLoggingsPayload>
          }
          update: {
            args: Prisma.GuildLoggingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLoggingsPayload>
          }
          deleteMany: {
            args: Prisma.GuildLoggingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuildLoggingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GuildLoggingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLoggingsPayload>
          }
          aggregate: {
            args: Prisma.GuildLoggingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuildLoggings>
          }
          groupBy: {
            args: Prisma.GuildLoggingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuildLoggingsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.GuildLoggingsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.GuildLoggingsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.GuildLoggingsCountArgs<ExtArgs>
            result: $Utils.Optional<GuildLoggingsCountAggregateOutputType> | number
          }
        }
      }
      GuildLoggers: {
        payload: Prisma.$GuildLoggersPayload<ExtArgs>
        fields: Prisma.GuildLoggersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuildLoggersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLoggersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuildLoggersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLoggersPayload>
          }
          findFirst: {
            args: Prisma.GuildLoggersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLoggersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuildLoggersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLoggersPayload>
          }
          findMany: {
            args: Prisma.GuildLoggersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLoggersPayload>[]
          }
          create: {
            args: Prisma.GuildLoggersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLoggersPayload>
          }
          createMany: {
            args: Prisma.GuildLoggersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GuildLoggersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLoggersPayload>
          }
          update: {
            args: Prisma.GuildLoggersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLoggersPayload>
          }
          deleteMany: {
            args: Prisma.GuildLoggersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuildLoggersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GuildLoggersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildLoggersPayload>
          }
          aggregate: {
            args: Prisma.GuildLoggersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuildLoggers>
          }
          groupBy: {
            args: Prisma.GuildLoggersGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuildLoggersGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.GuildLoggersFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.GuildLoggersAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.GuildLoggersCountArgs<ExtArgs>
            result: $Utils.Optional<GuildLoggersCountAggregateOutputType> | number
          }
        }
      }
      MessageTemplates: {
        payload: Prisma.$MessageTemplatesPayload<ExtArgs>
        fields: Prisma.MessageTemplatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageTemplatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageTemplatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatesPayload>
          }
          findFirst: {
            args: Prisma.MessageTemplatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageTemplatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatesPayload>
          }
          findMany: {
            args: Prisma.MessageTemplatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatesPayload>[]
          }
          create: {
            args: Prisma.MessageTemplatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatesPayload>
          }
          createMany: {
            args: Prisma.MessageTemplatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessageTemplatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatesPayload>
          }
          update: {
            args: Prisma.MessageTemplatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatesPayload>
          }
          deleteMany: {
            args: Prisma.MessageTemplatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageTemplatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageTemplatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatesPayload>
          }
          aggregate: {
            args: Prisma.MessageTemplatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageTemplates>
          }
          groupBy: {
            args: Prisma.MessageTemplatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageTemplatesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MessageTemplatesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MessageTemplatesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MessageTemplatesCountArgs<ExtArgs>
            result: $Utils.Optional<MessageTemplatesCountAggregateOutputType> | number
          }
        }
      }
      Permissions: {
        payload: Prisma.$PermissionsPayload<ExtArgs>
        fields: Prisma.PermissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          findFirst: {
            args: Prisma.PermissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          findMany: {
            args: Prisma.PermissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>[]
          }
          create: {
            args: Prisma.PermissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          createMany: {
            args: Prisma.PermissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PermissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          update: {
            args: Prisma.PermissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          deleteMany: {
            args: Prisma.PermissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          aggregate: {
            args: Prisma.PermissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermissions>
          }
          groupBy: {
            args: Prisma.PermissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PermissionsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PermissionsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PermissionsCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionsCountAggregateOutputType> | number
          }
        }
      }
      ReactionRoles: {
        payload: Prisma.$ReactionRolesPayload<ExtArgs>
        fields: Prisma.ReactionRolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReactionRolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionRolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReactionRolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionRolesPayload>
          }
          findFirst: {
            args: Prisma.ReactionRolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionRolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReactionRolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionRolesPayload>
          }
          findMany: {
            args: Prisma.ReactionRolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionRolesPayload>[]
          }
          create: {
            args: Prisma.ReactionRolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionRolesPayload>
          }
          createMany: {
            args: Prisma.ReactionRolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReactionRolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionRolesPayload>
          }
          update: {
            args: Prisma.ReactionRolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionRolesPayload>
          }
          deleteMany: {
            args: Prisma.ReactionRolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReactionRolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReactionRolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionRolesPayload>
          }
          aggregate: {
            args: Prisma.ReactionRolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReactionRoles>
          }
          groupBy: {
            args: Prisma.ReactionRolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReactionRolesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ReactionRolesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ReactionRolesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ReactionRolesCountArgs<ExtArgs>
            result: $Utils.Optional<ReactionRolesCountAggregateOutputType> | number
          }
        }
      }
      Securitys: {
        payload: Prisma.$SecuritysPayload<ExtArgs>
        fields: Prisma.SecuritysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecuritysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecuritysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecuritysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecuritysPayload>
          }
          findFirst: {
            args: Prisma.SecuritysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecuritysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecuritysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecuritysPayload>
          }
          findMany: {
            args: Prisma.SecuritysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecuritysPayload>[]
          }
          create: {
            args: Prisma.SecuritysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecuritysPayload>
          }
          createMany: {
            args: Prisma.SecuritysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SecuritysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecuritysPayload>
          }
          update: {
            args: Prisma.SecuritysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecuritysPayload>
          }
          deleteMany: {
            args: Prisma.SecuritysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SecuritysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SecuritysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecuritysPayload>
          }
          aggregate: {
            args: Prisma.SecuritysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecuritys>
          }
          groupBy: {
            args: Prisma.SecuritysGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecuritysGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SecuritysFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SecuritysAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SecuritysCountArgs<ExtArgs>
            result: $Utils.Optional<SecuritysCountAggregateOutputType> | number
          }
        }
      }
      VerificationGates: {
        payload: Prisma.$VerificationGatesPayload<ExtArgs>
        fields: Prisma.VerificationGatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationGatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationGatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationGatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationGatesPayload>
          }
          findFirst: {
            args: Prisma.VerificationGatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationGatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationGatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationGatesPayload>
          }
          findMany: {
            args: Prisma.VerificationGatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationGatesPayload>[]
          }
          create: {
            args: Prisma.VerificationGatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationGatesPayload>
          }
          createMany: {
            args: Prisma.VerificationGatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VerificationGatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationGatesPayload>
          }
          update: {
            args: Prisma.VerificationGatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationGatesPayload>
          }
          deleteMany: {
            args: Prisma.VerificationGatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationGatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationGatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationGatesPayload>
          }
          aggregate: {
            args: Prisma.VerificationGatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationGates>
          }
          groupBy: {
            args: Prisma.VerificationGatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGatesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.VerificationGatesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.VerificationGatesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.VerificationGatesCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationGatesCountAggregateOutputType> | number
          }
        }
      }
      VerificationGatesPermission: {
        payload: Prisma.$VerificationGatesPermissionPayload<ExtArgs>
        fields: Prisma.VerificationGatesPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationGatesPermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationGatesPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationGatesPermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationGatesPermissionPayload>
          }
          findFirst: {
            args: Prisma.VerificationGatesPermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationGatesPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationGatesPermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationGatesPermissionPayload>
          }
          findMany: {
            args: Prisma.VerificationGatesPermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationGatesPermissionPayload>[]
          }
          create: {
            args: Prisma.VerificationGatesPermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationGatesPermissionPayload>
          }
          createMany: {
            args: Prisma.VerificationGatesPermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VerificationGatesPermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationGatesPermissionPayload>
          }
          update: {
            args: Prisma.VerificationGatesPermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationGatesPermissionPayload>
          }
          deleteMany: {
            args: Prisma.VerificationGatesPermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationGatesPermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationGatesPermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationGatesPermissionPayload>
          }
          aggregate: {
            args: Prisma.VerificationGatesPermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationGatesPermission>
          }
          groupBy: {
            args: Prisma.VerificationGatesPermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGatesPermissionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.VerificationGatesPermissionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.VerificationGatesPermissionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.VerificationGatesPermissionCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationGatesPermissionCountAggregateOutputType> | number
          }
        }
      }
      SpotifyNotifications: {
        payload: Prisma.$SpotifyNotificationsPayload<ExtArgs>
        fields: Prisma.SpotifyNotificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpotifyNotificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpotifyNotificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpotifyNotificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpotifyNotificationsPayload>
          }
          findFirst: {
            args: Prisma.SpotifyNotificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpotifyNotificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpotifyNotificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpotifyNotificationsPayload>
          }
          findMany: {
            args: Prisma.SpotifyNotificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpotifyNotificationsPayload>[]
          }
          create: {
            args: Prisma.SpotifyNotificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpotifyNotificationsPayload>
          }
          createMany: {
            args: Prisma.SpotifyNotificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SpotifyNotificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpotifyNotificationsPayload>
          }
          update: {
            args: Prisma.SpotifyNotificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpotifyNotificationsPayload>
          }
          deleteMany: {
            args: Prisma.SpotifyNotificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpotifyNotificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpotifyNotificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpotifyNotificationsPayload>
          }
          aggregate: {
            args: Prisma.SpotifyNotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpotifyNotifications>
          }
          groupBy: {
            args: Prisma.SpotifyNotificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpotifyNotificationsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SpotifyNotificationsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SpotifyNotificationsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SpotifyNotificationsCountArgs<ExtArgs>
            result: $Utils.Optional<SpotifyNotificationsCountAggregateOutputType> | number
          }
        }
      }
      Tags: {
        payload: Prisma.$TagsPayload<ExtArgs>
        fields: Prisma.TagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          findFirst: {
            args: Prisma.TagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          findMany: {
            args: Prisma.TagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>[]
          }
          create: {
            args: Prisma.TagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          createMany: {
            args: Prisma.TagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          update: {
            args: Prisma.TagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          deleteMany: {
            args: Prisma.TagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          aggregate: {
            args: Prisma.TagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTags>
          }
          groupBy: {
            args: Prisma.TagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TagsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TagsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TagsCountArgs<ExtArgs>
            result: $Utils.Optional<TagsCountAggregateOutputType> | number
          }
        }
      }
      TicketSetups: {
        payload: Prisma.$TicketSetupsPayload<ExtArgs>
        fields: Prisma.TicketSetupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketSetupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketSetupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketSetupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketSetupsPayload>
          }
          findFirst: {
            args: Prisma.TicketSetupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketSetupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketSetupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketSetupsPayload>
          }
          findMany: {
            args: Prisma.TicketSetupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketSetupsPayload>[]
          }
          create: {
            args: Prisma.TicketSetupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketSetupsPayload>
          }
          createMany: {
            args: Prisma.TicketSetupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TicketSetupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketSetupsPayload>
          }
          update: {
            args: Prisma.TicketSetupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketSetupsPayload>
          }
          deleteMany: {
            args: Prisma.TicketSetupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketSetupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketSetupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketSetupsPayload>
          }
          aggregate: {
            args: Prisma.TicketSetupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketSetups>
          }
          groupBy: {
            args: Prisma.TicketSetupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketSetupsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TicketSetupsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TicketSetupsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TicketSetupsCountArgs<ExtArgs>
            result: $Utils.Optional<TicketSetupsCountAggregateOutputType> | number
          }
        }
      }
      TicketModalData: {
        payload: Prisma.$TicketModalDataPayload<ExtArgs>
        fields: Prisma.TicketModalDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketModalDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketModalDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketModalDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketModalDataPayload>
          }
          findFirst: {
            args: Prisma.TicketModalDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketModalDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketModalDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketModalDataPayload>
          }
          findMany: {
            args: Prisma.TicketModalDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketModalDataPayload>[]
          }
          create: {
            args: Prisma.TicketModalDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketModalDataPayload>
          }
          createMany: {
            args: Prisma.TicketModalDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TicketModalDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketModalDataPayload>
          }
          update: {
            args: Prisma.TicketModalDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketModalDataPayload>
          }
          deleteMany: {
            args: Prisma.TicketModalDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketModalDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketModalDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketModalDataPayload>
          }
          aggregate: {
            args: Prisma.TicketModalDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketModalData>
          }
          groupBy: {
            args: Prisma.TicketModalDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketModalDataGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TicketModalDataFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TicketModalDataAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TicketModalDataCountArgs<ExtArgs>
            result: $Utils.Optional<TicketModalDataCountAggregateOutputType> | number
          }
        }
      }
      TicketHandlers: {
        payload: Prisma.$TicketHandlersPayload<ExtArgs>
        fields: Prisma.TicketHandlersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketHandlersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHandlersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketHandlersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHandlersPayload>
          }
          findFirst: {
            args: Prisma.TicketHandlersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHandlersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketHandlersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHandlersPayload>
          }
          findMany: {
            args: Prisma.TicketHandlersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHandlersPayload>[]
          }
          create: {
            args: Prisma.TicketHandlersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHandlersPayload>
          }
          createMany: {
            args: Prisma.TicketHandlersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TicketHandlersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHandlersPayload>
          }
          update: {
            args: Prisma.TicketHandlersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHandlersPayload>
          }
          deleteMany: {
            args: Prisma.TicketHandlersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketHandlersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketHandlersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHandlersPayload>
          }
          aggregate: {
            args: Prisma.TicketHandlersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketHandlers>
          }
          groupBy: {
            args: Prisma.TicketHandlersGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketHandlersGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TicketHandlersFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TicketHandlersAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TicketHandlersCountArgs<ExtArgs>
            result: $Utils.Optional<TicketHandlersCountAggregateOutputType> | number
          }
        }
      }
      Tickets: {
        payload: Prisma.$TicketsPayload<ExtArgs>
        fields: Prisma.TicketsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload>
          }
          findFirst: {
            args: Prisma.TicketsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload>
          }
          findMany: {
            args: Prisma.TicketsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload>[]
          }
          create: {
            args: Prisma.TicketsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload>
          }
          createMany: {
            args: Prisma.TicketsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TicketsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload>
          }
          update: {
            args: Prisma.TicketsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload>
          }
          deleteMany: {
            args: Prisma.TicketsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload>
          }
          aggregate: {
            args: Prisma.TicketsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTickets>
          }
          groupBy: {
            args: Prisma.TicketsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TicketsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TicketsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TicketsCountArgs<ExtArgs>
            result: $Utils.Optional<TicketsCountAggregateOutputType> | number
          }
        }
      }
      TicketFeedback: {
        payload: Prisma.$TicketFeedbackPayload<ExtArgs>
        fields: Prisma.TicketFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketFeedbackPayload>
          }
          findFirst: {
            args: Prisma.TicketFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketFeedbackPayload>
          }
          findMany: {
            args: Prisma.TicketFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketFeedbackPayload>[]
          }
          create: {
            args: Prisma.TicketFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketFeedbackPayload>
          }
          createMany: {
            args: Prisma.TicketFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TicketFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketFeedbackPayload>
          }
          update: {
            args: Prisma.TicketFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.TicketFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketFeedbackPayload>
          }
          aggregate: {
            args: Prisma.TicketFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketFeedback>
          }
          groupBy: {
            args: Prisma.TicketFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketFeedbackGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TicketFeedbackFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TicketFeedbackAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TicketFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<TicketFeedbackCountAggregateOutputType> | number
          }
        }
      }
      GuildFeatureToggles: {
        payload: Prisma.$GuildFeatureTogglesPayload<ExtArgs>
        fields: Prisma.GuildFeatureTogglesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuildFeatureTogglesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildFeatureTogglesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuildFeatureTogglesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildFeatureTogglesPayload>
          }
          findFirst: {
            args: Prisma.GuildFeatureTogglesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildFeatureTogglesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuildFeatureTogglesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildFeatureTogglesPayload>
          }
          findMany: {
            args: Prisma.GuildFeatureTogglesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildFeatureTogglesPayload>[]
          }
          create: {
            args: Prisma.GuildFeatureTogglesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildFeatureTogglesPayload>
          }
          createMany: {
            args: Prisma.GuildFeatureTogglesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GuildFeatureTogglesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildFeatureTogglesPayload>
          }
          update: {
            args: Prisma.GuildFeatureTogglesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildFeatureTogglesPayload>
          }
          deleteMany: {
            args: Prisma.GuildFeatureTogglesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuildFeatureTogglesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GuildFeatureTogglesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildFeatureTogglesPayload>
          }
          aggregate: {
            args: Prisma.GuildFeatureTogglesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuildFeatureToggles>
          }
          groupBy: {
            args: Prisma.GuildFeatureTogglesGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuildFeatureTogglesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.GuildFeatureTogglesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.GuildFeatureTogglesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.GuildFeatureTogglesCountArgs<ExtArgs>
            result: $Utils.Optional<GuildFeatureTogglesCountAggregateOutputType> | number
          }
        }
      }
      TwitchNotifications: {
        payload: Prisma.$TwitchNotificationsPayload<ExtArgs>
        fields: Prisma.TwitchNotificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TwitchNotificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitchNotificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TwitchNotificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitchNotificationsPayload>
          }
          findFirst: {
            args: Prisma.TwitchNotificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitchNotificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TwitchNotificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitchNotificationsPayload>
          }
          findMany: {
            args: Prisma.TwitchNotificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitchNotificationsPayload>[]
          }
          create: {
            args: Prisma.TwitchNotificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitchNotificationsPayload>
          }
          createMany: {
            args: Prisma.TwitchNotificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TwitchNotificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitchNotificationsPayload>
          }
          update: {
            args: Prisma.TwitchNotificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitchNotificationsPayload>
          }
          deleteMany: {
            args: Prisma.TwitchNotificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TwitchNotificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TwitchNotificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitchNotificationsPayload>
          }
          aggregate: {
            args: Prisma.TwitchNotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTwitchNotifications>
          }
          groupBy: {
            args: Prisma.TwitchNotificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TwitchNotificationsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TwitchNotificationsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TwitchNotificationsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TwitchNotificationsCountArgs<ExtArgs>
            result: $Utils.Optional<TwitchNotificationsCountAggregateOutputType> | number
          }
        }
      }
      YoutubeNotifications: {
        payload: Prisma.$YoutubeNotificationsPayload<ExtArgs>
        fields: Prisma.YoutubeNotificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.YoutubeNotificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YoutubeNotificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.YoutubeNotificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YoutubeNotificationsPayload>
          }
          findFirst: {
            args: Prisma.YoutubeNotificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YoutubeNotificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.YoutubeNotificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YoutubeNotificationsPayload>
          }
          findMany: {
            args: Prisma.YoutubeNotificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YoutubeNotificationsPayload>[]
          }
          create: {
            args: Prisma.YoutubeNotificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YoutubeNotificationsPayload>
          }
          createMany: {
            args: Prisma.YoutubeNotificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.YoutubeNotificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YoutubeNotificationsPayload>
          }
          update: {
            args: Prisma.YoutubeNotificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YoutubeNotificationsPayload>
          }
          deleteMany: {
            args: Prisma.YoutubeNotificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.YoutubeNotificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.YoutubeNotificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YoutubeNotificationsPayload>
          }
          aggregate: {
            args: Prisma.YoutubeNotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateYoutubeNotifications>
          }
          groupBy: {
            args: Prisma.YoutubeNotificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<YoutubeNotificationsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.YoutubeNotificationsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.YoutubeNotificationsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.YoutubeNotificationsCountArgs<ExtArgs>
            result: $Utils.Optional<YoutubeNotificationsCountAggregateOutputType> | number
          }
        }
      }
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UsersFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UsersAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      Apis: {
        payload: Prisma.$ApisPayload<ExtArgs>
        fields: Prisma.ApisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApisPayload>
          }
          findFirst: {
            args: Prisma.ApisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApisPayload>
          }
          findMany: {
            args: Prisma.ApisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApisPayload>[]
          }
          create: {
            args: Prisma.ApisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApisPayload>
          }
          createMany: {
            args: Prisma.ApisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ApisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApisPayload>
          }
          update: {
            args: Prisma.ApisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApisPayload>
          }
          deleteMany: {
            args: Prisma.ApisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApisPayload>
          }
          aggregate: {
            args: Prisma.ApisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApis>
          }
          groupBy: {
            args: Prisma.ApisGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApisGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ApisFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ApisAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ApisCountArgs<ExtArgs>
            result: $Utils.Optional<ApisCountAggregateOutputType> | number
          }
        }
      }
      GuildBackups: {
        payload: Prisma.$GuildBackupsPayload<ExtArgs>
        fields: Prisma.GuildBackupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuildBackupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBackupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuildBackupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBackupsPayload>
          }
          findFirst: {
            args: Prisma.GuildBackupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBackupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuildBackupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBackupsPayload>
          }
          findMany: {
            args: Prisma.GuildBackupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBackupsPayload>[]
          }
          create: {
            args: Prisma.GuildBackupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBackupsPayload>
          }
          createMany: {
            args: Prisma.GuildBackupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GuildBackupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBackupsPayload>
          }
          update: {
            args: Prisma.GuildBackupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBackupsPayload>
          }
          deleteMany: {
            args: Prisma.GuildBackupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuildBackupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GuildBackupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBackupsPayload>
          }
          aggregate: {
            args: Prisma.GuildBackupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuildBackups>
          }
          groupBy: {
            args: Prisma.GuildBackupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuildBackupsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.GuildBackupsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.GuildBackupsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.GuildBackupsCountArgs<ExtArgs>
            result: $Utils.Optional<GuildBackupsCountAggregateOutputType> | number
          }
        }
      }
      Customers: {
        payload: Prisma.$CustomersPayload<ExtArgs>
        fields: Prisma.CustomersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          findFirst: {
            args: Prisma.CustomersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          findMany: {
            args: Prisma.CustomersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>[]
          }
          create: {
            args: Prisma.CustomersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          createMany: {
            args: Prisma.CustomersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          update: {
            args: Prisma.CustomersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          deleteMany: {
            args: Prisma.CustomersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          aggregate: {
            args: Prisma.CustomersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomers>
          }
          groupBy: {
            args: Prisma.CustomersGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomersGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CustomersFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CustomersAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CustomersCountArgs<ExtArgs>
            result: $Utils.Optional<CustomersCountAggregateOutputType> | number
          }
        }
      }
      Vanitys: {
        payload: Prisma.$VanitysPayload<ExtArgs>
        fields: Prisma.VanitysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VanitysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanitysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VanitysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanitysPayload>
          }
          findFirst: {
            args: Prisma.VanitysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanitysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VanitysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanitysPayload>
          }
          findMany: {
            args: Prisma.VanitysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanitysPayload>[]
          }
          create: {
            args: Prisma.VanitysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanitysPayload>
          }
          createMany: {
            args: Prisma.VanitysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VanitysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanitysPayload>
          }
          update: {
            args: Prisma.VanitysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanitysPayload>
          }
          deleteMany: {
            args: Prisma.VanitysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VanitysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VanitysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanitysPayload>
          }
          aggregate: {
            args: Prisma.VanitysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVanitys>
          }
          groupBy: {
            args: Prisma.VanitysGroupByArgs<ExtArgs>
            result: $Utils.Optional<VanitysGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.VanitysFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.VanitysAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.VanitysCountArgs<ExtArgs>
            result: $Utils.Optional<VanitysCountAggregateOutputType> | number
          }
        }
      }
      VanityEmbeds: {
        payload: Prisma.$VanityEmbedsPayload<ExtArgs>
        fields: Prisma.VanityEmbedsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VanityEmbedsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityEmbedsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VanityEmbedsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityEmbedsPayload>
          }
          findFirst: {
            args: Prisma.VanityEmbedsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityEmbedsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VanityEmbedsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityEmbedsPayload>
          }
          findMany: {
            args: Prisma.VanityEmbedsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityEmbedsPayload>[]
          }
          create: {
            args: Prisma.VanityEmbedsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityEmbedsPayload>
          }
          createMany: {
            args: Prisma.VanityEmbedsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VanityEmbedsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityEmbedsPayload>
          }
          update: {
            args: Prisma.VanityEmbedsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityEmbedsPayload>
          }
          deleteMany: {
            args: Prisma.VanityEmbedsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VanityEmbedsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VanityEmbedsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityEmbedsPayload>
          }
          aggregate: {
            args: Prisma.VanityEmbedsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVanityEmbeds>
          }
          groupBy: {
            args: Prisma.VanityEmbedsGroupByArgs<ExtArgs>
            result: $Utils.Optional<VanityEmbedsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.VanityEmbedsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.VanityEmbedsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.VanityEmbedsCountArgs<ExtArgs>
            result: $Utils.Optional<VanityEmbedsCountAggregateOutputType> | number
          }
        }
      }
      VanityEmbedAuthors: {
        payload: Prisma.$VanityEmbedAuthorsPayload<ExtArgs>
        fields: Prisma.VanityEmbedAuthorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VanityEmbedAuthorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityEmbedAuthorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VanityEmbedAuthorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityEmbedAuthorsPayload>
          }
          findFirst: {
            args: Prisma.VanityEmbedAuthorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityEmbedAuthorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VanityEmbedAuthorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityEmbedAuthorsPayload>
          }
          findMany: {
            args: Prisma.VanityEmbedAuthorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityEmbedAuthorsPayload>[]
          }
          create: {
            args: Prisma.VanityEmbedAuthorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityEmbedAuthorsPayload>
          }
          createMany: {
            args: Prisma.VanityEmbedAuthorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VanityEmbedAuthorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityEmbedAuthorsPayload>
          }
          update: {
            args: Prisma.VanityEmbedAuthorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityEmbedAuthorsPayload>
          }
          deleteMany: {
            args: Prisma.VanityEmbedAuthorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VanityEmbedAuthorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VanityEmbedAuthorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityEmbedAuthorsPayload>
          }
          aggregate: {
            args: Prisma.VanityEmbedAuthorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVanityEmbedAuthors>
          }
          groupBy: {
            args: Prisma.VanityEmbedAuthorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<VanityEmbedAuthorsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.VanityEmbedAuthorsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.VanityEmbedAuthorsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.VanityEmbedAuthorsCountArgs<ExtArgs>
            result: $Utils.Optional<VanityEmbedAuthorsCountAggregateOutputType> | number
          }
        }
      }
      VanityAnalytics: {
        payload: Prisma.$VanityAnalyticsPayload<ExtArgs>
        fields: Prisma.VanityAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VanityAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VanityAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.VanityAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VanityAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityAnalyticsPayload>
          }
          findMany: {
            args: Prisma.VanityAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityAnalyticsPayload>[]
          }
          create: {
            args: Prisma.VanityAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityAnalyticsPayload>
          }
          createMany: {
            args: Prisma.VanityAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VanityAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityAnalyticsPayload>
          }
          update: {
            args: Prisma.VanityAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.VanityAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VanityAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VanityAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VanityAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.VanityAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVanityAnalytics>
          }
          groupBy: {
            args: Prisma.VanityAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<VanityAnalyticsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.VanityAnalyticsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.VanityAnalyticsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.VanityAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<VanityAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsLatest30Days: {
        payload: Prisma.$AnalyticsLatest30DaysPayload<ExtArgs>
        fields: Prisma.AnalyticsLatest30DaysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsLatest30DaysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsLatest30DaysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsLatest30DaysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsLatest30DaysPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsLatest30DaysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsLatest30DaysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsLatest30DaysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsLatest30DaysPayload>
          }
          findMany: {
            args: Prisma.AnalyticsLatest30DaysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsLatest30DaysPayload>[]
          }
          create: {
            args: Prisma.AnalyticsLatest30DaysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsLatest30DaysPayload>
          }
          createMany: {
            args: Prisma.AnalyticsLatest30DaysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AnalyticsLatest30DaysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsLatest30DaysPayload>
          }
          update: {
            args: Prisma.AnalyticsLatest30DaysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsLatest30DaysPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsLatest30DaysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsLatest30DaysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnalyticsLatest30DaysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsLatest30DaysPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsLatest30DaysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsLatest30Days>
          }
          groupBy: {
            args: Prisma.AnalyticsLatest30DaysGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsLatest30DaysGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AnalyticsLatest30DaysFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AnalyticsLatest30DaysAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AnalyticsLatest30DaysCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsLatest30DaysCountAggregateOutputType> | number
          }
        }
      }
      DisBotUserNotifications: {
        payload: Prisma.$DisBotUserNotificationsPayload<ExtArgs>
        fields: Prisma.DisBotUserNotificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisBotUserNotificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisBotUserNotificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisBotUserNotificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisBotUserNotificationsPayload>
          }
          findFirst: {
            args: Prisma.DisBotUserNotificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisBotUserNotificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisBotUserNotificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisBotUserNotificationsPayload>
          }
          findMany: {
            args: Prisma.DisBotUserNotificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisBotUserNotificationsPayload>[]
          }
          create: {
            args: Prisma.DisBotUserNotificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisBotUserNotificationsPayload>
          }
          createMany: {
            args: Prisma.DisBotUserNotificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DisBotUserNotificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisBotUserNotificationsPayload>
          }
          update: {
            args: Prisma.DisBotUserNotificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisBotUserNotificationsPayload>
          }
          deleteMany: {
            args: Prisma.DisBotUserNotificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisBotUserNotificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DisBotUserNotificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisBotUserNotificationsPayload>
          }
          aggregate: {
            args: Prisma.DisBotUserNotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisBotUserNotifications>
          }
          groupBy: {
            args: Prisma.DisBotUserNotificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisBotUserNotificationsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DisBotUserNotificationsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DisBotUserNotificationsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DisBotUserNotificationsCountArgs<ExtArgs>
            result: $Utils.Optional<DisBotUserNotificationsCountAggregateOutputType> | number
          }
        }
      }
      DisBot: {
        payload: Prisma.$DisBotPayload<ExtArgs>
        fields: Prisma.DisBotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisBotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisBotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisBotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisBotPayload>
          }
          findFirst: {
            args: Prisma.DisBotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisBotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisBotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisBotPayload>
          }
          findMany: {
            args: Prisma.DisBotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisBotPayload>[]
          }
          create: {
            args: Prisma.DisBotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisBotPayload>
          }
          createMany: {
            args: Prisma.DisBotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DisBotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisBotPayload>
          }
          update: {
            args: Prisma.DisBotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisBotPayload>
          }
          deleteMany: {
            args: Prisma.DisBotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisBotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DisBotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisBotPayload>
          }
          aggregate: {
            args: Prisma.DisBotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisBot>
          }
          groupBy: {
            args: Prisma.DisBotGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisBotGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DisBotFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DisBotAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DisBotCountArgs<ExtArgs>
            result: $Utils.Optional<DisBotCountAggregateOutputType> | number
          }
        }
      }
      ImageApis: {
        payload: Prisma.$ImageApisPayload<ExtArgs>
        fields: Prisma.ImageApisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImageApisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageApisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImageApisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageApisPayload>
          }
          findFirst: {
            args: Prisma.ImageApisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageApisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImageApisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageApisPayload>
          }
          findMany: {
            args: Prisma.ImageApisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageApisPayload>[]
          }
          create: {
            args: Prisma.ImageApisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageApisPayload>
          }
          createMany: {
            args: Prisma.ImageApisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ImageApisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageApisPayload>
          }
          update: {
            args: Prisma.ImageApisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageApisPayload>
          }
          deleteMany: {
            args: Prisma.ImageApisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImageApisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImageApisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageApisPayload>
          }
          aggregate: {
            args: Prisma.ImageApisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImageApis>
          }
          groupBy: {
            args: Prisma.ImageApisGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImageApisGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ImageApisFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ImageApisAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ImageApisCountArgs<ExtArgs>
            result: $Utils.Optional<ImageApisCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    guilds?: GuildsOmit
    autoDeletes?: AutoDeletesOmit
    autoPublish?: AutoPublishOmit
    autoReacts?: AutoReactsOmit
    autoRoles?: AutoRolesOmit
    guildBans?: GuildBansOmit
    chatModerations?: ChatModerationsOmit
    channelLinks?: ChannelLinksOmit
    syncedChannelLinkMessages?: SyncedChannelLinkMessagesOmit
    discordAddons?: DiscordAddonsOmit
    giveaways?: GiveawaysOmit
    tempVoices?: TempVoicesOmit
    tempVoiceChannels?: TempVoiceChannelsOmit
    guildLeaveSetups?: GuildLeaveSetupsOmit
    guildWelcomeSetups?: GuildWelcomeSetupsOmit
    guildLoggings?: GuildLoggingsOmit
    guildLoggers?: GuildLoggersOmit
    messageTemplates?: MessageTemplatesOmit
    permissions?: PermissionsOmit
    reactionRoles?: ReactionRolesOmit
    securitys?: SecuritysOmit
    verificationGates?: VerificationGatesOmit
    verificationGatesPermission?: VerificationGatesPermissionOmit
    spotifyNotifications?: SpotifyNotificationsOmit
    tags?: TagsOmit
    ticketSetups?: TicketSetupsOmit
    ticketModalData?: TicketModalDataOmit
    ticketHandlers?: TicketHandlersOmit
    tickets?: TicketsOmit
    ticketFeedback?: TicketFeedbackOmit
    guildFeatureToggles?: GuildFeatureTogglesOmit
    twitchNotifications?: TwitchNotificationsOmit
    youtubeNotifications?: YoutubeNotificationsOmit
    users?: UsersOmit
    apis?: ApisOmit
    guildBackups?: GuildBackupsOmit
    customers?: CustomersOmit
    vanitys?: VanitysOmit
    vanityEmbeds?: VanityEmbedsOmit
    vanityEmbedAuthors?: VanityEmbedAuthorsOmit
    vanityAnalytics?: VanityAnalyticsOmit
    analyticsLatest30Days?: AnalyticsLatest30DaysOmit
    disBotUserNotifications?: DisBotUserNotificationsOmit
    disBot?: DisBotOmit
    imageApis?: ImageApisOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type GuildsCountOutputType
   */

  export type GuildsCountOutputType = {
    AutoAutoDeletes: number
    AutoReacts: number
    AutoRoles: number
    GuildBans: number
    ChannelLinks: number
    Giveaways: number
    TempVoices: number
    MessageTemplates: number
    ReactionRole: number
    SpotifyNotifications: number
    Tags: number
    TicketSetups: number
    TwitchNotifications: number
    YoutubeNotifications: number
    GuildLoggers: number
  }

  export type GuildsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AutoAutoDeletes?: boolean | GuildsCountOutputTypeCountAutoAutoDeletesArgs
    AutoReacts?: boolean | GuildsCountOutputTypeCountAutoReactsArgs
    AutoRoles?: boolean | GuildsCountOutputTypeCountAutoRolesArgs
    GuildBans?: boolean | GuildsCountOutputTypeCountGuildBansArgs
    ChannelLinks?: boolean | GuildsCountOutputTypeCountChannelLinksArgs
    Giveaways?: boolean | GuildsCountOutputTypeCountGiveawaysArgs
    TempVoices?: boolean | GuildsCountOutputTypeCountTempVoicesArgs
    MessageTemplates?: boolean | GuildsCountOutputTypeCountMessageTemplatesArgs
    ReactionRole?: boolean | GuildsCountOutputTypeCountReactionRoleArgs
    SpotifyNotifications?: boolean | GuildsCountOutputTypeCountSpotifyNotificationsArgs
    Tags?: boolean | GuildsCountOutputTypeCountTagsArgs
    TicketSetups?: boolean | GuildsCountOutputTypeCountTicketSetupsArgs
    TwitchNotifications?: boolean | GuildsCountOutputTypeCountTwitchNotificationsArgs
    YoutubeNotifications?: boolean | GuildsCountOutputTypeCountYoutubeNotificationsArgs
    GuildLoggers?: boolean | GuildsCountOutputTypeCountGuildLoggersArgs
  }

  // Custom InputTypes
  /**
   * GuildsCountOutputType without action
   */
  export type GuildsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildsCountOutputType
     */
    select?: GuildsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GuildsCountOutputType without action
   */
  export type GuildsCountOutputTypeCountAutoAutoDeletesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoDeletesWhereInput
  }

  /**
   * GuildsCountOutputType without action
   */
  export type GuildsCountOutputTypeCountAutoReactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoReactsWhereInput
  }

  /**
   * GuildsCountOutputType without action
   */
  export type GuildsCountOutputTypeCountAutoRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoRolesWhereInput
  }

  /**
   * GuildsCountOutputType without action
   */
  export type GuildsCountOutputTypeCountGuildBansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildBansWhereInput
  }

  /**
   * GuildsCountOutputType without action
   */
  export type GuildsCountOutputTypeCountChannelLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelLinksWhereInput
  }

  /**
   * GuildsCountOutputType without action
   */
  export type GuildsCountOutputTypeCountGiveawaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GiveawaysWhereInput
  }

  /**
   * GuildsCountOutputType without action
   */
  export type GuildsCountOutputTypeCountTempVoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TempVoicesWhereInput
  }

  /**
   * GuildsCountOutputType without action
   */
  export type GuildsCountOutputTypeCountMessageTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageTemplatesWhereInput
  }

  /**
   * GuildsCountOutputType without action
   */
  export type GuildsCountOutputTypeCountReactionRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactionRolesWhereInput
  }

  /**
   * GuildsCountOutputType without action
   */
  export type GuildsCountOutputTypeCountSpotifyNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpotifyNotificationsWhereInput
  }

  /**
   * GuildsCountOutputType without action
   */
  export type GuildsCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagsWhereInput
  }

  /**
   * GuildsCountOutputType without action
   */
  export type GuildsCountOutputTypeCountTicketSetupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketSetupsWhereInput
  }

  /**
   * GuildsCountOutputType without action
   */
  export type GuildsCountOutputTypeCountTwitchNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwitchNotificationsWhereInput
  }

  /**
   * GuildsCountOutputType without action
   */
  export type GuildsCountOutputTypeCountYoutubeNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YoutubeNotificationsWhereInput
  }

  /**
   * GuildsCountOutputType without action
   */
  export type GuildsCountOutputTypeCountGuildLoggersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildLoggersWhereInput
  }


  /**
   * Count Type ChannelLinksCountOutputType
   */

  export type ChannelLinksCountOutputType = {
    SyncedChannelLinkMessage: number
  }

  export type ChannelLinksCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SyncedChannelLinkMessage?: boolean | ChannelLinksCountOutputTypeCountSyncedChannelLinkMessageArgs
  }

  // Custom InputTypes
  /**
   * ChannelLinksCountOutputType without action
   */
  export type ChannelLinksCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelLinksCountOutputType
     */
    select?: ChannelLinksCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChannelLinksCountOutputType without action
   */
  export type ChannelLinksCountOutputTypeCountSyncedChannelLinkMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncedChannelLinkMessagesWhereInput
  }


  /**
   * Count Type TempVoicesCountOutputType
   */

  export type TempVoicesCountOutputType = {
    TempVoiceChannels: number
  }

  export type TempVoicesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TempVoiceChannels?: boolean | TempVoicesCountOutputTypeCountTempVoiceChannelsArgs
  }

  // Custom InputTypes
  /**
   * TempVoicesCountOutputType without action
   */
  export type TempVoicesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempVoicesCountOutputType
     */
    select?: TempVoicesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TempVoicesCountOutputType without action
   */
  export type TempVoicesCountOutputTypeCountTempVoiceChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TempVoiceChannelsWhereInput
  }


  /**
   * Count Type SecuritysCountOutputType
   */

  export type SecuritysCountOutputType = {
    VerificationGates: number
  }

  export type SecuritysCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VerificationGates?: boolean | SecuritysCountOutputTypeCountVerificationGatesArgs
  }

  // Custom InputTypes
  /**
   * SecuritysCountOutputType without action
   */
  export type SecuritysCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecuritysCountOutputType
     */
    select?: SecuritysCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SecuritysCountOutputType without action
   */
  export type SecuritysCountOutputTypeCountVerificationGatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationGatesWhereInput
  }


  /**
   * Count Type VerificationGatesCountOutputType
   */

  export type VerificationGatesCountOutputType = {
    ChannelPermissions: number
  }

  export type VerificationGatesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ChannelPermissions?: boolean | VerificationGatesCountOutputTypeCountChannelPermissionsArgs
  }

  // Custom InputTypes
  /**
   * VerificationGatesCountOutputType without action
   */
  export type VerificationGatesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationGatesCountOutputType
     */
    select?: VerificationGatesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VerificationGatesCountOutputType without action
   */
  export type VerificationGatesCountOutputTypeCountChannelPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationGatesPermissionWhereInput
  }


  /**
   * Count Type TicketSetupsCountOutputType
   */

  export type TicketSetupsCountOutputType = {
    ModalOptions: number
    Tickets: number
  }

  export type TicketSetupsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ModalOptions?: boolean | TicketSetupsCountOutputTypeCountModalOptionsArgs
    Tickets?: boolean | TicketSetupsCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * TicketSetupsCountOutputType without action
   */
  export type TicketSetupsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSetupsCountOutputType
     */
    select?: TicketSetupsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketSetupsCountOutputType without action
   */
  export type TicketSetupsCountOutputTypeCountModalOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketModalDataWhereInput
  }

  /**
   * TicketSetupsCountOutputType without action
   */
  export type TicketSetupsCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketsWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    Apiss: number
    GuildBackups: number
    Customers: number
    Vanitys: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Apiss?: boolean | UsersCountOutputTypeCountApissArgs
    GuildBackups?: boolean | UsersCountOutputTypeCountGuildBackupsArgs
    Customers?: boolean | UsersCountOutputTypeCountCustomersArgs
    Vanitys?: boolean | UsersCountOutputTypeCountVanitysArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountApissArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApisWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountGuildBackupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildBackupsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountVanitysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VanitysWhereInput
  }


  /**
   * Models
   */

  /**
   * Model WelcomeLeaveImageData
   */





  export type WelcomeLeaveImageDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Title?: boolean
    Text?: boolean
    Subtitle?: boolean
    Background?: boolean
    Theme?: boolean
    Color?: boolean
    Gradient?: boolean
  }, ExtArgs["result"]["welcomeLeaveImageData"]>



  export type WelcomeLeaveImageDataSelectScalar = {
    Title?: boolean
    Text?: boolean
    Subtitle?: boolean
    Background?: boolean
    Theme?: boolean
    Color?: boolean
    Gradient?: boolean
  }

  export type WelcomeLeaveImageDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Title" | "Text" | "Subtitle" | "Background" | "Theme" | "Color" | "Gradient", ExtArgs["result"]["welcomeLeaveImageData"]>

  export type $WelcomeLeaveImageDataPayload = {
    name: "WelcomeLeaveImageData"
    objects: {}
    scalars: {
      Title: string
      Text: string
      Subtitle: string
      Background: string
      Theme: string
      Color: string
      Gradient: string
    }
    composites: {}
  }

  type WelcomeLeaveImageDataGetPayload<S extends boolean | null | undefined | WelcomeLeaveImageDataDefaultArgs> = $Result.GetResult<Prisma.$WelcomeLeaveImageDataPayload, S>





  /**
   * Fields of the WelcomeLeaveImageData model
   */
  interface WelcomeLeaveImageDataFieldRefs {
    readonly Title: FieldRef<"WelcomeLeaveImageData", 'String'>
    readonly Text: FieldRef<"WelcomeLeaveImageData", 'String'>
    readonly Subtitle: FieldRef<"WelcomeLeaveImageData", 'String'>
    readonly Background: FieldRef<"WelcomeLeaveImageData", 'String'>
    readonly Theme: FieldRef<"WelcomeLeaveImageData", 'String'>
    readonly Color: FieldRef<"WelcomeLeaveImageData", 'String'>
    readonly Gradient: FieldRef<"WelcomeLeaveImageData", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WelcomeLeaveImageData without action
   */
  export type WelcomeLeaveImageDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WelcomeLeaveImageData
     */
    select?: WelcomeLeaveImageDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WelcomeLeaveImageData
     */
    omit?: WelcomeLeaveImageDataOmit<ExtArgs> | null
  }


  /**
   * Model PermissionData
   */





  export type PermissionDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    RoleId?: boolean
    Type?: boolean
  }, ExtArgs["result"]["permissionData"]>



  export type PermissionDataSelectScalar = {
    RoleId?: boolean
    Type?: boolean
  }

  export type PermissionDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"RoleId" | "Type", ExtArgs["result"]["permissionData"]>

  export type $PermissionDataPayload = {
    name: "PermissionData"
    objects: {}
    scalars: {
      RoleId: string
      Type: string
    }
    composites: {}
  }

  type PermissionDataGetPayload<S extends boolean | null | undefined | PermissionDataDefaultArgs> = $Result.GetResult<Prisma.$PermissionDataPayload, S>





  /**
   * Fields of the PermissionData model
   */
  interface PermissionDataFieldRefs {
    readonly RoleId: FieldRef<"PermissionData", 'String'>
    readonly Type: FieldRef<"PermissionData", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PermissionData without action
   */
  export type PermissionDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionData
     */
    select?: PermissionDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionData
     */
    omit?: PermissionDataOmit<ExtArgs> | null
  }


  /**
   * Model ReactionRoleSelectmenu
   */





  export type ReactionRoleSelectmenuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Emoji?: boolean
    Label?: boolean
    Description?: boolean
  }, ExtArgs["result"]["reactionRoleSelectmenu"]>



  export type ReactionRoleSelectmenuSelectScalar = {
    Emoji?: boolean
    Label?: boolean
    Description?: boolean
  }

  export type ReactionRoleSelectmenuOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Emoji" | "Label" | "Description", ExtArgs["result"]["reactionRoleSelectmenu"]>

  export type $ReactionRoleSelectmenuPayload = {
    name: "ReactionRoleSelectmenu"
    objects: {}
    scalars: {
      Emoji: string
      Label: string
      Description: string
    }
    composites: {}
  }

  type ReactionRoleSelectmenuGetPayload<S extends boolean | null | undefined | ReactionRoleSelectmenuDefaultArgs> = $Result.GetResult<Prisma.$ReactionRoleSelectmenuPayload, S>





  /**
   * Fields of the ReactionRoleSelectmenu model
   */
  interface ReactionRoleSelectmenuFieldRefs {
    readonly Emoji: FieldRef<"ReactionRoleSelectmenu", 'String'>
    readonly Label: FieldRef<"ReactionRoleSelectmenu", 'String'>
    readonly Description: FieldRef<"ReactionRoleSelectmenu", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReactionRoleSelectmenu without action
   */
  export type ReactionRoleSelectmenuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReactionRoleSelectmenu
     */
    select?: ReactionRoleSelectmenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReactionRoleSelectmenu
     */
    omit?: ReactionRoleSelectmenuOmit<ExtArgs> | null
  }


  /**
   * Model ReactionRoleButton
   */





  export type ReactionRoleButtonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Emoji?: boolean
    Type?: boolean
    Label?: boolean
  }, ExtArgs["result"]["reactionRoleButton"]>



  export type ReactionRoleButtonSelectScalar = {
    Emoji?: boolean
    Type?: boolean
    Label?: boolean
  }

  export type ReactionRoleButtonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Emoji" | "Type" | "Label", ExtArgs["result"]["reactionRoleButton"]>

  export type $ReactionRoleButtonPayload = {
    name: "ReactionRoleButton"
    objects: {}
    scalars: {
      Emoji: string
      Type: string
      Label: string
    }
    composites: {}
  }

  type ReactionRoleButtonGetPayload<S extends boolean | null | undefined | ReactionRoleButtonDefaultArgs> = $Result.GetResult<Prisma.$ReactionRoleButtonPayload, S>





  /**
   * Fields of the ReactionRoleButton model
   */
  interface ReactionRoleButtonFieldRefs {
    readonly Emoji: FieldRef<"ReactionRoleButton", 'String'>
    readonly Type: FieldRef<"ReactionRoleButton", 'String'>
    readonly Label: FieldRef<"ReactionRoleButton", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReactionRoleButton without action
   */
  export type ReactionRoleButtonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReactionRoleButton
     */
    select?: ReactionRoleButtonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReactionRoleButton
     */
    omit?: ReactionRoleButtonOmit<ExtArgs> | null
  }


  /**
   * Model BotStatus
   */





  export type BotStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Type?: boolean
    Text?: boolean
    Status?: boolean
    URL?: boolean
  }, ExtArgs["result"]["botStatus"]>



  export type BotStatusSelectScalar = {
    Type?: boolean
    Text?: boolean
    Status?: boolean
    URL?: boolean
  }

  export type BotStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Type" | "Text" | "Status" | "URL", ExtArgs["result"]["botStatus"]>

  export type $BotStatusPayload = {
    name: "BotStatus"
    objects: {}
    scalars: {
      Type: number
      Text: string
      Status: string
      URL: string
    }
    composites: {}
  }

  type BotStatusGetPayload<S extends boolean | null | undefined | BotStatusDefaultArgs> = $Result.GetResult<Prisma.$BotStatusPayload, S>





  /**
   * Fields of the BotStatus model
   */
  interface BotStatusFieldRefs {
    readonly Type: FieldRef<"BotStatus", 'Int'>
    readonly Text: FieldRef<"BotStatus", 'String'>
    readonly Status: FieldRef<"BotStatus", 'String'>
    readonly URL: FieldRef<"BotStatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BotStatus without action
   */
  export type BotStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotStatus
     */
    select?: BotStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotStatus
     */
    omit?: BotStatusOmit<ExtArgs> | null
  }


  /**
   * Model DisbotsLogs
   */





  export type DisbotsLogsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Action?: boolean
    BotType?: boolean
    ChannelId?: boolean
    GuildId?: boolean
    Label?: boolean
    Level?: boolean
    Message?: boolean
    MessageId?: boolean
    Timestamp?: boolean
    UUID?: boolean
    UserId?: boolean
  }, ExtArgs["result"]["disbotsLogs"]>



  export type DisbotsLogsSelectScalar = {
    Action?: boolean
    BotType?: boolean
    ChannelId?: boolean
    GuildId?: boolean
    Label?: boolean
    Level?: boolean
    Message?: boolean
    MessageId?: boolean
    Timestamp?: boolean
    UUID?: boolean
    UserId?: boolean
  }

  export type DisbotsLogsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Action" | "BotType" | "ChannelId" | "GuildId" | "Label" | "Level" | "Message" | "MessageId" | "Timestamp" | "UUID" | "UserId", ExtArgs["result"]["disbotsLogs"]>

  export type $DisbotsLogsPayload = {
    name: "DisbotsLogs"
    objects: {}
    scalars: {
      Action: string
      BotType: string
      ChannelId: string
      GuildId: string
      Label: string
      Level: string
      Message: string
      MessageId: string
      Timestamp: string
      UUID: string
      UserId: string
    }
    composites: {}
  }

  type DisbotsLogsGetPayload<S extends boolean | null | undefined | DisbotsLogsDefaultArgs> = $Result.GetResult<Prisma.$DisbotsLogsPayload, S>





  /**
   * Fields of the DisbotsLogs model
   */
  interface DisbotsLogsFieldRefs {
    readonly Action: FieldRef<"DisbotsLogs", 'String'>
    readonly BotType: FieldRef<"DisbotsLogs", 'String'>
    readonly ChannelId: FieldRef<"DisbotsLogs", 'String'>
    readonly GuildId: FieldRef<"DisbotsLogs", 'String'>
    readonly Label: FieldRef<"DisbotsLogs", 'String'>
    readonly Level: FieldRef<"DisbotsLogs", 'String'>
    readonly Message: FieldRef<"DisbotsLogs", 'String'>
    readonly MessageId: FieldRef<"DisbotsLogs", 'String'>
    readonly Timestamp: FieldRef<"DisbotsLogs", 'String'>
    readonly UUID: FieldRef<"DisbotsLogs", 'String'>
    readonly UserId: FieldRef<"DisbotsLogs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DisbotsLogs without action
   */
  export type DisbotsLogsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisbotsLogs
     */
    select?: DisbotsLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisbotsLogs
     */
    omit?: DisbotsLogsOmit<ExtArgs> | null
  }


  /**
   * Model Guilds
   */

  export type AggregateGuilds = {
    _count: GuildsCountAggregateOutputType | null
    _min: GuildsMinAggregateOutputType | null
    _max: GuildsMaxAggregateOutputType | null
  }

  export type GuildsMinAggregateOutputType = {
    id: string | null
    GuildId: string | null
    GuildName: string | null
    GuildOwner: string | null
  }

  export type GuildsMaxAggregateOutputType = {
    id: string | null
    GuildId: string | null
    GuildName: string | null
    GuildOwner: string | null
  }

  export type GuildsCountAggregateOutputType = {
    id: number
    GuildId: number
    GuildName: number
    GuildOwner: number
    _all: number
  }


  export type GuildsMinAggregateInputType = {
    id?: true
    GuildId?: true
    GuildName?: true
    GuildOwner?: true
  }

  export type GuildsMaxAggregateInputType = {
    id?: true
    GuildId?: true
    GuildName?: true
    GuildOwner?: true
  }

  export type GuildsCountAggregateInputType = {
    id?: true
    GuildId?: true
    GuildName?: true
    GuildOwner?: true
    _all?: true
  }

  export type GuildsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guilds to aggregate.
     */
    where?: GuildsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guilds to fetch.
     */
    orderBy?: GuildsOrderByWithRelationInput | GuildsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuildsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Guilds
    **/
    _count?: true | GuildsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildsMaxAggregateInputType
  }

  export type GetGuildsAggregateType<T extends GuildsAggregateArgs> = {
        [P in keyof T & keyof AggregateGuilds]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuilds[P]>
      : GetScalarType<T[P], AggregateGuilds[P]>
  }




  export type GuildsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildsWhereInput
    orderBy?: GuildsOrderByWithAggregationInput | GuildsOrderByWithAggregationInput[]
    by: GuildsScalarFieldEnum[] | GuildsScalarFieldEnum
    having?: GuildsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildsCountAggregateInputType | true
    _min?: GuildsMinAggregateInputType
    _max?: GuildsMaxAggregateInputType
  }

  export type GuildsGroupByOutputType = {
    id: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    _count: GuildsCountAggregateOutputType | null
    _min: GuildsMinAggregateOutputType | null
    _max: GuildsMaxAggregateOutputType | null
  }

  type GetGuildsGroupByPayload<T extends GuildsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildsGroupByOutputType[P]>
            : GetScalarType<T[P], GuildsGroupByOutputType[P]>
        }
      >
    >


  export type GuildsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    GuildId?: boolean
    GuildName?: boolean
    GuildOwner?: boolean
    AutoAutoDeletes?: boolean | Guilds$AutoAutoDeletesArgs<ExtArgs>
    AutoPublish?: boolean | Guilds$AutoPublishArgs<ExtArgs>
    AutoReacts?: boolean | Guilds$AutoReactsArgs<ExtArgs>
    AutoRoles?: boolean | Guilds$AutoRolesArgs<ExtArgs>
    GuildBans?: boolean | Guilds$GuildBansArgs<ExtArgs>
    ChatModerations?: boolean | Guilds$ChatModerationsArgs<ExtArgs>
    ChannelLinks?: boolean | Guilds$ChannelLinksArgs<ExtArgs>
    DiscordAddons?: boolean | Guilds$DiscordAddonsArgs<ExtArgs>
    Giveaways?: boolean | Guilds$GiveawaysArgs<ExtArgs>
    TempVoices?: boolean | Guilds$TempVoicesArgs<ExtArgs>
    GuildLeaveSetup?: boolean | Guilds$GuildLeaveSetupArgs<ExtArgs>
    GuildLogging?: boolean | Guilds$GuildLoggingArgs<ExtArgs>
    MessageTemplates?: boolean | Guilds$MessageTemplatesArgs<ExtArgs>
    Permissions?: boolean | Guilds$PermissionsArgs<ExtArgs>
    ReactionRole?: boolean | Guilds$ReactionRoleArgs<ExtArgs>
    Security?: boolean | Guilds$SecurityArgs<ExtArgs>
    SpotifyNotifications?: boolean | Guilds$SpotifyNotificationsArgs<ExtArgs>
    Tags?: boolean | Guilds$TagsArgs<ExtArgs>
    TicketSetups?: boolean | Guilds$TicketSetupsArgs<ExtArgs>
    GuildFeatureToggle?: boolean | Guilds$GuildFeatureToggleArgs<ExtArgs>
    TwitchNotifications?: boolean | Guilds$TwitchNotificationsArgs<ExtArgs>
    GuildWelcomeSetup?: boolean | Guilds$GuildWelcomeSetupArgs<ExtArgs>
    YoutubeNotifications?: boolean | Guilds$YoutubeNotificationsArgs<ExtArgs>
    GuildLoggers?: boolean | Guilds$GuildLoggersArgs<ExtArgs>
    _count?: boolean | GuildsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guilds"]>



  export type GuildsSelectScalar = {
    id?: boolean
    GuildId?: boolean
    GuildName?: boolean
    GuildOwner?: boolean
  }

  export type GuildsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "GuildId" | "GuildName" | "GuildOwner", ExtArgs["result"]["guilds"]>
  export type GuildsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AutoAutoDeletes?: boolean | Guilds$AutoAutoDeletesArgs<ExtArgs>
    AutoPublish?: boolean | Guilds$AutoPublishArgs<ExtArgs>
    AutoReacts?: boolean | Guilds$AutoReactsArgs<ExtArgs>
    AutoRoles?: boolean | Guilds$AutoRolesArgs<ExtArgs>
    GuildBans?: boolean | Guilds$GuildBansArgs<ExtArgs>
    ChatModerations?: boolean | Guilds$ChatModerationsArgs<ExtArgs>
    ChannelLinks?: boolean | Guilds$ChannelLinksArgs<ExtArgs>
    DiscordAddons?: boolean | Guilds$DiscordAddonsArgs<ExtArgs>
    Giveaways?: boolean | Guilds$GiveawaysArgs<ExtArgs>
    TempVoices?: boolean | Guilds$TempVoicesArgs<ExtArgs>
    GuildLeaveSetup?: boolean | Guilds$GuildLeaveSetupArgs<ExtArgs>
    GuildLogging?: boolean | Guilds$GuildLoggingArgs<ExtArgs>
    MessageTemplates?: boolean | Guilds$MessageTemplatesArgs<ExtArgs>
    Permissions?: boolean | Guilds$PermissionsArgs<ExtArgs>
    ReactionRole?: boolean | Guilds$ReactionRoleArgs<ExtArgs>
    Security?: boolean | Guilds$SecurityArgs<ExtArgs>
    SpotifyNotifications?: boolean | Guilds$SpotifyNotificationsArgs<ExtArgs>
    Tags?: boolean | Guilds$TagsArgs<ExtArgs>
    TicketSetups?: boolean | Guilds$TicketSetupsArgs<ExtArgs>
    GuildFeatureToggle?: boolean | Guilds$GuildFeatureToggleArgs<ExtArgs>
    TwitchNotifications?: boolean | Guilds$TwitchNotificationsArgs<ExtArgs>
    GuildWelcomeSetup?: boolean | Guilds$GuildWelcomeSetupArgs<ExtArgs>
    YoutubeNotifications?: boolean | Guilds$YoutubeNotificationsArgs<ExtArgs>
    GuildLoggers?: boolean | Guilds$GuildLoggersArgs<ExtArgs>
    _count?: boolean | GuildsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $GuildsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Guilds"
    objects: {
      AutoAutoDeletes: Prisma.$AutoDeletesPayload<ExtArgs>[]
      AutoPublish: Prisma.$AutoPublishPayload<ExtArgs> | null
      AutoReacts: Prisma.$AutoReactsPayload<ExtArgs>[]
      AutoRoles: Prisma.$AutoRolesPayload<ExtArgs>[]
      GuildBans: Prisma.$GuildBansPayload<ExtArgs>[]
      ChatModerations: Prisma.$ChatModerationsPayload<ExtArgs> | null
      ChannelLinks: Prisma.$ChannelLinksPayload<ExtArgs>[]
      DiscordAddons: Prisma.$DiscordAddonsPayload<ExtArgs> | null
      Giveaways: Prisma.$GiveawaysPayload<ExtArgs>[]
      TempVoices: Prisma.$TempVoicesPayload<ExtArgs>[]
      GuildLeaveSetup: Prisma.$GuildLeaveSetupsPayload<ExtArgs> | null
      GuildLogging: Prisma.$GuildLoggingsPayload<ExtArgs> | null
      MessageTemplates: Prisma.$MessageTemplatesPayload<ExtArgs>[]
      Permissions: Prisma.$PermissionsPayload<ExtArgs> | null
      ReactionRole: Prisma.$ReactionRolesPayload<ExtArgs>[]
      Security: Prisma.$SecuritysPayload<ExtArgs> | null
      SpotifyNotifications: Prisma.$SpotifyNotificationsPayload<ExtArgs>[]
      Tags: Prisma.$TagsPayload<ExtArgs>[]
      TicketSetups: Prisma.$TicketSetupsPayload<ExtArgs>[]
      GuildFeatureToggle: Prisma.$GuildFeatureTogglesPayload<ExtArgs> | null
      TwitchNotifications: Prisma.$TwitchNotificationsPayload<ExtArgs>[]
      GuildWelcomeSetup: Prisma.$GuildWelcomeSetupsPayload<ExtArgs> | null
      YoutubeNotifications: Prisma.$YoutubeNotificationsPayload<ExtArgs>[]
      GuildLoggers: Prisma.$GuildLoggersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      GuildId: string
      GuildName: string
      GuildOwner: string
    }, ExtArgs["result"]["guilds"]>
    composites: {}
  }

  type GuildsGetPayload<S extends boolean | null | undefined | GuildsDefaultArgs> = $Result.GetResult<Prisma.$GuildsPayload, S>

  type GuildsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuildsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuildsCountAggregateInputType | true
    }

  export interface GuildsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Guilds'], meta: { name: 'Guilds' } }
    /**
     * Find zero or one Guilds that matches the filter.
     * @param {GuildsFindUniqueArgs} args - Arguments to find a Guilds
     * @example
     * // Get one Guilds
     * const guilds = await prisma.guilds.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuildsFindUniqueArgs>(args: SelectSubset<T, GuildsFindUniqueArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Guilds that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuildsFindUniqueOrThrowArgs} args - Arguments to find a Guilds
     * @example
     * // Get one Guilds
     * const guilds = await prisma.guilds.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuildsFindUniqueOrThrowArgs>(args: SelectSubset<T, GuildsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Guilds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildsFindFirstArgs} args - Arguments to find a Guilds
     * @example
     * // Get one Guilds
     * const guilds = await prisma.guilds.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuildsFindFirstArgs>(args?: SelectSubset<T, GuildsFindFirstArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Guilds that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildsFindFirstOrThrowArgs} args - Arguments to find a Guilds
     * @example
     * // Get one Guilds
     * const guilds = await prisma.guilds.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuildsFindFirstOrThrowArgs>(args?: SelectSubset<T, GuildsFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Guilds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guilds
     * const guilds = await prisma.guilds.findMany()
     * 
     * // Get first 10 Guilds
     * const guilds = await prisma.guilds.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildsWithIdOnly = await prisma.guilds.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuildsFindManyArgs>(args?: SelectSubset<T, GuildsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Guilds.
     * @param {GuildsCreateArgs} args - Arguments to create a Guilds.
     * @example
     * // Create one Guilds
     * const Guilds = await prisma.guilds.create({
     *   data: {
     *     // ... data to create a Guilds
     *   }
     * })
     * 
     */
    create<T extends GuildsCreateArgs>(args: SelectSubset<T, GuildsCreateArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Guilds.
     * @param {GuildsCreateManyArgs} args - Arguments to create many Guilds.
     * @example
     * // Create many Guilds
     * const guilds = await prisma.guilds.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuildsCreateManyArgs>(args?: SelectSubset<T, GuildsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Guilds.
     * @param {GuildsDeleteArgs} args - Arguments to delete one Guilds.
     * @example
     * // Delete one Guilds
     * const Guilds = await prisma.guilds.delete({
     *   where: {
     *     // ... filter to delete one Guilds
     *   }
     * })
     * 
     */
    delete<T extends GuildsDeleteArgs>(args: SelectSubset<T, GuildsDeleteArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Guilds.
     * @param {GuildsUpdateArgs} args - Arguments to update one Guilds.
     * @example
     * // Update one Guilds
     * const guilds = await prisma.guilds.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuildsUpdateArgs>(args: SelectSubset<T, GuildsUpdateArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Guilds.
     * @param {GuildsDeleteManyArgs} args - Arguments to filter Guilds to delete.
     * @example
     * // Delete a few Guilds
     * const { count } = await prisma.guilds.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuildsDeleteManyArgs>(args?: SelectSubset<T, GuildsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guilds
     * const guilds = await prisma.guilds.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuildsUpdateManyArgs>(args: SelectSubset<T, GuildsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Guilds.
     * @param {GuildsUpsertArgs} args - Arguments to update or create a Guilds.
     * @example
     * // Update or create a Guilds
     * const guilds = await prisma.guilds.upsert({
     *   create: {
     *     // ... data to create a Guilds
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guilds we want to update
     *   }
     * })
     */
    upsert<T extends GuildsUpsertArgs>(args: SelectSubset<T, GuildsUpsertArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Guilds that matches the filter.
     * @param {GuildsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const guilds = await prisma.guilds.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: GuildsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Guilds.
     * @param {GuildsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const guilds = await prisma.guilds.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: GuildsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Guilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildsCountArgs} args - Arguments to filter Guilds to count.
     * @example
     * // Count the number of Guilds
     * const count = await prisma.guilds.count({
     *   where: {
     *     // ... the filter for the Guilds we want to count
     *   }
     * })
    **/
    count<T extends GuildsCountArgs>(
      args?: Subset<T, GuildsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildsAggregateArgs>(args: Subset<T, GuildsAggregateArgs>): Prisma.PrismaPromise<GetGuildsAggregateType<T>>

    /**
     * Group by Guilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildsGroupByArgs['orderBy'] }
        : { orderBy?: GuildsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Guilds model
   */
  readonly fields: GuildsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Guilds.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuildsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AutoAutoDeletes<T extends Guilds$AutoAutoDeletesArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$AutoAutoDeletesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoDeletesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AutoPublish<T extends Guilds$AutoPublishArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$AutoPublishArgs<ExtArgs>>): Prisma__AutoPublishClient<$Result.GetResult<Prisma.$AutoPublishPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    AutoReacts<T extends Guilds$AutoReactsArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$AutoReactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoReactsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AutoRoles<T extends Guilds$AutoRolesArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$AutoRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoRolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    GuildBans<T extends Guilds$GuildBansArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$GuildBansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildBansPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ChatModerations<T extends Guilds$ChatModerationsArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$ChatModerationsArgs<ExtArgs>>): Prisma__ChatModerationsClient<$Result.GetResult<Prisma.$ChatModerationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ChannelLinks<T extends Guilds$ChannelLinksArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$ChannelLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelLinksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DiscordAddons<T extends Guilds$DiscordAddonsArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$DiscordAddonsArgs<ExtArgs>>): Prisma__DiscordAddonsClient<$Result.GetResult<Prisma.$DiscordAddonsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Giveaways<T extends Guilds$GiveawaysArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$GiveawaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GiveawaysPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TempVoices<T extends Guilds$TempVoicesArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$TempVoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TempVoicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    GuildLeaveSetup<T extends Guilds$GuildLeaveSetupArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$GuildLeaveSetupArgs<ExtArgs>>): Prisma__GuildLeaveSetupsClient<$Result.GetResult<Prisma.$GuildLeaveSetupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    GuildLogging<T extends Guilds$GuildLoggingArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$GuildLoggingArgs<ExtArgs>>): Prisma__GuildLoggingsClient<$Result.GetResult<Prisma.$GuildLoggingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    MessageTemplates<T extends Guilds$MessageTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$MessageTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageTemplatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Permissions<T extends Guilds$PermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$PermissionsArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ReactionRole<T extends Guilds$ReactionRoleArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$ReactionRoleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionRolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Security<T extends Guilds$SecurityArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$SecurityArgs<ExtArgs>>): Prisma__SecuritysClient<$Result.GetResult<Prisma.$SecuritysPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    SpotifyNotifications<T extends Guilds$SpotifyNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$SpotifyNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpotifyNotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Tags<T extends Guilds$TagsArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$TagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TicketSetups<T extends Guilds$TicketSetupsArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$TicketSetupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketSetupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    GuildFeatureToggle<T extends Guilds$GuildFeatureToggleArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$GuildFeatureToggleArgs<ExtArgs>>): Prisma__GuildFeatureTogglesClient<$Result.GetResult<Prisma.$GuildFeatureTogglesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    TwitchNotifications<T extends Guilds$TwitchNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$TwitchNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwitchNotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    GuildWelcomeSetup<T extends Guilds$GuildWelcomeSetupArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$GuildWelcomeSetupArgs<ExtArgs>>): Prisma__GuildWelcomeSetupsClient<$Result.GetResult<Prisma.$GuildWelcomeSetupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    YoutubeNotifications<T extends Guilds$YoutubeNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$YoutubeNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YoutubeNotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    GuildLoggers<T extends Guilds$GuildLoggersArgs<ExtArgs> = {}>(args?: Subset<T, Guilds$GuildLoggersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildLoggersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Guilds model
   */
  interface GuildsFieldRefs {
    readonly id: FieldRef<"Guilds", 'String'>
    readonly GuildId: FieldRef<"Guilds", 'String'>
    readonly GuildName: FieldRef<"Guilds", 'String'>
    readonly GuildOwner: FieldRef<"Guilds", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Guilds findUnique
   */
  export type GuildsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guilds
     */
    select?: GuildsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guilds
     */
    omit?: GuildsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildsInclude<ExtArgs> | null
    /**
     * Filter, which Guilds to fetch.
     */
    where: GuildsWhereUniqueInput
  }

  /**
   * Guilds findUniqueOrThrow
   */
  export type GuildsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guilds
     */
    select?: GuildsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guilds
     */
    omit?: GuildsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildsInclude<ExtArgs> | null
    /**
     * Filter, which Guilds to fetch.
     */
    where: GuildsWhereUniqueInput
  }

  /**
   * Guilds findFirst
   */
  export type GuildsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guilds
     */
    select?: GuildsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guilds
     */
    omit?: GuildsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildsInclude<ExtArgs> | null
    /**
     * Filter, which Guilds to fetch.
     */
    where?: GuildsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guilds to fetch.
     */
    orderBy?: GuildsOrderByWithRelationInput | GuildsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guilds.
     */
    cursor?: GuildsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guilds.
     */
    distinct?: GuildsScalarFieldEnum | GuildsScalarFieldEnum[]
  }

  /**
   * Guilds findFirstOrThrow
   */
  export type GuildsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guilds
     */
    select?: GuildsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guilds
     */
    omit?: GuildsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildsInclude<ExtArgs> | null
    /**
     * Filter, which Guilds to fetch.
     */
    where?: GuildsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guilds to fetch.
     */
    orderBy?: GuildsOrderByWithRelationInput | GuildsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guilds.
     */
    cursor?: GuildsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guilds.
     */
    distinct?: GuildsScalarFieldEnum | GuildsScalarFieldEnum[]
  }

  /**
   * Guilds findMany
   */
  export type GuildsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guilds
     */
    select?: GuildsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guilds
     */
    omit?: GuildsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildsInclude<ExtArgs> | null
    /**
     * Filter, which Guilds to fetch.
     */
    where?: GuildsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guilds to fetch.
     */
    orderBy?: GuildsOrderByWithRelationInput | GuildsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Guilds.
     */
    cursor?: GuildsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guilds.
     */
    skip?: number
    distinct?: GuildsScalarFieldEnum | GuildsScalarFieldEnum[]
  }

  /**
   * Guilds create
   */
  export type GuildsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guilds
     */
    select?: GuildsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guilds
     */
    omit?: GuildsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildsInclude<ExtArgs> | null
    /**
     * The data needed to create a Guilds.
     */
    data: XOR<GuildsCreateInput, GuildsUncheckedCreateInput>
  }

  /**
   * Guilds createMany
   */
  export type GuildsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Guilds.
     */
    data: GuildsCreateManyInput | GuildsCreateManyInput[]
  }

  /**
   * Guilds update
   */
  export type GuildsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guilds
     */
    select?: GuildsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guilds
     */
    omit?: GuildsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildsInclude<ExtArgs> | null
    /**
     * The data needed to update a Guilds.
     */
    data: XOR<GuildsUpdateInput, GuildsUncheckedUpdateInput>
    /**
     * Choose, which Guilds to update.
     */
    where: GuildsWhereUniqueInput
  }

  /**
   * Guilds updateMany
   */
  export type GuildsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Guilds.
     */
    data: XOR<GuildsUpdateManyMutationInput, GuildsUncheckedUpdateManyInput>
    /**
     * Filter which Guilds to update
     */
    where?: GuildsWhereInput
    /**
     * Limit how many Guilds to update.
     */
    limit?: number
  }

  /**
   * Guilds upsert
   */
  export type GuildsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guilds
     */
    select?: GuildsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guilds
     */
    omit?: GuildsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildsInclude<ExtArgs> | null
    /**
     * The filter to search for the Guilds to update in case it exists.
     */
    where: GuildsWhereUniqueInput
    /**
     * In case the Guilds found by the `where` argument doesn't exist, create a new Guilds with this data.
     */
    create: XOR<GuildsCreateInput, GuildsUncheckedCreateInput>
    /**
     * In case the Guilds was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuildsUpdateInput, GuildsUncheckedUpdateInput>
  }

  /**
   * Guilds delete
   */
  export type GuildsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guilds
     */
    select?: GuildsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guilds
     */
    omit?: GuildsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildsInclude<ExtArgs> | null
    /**
     * Filter which Guilds to delete.
     */
    where: GuildsWhereUniqueInput
  }

  /**
   * Guilds deleteMany
   */
  export type GuildsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guilds to delete
     */
    where?: GuildsWhereInput
    /**
     * Limit how many Guilds to delete.
     */
    limit?: number
  }

  /**
   * Guilds findRaw
   */
  export type GuildsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Guilds aggregateRaw
   */
  export type GuildsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Guilds.AutoAutoDeletes
   */
  export type Guilds$AutoAutoDeletesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoDeletes
     */
    select?: AutoDeletesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoDeletes
     */
    omit?: AutoDeletesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoDeletesInclude<ExtArgs> | null
    where?: AutoDeletesWhereInput
    orderBy?: AutoDeletesOrderByWithRelationInput | AutoDeletesOrderByWithRelationInput[]
    cursor?: AutoDeletesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutoDeletesScalarFieldEnum | AutoDeletesScalarFieldEnum[]
  }

  /**
   * Guilds.AutoPublish
   */
  export type Guilds$AutoPublishArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoPublish
     */
    select?: AutoPublishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoPublish
     */
    omit?: AutoPublishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoPublishInclude<ExtArgs> | null
    where?: AutoPublishWhereInput
  }

  /**
   * Guilds.AutoReacts
   */
  export type Guilds$AutoReactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoReacts
     */
    select?: AutoReactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoReacts
     */
    omit?: AutoReactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoReactsInclude<ExtArgs> | null
    where?: AutoReactsWhereInput
    orderBy?: AutoReactsOrderByWithRelationInput | AutoReactsOrderByWithRelationInput[]
    cursor?: AutoReactsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutoReactsScalarFieldEnum | AutoReactsScalarFieldEnum[]
  }

  /**
   * Guilds.AutoRoles
   */
  export type Guilds$AutoRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRoles
     */
    select?: AutoRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoRoles
     */
    omit?: AutoRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRolesInclude<ExtArgs> | null
    where?: AutoRolesWhereInput
    orderBy?: AutoRolesOrderByWithRelationInput | AutoRolesOrderByWithRelationInput[]
    cursor?: AutoRolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutoRolesScalarFieldEnum | AutoRolesScalarFieldEnum[]
  }

  /**
   * Guilds.GuildBans
   */
  export type Guilds$GuildBansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBans
     */
    select?: GuildBansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBans
     */
    omit?: GuildBansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBansInclude<ExtArgs> | null
    where?: GuildBansWhereInput
    orderBy?: GuildBansOrderByWithRelationInput | GuildBansOrderByWithRelationInput[]
    cursor?: GuildBansWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GuildBansScalarFieldEnum | GuildBansScalarFieldEnum[]
  }

  /**
   * Guilds.ChatModerations
   */
  export type Guilds$ChatModerationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatModerations
     */
    select?: ChatModerationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatModerations
     */
    omit?: ChatModerationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatModerationsInclude<ExtArgs> | null
    where?: ChatModerationsWhereInput
  }

  /**
   * Guilds.ChannelLinks
   */
  export type Guilds$ChannelLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelLinks
     */
    select?: ChannelLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelLinks
     */
    omit?: ChannelLinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelLinksInclude<ExtArgs> | null
    where?: ChannelLinksWhereInput
    orderBy?: ChannelLinksOrderByWithRelationInput | ChannelLinksOrderByWithRelationInput[]
    cursor?: ChannelLinksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelLinksScalarFieldEnum | ChannelLinksScalarFieldEnum[]
  }

  /**
   * Guilds.DiscordAddons
   */
  export type Guilds$DiscordAddonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAddons
     */
    select?: DiscordAddonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAddons
     */
    omit?: DiscordAddonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAddonsInclude<ExtArgs> | null
    where?: DiscordAddonsWhereInput
  }

  /**
   * Guilds.Giveaways
   */
  export type Guilds$GiveawaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Giveaways
     */
    select?: GiveawaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Giveaways
     */
    omit?: GiveawaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiveawaysInclude<ExtArgs> | null
    where?: GiveawaysWhereInput
    orderBy?: GiveawaysOrderByWithRelationInput | GiveawaysOrderByWithRelationInput[]
    cursor?: GiveawaysWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GiveawaysScalarFieldEnum | GiveawaysScalarFieldEnum[]
  }

  /**
   * Guilds.TempVoices
   */
  export type Guilds$TempVoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempVoices
     */
    select?: TempVoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempVoices
     */
    omit?: TempVoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempVoicesInclude<ExtArgs> | null
    where?: TempVoicesWhereInput
    orderBy?: TempVoicesOrderByWithRelationInput | TempVoicesOrderByWithRelationInput[]
    cursor?: TempVoicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TempVoicesScalarFieldEnum | TempVoicesScalarFieldEnum[]
  }

  /**
   * Guilds.GuildLeaveSetup
   */
  export type Guilds$GuildLeaveSetupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLeaveSetups
     */
    select?: GuildLeaveSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLeaveSetups
     */
    omit?: GuildLeaveSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLeaveSetupsInclude<ExtArgs> | null
    where?: GuildLeaveSetupsWhereInput
  }

  /**
   * Guilds.GuildLogging
   */
  export type Guilds$GuildLoggingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLoggings
     */
    select?: GuildLoggingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLoggings
     */
    omit?: GuildLoggingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLoggingsInclude<ExtArgs> | null
    where?: GuildLoggingsWhereInput
  }

  /**
   * Guilds.MessageTemplates
   */
  export type Guilds$MessageTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplates
     */
    select?: MessageTemplatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplates
     */
    omit?: MessageTemplatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplatesInclude<ExtArgs> | null
    where?: MessageTemplatesWhereInput
    orderBy?: MessageTemplatesOrderByWithRelationInput | MessageTemplatesOrderByWithRelationInput[]
    cursor?: MessageTemplatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageTemplatesScalarFieldEnum | MessageTemplatesScalarFieldEnum[]
  }

  /**
   * Guilds.Permissions
   */
  export type Guilds$PermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    where?: PermissionsWhereInput
  }

  /**
   * Guilds.ReactionRole
   */
  export type Guilds$ReactionRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReactionRoles
     */
    select?: ReactionRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReactionRoles
     */
    omit?: ReactionRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionRolesInclude<ExtArgs> | null
    where?: ReactionRolesWhereInput
    orderBy?: ReactionRolesOrderByWithRelationInput | ReactionRolesOrderByWithRelationInput[]
    cursor?: ReactionRolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReactionRolesScalarFieldEnum | ReactionRolesScalarFieldEnum[]
  }

  /**
   * Guilds.Security
   */
  export type Guilds$SecurityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Securitys
     */
    select?: SecuritysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Securitys
     */
    omit?: SecuritysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecuritysInclude<ExtArgs> | null
    where?: SecuritysWhereInput
  }

  /**
   * Guilds.SpotifyNotifications
   */
  export type Guilds$SpotifyNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpotifyNotifications
     */
    select?: SpotifyNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpotifyNotifications
     */
    omit?: SpotifyNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpotifyNotificationsInclude<ExtArgs> | null
    where?: SpotifyNotificationsWhereInput
    orderBy?: SpotifyNotificationsOrderByWithRelationInput | SpotifyNotificationsOrderByWithRelationInput[]
    cursor?: SpotifyNotificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpotifyNotificationsScalarFieldEnum | SpotifyNotificationsScalarFieldEnum[]
  }

  /**
   * Guilds.Tags
   */
  export type Guilds$TagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    where?: TagsWhereInput
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    cursor?: TagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Guilds.TicketSetups
   */
  export type Guilds$TicketSetupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSetups
     */
    select?: TicketSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketSetups
     */
    omit?: TicketSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketSetupsInclude<ExtArgs> | null
    where?: TicketSetupsWhereInput
    orderBy?: TicketSetupsOrderByWithRelationInput | TicketSetupsOrderByWithRelationInput[]
    cursor?: TicketSetupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketSetupsScalarFieldEnum | TicketSetupsScalarFieldEnum[]
  }

  /**
   * Guilds.GuildFeatureToggle
   */
  export type Guilds$GuildFeatureToggleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildFeatureToggles
     */
    select?: GuildFeatureTogglesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildFeatureToggles
     */
    omit?: GuildFeatureTogglesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildFeatureTogglesInclude<ExtArgs> | null
    where?: GuildFeatureTogglesWhereInput
  }

  /**
   * Guilds.TwitchNotifications
   */
  export type Guilds$TwitchNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitchNotifications
     */
    select?: TwitchNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitchNotifications
     */
    omit?: TwitchNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitchNotificationsInclude<ExtArgs> | null
    where?: TwitchNotificationsWhereInput
    orderBy?: TwitchNotificationsOrderByWithRelationInput | TwitchNotificationsOrderByWithRelationInput[]
    cursor?: TwitchNotificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TwitchNotificationsScalarFieldEnum | TwitchNotificationsScalarFieldEnum[]
  }

  /**
   * Guilds.GuildWelcomeSetup
   */
  export type Guilds$GuildWelcomeSetupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildWelcomeSetups
     */
    select?: GuildWelcomeSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildWelcomeSetups
     */
    omit?: GuildWelcomeSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildWelcomeSetupsInclude<ExtArgs> | null
    where?: GuildWelcomeSetupsWhereInput
  }

  /**
   * Guilds.YoutubeNotifications
   */
  export type Guilds$YoutubeNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YoutubeNotifications
     */
    select?: YoutubeNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YoutubeNotifications
     */
    omit?: YoutubeNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YoutubeNotificationsInclude<ExtArgs> | null
    where?: YoutubeNotificationsWhereInput
    orderBy?: YoutubeNotificationsOrderByWithRelationInput | YoutubeNotificationsOrderByWithRelationInput[]
    cursor?: YoutubeNotificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: YoutubeNotificationsScalarFieldEnum | YoutubeNotificationsScalarFieldEnum[]
  }

  /**
   * Guilds.GuildLoggers
   */
  export type Guilds$GuildLoggersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLoggers
     */
    select?: GuildLoggersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLoggers
     */
    omit?: GuildLoggersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLoggersInclude<ExtArgs> | null
    where?: GuildLoggersWhereInput
    orderBy?: GuildLoggersOrderByWithRelationInput | GuildLoggersOrderByWithRelationInput[]
    cursor?: GuildLoggersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GuildLoggersScalarFieldEnum | GuildLoggersScalarFieldEnum[]
  }

  /**
   * Guilds without action
   */
  export type GuildsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guilds
     */
    select?: GuildsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guilds
     */
    omit?: GuildsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildsInclude<ExtArgs> | null
  }


  /**
   * Model AutoDeletes
   */

  export type AggregateAutoDeletes = {
    _count: AutoDeletesCountAggregateOutputType | null
    _min: AutoDeletesMinAggregateOutputType | null
    _max: AutoDeletesMaxAggregateOutputType | null
  }

  export type AutoDeletesMinAggregateOutputType = {
    id: string | null
    ChannelId: string | null
    IsActive: boolean | null
    Time: string | null
    UUID: string | null
    GuildId: string | null
  }

  export type AutoDeletesMaxAggregateOutputType = {
    id: string | null
    ChannelId: string | null
    IsActive: boolean | null
    Time: string | null
    UUID: string | null
    GuildId: string | null
  }

  export type AutoDeletesCountAggregateOutputType = {
    id: number
    ChannelId: number
    IsActive: number
    Time: number
    UUID: number
    WhitelistedMessages: number
    WhitelistedRoles: number
    WhitelistedUsers: number
    GuildId: number
    _all: number
  }


  export type AutoDeletesMinAggregateInputType = {
    id?: true
    ChannelId?: true
    IsActive?: true
    Time?: true
    UUID?: true
    GuildId?: true
  }

  export type AutoDeletesMaxAggregateInputType = {
    id?: true
    ChannelId?: true
    IsActive?: true
    Time?: true
    UUID?: true
    GuildId?: true
  }

  export type AutoDeletesCountAggregateInputType = {
    id?: true
    ChannelId?: true
    IsActive?: true
    Time?: true
    UUID?: true
    WhitelistedMessages?: true
    WhitelistedRoles?: true
    WhitelistedUsers?: true
    GuildId?: true
    _all?: true
  }

  export type AutoDeletesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoDeletes to aggregate.
     */
    where?: AutoDeletesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoDeletes to fetch.
     */
    orderBy?: AutoDeletesOrderByWithRelationInput | AutoDeletesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutoDeletesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoDeletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoDeletes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutoDeletes
    **/
    _count?: true | AutoDeletesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutoDeletesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutoDeletesMaxAggregateInputType
  }

  export type GetAutoDeletesAggregateType<T extends AutoDeletesAggregateArgs> = {
        [P in keyof T & keyof AggregateAutoDeletes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutoDeletes[P]>
      : GetScalarType<T[P], AggregateAutoDeletes[P]>
  }




  export type AutoDeletesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoDeletesWhereInput
    orderBy?: AutoDeletesOrderByWithAggregationInput | AutoDeletesOrderByWithAggregationInput[]
    by: AutoDeletesScalarFieldEnum[] | AutoDeletesScalarFieldEnum
    having?: AutoDeletesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutoDeletesCountAggregateInputType | true
    _min?: AutoDeletesMinAggregateInputType
    _max?: AutoDeletesMaxAggregateInputType
  }

  export type AutoDeletesGroupByOutputType = {
    id: string
    ChannelId: string | null
    IsActive: boolean | null
    Time: string | null
    UUID: string | null
    WhitelistedMessages: string[]
    WhitelistedRoles: string[]
    WhitelistedUsers: string[]
    GuildId: string
    _count: AutoDeletesCountAggregateOutputType | null
    _min: AutoDeletesMinAggregateOutputType | null
    _max: AutoDeletesMaxAggregateOutputType | null
  }

  type GetAutoDeletesGroupByPayload<T extends AutoDeletesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutoDeletesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutoDeletesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutoDeletesGroupByOutputType[P]>
            : GetScalarType<T[P], AutoDeletesGroupByOutputType[P]>
        }
      >
    >


  export type AutoDeletesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ChannelId?: boolean
    IsActive?: boolean
    Time?: boolean
    UUID?: boolean
    WhitelistedMessages?: boolean
    WhitelistedRoles?: boolean
    WhitelistedUsers?: boolean
    GuildId?: boolean
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autoDeletes"]>



  export type AutoDeletesSelectScalar = {
    id?: boolean
    ChannelId?: boolean
    IsActive?: boolean
    Time?: boolean
    UUID?: boolean
    WhitelistedMessages?: boolean
    WhitelistedRoles?: boolean
    WhitelistedUsers?: boolean
    GuildId?: boolean
  }

  export type AutoDeletesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ChannelId" | "IsActive" | "Time" | "UUID" | "WhitelistedMessages" | "WhitelistedRoles" | "WhitelistedUsers" | "GuildId", ExtArgs["result"]["autoDeletes"]>
  export type AutoDeletesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }

  export type $AutoDeletesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutoDeletes"
    objects: {
      Guilds: Prisma.$GuildsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ChannelId: string | null
      IsActive: boolean | null
      Time: string | null
      UUID: string | null
      WhitelistedMessages: string[]
      WhitelistedRoles: string[]
      WhitelistedUsers: string[]
      GuildId: string
    }, ExtArgs["result"]["autoDeletes"]>
    composites: {}
  }

  type AutoDeletesGetPayload<S extends boolean | null | undefined | AutoDeletesDefaultArgs> = $Result.GetResult<Prisma.$AutoDeletesPayload, S>

  type AutoDeletesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutoDeletesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutoDeletesCountAggregateInputType | true
    }

  export interface AutoDeletesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutoDeletes'], meta: { name: 'AutoDeletes' } }
    /**
     * Find zero or one AutoDeletes that matches the filter.
     * @param {AutoDeletesFindUniqueArgs} args - Arguments to find a AutoDeletes
     * @example
     * // Get one AutoDeletes
     * const autoDeletes = await prisma.autoDeletes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutoDeletesFindUniqueArgs>(args: SelectSubset<T, AutoDeletesFindUniqueArgs<ExtArgs>>): Prisma__AutoDeletesClient<$Result.GetResult<Prisma.$AutoDeletesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AutoDeletes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutoDeletesFindUniqueOrThrowArgs} args - Arguments to find a AutoDeletes
     * @example
     * // Get one AutoDeletes
     * const autoDeletes = await prisma.autoDeletes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutoDeletesFindUniqueOrThrowArgs>(args: SelectSubset<T, AutoDeletesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutoDeletesClient<$Result.GetResult<Prisma.$AutoDeletesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutoDeletes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoDeletesFindFirstArgs} args - Arguments to find a AutoDeletes
     * @example
     * // Get one AutoDeletes
     * const autoDeletes = await prisma.autoDeletes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutoDeletesFindFirstArgs>(args?: SelectSubset<T, AutoDeletesFindFirstArgs<ExtArgs>>): Prisma__AutoDeletesClient<$Result.GetResult<Prisma.$AutoDeletesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutoDeletes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoDeletesFindFirstOrThrowArgs} args - Arguments to find a AutoDeletes
     * @example
     * // Get one AutoDeletes
     * const autoDeletes = await prisma.autoDeletes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutoDeletesFindFirstOrThrowArgs>(args?: SelectSubset<T, AutoDeletesFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutoDeletesClient<$Result.GetResult<Prisma.$AutoDeletesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AutoDeletes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoDeletesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutoDeletes
     * const autoDeletes = await prisma.autoDeletes.findMany()
     * 
     * // Get first 10 AutoDeletes
     * const autoDeletes = await prisma.autoDeletes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const autoDeletesWithIdOnly = await prisma.autoDeletes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutoDeletesFindManyArgs>(args?: SelectSubset<T, AutoDeletesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoDeletesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AutoDeletes.
     * @param {AutoDeletesCreateArgs} args - Arguments to create a AutoDeletes.
     * @example
     * // Create one AutoDeletes
     * const AutoDeletes = await prisma.autoDeletes.create({
     *   data: {
     *     // ... data to create a AutoDeletes
     *   }
     * })
     * 
     */
    create<T extends AutoDeletesCreateArgs>(args: SelectSubset<T, AutoDeletesCreateArgs<ExtArgs>>): Prisma__AutoDeletesClient<$Result.GetResult<Prisma.$AutoDeletesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AutoDeletes.
     * @param {AutoDeletesCreateManyArgs} args - Arguments to create many AutoDeletes.
     * @example
     * // Create many AutoDeletes
     * const autoDeletes = await prisma.autoDeletes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutoDeletesCreateManyArgs>(args?: SelectSubset<T, AutoDeletesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AutoDeletes.
     * @param {AutoDeletesDeleteArgs} args - Arguments to delete one AutoDeletes.
     * @example
     * // Delete one AutoDeletes
     * const AutoDeletes = await prisma.autoDeletes.delete({
     *   where: {
     *     // ... filter to delete one AutoDeletes
     *   }
     * })
     * 
     */
    delete<T extends AutoDeletesDeleteArgs>(args: SelectSubset<T, AutoDeletesDeleteArgs<ExtArgs>>): Prisma__AutoDeletesClient<$Result.GetResult<Prisma.$AutoDeletesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AutoDeletes.
     * @param {AutoDeletesUpdateArgs} args - Arguments to update one AutoDeletes.
     * @example
     * // Update one AutoDeletes
     * const autoDeletes = await prisma.autoDeletes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutoDeletesUpdateArgs>(args: SelectSubset<T, AutoDeletesUpdateArgs<ExtArgs>>): Prisma__AutoDeletesClient<$Result.GetResult<Prisma.$AutoDeletesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AutoDeletes.
     * @param {AutoDeletesDeleteManyArgs} args - Arguments to filter AutoDeletes to delete.
     * @example
     * // Delete a few AutoDeletes
     * const { count } = await prisma.autoDeletes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutoDeletesDeleteManyArgs>(args?: SelectSubset<T, AutoDeletesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutoDeletes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoDeletesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutoDeletes
     * const autoDeletes = await prisma.autoDeletes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutoDeletesUpdateManyArgs>(args: SelectSubset<T, AutoDeletesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AutoDeletes.
     * @param {AutoDeletesUpsertArgs} args - Arguments to update or create a AutoDeletes.
     * @example
     * // Update or create a AutoDeletes
     * const autoDeletes = await prisma.autoDeletes.upsert({
     *   create: {
     *     // ... data to create a AutoDeletes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutoDeletes we want to update
     *   }
     * })
     */
    upsert<T extends AutoDeletesUpsertArgs>(args: SelectSubset<T, AutoDeletesUpsertArgs<ExtArgs>>): Prisma__AutoDeletesClient<$Result.GetResult<Prisma.$AutoDeletesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AutoDeletes that matches the filter.
     * @param {AutoDeletesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const autoDeletes = await prisma.autoDeletes.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AutoDeletesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AutoDeletes.
     * @param {AutoDeletesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const autoDeletes = await prisma.autoDeletes.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AutoDeletesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AutoDeletes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoDeletesCountArgs} args - Arguments to filter AutoDeletes to count.
     * @example
     * // Count the number of AutoDeletes
     * const count = await prisma.autoDeletes.count({
     *   where: {
     *     // ... the filter for the AutoDeletes we want to count
     *   }
     * })
    **/
    count<T extends AutoDeletesCountArgs>(
      args?: Subset<T, AutoDeletesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutoDeletesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutoDeletes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoDeletesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutoDeletesAggregateArgs>(args: Subset<T, AutoDeletesAggregateArgs>): Prisma.PrismaPromise<GetAutoDeletesAggregateType<T>>

    /**
     * Group by AutoDeletes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoDeletesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutoDeletesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutoDeletesGroupByArgs['orderBy'] }
        : { orderBy?: AutoDeletesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutoDeletesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutoDeletesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutoDeletes model
   */
  readonly fields: AutoDeletesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutoDeletes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutoDeletesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutoDeletes model
   */
  interface AutoDeletesFieldRefs {
    readonly id: FieldRef<"AutoDeletes", 'String'>
    readonly ChannelId: FieldRef<"AutoDeletes", 'String'>
    readonly IsActive: FieldRef<"AutoDeletes", 'Boolean'>
    readonly Time: FieldRef<"AutoDeletes", 'String'>
    readonly UUID: FieldRef<"AutoDeletes", 'String'>
    readonly WhitelistedMessages: FieldRef<"AutoDeletes", 'String[]'>
    readonly WhitelistedRoles: FieldRef<"AutoDeletes", 'String[]'>
    readonly WhitelistedUsers: FieldRef<"AutoDeletes", 'String[]'>
    readonly GuildId: FieldRef<"AutoDeletes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AutoDeletes findUnique
   */
  export type AutoDeletesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoDeletes
     */
    select?: AutoDeletesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoDeletes
     */
    omit?: AutoDeletesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoDeletesInclude<ExtArgs> | null
    /**
     * Filter, which AutoDeletes to fetch.
     */
    where: AutoDeletesWhereUniqueInput
  }

  /**
   * AutoDeletes findUniqueOrThrow
   */
  export type AutoDeletesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoDeletes
     */
    select?: AutoDeletesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoDeletes
     */
    omit?: AutoDeletesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoDeletesInclude<ExtArgs> | null
    /**
     * Filter, which AutoDeletes to fetch.
     */
    where: AutoDeletesWhereUniqueInput
  }

  /**
   * AutoDeletes findFirst
   */
  export type AutoDeletesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoDeletes
     */
    select?: AutoDeletesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoDeletes
     */
    omit?: AutoDeletesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoDeletesInclude<ExtArgs> | null
    /**
     * Filter, which AutoDeletes to fetch.
     */
    where?: AutoDeletesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoDeletes to fetch.
     */
    orderBy?: AutoDeletesOrderByWithRelationInput | AutoDeletesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoDeletes.
     */
    cursor?: AutoDeletesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoDeletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoDeletes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoDeletes.
     */
    distinct?: AutoDeletesScalarFieldEnum | AutoDeletesScalarFieldEnum[]
  }

  /**
   * AutoDeletes findFirstOrThrow
   */
  export type AutoDeletesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoDeletes
     */
    select?: AutoDeletesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoDeletes
     */
    omit?: AutoDeletesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoDeletesInclude<ExtArgs> | null
    /**
     * Filter, which AutoDeletes to fetch.
     */
    where?: AutoDeletesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoDeletes to fetch.
     */
    orderBy?: AutoDeletesOrderByWithRelationInput | AutoDeletesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoDeletes.
     */
    cursor?: AutoDeletesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoDeletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoDeletes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoDeletes.
     */
    distinct?: AutoDeletesScalarFieldEnum | AutoDeletesScalarFieldEnum[]
  }

  /**
   * AutoDeletes findMany
   */
  export type AutoDeletesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoDeletes
     */
    select?: AutoDeletesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoDeletes
     */
    omit?: AutoDeletesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoDeletesInclude<ExtArgs> | null
    /**
     * Filter, which AutoDeletes to fetch.
     */
    where?: AutoDeletesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoDeletes to fetch.
     */
    orderBy?: AutoDeletesOrderByWithRelationInput | AutoDeletesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutoDeletes.
     */
    cursor?: AutoDeletesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoDeletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoDeletes.
     */
    skip?: number
    distinct?: AutoDeletesScalarFieldEnum | AutoDeletesScalarFieldEnum[]
  }

  /**
   * AutoDeletes create
   */
  export type AutoDeletesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoDeletes
     */
    select?: AutoDeletesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoDeletes
     */
    omit?: AutoDeletesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoDeletesInclude<ExtArgs> | null
    /**
     * The data needed to create a AutoDeletes.
     */
    data: XOR<AutoDeletesCreateInput, AutoDeletesUncheckedCreateInput>
  }

  /**
   * AutoDeletes createMany
   */
  export type AutoDeletesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutoDeletes.
     */
    data: AutoDeletesCreateManyInput | AutoDeletesCreateManyInput[]
  }

  /**
   * AutoDeletes update
   */
  export type AutoDeletesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoDeletes
     */
    select?: AutoDeletesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoDeletes
     */
    omit?: AutoDeletesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoDeletesInclude<ExtArgs> | null
    /**
     * The data needed to update a AutoDeletes.
     */
    data: XOR<AutoDeletesUpdateInput, AutoDeletesUncheckedUpdateInput>
    /**
     * Choose, which AutoDeletes to update.
     */
    where: AutoDeletesWhereUniqueInput
  }

  /**
   * AutoDeletes updateMany
   */
  export type AutoDeletesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutoDeletes.
     */
    data: XOR<AutoDeletesUpdateManyMutationInput, AutoDeletesUncheckedUpdateManyInput>
    /**
     * Filter which AutoDeletes to update
     */
    where?: AutoDeletesWhereInput
    /**
     * Limit how many AutoDeletes to update.
     */
    limit?: number
  }

  /**
   * AutoDeletes upsert
   */
  export type AutoDeletesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoDeletes
     */
    select?: AutoDeletesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoDeletes
     */
    omit?: AutoDeletesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoDeletesInclude<ExtArgs> | null
    /**
     * The filter to search for the AutoDeletes to update in case it exists.
     */
    where: AutoDeletesWhereUniqueInput
    /**
     * In case the AutoDeletes found by the `where` argument doesn't exist, create a new AutoDeletes with this data.
     */
    create: XOR<AutoDeletesCreateInput, AutoDeletesUncheckedCreateInput>
    /**
     * In case the AutoDeletes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutoDeletesUpdateInput, AutoDeletesUncheckedUpdateInput>
  }

  /**
   * AutoDeletes delete
   */
  export type AutoDeletesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoDeletes
     */
    select?: AutoDeletesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoDeletes
     */
    omit?: AutoDeletesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoDeletesInclude<ExtArgs> | null
    /**
     * Filter which AutoDeletes to delete.
     */
    where: AutoDeletesWhereUniqueInput
  }

  /**
   * AutoDeletes deleteMany
   */
  export type AutoDeletesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoDeletes to delete
     */
    where?: AutoDeletesWhereInput
    /**
     * Limit how many AutoDeletes to delete.
     */
    limit?: number
  }

  /**
   * AutoDeletes findRaw
   */
  export type AutoDeletesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AutoDeletes aggregateRaw
   */
  export type AutoDeletesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AutoDeletes without action
   */
  export type AutoDeletesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoDeletes
     */
    select?: AutoDeletesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoDeletes
     */
    omit?: AutoDeletesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoDeletesInclude<ExtArgs> | null
  }


  /**
   * Model AutoPublish
   */

  export type AggregateAutoPublish = {
    _count: AutoPublishCountAggregateOutputType | null
    _min: AutoPublishMinAggregateOutputType | null
    _max: AutoPublishMaxAggregateOutputType | null
  }

  export type AutoPublishMinAggregateOutputType = {
    id: string | null
    GuildId: string | null
  }

  export type AutoPublishMaxAggregateOutputType = {
    id: string | null
    GuildId: string | null
  }

  export type AutoPublishCountAggregateOutputType = {
    id: number
    Channels: number
    GuildId: number
    _all: number
  }


  export type AutoPublishMinAggregateInputType = {
    id?: true
    GuildId?: true
  }

  export type AutoPublishMaxAggregateInputType = {
    id?: true
    GuildId?: true
  }

  export type AutoPublishCountAggregateInputType = {
    id?: true
    Channels?: true
    GuildId?: true
    _all?: true
  }

  export type AutoPublishAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoPublish to aggregate.
     */
    where?: AutoPublishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoPublishes to fetch.
     */
    orderBy?: AutoPublishOrderByWithRelationInput | AutoPublishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutoPublishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoPublishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoPublishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutoPublishes
    **/
    _count?: true | AutoPublishCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutoPublishMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutoPublishMaxAggregateInputType
  }

  export type GetAutoPublishAggregateType<T extends AutoPublishAggregateArgs> = {
        [P in keyof T & keyof AggregateAutoPublish]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutoPublish[P]>
      : GetScalarType<T[P], AggregateAutoPublish[P]>
  }




  export type AutoPublishGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoPublishWhereInput
    orderBy?: AutoPublishOrderByWithAggregationInput | AutoPublishOrderByWithAggregationInput[]
    by: AutoPublishScalarFieldEnum[] | AutoPublishScalarFieldEnum
    having?: AutoPublishScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutoPublishCountAggregateInputType | true
    _min?: AutoPublishMinAggregateInputType
    _max?: AutoPublishMaxAggregateInputType
  }

  export type AutoPublishGroupByOutputType = {
    id: string
    Channels: string[]
    GuildId: string
    _count: AutoPublishCountAggregateOutputType | null
    _min: AutoPublishMinAggregateOutputType | null
    _max: AutoPublishMaxAggregateOutputType | null
  }

  type GetAutoPublishGroupByPayload<T extends AutoPublishGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutoPublishGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutoPublishGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutoPublishGroupByOutputType[P]>
            : GetScalarType<T[P], AutoPublishGroupByOutputType[P]>
        }
      >
    >


  export type AutoPublishSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Channels?: boolean
    GuildId?: boolean
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autoPublish"]>



  export type AutoPublishSelectScalar = {
    id?: boolean
    Channels?: boolean
    GuildId?: boolean
  }

  export type AutoPublishOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Channels" | "GuildId", ExtArgs["result"]["autoPublish"]>
  export type AutoPublishInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }

  export type $AutoPublishPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutoPublish"
    objects: {
      Guilds: Prisma.$GuildsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Channels: string[]
      GuildId: string
    }, ExtArgs["result"]["autoPublish"]>
    composites: {}
  }

  type AutoPublishGetPayload<S extends boolean | null | undefined | AutoPublishDefaultArgs> = $Result.GetResult<Prisma.$AutoPublishPayload, S>

  type AutoPublishCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutoPublishFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutoPublishCountAggregateInputType | true
    }

  export interface AutoPublishDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutoPublish'], meta: { name: 'AutoPublish' } }
    /**
     * Find zero or one AutoPublish that matches the filter.
     * @param {AutoPublishFindUniqueArgs} args - Arguments to find a AutoPublish
     * @example
     * // Get one AutoPublish
     * const autoPublish = await prisma.autoPublish.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutoPublishFindUniqueArgs>(args: SelectSubset<T, AutoPublishFindUniqueArgs<ExtArgs>>): Prisma__AutoPublishClient<$Result.GetResult<Prisma.$AutoPublishPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AutoPublish that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutoPublishFindUniqueOrThrowArgs} args - Arguments to find a AutoPublish
     * @example
     * // Get one AutoPublish
     * const autoPublish = await prisma.autoPublish.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutoPublishFindUniqueOrThrowArgs>(args: SelectSubset<T, AutoPublishFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutoPublishClient<$Result.GetResult<Prisma.$AutoPublishPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutoPublish that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoPublishFindFirstArgs} args - Arguments to find a AutoPublish
     * @example
     * // Get one AutoPublish
     * const autoPublish = await prisma.autoPublish.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutoPublishFindFirstArgs>(args?: SelectSubset<T, AutoPublishFindFirstArgs<ExtArgs>>): Prisma__AutoPublishClient<$Result.GetResult<Prisma.$AutoPublishPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutoPublish that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoPublishFindFirstOrThrowArgs} args - Arguments to find a AutoPublish
     * @example
     * // Get one AutoPublish
     * const autoPublish = await prisma.autoPublish.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutoPublishFindFirstOrThrowArgs>(args?: SelectSubset<T, AutoPublishFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutoPublishClient<$Result.GetResult<Prisma.$AutoPublishPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AutoPublishes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoPublishFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutoPublishes
     * const autoPublishes = await prisma.autoPublish.findMany()
     * 
     * // Get first 10 AutoPublishes
     * const autoPublishes = await prisma.autoPublish.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const autoPublishWithIdOnly = await prisma.autoPublish.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutoPublishFindManyArgs>(args?: SelectSubset<T, AutoPublishFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoPublishPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AutoPublish.
     * @param {AutoPublishCreateArgs} args - Arguments to create a AutoPublish.
     * @example
     * // Create one AutoPublish
     * const AutoPublish = await prisma.autoPublish.create({
     *   data: {
     *     // ... data to create a AutoPublish
     *   }
     * })
     * 
     */
    create<T extends AutoPublishCreateArgs>(args: SelectSubset<T, AutoPublishCreateArgs<ExtArgs>>): Prisma__AutoPublishClient<$Result.GetResult<Prisma.$AutoPublishPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AutoPublishes.
     * @param {AutoPublishCreateManyArgs} args - Arguments to create many AutoPublishes.
     * @example
     * // Create many AutoPublishes
     * const autoPublish = await prisma.autoPublish.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutoPublishCreateManyArgs>(args?: SelectSubset<T, AutoPublishCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AutoPublish.
     * @param {AutoPublishDeleteArgs} args - Arguments to delete one AutoPublish.
     * @example
     * // Delete one AutoPublish
     * const AutoPublish = await prisma.autoPublish.delete({
     *   where: {
     *     // ... filter to delete one AutoPublish
     *   }
     * })
     * 
     */
    delete<T extends AutoPublishDeleteArgs>(args: SelectSubset<T, AutoPublishDeleteArgs<ExtArgs>>): Prisma__AutoPublishClient<$Result.GetResult<Prisma.$AutoPublishPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AutoPublish.
     * @param {AutoPublishUpdateArgs} args - Arguments to update one AutoPublish.
     * @example
     * // Update one AutoPublish
     * const autoPublish = await prisma.autoPublish.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutoPublishUpdateArgs>(args: SelectSubset<T, AutoPublishUpdateArgs<ExtArgs>>): Prisma__AutoPublishClient<$Result.GetResult<Prisma.$AutoPublishPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AutoPublishes.
     * @param {AutoPublishDeleteManyArgs} args - Arguments to filter AutoPublishes to delete.
     * @example
     * // Delete a few AutoPublishes
     * const { count } = await prisma.autoPublish.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutoPublishDeleteManyArgs>(args?: SelectSubset<T, AutoPublishDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutoPublishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoPublishUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutoPublishes
     * const autoPublish = await prisma.autoPublish.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutoPublishUpdateManyArgs>(args: SelectSubset<T, AutoPublishUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AutoPublish.
     * @param {AutoPublishUpsertArgs} args - Arguments to update or create a AutoPublish.
     * @example
     * // Update or create a AutoPublish
     * const autoPublish = await prisma.autoPublish.upsert({
     *   create: {
     *     // ... data to create a AutoPublish
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutoPublish we want to update
     *   }
     * })
     */
    upsert<T extends AutoPublishUpsertArgs>(args: SelectSubset<T, AutoPublishUpsertArgs<ExtArgs>>): Prisma__AutoPublishClient<$Result.GetResult<Prisma.$AutoPublishPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AutoPublishes that matches the filter.
     * @param {AutoPublishFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const autoPublish = await prisma.autoPublish.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AutoPublishFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AutoPublish.
     * @param {AutoPublishAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const autoPublish = await prisma.autoPublish.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AutoPublishAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AutoPublishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoPublishCountArgs} args - Arguments to filter AutoPublishes to count.
     * @example
     * // Count the number of AutoPublishes
     * const count = await prisma.autoPublish.count({
     *   where: {
     *     // ... the filter for the AutoPublishes we want to count
     *   }
     * })
    **/
    count<T extends AutoPublishCountArgs>(
      args?: Subset<T, AutoPublishCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutoPublishCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutoPublish.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoPublishAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutoPublishAggregateArgs>(args: Subset<T, AutoPublishAggregateArgs>): Prisma.PrismaPromise<GetAutoPublishAggregateType<T>>

    /**
     * Group by AutoPublish.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoPublishGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutoPublishGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutoPublishGroupByArgs['orderBy'] }
        : { orderBy?: AutoPublishGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutoPublishGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutoPublishGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutoPublish model
   */
  readonly fields: AutoPublishFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutoPublish.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutoPublishClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutoPublish model
   */
  interface AutoPublishFieldRefs {
    readonly id: FieldRef<"AutoPublish", 'String'>
    readonly Channels: FieldRef<"AutoPublish", 'String[]'>
    readonly GuildId: FieldRef<"AutoPublish", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AutoPublish findUnique
   */
  export type AutoPublishFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoPublish
     */
    select?: AutoPublishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoPublish
     */
    omit?: AutoPublishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoPublishInclude<ExtArgs> | null
    /**
     * Filter, which AutoPublish to fetch.
     */
    where: AutoPublishWhereUniqueInput
  }

  /**
   * AutoPublish findUniqueOrThrow
   */
  export type AutoPublishFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoPublish
     */
    select?: AutoPublishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoPublish
     */
    omit?: AutoPublishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoPublishInclude<ExtArgs> | null
    /**
     * Filter, which AutoPublish to fetch.
     */
    where: AutoPublishWhereUniqueInput
  }

  /**
   * AutoPublish findFirst
   */
  export type AutoPublishFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoPublish
     */
    select?: AutoPublishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoPublish
     */
    omit?: AutoPublishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoPublishInclude<ExtArgs> | null
    /**
     * Filter, which AutoPublish to fetch.
     */
    where?: AutoPublishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoPublishes to fetch.
     */
    orderBy?: AutoPublishOrderByWithRelationInput | AutoPublishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoPublishes.
     */
    cursor?: AutoPublishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoPublishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoPublishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoPublishes.
     */
    distinct?: AutoPublishScalarFieldEnum | AutoPublishScalarFieldEnum[]
  }

  /**
   * AutoPublish findFirstOrThrow
   */
  export type AutoPublishFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoPublish
     */
    select?: AutoPublishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoPublish
     */
    omit?: AutoPublishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoPublishInclude<ExtArgs> | null
    /**
     * Filter, which AutoPublish to fetch.
     */
    where?: AutoPublishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoPublishes to fetch.
     */
    orderBy?: AutoPublishOrderByWithRelationInput | AutoPublishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoPublishes.
     */
    cursor?: AutoPublishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoPublishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoPublishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoPublishes.
     */
    distinct?: AutoPublishScalarFieldEnum | AutoPublishScalarFieldEnum[]
  }

  /**
   * AutoPublish findMany
   */
  export type AutoPublishFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoPublish
     */
    select?: AutoPublishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoPublish
     */
    omit?: AutoPublishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoPublishInclude<ExtArgs> | null
    /**
     * Filter, which AutoPublishes to fetch.
     */
    where?: AutoPublishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoPublishes to fetch.
     */
    orderBy?: AutoPublishOrderByWithRelationInput | AutoPublishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutoPublishes.
     */
    cursor?: AutoPublishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoPublishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoPublishes.
     */
    skip?: number
    distinct?: AutoPublishScalarFieldEnum | AutoPublishScalarFieldEnum[]
  }

  /**
   * AutoPublish create
   */
  export type AutoPublishCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoPublish
     */
    select?: AutoPublishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoPublish
     */
    omit?: AutoPublishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoPublishInclude<ExtArgs> | null
    /**
     * The data needed to create a AutoPublish.
     */
    data: XOR<AutoPublishCreateInput, AutoPublishUncheckedCreateInput>
  }

  /**
   * AutoPublish createMany
   */
  export type AutoPublishCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutoPublishes.
     */
    data: AutoPublishCreateManyInput | AutoPublishCreateManyInput[]
  }

  /**
   * AutoPublish update
   */
  export type AutoPublishUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoPublish
     */
    select?: AutoPublishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoPublish
     */
    omit?: AutoPublishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoPublishInclude<ExtArgs> | null
    /**
     * The data needed to update a AutoPublish.
     */
    data: XOR<AutoPublishUpdateInput, AutoPublishUncheckedUpdateInput>
    /**
     * Choose, which AutoPublish to update.
     */
    where: AutoPublishWhereUniqueInput
  }

  /**
   * AutoPublish updateMany
   */
  export type AutoPublishUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutoPublishes.
     */
    data: XOR<AutoPublishUpdateManyMutationInput, AutoPublishUncheckedUpdateManyInput>
    /**
     * Filter which AutoPublishes to update
     */
    where?: AutoPublishWhereInput
    /**
     * Limit how many AutoPublishes to update.
     */
    limit?: number
  }

  /**
   * AutoPublish upsert
   */
  export type AutoPublishUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoPublish
     */
    select?: AutoPublishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoPublish
     */
    omit?: AutoPublishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoPublishInclude<ExtArgs> | null
    /**
     * The filter to search for the AutoPublish to update in case it exists.
     */
    where: AutoPublishWhereUniqueInput
    /**
     * In case the AutoPublish found by the `where` argument doesn't exist, create a new AutoPublish with this data.
     */
    create: XOR<AutoPublishCreateInput, AutoPublishUncheckedCreateInput>
    /**
     * In case the AutoPublish was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutoPublishUpdateInput, AutoPublishUncheckedUpdateInput>
  }

  /**
   * AutoPublish delete
   */
  export type AutoPublishDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoPublish
     */
    select?: AutoPublishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoPublish
     */
    omit?: AutoPublishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoPublishInclude<ExtArgs> | null
    /**
     * Filter which AutoPublish to delete.
     */
    where: AutoPublishWhereUniqueInput
  }

  /**
   * AutoPublish deleteMany
   */
  export type AutoPublishDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoPublishes to delete
     */
    where?: AutoPublishWhereInput
    /**
     * Limit how many AutoPublishes to delete.
     */
    limit?: number
  }

  /**
   * AutoPublish findRaw
   */
  export type AutoPublishFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AutoPublish aggregateRaw
   */
  export type AutoPublishAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AutoPublish without action
   */
  export type AutoPublishDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoPublish
     */
    select?: AutoPublishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoPublish
     */
    omit?: AutoPublishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoPublishInclude<ExtArgs> | null
  }


  /**
   * Model AutoReacts
   */

  export type AggregateAutoReacts = {
    _count: AutoReactsCountAggregateOutputType | null
    _min: AutoReactsMinAggregateOutputType | null
    _max: AutoReactsMaxAggregateOutputType | null
  }

  export type AutoReactsMinAggregateOutputType = {
    id: string | null
    ChannelId: string | null
    Emoji: string | null
    GuildId: string | null
  }

  export type AutoReactsMaxAggregateOutputType = {
    id: string | null
    ChannelId: string | null
    Emoji: string | null
    GuildId: string | null
  }

  export type AutoReactsCountAggregateOutputType = {
    id: number
    ChannelId: number
    Emoji: number
    GuildId: number
    _all: number
  }


  export type AutoReactsMinAggregateInputType = {
    id?: true
    ChannelId?: true
    Emoji?: true
    GuildId?: true
  }

  export type AutoReactsMaxAggregateInputType = {
    id?: true
    ChannelId?: true
    Emoji?: true
    GuildId?: true
  }

  export type AutoReactsCountAggregateInputType = {
    id?: true
    ChannelId?: true
    Emoji?: true
    GuildId?: true
    _all?: true
  }

  export type AutoReactsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoReacts to aggregate.
     */
    where?: AutoReactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoReacts to fetch.
     */
    orderBy?: AutoReactsOrderByWithRelationInput | AutoReactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutoReactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoReacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoReacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutoReacts
    **/
    _count?: true | AutoReactsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutoReactsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutoReactsMaxAggregateInputType
  }

  export type GetAutoReactsAggregateType<T extends AutoReactsAggregateArgs> = {
        [P in keyof T & keyof AggregateAutoReacts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutoReacts[P]>
      : GetScalarType<T[P], AggregateAutoReacts[P]>
  }




  export type AutoReactsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoReactsWhereInput
    orderBy?: AutoReactsOrderByWithAggregationInput | AutoReactsOrderByWithAggregationInput[]
    by: AutoReactsScalarFieldEnum[] | AutoReactsScalarFieldEnum
    having?: AutoReactsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutoReactsCountAggregateInputType | true
    _min?: AutoReactsMinAggregateInputType
    _max?: AutoReactsMaxAggregateInputType
  }

  export type AutoReactsGroupByOutputType = {
    id: string
    ChannelId: string
    Emoji: string
    GuildId: string
    _count: AutoReactsCountAggregateOutputType | null
    _min: AutoReactsMinAggregateOutputType | null
    _max: AutoReactsMaxAggregateOutputType | null
  }

  type GetAutoReactsGroupByPayload<T extends AutoReactsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutoReactsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutoReactsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutoReactsGroupByOutputType[P]>
            : GetScalarType<T[P], AutoReactsGroupByOutputType[P]>
        }
      >
    >


  export type AutoReactsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ChannelId?: boolean
    Emoji?: boolean
    GuildId?: boolean
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autoReacts"]>



  export type AutoReactsSelectScalar = {
    id?: boolean
    ChannelId?: boolean
    Emoji?: boolean
    GuildId?: boolean
  }

  export type AutoReactsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ChannelId" | "Emoji" | "GuildId", ExtArgs["result"]["autoReacts"]>
  export type AutoReactsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }

  export type $AutoReactsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutoReacts"
    objects: {
      Guilds: Prisma.$GuildsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ChannelId: string
      Emoji: string
      GuildId: string
    }, ExtArgs["result"]["autoReacts"]>
    composites: {}
  }

  type AutoReactsGetPayload<S extends boolean | null | undefined | AutoReactsDefaultArgs> = $Result.GetResult<Prisma.$AutoReactsPayload, S>

  type AutoReactsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutoReactsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutoReactsCountAggregateInputType | true
    }

  export interface AutoReactsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutoReacts'], meta: { name: 'AutoReacts' } }
    /**
     * Find zero or one AutoReacts that matches the filter.
     * @param {AutoReactsFindUniqueArgs} args - Arguments to find a AutoReacts
     * @example
     * // Get one AutoReacts
     * const autoReacts = await prisma.autoReacts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutoReactsFindUniqueArgs>(args: SelectSubset<T, AutoReactsFindUniqueArgs<ExtArgs>>): Prisma__AutoReactsClient<$Result.GetResult<Prisma.$AutoReactsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AutoReacts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutoReactsFindUniqueOrThrowArgs} args - Arguments to find a AutoReacts
     * @example
     * // Get one AutoReacts
     * const autoReacts = await prisma.autoReacts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutoReactsFindUniqueOrThrowArgs>(args: SelectSubset<T, AutoReactsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutoReactsClient<$Result.GetResult<Prisma.$AutoReactsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutoReacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoReactsFindFirstArgs} args - Arguments to find a AutoReacts
     * @example
     * // Get one AutoReacts
     * const autoReacts = await prisma.autoReacts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutoReactsFindFirstArgs>(args?: SelectSubset<T, AutoReactsFindFirstArgs<ExtArgs>>): Prisma__AutoReactsClient<$Result.GetResult<Prisma.$AutoReactsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutoReacts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoReactsFindFirstOrThrowArgs} args - Arguments to find a AutoReacts
     * @example
     * // Get one AutoReacts
     * const autoReacts = await prisma.autoReacts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutoReactsFindFirstOrThrowArgs>(args?: SelectSubset<T, AutoReactsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutoReactsClient<$Result.GetResult<Prisma.$AutoReactsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AutoReacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoReactsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutoReacts
     * const autoReacts = await prisma.autoReacts.findMany()
     * 
     * // Get first 10 AutoReacts
     * const autoReacts = await prisma.autoReacts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const autoReactsWithIdOnly = await prisma.autoReacts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutoReactsFindManyArgs>(args?: SelectSubset<T, AutoReactsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoReactsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AutoReacts.
     * @param {AutoReactsCreateArgs} args - Arguments to create a AutoReacts.
     * @example
     * // Create one AutoReacts
     * const AutoReacts = await prisma.autoReacts.create({
     *   data: {
     *     // ... data to create a AutoReacts
     *   }
     * })
     * 
     */
    create<T extends AutoReactsCreateArgs>(args: SelectSubset<T, AutoReactsCreateArgs<ExtArgs>>): Prisma__AutoReactsClient<$Result.GetResult<Prisma.$AutoReactsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AutoReacts.
     * @param {AutoReactsCreateManyArgs} args - Arguments to create many AutoReacts.
     * @example
     * // Create many AutoReacts
     * const autoReacts = await prisma.autoReacts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutoReactsCreateManyArgs>(args?: SelectSubset<T, AutoReactsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AutoReacts.
     * @param {AutoReactsDeleteArgs} args - Arguments to delete one AutoReacts.
     * @example
     * // Delete one AutoReacts
     * const AutoReacts = await prisma.autoReacts.delete({
     *   where: {
     *     // ... filter to delete one AutoReacts
     *   }
     * })
     * 
     */
    delete<T extends AutoReactsDeleteArgs>(args: SelectSubset<T, AutoReactsDeleteArgs<ExtArgs>>): Prisma__AutoReactsClient<$Result.GetResult<Prisma.$AutoReactsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AutoReacts.
     * @param {AutoReactsUpdateArgs} args - Arguments to update one AutoReacts.
     * @example
     * // Update one AutoReacts
     * const autoReacts = await prisma.autoReacts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutoReactsUpdateArgs>(args: SelectSubset<T, AutoReactsUpdateArgs<ExtArgs>>): Prisma__AutoReactsClient<$Result.GetResult<Prisma.$AutoReactsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AutoReacts.
     * @param {AutoReactsDeleteManyArgs} args - Arguments to filter AutoReacts to delete.
     * @example
     * // Delete a few AutoReacts
     * const { count } = await prisma.autoReacts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutoReactsDeleteManyArgs>(args?: SelectSubset<T, AutoReactsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutoReacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoReactsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutoReacts
     * const autoReacts = await prisma.autoReacts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutoReactsUpdateManyArgs>(args: SelectSubset<T, AutoReactsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AutoReacts.
     * @param {AutoReactsUpsertArgs} args - Arguments to update or create a AutoReacts.
     * @example
     * // Update or create a AutoReacts
     * const autoReacts = await prisma.autoReacts.upsert({
     *   create: {
     *     // ... data to create a AutoReacts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutoReacts we want to update
     *   }
     * })
     */
    upsert<T extends AutoReactsUpsertArgs>(args: SelectSubset<T, AutoReactsUpsertArgs<ExtArgs>>): Prisma__AutoReactsClient<$Result.GetResult<Prisma.$AutoReactsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AutoReacts that matches the filter.
     * @param {AutoReactsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const autoReacts = await prisma.autoReacts.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AutoReactsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AutoReacts.
     * @param {AutoReactsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const autoReacts = await prisma.autoReacts.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AutoReactsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AutoReacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoReactsCountArgs} args - Arguments to filter AutoReacts to count.
     * @example
     * // Count the number of AutoReacts
     * const count = await prisma.autoReacts.count({
     *   where: {
     *     // ... the filter for the AutoReacts we want to count
     *   }
     * })
    **/
    count<T extends AutoReactsCountArgs>(
      args?: Subset<T, AutoReactsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutoReactsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutoReacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoReactsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutoReactsAggregateArgs>(args: Subset<T, AutoReactsAggregateArgs>): Prisma.PrismaPromise<GetAutoReactsAggregateType<T>>

    /**
     * Group by AutoReacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoReactsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutoReactsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutoReactsGroupByArgs['orderBy'] }
        : { orderBy?: AutoReactsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutoReactsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutoReactsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutoReacts model
   */
  readonly fields: AutoReactsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutoReacts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutoReactsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutoReacts model
   */
  interface AutoReactsFieldRefs {
    readonly id: FieldRef<"AutoReacts", 'String'>
    readonly ChannelId: FieldRef<"AutoReacts", 'String'>
    readonly Emoji: FieldRef<"AutoReacts", 'String'>
    readonly GuildId: FieldRef<"AutoReacts", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AutoReacts findUnique
   */
  export type AutoReactsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoReacts
     */
    select?: AutoReactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoReacts
     */
    omit?: AutoReactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoReactsInclude<ExtArgs> | null
    /**
     * Filter, which AutoReacts to fetch.
     */
    where: AutoReactsWhereUniqueInput
  }

  /**
   * AutoReacts findUniqueOrThrow
   */
  export type AutoReactsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoReacts
     */
    select?: AutoReactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoReacts
     */
    omit?: AutoReactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoReactsInclude<ExtArgs> | null
    /**
     * Filter, which AutoReacts to fetch.
     */
    where: AutoReactsWhereUniqueInput
  }

  /**
   * AutoReacts findFirst
   */
  export type AutoReactsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoReacts
     */
    select?: AutoReactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoReacts
     */
    omit?: AutoReactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoReactsInclude<ExtArgs> | null
    /**
     * Filter, which AutoReacts to fetch.
     */
    where?: AutoReactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoReacts to fetch.
     */
    orderBy?: AutoReactsOrderByWithRelationInput | AutoReactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoReacts.
     */
    cursor?: AutoReactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoReacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoReacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoReacts.
     */
    distinct?: AutoReactsScalarFieldEnum | AutoReactsScalarFieldEnum[]
  }

  /**
   * AutoReacts findFirstOrThrow
   */
  export type AutoReactsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoReacts
     */
    select?: AutoReactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoReacts
     */
    omit?: AutoReactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoReactsInclude<ExtArgs> | null
    /**
     * Filter, which AutoReacts to fetch.
     */
    where?: AutoReactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoReacts to fetch.
     */
    orderBy?: AutoReactsOrderByWithRelationInput | AutoReactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoReacts.
     */
    cursor?: AutoReactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoReacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoReacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoReacts.
     */
    distinct?: AutoReactsScalarFieldEnum | AutoReactsScalarFieldEnum[]
  }

  /**
   * AutoReacts findMany
   */
  export type AutoReactsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoReacts
     */
    select?: AutoReactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoReacts
     */
    omit?: AutoReactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoReactsInclude<ExtArgs> | null
    /**
     * Filter, which AutoReacts to fetch.
     */
    where?: AutoReactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoReacts to fetch.
     */
    orderBy?: AutoReactsOrderByWithRelationInput | AutoReactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutoReacts.
     */
    cursor?: AutoReactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoReacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoReacts.
     */
    skip?: number
    distinct?: AutoReactsScalarFieldEnum | AutoReactsScalarFieldEnum[]
  }

  /**
   * AutoReacts create
   */
  export type AutoReactsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoReacts
     */
    select?: AutoReactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoReacts
     */
    omit?: AutoReactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoReactsInclude<ExtArgs> | null
    /**
     * The data needed to create a AutoReacts.
     */
    data: XOR<AutoReactsCreateInput, AutoReactsUncheckedCreateInput>
  }

  /**
   * AutoReacts createMany
   */
  export type AutoReactsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutoReacts.
     */
    data: AutoReactsCreateManyInput | AutoReactsCreateManyInput[]
  }

  /**
   * AutoReacts update
   */
  export type AutoReactsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoReacts
     */
    select?: AutoReactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoReacts
     */
    omit?: AutoReactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoReactsInclude<ExtArgs> | null
    /**
     * The data needed to update a AutoReacts.
     */
    data: XOR<AutoReactsUpdateInput, AutoReactsUncheckedUpdateInput>
    /**
     * Choose, which AutoReacts to update.
     */
    where: AutoReactsWhereUniqueInput
  }

  /**
   * AutoReacts updateMany
   */
  export type AutoReactsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutoReacts.
     */
    data: XOR<AutoReactsUpdateManyMutationInput, AutoReactsUncheckedUpdateManyInput>
    /**
     * Filter which AutoReacts to update
     */
    where?: AutoReactsWhereInput
    /**
     * Limit how many AutoReacts to update.
     */
    limit?: number
  }

  /**
   * AutoReacts upsert
   */
  export type AutoReactsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoReacts
     */
    select?: AutoReactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoReacts
     */
    omit?: AutoReactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoReactsInclude<ExtArgs> | null
    /**
     * The filter to search for the AutoReacts to update in case it exists.
     */
    where: AutoReactsWhereUniqueInput
    /**
     * In case the AutoReacts found by the `where` argument doesn't exist, create a new AutoReacts with this data.
     */
    create: XOR<AutoReactsCreateInput, AutoReactsUncheckedCreateInput>
    /**
     * In case the AutoReacts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutoReactsUpdateInput, AutoReactsUncheckedUpdateInput>
  }

  /**
   * AutoReacts delete
   */
  export type AutoReactsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoReacts
     */
    select?: AutoReactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoReacts
     */
    omit?: AutoReactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoReactsInclude<ExtArgs> | null
    /**
     * Filter which AutoReacts to delete.
     */
    where: AutoReactsWhereUniqueInput
  }

  /**
   * AutoReacts deleteMany
   */
  export type AutoReactsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoReacts to delete
     */
    where?: AutoReactsWhereInput
    /**
     * Limit how many AutoReacts to delete.
     */
    limit?: number
  }

  /**
   * AutoReacts findRaw
   */
  export type AutoReactsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AutoReacts aggregateRaw
   */
  export type AutoReactsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AutoReacts without action
   */
  export type AutoReactsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoReacts
     */
    select?: AutoReactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoReacts
     */
    omit?: AutoReactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoReactsInclude<ExtArgs> | null
  }


  /**
   * Model AutoRoles
   */

  export type AggregateAutoRoles = {
    _count: AutoRolesCountAggregateOutputType | null
    _min: AutoRolesMinAggregateOutputType | null
    _max: AutoRolesMaxAggregateOutputType | null
  }

  export type AutoRolesMinAggregateOutputType = {
    id: string | null
    RoleId: string | null
    GuildId: string | null
  }

  export type AutoRolesMaxAggregateOutputType = {
    id: string | null
    RoleId: string | null
    GuildId: string | null
  }

  export type AutoRolesCountAggregateOutputType = {
    id: number
    RoleId: number
    GuildId: number
    _all: number
  }


  export type AutoRolesMinAggregateInputType = {
    id?: true
    RoleId?: true
    GuildId?: true
  }

  export type AutoRolesMaxAggregateInputType = {
    id?: true
    RoleId?: true
    GuildId?: true
  }

  export type AutoRolesCountAggregateInputType = {
    id?: true
    RoleId?: true
    GuildId?: true
    _all?: true
  }

  export type AutoRolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoRoles to aggregate.
     */
    where?: AutoRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoRoles to fetch.
     */
    orderBy?: AutoRolesOrderByWithRelationInput | AutoRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutoRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutoRoles
    **/
    _count?: true | AutoRolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutoRolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutoRolesMaxAggregateInputType
  }

  export type GetAutoRolesAggregateType<T extends AutoRolesAggregateArgs> = {
        [P in keyof T & keyof AggregateAutoRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutoRoles[P]>
      : GetScalarType<T[P], AggregateAutoRoles[P]>
  }




  export type AutoRolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoRolesWhereInput
    orderBy?: AutoRolesOrderByWithAggregationInput | AutoRolesOrderByWithAggregationInput[]
    by: AutoRolesScalarFieldEnum[] | AutoRolesScalarFieldEnum
    having?: AutoRolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutoRolesCountAggregateInputType | true
    _min?: AutoRolesMinAggregateInputType
    _max?: AutoRolesMaxAggregateInputType
  }

  export type AutoRolesGroupByOutputType = {
    id: string
    RoleId: string
    GuildId: string
    _count: AutoRolesCountAggregateOutputType | null
    _min: AutoRolesMinAggregateOutputType | null
    _max: AutoRolesMaxAggregateOutputType | null
  }

  type GetAutoRolesGroupByPayload<T extends AutoRolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutoRolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutoRolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutoRolesGroupByOutputType[P]>
            : GetScalarType<T[P], AutoRolesGroupByOutputType[P]>
        }
      >
    >


  export type AutoRolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    RoleId?: boolean
    GuildId?: boolean
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autoRoles"]>



  export type AutoRolesSelectScalar = {
    id?: boolean
    RoleId?: boolean
    GuildId?: boolean
  }

  export type AutoRolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "RoleId" | "GuildId", ExtArgs["result"]["autoRoles"]>
  export type AutoRolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }

  export type $AutoRolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutoRoles"
    objects: {
      Guilds: Prisma.$GuildsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      RoleId: string
      GuildId: string
    }, ExtArgs["result"]["autoRoles"]>
    composites: {}
  }

  type AutoRolesGetPayload<S extends boolean | null | undefined | AutoRolesDefaultArgs> = $Result.GetResult<Prisma.$AutoRolesPayload, S>

  type AutoRolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutoRolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutoRolesCountAggregateInputType | true
    }

  export interface AutoRolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutoRoles'], meta: { name: 'AutoRoles' } }
    /**
     * Find zero or one AutoRoles that matches the filter.
     * @param {AutoRolesFindUniqueArgs} args - Arguments to find a AutoRoles
     * @example
     * // Get one AutoRoles
     * const autoRoles = await prisma.autoRoles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutoRolesFindUniqueArgs>(args: SelectSubset<T, AutoRolesFindUniqueArgs<ExtArgs>>): Prisma__AutoRolesClient<$Result.GetResult<Prisma.$AutoRolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AutoRoles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutoRolesFindUniqueOrThrowArgs} args - Arguments to find a AutoRoles
     * @example
     * // Get one AutoRoles
     * const autoRoles = await prisma.autoRoles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutoRolesFindUniqueOrThrowArgs>(args: SelectSubset<T, AutoRolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutoRolesClient<$Result.GetResult<Prisma.$AutoRolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutoRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoRolesFindFirstArgs} args - Arguments to find a AutoRoles
     * @example
     * // Get one AutoRoles
     * const autoRoles = await prisma.autoRoles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutoRolesFindFirstArgs>(args?: SelectSubset<T, AutoRolesFindFirstArgs<ExtArgs>>): Prisma__AutoRolesClient<$Result.GetResult<Prisma.$AutoRolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutoRoles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoRolesFindFirstOrThrowArgs} args - Arguments to find a AutoRoles
     * @example
     * // Get one AutoRoles
     * const autoRoles = await prisma.autoRoles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutoRolesFindFirstOrThrowArgs>(args?: SelectSubset<T, AutoRolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutoRolesClient<$Result.GetResult<Prisma.$AutoRolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AutoRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoRolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutoRoles
     * const autoRoles = await prisma.autoRoles.findMany()
     * 
     * // Get first 10 AutoRoles
     * const autoRoles = await prisma.autoRoles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const autoRolesWithIdOnly = await prisma.autoRoles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutoRolesFindManyArgs>(args?: SelectSubset<T, AutoRolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoRolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AutoRoles.
     * @param {AutoRolesCreateArgs} args - Arguments to create a AutoRoles.
     * @example
     * // Create one AutoRoles
     * const AutoRoles = await prisma.autoRoles.create({
     *   data: {
     *     // ... data to create a AutoRoles
     *   }
     * })
     * 
     */
    create<T extends AutoRolesCreateArgs>(args: SelectSubset<T, AutoRolesCreateArgs<ExtArgs>>): Prisma__AutoRolesClient<$Result.GetResult<Prisma.$AutoRolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AutoRoles.
     * @param {AutoRolesCreateManyArgs} args - Arguments to create many AutoRoles.
     * @example
     * // Create many AutoRoles
     * const autoRoles = await prisma.autoRoles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutoRolesCreateManyArgs>(args?: SelectSubset<T, AutoRolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AutoRoles.
     * @param {AutoRolesDeleteArgs} args - Arguments to delete one AutoRoles.
     * @example
     * // Delete one AutoRoles
     * const AutoRoles = await prisma.autoRoles.delete({
     *   where: {
     *     // ... filter to delete one AutoRoles
     *   }
     * })
     * 
     */
    delete<T extends AutoRolesDeleteArgs>(args: SelectSubset<T, AutoRolesDeleteArgs<ExtArgs>>): Prisma__AutoRolesClient<$Result.GetResult<Prisma.$AutoRolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AutoRoles.
     * @param {AutoRolesUpdateArgs} args - Arguments to update one AutoRoles.
     * @example
     * // Update one AutoRoles
     * const autoRoles = await prisma.autoRoles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutoRolesUpdateArgs>(args: SelectSubset<T, AutoRolesUpdateArgs<ExtArgs>>): Prisma__AutoRolesClient<$Result.GetResult<Prisma.$AutoRolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AutoRoles.
     * @param {AutoRolesDeleteManyArgs} args - Arguments to filter AutoRoles to delete.
     * @example
     * // Delete a few AutoRoles
     * const { count } = await prisma.autoRoles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutoRolesDeleteManyArgs>(args?: SelectSubset<T, AutoRolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutoRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoRolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutoRoles
     * const autoRoles = await prisma.autoRoles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutoRolesUpdateManyArgs>(args: SelectSubset<T, AutoRolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AutoRoles.
     * @param {AutoRolesUpsertArgs} args - Arguments to update or create a AutoRoles.
     * @example
     * // Update or create a AutoRoles
     * const autoRoles = await prisma.autoRoles.upsert({
     *   create: {
     *     // ... data to create a AutoRoles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutoRoles we want to update
     *   }
     * })
     */
    upsert<T extends AutoRolesUpsertArgs>(args: SelectSubset<T, AutoRolesUpsertArgs<ExtArgs>>): Prisma__AutoRolesClient<$Result.GetResult<Prisma.$AutoRolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AutoRoles that matches the filter.
     * @param {AutoRolesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const autoRoles = await prisma.autoRoles.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AutoRolesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AutoRoles.
     * @param {AutoRolesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const autoRoles = await prisma.autoRoles.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AutoRolesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AutoRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoRolesCountArgs} args - Arguments to filter AutoRoles to count.
     * @example
     * // Count the number of AutoRoles
     * const count = await prisma.autoRoles.count({
     *   where: {
     *     // ... the filter for the AutoRoles we want to count
     *   }
     * })
    **/
    count<T extends AutoRolesCountArgs>(
      args?: Subset<T, AutoRolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutoRolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutoRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoRolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutoRolesAggregateArgs>(args: Subset<T, AutoRolesAggregateArgs>): Prisma.PrismaPromise<GetAutoRolesAggregateType<T>>

    /**
     * Group by AutoRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoRolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutoRolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutoRolesGroupByArgs['orderBy'] }
        : { orderBy?: AutoRolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutoRolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutoRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutoRoles model
   */
  readonly fields: AutoRolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutoRoles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutoRolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutoRoles model
   */
  interface AutoRolesFieldRefs {
    readonly id: FieldRef<"AutoRoles", 'String'>
    readonly RoleId: FieldRef<"AutoRoles", 'String'>
    readonly GuildId: FieldRef<"AutoRoles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AutoRoles findUnique
   */
  export type AutoRolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRoles
     */
    select?: AutoRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoRoles
     */
    omit?: AutoRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRolesInclude<ExtArgs> | null
    /**
     * Filter, which AutoRoles to fetch.
     */
    where: AutoRolesWhereUniqueInput
  }

  /**
   * AutoRoles findUniqueOrThrow
   */
  export type AutoRolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRoles
     */
    select?: AutoRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoRoles
     */
    omit?: AutoRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRolesInclude<ExtArgs> | null
    /**
     * Filter, which AutoRoles to fetch.
     */
    where: AutoRolesWhereUniqueInput
  }

  /**
   * AutoRoles findFirst
   */
  export type AutoRolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRoles
     */
    select?: AutoRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoRoles
     */
    omit?: AutoRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRolesInclude<ExtArgs> | null
    /**
     * Filter, which AutoRoles to fetch.
     */
    where?: AutoRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoRoles to fetch.
     */
    orderBy?: AutoRolesOrderByWithRelationInput | AutoRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoRoles.
     */
    cursor?: AutoRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoRoles.
     */
    distinct?: AutoRolesScalarFieldEnum | AutoRolesScalarFieldEnum[]
  }

  /**
   * AutoRoles findFirstOrThrow
   */
  export type AutoRolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRoles
     */
    select?: AutoRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoRoles
     */
    omit?: AutoRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRolesInclude<ExtArgs> | null
    /**
     * Filter, which AutoRoles to fetch.
     */
    where?: AutoRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoRoles to fetch.
     */
    orderBy?: AutoRolesOrderByWithRelationInput | AutoRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoRoles.
     */
    cursor?: AutoRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoRoles.
     */
    distinct?: AutoRolesScalarFieldEnum | AutoRolesScalarFieldEnum[]
  }

  /**
   * AutoRoles findMany
   */
  export type AutoRolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRoles
     */
    select?: AutoRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoRoles
     */
    omit?: AutoRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRolesInclude<ExtArgs> | null
    /**
     * Filter, which AutoRoles to fetch.
     */
    where?: AutoRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoRoles to fetch.
     */
    orderBy?: AutoRolesOrderByWithRelationInput | AutoRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutoRoles.
     */
    cursor?: AutoRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoRoles.
     */
    skip?: number
    distinct?: AutoRolesScalarFieldEnum | AutoRolesScalarFieldEnum[]
  }

  /**
   * AutoRoles create
   */
  export type AutoRolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRoles
     */
    select?: AutoRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoRoles
     */
    omit?: AutoRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRolesInclude<ExtArgs> | null
    /**
     * The data needed to create a AutoRoles.
     */
    data: XOR<AutoRolesCreateInput, AutoRolesUncheckedCreateInput>
  }

  /**
   * AutoRoles createMany
   */
  export type AutoRolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutoRoles.
     */
    data: AutoRolesCreateManyInput | AutoRolesCreateManyInput[]
  }

  /**
   * AutoRoles update
   */
  export type AutoRolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRoles
     */
    select?: AutoRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoRoles
     */
    omit?: AutoRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRolesInclude<ExtArgs> | null
    /**
     * The data needed to update a AutoRoles.
     */
    data: XOR<AutoRolesUpdateInput, AutoRolesUncheckedUpdateInput>
    /**
     * Choose, which AutoRoles to update.
     */
    where: AutoRolesWhereUniqueInput
  }

  /**
   * AutoRoles updateMany
   */
  export type AutoRolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutoRoles.
     */
    data: XOR<AutoRolesUpdateManyMutationInput, AutoRolesUncheckedUpdateManyInput>
    /**
     * Filter which AutoRoles to update
     */
    where?: AutoRolesWhereInput
    /**
     * Limit how many AutoRoles to update.
     */
    limit?: number
  }

  /**
   * AutoRoles upsert
   */
  export type AutoRolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRoles
     */
    select?: AutoRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoRoles
     */
    omit?: AutoRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRolesInclude<ExtArgs> | null
    /**
     * The filter to search for the AutoRoles to update in case it exists.
     */
    where: AutoRolesWhereUniqueInput
    /**
     * In case the AutoRoles found by the `where` argument doesn't exist, create a new AutoRoles with this data.
     */
    create: XOR<AutoRolesCreateInput, AutoRolesUncheckedCreateInput>
    /**
     * In case the AutoRoles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutoRolesUpdateInput, AutoRolesUncheckedUpdateInput>
  }

  /**
   * AutoRoles delete
   */
  export type AutoRolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRoles
     */
    select?: AutoRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoRoles
     */
    omit?: AutoRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRolesInclude<ExtArgs> | null
    /**
     * Filter which AutoRoles to delete.
     */
    where: AutoRolesWhereUniqueInput
  }

  /**
   * AutoRoles deleteMany
   */
  export type AutoRolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoRoles to delete
     */
    where?: AutoRolesWhereInput
    /**
     * Limit how many AutoRoles to delete.
     */
    limit?: number
  }

  /**
   * AutoRoles findRaw
   */
  export type AutoRolesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AutoRoles aggregateRaw
   */
  export type AutoRolesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AutoRoles without action
   */
  export type AutoRolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRoles
     */
    select?: AutoRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoRoles
     */
    omit?: AutoRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRolesInclude<ExtArgs> | null
  }


  /**
   * Model GuildBans
   */

  export type AggregateGuildBans = {
    _count: GuildBansCountAggregateOutputType | null
    _min: GuildBansMinAggregateOutputType | null
    _max: GuildBansMaxAggregateOutputType | null
  }

  export type GuildBansMinAggregateOutputType = {
    id: string | null
    UUID: string | null
    Time: string | null
    Reason: string | null
    ModeratorId: string | null
    DmMessage: string | null
    Banned: boolean | null
    CreatedAt: Date | null
    GuildId: string | null
  }

  export type GuildBansMaxAggregateOutputType = {
    id: string | null
    UUID: string | null
    Time: string | null
    Reason: string | null
    ModeratorId: string | null
    DmMessage: string | null
    Banned: boolean | null
    CreatedAt: Date | null
    GuildId: string | null
  }

  export type GuildBansCountAggregateOutputType = {
    id: number
    UUID: number
    Time: number
    UserId: number
    Reason: number
    ModeratorId: number
    DmMessage: number
    Banned: number
    CreatedAt: number
    GuildId: number
    _all: number
  }


  export type GuildBansMinAggregateInputType = {
    id?: true
    UUID?: true
    Time?: true
    Reason?: true
    ModeratorId?: true
    DmMessage?: true
    Banned?: true
    CreatedAt?: true
    GuildId?: true
  }

  export type GuildBansMaxAggregateInputType = {
    id?: true
    UUID?: true
    Time?: true
    Reason?: true
    ModeratorId?: true
    DmMessage?: true
    Banned?: true
    CreatedAt?: true
    GuildId?: true
  }

  export type GuildBansCountAggregateInputType = {
    id?: true
    UUID?: true
    Time?: true
    UserId?: true
    Reason?: true
    ModeratorId?: true
    DmMessage?: true
    Banned?: true
    CreatedAt?: true
    GuildId?: true
    _all?: true
  }

  export type GuildBansAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildBans to aggregate.
     */
    where?: GuildBansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildBans to fetch.
     */
    orderBy?: GuildBansOrderByWithRelationInput | GuildBansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuildBansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildBans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildBans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuildBans
    **/
    _count?: true | GuildBansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildBansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildBansMaxAggregateInputType
  }

  export type GetGuildBansAggregateType<T extends GuildBansAggregateArgs> = {
        [P in keyof T & keyof AggregateGuildBans]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuildBans[P]>
      : GetScalarType<T[P], AggregateGuildBans[P]>
  }




  export type GuildBansGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildBansWhereInput
    orderBy?: GuildBansOrderByWithAggregationInput | GuildBansOrderByWithAggregationInput[]
    by: GuildBansScalarFieldEnum[] | GuildBansScalarFieldEnum
    having?: GuildBansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildBansCountAggregateInputType | true
    _min?: GuildBansMinAggregateInputType
    _max?: GuildBansMaxAggregateInputType
  }

  export type GuildBansGroupByOutputType = {
    id: string
    UUID: string
    Time: string | null
    UserId: string[]
    Reason: string | null
    ModeratorId: string | null
    DmMessage: string | null
    Banned: boolean | null
    CreatedAt: Date | null
    GuildId: string
    _count: GuildBansCountAggregateOutputType | null
    _min: GuildBansMinAggregateOutputType | null
    _max: GuildBansMaxAggregateOutputType | null
  }

  type GetGuildBansGroupByPayload<T extends GuildBansGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildBansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildBansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildBansGroupByOutputType[P]>
            : GetScalarType<T[P], GuildBansGroupByOutputType[P]>
        }
      >
    >


  export type GuildBansSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    UUID?: boolean
    Time?: boolean
    UserId?: boolean
    Reason?: boolean
    ModeratorId?: boolean
    DmMessage?: boolean
    Banned?: boolean
    CreatedAt?: boolean
    GuildId?: boolean
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guildBans"]>



  export type GuildBansSelectScalar = {
    id?: boolean
    UUID?: boolean
    Time?: boolean
    UserId?: boolean
    Reason?: boolean
    ModeratorId?: boolean
    DmMessage?: boolean
    Banned?: boolean
    CreatedAt?: boolean
    GuildId?: boolean
  }

  export type GuildBansOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "UUID" | "Time" | "UserId" | "Reason" | "ModeratorId" | "DmMessage" | "Banned" | "CreatedAt" | "GuildId", ExtArgs["result"]["guildBans"]>
  export type GuildBansInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }

  export type $GuildBansPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GuildBans"
    objects: {
      Guilds: Prisma.$GuildsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      UUID: string
      Time: string | null
      UserId: string[]
      Reason: string | null
      ModeratorId: string | null
      DmMessage: string | null
      Banned: boolean | null
      CreatedAt: Date | null
      GuildId: string
    }, ExtArgs["result"]["guildBans"]>
    composites: {}
  }

  type GuildBansGetPayload<S extends boolean | null | undefined | GuildBansDefaultArgs> = $Result.GetResult<Prisma.$GuildBansPayload, S>

  type GuildBansCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuildBansFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuildBansCountAggregateInputType | true
    }

  export interface GuildBansDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GuildBans'], meta: { name: 'GuildBans' } }
    /**
     * Find zero or one GuildBans that matches the filter.
     * @param {GuildBansFindUniqueArgs} args - Arguments to find a GuildBans
     * @example
     * // Get one GuildBans
     * const guildBans = await prisma.guildBans.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuildBansFindUniqueArgs>(args: SelectSubset<T, GuildBansFindUniqueArgs<ExtArgs>>): Prisma__GuildBansClient<$Result.GetResult<Prisma.$GuildBansPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GuildBans that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuildBansFindUniqueOrThrowArgs} args - Arguments to find a GuildBans
     * @example
     * // Get one GuildBans
     * const guildBans = await prisma.guildBans.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuildBansFindUniqueOrThrowArgs>(args: SelectSubset<T, GuildBansFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuildBansClient<$Result.GetResult<Prisma.$GuildBansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuildBans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildBansFindFirstArgs} args - Arguments to find a GuildBans
     * @example
     * // Get one GuildBans
     * const guildBans = await prisma.guildBans.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuildBansFindFirstArgs>(args?: SelectSubset<T, GuildBansFindFirstArgs<ExtArgs>>): Prisma__GuildBansClient<$Result.GetResult<Prisma.$GuildBansPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuildBans that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildBansFindFirstOrThrowArgs} args - Arguments to find a GuildBans
     * @example
     * // Get one GuildBans
     * const guildBans = await prisma.guildBans.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuildBansFindFirstOrThrowArgs>(args?: SelectSubset<T, GuildBansFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuildBansClient<$Result.GetResult<Prisma.$GuildBansPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuildBans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildBansFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuildBans
     * const guildBans = await prisma.guildBans.findMany()
     * 
     * // Get first 10 GuildBans
     * const guildBans = await prisma.guildBans.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildBansWithIdOnly = await prisma.guildBans.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuildBansFindManyArgs>(args?: SelectSubset<T, GuildBansFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildBansPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GuildBans.
     * @param {GuildBansCreateArgs} args - Arguments to create a GuildBans.
     * @example
     * // Create one GuildBans
     * const GuildBans = await prisma.guildBans.create({
     *   data: {
     *     // ... data to create a GuildBans
     *   }
     * })
     * 
     */
    create<T extends GuildBansCreateArgs>(args: SelectSubset<T, GuildBansCreateArgs<ExtArgs>>): Prisma__GuildBansClient<$Result.GetResult<Prisma.$GuildBansPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GuildBans.
     * @param {GuildBansCreateManyArgs} args - Arguments to create many GuildBans.
     * @example
     * // Create many GuildBans
     * const guildBans = await prisma.guildBans.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuildBansCreateManyArgs>(args?: SelectSubset<T, GuildBansCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GuildBans.
     * @param {GuildBansDeleteArgs} args - Arguments to delete one GuildBans.
     * @example
     * // Delete one GuildBans
     * const GuildBans = await prisma.guildBans.delete({
     *   where: {
     *     // ... filter to delete one GuildBans
     *   }
     * })
     * 
     */
    delete<T extends GuildBansDeleteArgs>(args: SelectSubset<T, GuildBansDeleteArgs<ExtArgs>>): Prisma__GuildBansClient<$Result.GetResult<Prisma.$GuildBansPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GuildBans.
     * @param {GuildBansUpdateArgs} args - Arguments to update one GuildBans.
     * @example
     * // Update one GuildBans
     * const guildBans = await prisma.guildBans.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuildBansUpdateArgs>(args: SelectSubset<T, GuildBansUpdateArgs<ExtArgs>>): Prisma__GuildBansClient<$Result.GetResult<Prisma.$GuildBansPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GuildBans.
     * @param {GuildBansDeleteManyArgs} args - Arguments to filter GuildBans to delete.
     * @example
     * // Delete a few GuildBans
     * const { count } = await prisma.guildBans.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuildBansDeleteManyArgs>(args?: SelectSubset<T, GuildBansDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuildBans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildBansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuildBans
     * const guildBans = await prisma.guildBans.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuildBansUpdateManyArgs>(args: SelectSubset<T, GuildBansUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GuildBans.
     * @param {GuildBansUpsertArgs} args - Arguments to update or create a GuildBans.
     * @example
     * // Update or create a GuildBans
     * const guildBans = await prisma.guildBans.upsert({
     *   create: {
     *     // ... data to create a GuildBans
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuildBans we want to update
     *   }
     * })
     */
    upsert<T extends GuildBansUpsertArgs>(args: SelectSubset<T, GuildBansUpsertArgs<ExtArgs>>): Prisma__GuildBansClient<$Result.GetResult<Prisma.$GuildBansPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuildBans that matches the filter.
     * @param {GuildBansFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const guildBans = await prisma.guildBans.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: GuildBansFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a GuildBans.
     * @param {GuildBansAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const guildBans = await prisma.guildBans.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: GuildBansAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of GuildBans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildBansCountArgs} args - Arguments to filter GuildBans to count.
     * @example
     * // Count the number of GuildBans
     * const count = await prisma.guildBans.count({
     *   where: {
     *     // ... the filter for the GuildBans we want to count
     *   }
     * })
    **/
    count<T extends GuildBansCountArgs>(
      args?: Subset<T, GuildBansCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildBansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuildBans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildBansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildBansAggregateArgs>(args: Subset<T, GuildBansAggregateArgs>): Prisma.PrismaPromise<GetGuildBansAggregateType<T>>

    /**
     * Group by GuildBans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildBansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildBansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildBansGroupByArgs['orderBy'] }
        : { orderBy?: GuildBansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildBansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildBansGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GuildBans model
   */
  readonly fields: GuildBansFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuildBans.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuildBansClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GuildBans model
   */
  interface GuildBansFieldRefs {
    readonly id: FieldRef<"GuildBans", 'String'>
    readonly UUID: FieldRef<"GuildBans", 'String'>
    readonly Time: FieldRef<"GuildBans", 'String'>
    readonly UserId: FieldRef<"GuildBans", 'String[]'>
    readonly Reason: FieldRef<"GuildBans", 'String'>
    readonly ModeratorId: FieldRef<"GuildBans", 'String'>
    readonly DmMessage: FieldRef<"GuildBans", 'String'>
    readonly Banned: FieldRef<"GuildBans", 'Boolean'>
    readonly CreatedAt: FieldRef<"GuildBans", 'DateTime'>
    readonly GuildId: FieldRef<"GuildBans", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GuildBans findUnique
   */
  export type GuildBansFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBans
     */
    select?: GuildBansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBans
     */
    omit?: GuildBansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBansInclude<ExtArgs> | null
    /**
     * Filter, which GuildBans to fetch.
     */
    where: GuildBansWhereUniqueInput
  }

  /**
   * GuildBans findUniqueOrThrow
   */
  export type GuildBansFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBans
     */
    select?: GuildBansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBans
     */
    omit?: GuildBansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBansInclude<ExtArgs> | null
    /**
     * Filter, which GuildBans to fetch.
     */
    where: GuildBansWhereUniqueInput
  }

  /**
   * GuildBans findFirst
   */
  export type GuildBansFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBans
     */
    select?: GuildBansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBans
     */
    omit?: GuildBansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBansInclude<ExtArgs> | null
    /**
     * Filter, which GuildBans to fetch.
     */
    where?: GuildBansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildBans to fetch.
     */
    orderBy?: GuildBansOrderByWithRelationInput | GuildBansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildBans.
     */
    cursor?: GuildBansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildBans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildBans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildBans.
     */
    distinct?: GuildBansScalarFieldEnum | GuildBansScalarFieldEnum[]
  }

  /**
   * GuildBans findFirstOrThrow
   */
  export type GuildBansFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBans
     */
    select?: GuildBansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBans
     */
    omit?: GuildBansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBansInclude<ExtArgs> | null
    /**
     * Filter, which GuildBans to fetch.
     */
    where?: GuildBansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildBans to fetch.
     */
    orderBy?: GuildBansOrderByWithRelationInput | GuildBansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildBans.
     */
    cursor?: GuildBansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildBans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildBans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildBans.
     */
    distinct?: GuildBansScalarFieldEnum | GuildBansScalarFieldEnum[]
  }

  /**
   * GuildBans findMany
   */
  export type GuildBansFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBans
     */
    select?: GuildBansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBans
     */
    omit?: GuildBansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBansInclude<ExtArgs> | null
    /**
     * Filter, which GuildBans to fetch.
     */
    where?: GuildBansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildBans to fetch.
     */
    orderBy?: GuildBansOrderByWithRelationInput | GuildBansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuildBans.
     */
    cursor?: GuildBansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildBans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildBans.
     */
    skip?: number
    distinct?: GuildBansScalarFieldEnum | GuildBansScalarFieldEnum[]
  }

  /**
   * GuildBans create
   */
  export type GuildBansCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBans
     */
    select?: GuildBansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBans
     */
    omit?: GuildBansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBansInclude<ExtArgs> | null
    /**
     * The data needed to create a GuildBans.
     */
    data: XOR<GuildBansCreateInput, GuildBansUncheckedCreateInput>
  }

  /**
   * GuildBans createMany
   */
  export type GuildBansCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GuildBans.
     */
    data: GuildBansCreateManyInput | GuildBansCreateManyInput[]
  }

  /**
   * GuildBans update
   */
  export type GuildBansUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBans
     */
    select?: GuildBansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBans
     */
    omit?: GuildBansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBansInclude<ExtArgs> | null
    /**
     * The data needed to update a GuildBans.
     */
    data: XOR<GuildBansUpdateInput, GuildBansUncheckedUpdateInput>
    /**
     * Choose, which GuildBans to update.
     */
    where: GuildBansWhereUniqueInput
  }

  /**
   * GuildBans updateMany
   */
  export type GuildBansUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GuildBans.
     */
    data: XOR<GuildBansUpdateManyMutationInput, GuildBansUncheckedUpdateManyInput>
    /**
     * Filter which GuildBans to update
     */
    where?: GuildBansWhereInput
    /**
     * Limit how many GuildBans to update.
     */
    limit?: number
  }

  /**
   * GuildBans upsert
   */
  export type GuildBansUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBans
     */
    select?: GuildBansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBans
     */
    omit?: GuildBansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBansInclude<ExtArgs> | null
    /**
     * The filter to search for the GuildBans to update in case it exists.
     */
    where: GuildBansWhereUniqueInput
    /**
     * In case the GuildBans found by the `where` argument doesn't exist, create a new GuildBans with this data.
     */
    create: XOR<GuildBansCreateInput, GuildBansUncheckedCreateInput>
    /**
     * In case the GuildBans was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuildBansUpdateInput, GuildBansUncheckedUpdateInput>
  }

  /**
   * GuildBans delete
   */
  export type GuildBansDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBans
     */
    select?: GuildBansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBans
     */
    omit?: GuildBansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBansInclude<ExtArgs> | null
    /**
     * Filter which GuildBans to delete.
     */
    where: GuildBansWhereUniqueInput
  }

  /**
   * GuildBans deleteMany
   */
  export type GuildBansDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildBans to delete
     */
    where?: GuildBansWhereInput
    /**
     * Limit how many GuildBans to delete.
     */
    limit?: number
  }

  /**
   * GuildBans findRaw
   */
  export type GuildBansFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GuildBans aggregateRaw
   */
  export type GuildBansAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GuildBans without action
   */
  export type GuildBansDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBans
     */
    select?: GuildBansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBans
     */
    omit?: GuildBansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBansInclude<ExtArgs> | null
  }


  /**
   * Model ChatModerations
   */

  export type AggregateChatModerations = {
    _count: ChatModerationsCountAggregateOutputType | null
    _min: ChatModerationsMinAggregateOutputType | null
    _max: ChatModerationsMaxAggregateOutputType | null
  }

  export type ChatModerationsMinAggregateOutputType = {
    id: string | null
    LogChannelId: string | null
    GuildId: string | null
  }

  export type ChatModerationsMaxAggregateOutputType = {
    id: string | null
    LogChannelId: string | null
    GuildId: string | null
  }

  export type ChatModerationsCountAggregateOutputType = {
    id: number
    LogChannelId: number
    Words: number
    WhiteListRole: number
    WhiteListChannel: number
    GuildId: number
    _all: number
  }


  export type ChatModerationsMinAggregateInputType = {
    id?: true
    LogChannelId?: true
    GuildId?: true
  }

  export type ChatModerationsMaxAggregateInputType = {
    id?: true
    LogChannelId?: true
    GuildId?: true
  }

  export type ChatModerationsCountAggregateInputType = {
    id?: true
    LogChannelId?: true
    Words?: true
    WhiteListRole?: true
    WhiteListChannel?: true
    GuildId?: true
    _all?: true
  }

  export type ChatModerationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatModerations to aggregate.
     */
    where?: ChatModerationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatModerations to fetch.
     */
    orderBy?: ChatModerationsOrderByWithRelationInput | ChatModerationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatModerationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatModerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatModerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatModerations
    **/
    _count?: true | ChatModerationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatModerationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatModerationsMaxAggregateInputType
  }

  export type GetChatModerationsAggregateType<T extends ChatModerationsAggregateArgs> = {
        [P in keyof T & keyof AggregateChatModerations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatModerations[P]>
      : GetScalarType<T[P], AggregateChatModerations[P]>
  }




  export type ChatModerationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatModerationsWhereInput
    orderBy?: ChatModerationsOrderByWithAggregationInput | ChatModerationsOrderByWithAggregationInput[]
    by: ChatModerationsScalarFieldEnum[] | ChatModerationsScalarFieldEnum
    having?: ChatModerationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatModerationsCountAggregateInputType | true
    _min?: ChatModerationsMinAggregateInputType
    _max?: ChatModerationsMaxAggregateInputType
  }

  export type ChatModerationsGroupByOutputType = {
    id: string
    LogChannelId: string
    Words: string[]
    WhiteListRole: string[]
    WhiteListChannel: string[]
    GuildId: string
    _count: ChatModerationsCountAggregateOutputType | null
    _min: ChatModerationsMinAggregateOutputType | null
    _max: ChatModerationsMaxAggregateOutputType | null
  }

  type GetChatModerationsGroupByPayload<T extends ChatModerationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatModerationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatModerationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatModerationsGroupByOutputType[P]>
            : GetScalarType<T[P], ChatModerationsGroupByOutputType[P]>
        }
      >
    >


  export type ChatModerationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    LogChannelId?: boolean
    Words?: boolean
    WhiteListRole?: boolean
    WhiteListChannel?: boolean
    GuildId?: boolean
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatModerations"]>



  export type ChatModerationsSelectScalar = {
    id?: boolean
    LogChannelId?: boolean
    Words?: boolean
    WhiteListRole?: boolean
    WhiteListChannel?: boolean
    GuildId?: boolean
  }

  export type ChatModerationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "LogChannelId" | "Words" | "WhiteListRole" | "WhiteListChannel" | "GuildId", ExtArgs["result"]["chatModerations"]>
  export type ChatModerationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }

  export type $ChatModerationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatModerations"
    objects: {
      Guilds: Prisma.$GuildsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      LogChannelId: string
      Words: string[]
      WhiteListRole: string[]
      WhiteListChannel: string[]
      GuildId: string
    }, ExtArgs["result"]["chatModerations"]>
    composites: {}
  }

  type ChatModerationsGetPayload<S extends boolean | null | undefined | ChatModerationsDefaultArgs> = $Result.GetResult<Prisma.$ChatModerationsPayload, S>

  type ChatModerationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatModerationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatModerationsCountAggregateInputType | true
    }

  export interface ChatModerationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatModerations'], meta: { name: 'ChatModerations' } }
    /**
     * Find zero or one ChatModerations that matches the filter.
     * @param {ChatModerationsFindUniqueArgs} args - Arguments to find a ChatModerations
     * @example
     * // Get one ChatModerations
     * const chatModerations = await prisma.chatModerations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatModerationsFindUniqueArgs>(args: SelectSubset<T, ChatModerationsFindUniqueArgs<ExtArgs>>): Prisma__ChatModerationsClient<$Result.GetResult<Prisma.$ChatModerationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatModerations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatModerationsFindUniqueOrThrowArgs} args - Arguments to find a ChatModerations
     * @example
     * // Get one ChatModerations
     * const chatModerations = await prisma.chatModerations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatModerationsFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatModerationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatModerationsClient<$Result.GetResult<Prisma.$ChatModerationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatModerations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatModerationsFindFirstArgs} args - Arguments to find a ChatModerations
     * @example
     * // Get one ChatModerations
     * const chatModerations = await prisma.chatModerations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatModerationsFindFirstArgs>(args?: SelectSubset<T, ChatModerationsFindFirstArgs<ExtArgs>>): Prisma__ChatModerationsClient<$Result.GetResult<Prisma.$ChatModerationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatModerations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatModerationsFindFirstOrThrowArgs} args - Arguments to find a ChatModerations
     * @example
     * // Get one ChatModerations
     * const chatModerations = await prisma.chatModerations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatModerationsFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatModerationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatModerationsClient<$Result.GetResult<Prisma.$ChatModerationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatModerations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatModerationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatModerations
     * const chatModerations = await prisma.chatModerations.findMany()
     * 
     * // Get first 10 ChatModerations
     * const chatModerations = await prisma.chatModerations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatModerationsWithIdOnly = await prisma.chatModerations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatModerationsFindManyArgs>(args?: SelectSubset<T, ChatModerationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatModerationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatModerations.
     * @param {ChatModerationsCreateArgs} args - Arguments to create a ChatModerations.
     * @example
     * // Create one ChatModerations
     * const ChatModerations = await prisma.chatModerations.create({
     *   data: {
     *     // ... data to create a ChatModerations
     *   }
     * })
     * 
     */
    create<T extends ChatModerationsCreateArgs>(args: SelectSubset<T, ChatModerationsCreateArgs<ExtArgs>>): Prisma__ChatModerationsClient<$Result.GetResult<Prisma.$ChatModerationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatModerations.
     * @param {ChatModerationsCreateManyArgs} args - Arguments to create many ChatModerations.
     * @example
     * // Create many ChatModerations
     * const chatModerations = await prisma.chatModerations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatModerationsCreateManyArgs>(args?: SelectSubset<T, ChatModerationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChatModerations.
     * @param {ChatModerationsDeleteArgs} args - Arguments to delete one ChatModerations.
     * @example
     * // Delete one ChatModerations
     * const ChatModerations = await prisma.chatModerations.delete({
     *   where: {
     *     // ... filter to delete one ChatModerations
     *   }
     * })
     * 
     */
    delete<T extends ChatModerationsDeleteArgs>(args: SelectSubset<T, ChatModerationsDeleteArgs<ExtArgs>>): Prisma__ChatModerationsClient<$Result.GetResult<Prisma.$ChatModerationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatModerations.
     * @param {ChatModerationsUpdateArgs} args - Arguments to update one ChatModerations.
     * @example
     * // Update one ChatModerations
     * const chatModerations = await prisma.chatModerations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatModerationsUpdateArgs>(args: SelectSubset<T, ChatModerationsUpdateArgs<ExtArgs>>): Prisma__ChatModerationsClient<$Result.GetResult<Prisma.$ChatModerationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatModerations.
     * @param {ChatModerationsDeleteManyArgs} args - Arguments to filter ChatModerations to delete.
     * @example
     * // Delete a few ChatModerations
     * const { count } = await prisma.chatModerations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatModerationsDeleteManyArgs>(args?: SelectSubset<T, ChatModerationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatModerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatModerationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatModerations
     * const chatModerations = await prisma.chatModerations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatModerationsUpdateManyArgs>(args: SelectSubset<T, ChatModerationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatModerations.
     * @param {ChatModerationsUpsertArgs} args - Arguments to update or create a ChatModerations.
     * @example
     * // Update or create a ChatModerations
     * const chatModerations = await prisma.chatModerations.upsert({
     *   create: {
     *     // ... data to create a ChatModerations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatModerations we want to update
     *   }
     * })
     */
    upsert<T extends ChatModerationsUpsertArgs>(args: SelectSubset<T, ChatModerationsUpsertArgs<ExtArgs>>): Prisma__ChatModerationsClient<$Result.GetResult<Prisma.$ChatModerationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatModerations that matches the filter.
     * @param {ChatModerationsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const chatModerations = await prisma.chatModerations.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ChatModerationsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ChatModerations.
     * @param {ChatModerationsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const chatModerations = await prisma.chatModerations.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ChatModerationsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ChatModerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatModerationsCountArgs} args - Arguments to filter ChatModerations to count.
     * @example
     * // Count the number of ChatModerations
     * const count = await prisma.chatModerations.count({
     *   where: {
     *     // ... the filter for the ChatModerations we want to count
     *   }
     * })
    **/
    count<T extends ChatModerationsCountArgs>(
      args?: Subset<T, ChatModerationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatModerationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatModerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatModerationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatModerationsAggregateArgs>(args: Subset<T, ChatModerationsAggregateArgs>): Prisma.PrismaPromise<GetChatModerationsAggregateType<T>>

    /**
     * Group by ChatModerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatModerationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatModerationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatModerationsGroupByArgs['orderBy'] }
        : { orderBy?: ChatModerationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatModerationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatModerationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatModerations model
   */
  readonly fields: ChatModerationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatModerations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatModerationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatModerations model
   */
  interface ChatModerationsFieldRefs {
    readonly id: FieldRef<"ChatModerations", 'String'>
    readonly LogChannelId: FieldRef<"ChatModerations", 'String'>
    readonly Words: FieldRef<"ChatModerations", 'String[]'>
    readonly WhiteListRole: FieldRef<"ChatModerations", 'String[]'>
    readonly WhiteListChannel: FieldRef<"ChatModerations", 'String[]'>
    readonly GuildId: FieldRef<"ChatModerations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChatModerations findUnique
   */
  export type ChatModerationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatModerations
     */
    select?: ChatModerationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatModerations
     */
    omit?: ChatModerationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatModerationsInclude<ExtArgs> | null
    /**
     * Filter, which ChatModerations to fetch.
     */
    where: ChatModerationsWhereUniqueInput
  }

  /**
   * ChatModerations findUniqueOrThrow
   */
  export type ChatModerationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatModerations
     */
    select?: ChatModerationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatModerations
     */
    omit?: ChatModerationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatModerationsInclude<ExtArgs> | null
    /**
     * Filter, which ChatModerations to fetch.
     */
    where: ChatModerationsWhereUniqueInput
  }

  /**
   * ChatModerations findFirst
   */
  export type ChatModerationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatModerations
     */
    select?: ChatModerationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatModerations
     */
    omit?: ChatModerationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatModerationsInclude<ExtArgs> | null
    /**
     * Filter, which ChatModerations to fetch.
     */
    where?: ChatModerationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatModerations to fetch.
     */
    orderBy?: ChatModerationsOrderByWithRelationInput | ChatModerationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatModerations.
     */
    cursor?: ChatModerationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatModerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatModerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatModerations.
     */
    distinct?: ChatModerationsScalarFieldEnum | ChatModerationsScalarFieldEnum[]
  }

  /**
   * ChatModerations findFirstOrThrow
   */
  export type ChatModerationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatModerations
     */
    select?: ChatModerationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatModerations
     */
    omit?: ChatModerationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatModerationsInclude<ExtArgs> | null
    /**
     * Filter, which ChatModerations to fetch.
     */
    where?: ChatModerationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatModerations to fetch.
     */
    orderBy?: ChatModerationsOrderByWithRelationInput | ChatModerationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatModerations.
     */
    cursor?: ChatModerationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatModerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatModerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatModerations.
     */
    distinct?: ChatModerationsScalarFieldEnum | ChatModerationsScalarFieldEnum[]
  }

  /**
   * ChatModerations findMany
   */
  export type ChatModerationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatModerations
     */
    select?: ChatModerationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatModerations
     */
    omit?: ChatModerationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatModerationsInclude<ExtArgs> | null
    /**
     * Filter, which ChatModerations to fetch.
     */
    where?: ChatModerationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatModerations to fetch.
     */
    orderBy?: ChatModerationsOrderByWithRelationInput | ChatModerationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatModerations.
     */
    cursor?: ChatModerationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatModerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatModerations.
     */
    skip?: number
    distinct?: ChatModerationsScalarFieldEnum | ChatModerationsScalarFieldEnum[]
  }

  /**
   * ChatModerations create
   */
  export type ChatModerationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatModerations
     */
    select?: ChatModerationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatModerations
     */
    omit?: ChatModerationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatModerationsInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatModerations.
     */
    data: XOR<ChatModerationsCreateInput, ChatModerationsUncheckedCreateInput>
  }

  /**
   * ChatModerations createMany
   */
  export type ChatModerationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatModerations.
     */
    data: ChatModerationsCreateManyInput | ChatModerationsCreateManyInput[]
  }

  /**
   * ChatModerations update
   */
  export type ChatModerationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatModerations
     */
    select?: ChatModerationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatModerations
     */
    omit?: ChatModerationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatModerationsInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatModerations.
     */
    data: XOR<ChatModerationsUpdateInput, ChatModerationsUncheckedUpdateInput>
    /**
     * Choose, which ChatModerations to update.
     */
    where: ChatModerationsWhereUniqueInput
  }

  /**
   * ChatModerations updateMany
   */
  export type ChatModerationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatModerations.
     */
    data: XOR<ChatModerationsUpdateManyMutationInput, ChatModerationsUncheckedUpdateManyInput>
    /**
     * Filter which ChatModerations to update
     */
    where?: ChatModerationsWhereInput
    /**
     * Limit how many ChatModerations to update.
     */
    limit?: number
  }

  /**
   * ChatModerations upsert
   */
  export type ChatModerationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatModerations
     */
    select?: ChatModerationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatModerations
     */
    omit?: ChatModerationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatModerationsInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatModerations to update in case it exists.
     */
    where: ChatModerationsWhereUniqueInput
    /**
     * In case the ChatModerations found by the `where` argument doesn't exist, create a new ChatModerations with this data.
     */
    create: XOR<ChatModerationsCreateInput, ChatModerationsUncheckedCreateInput>
    /**
     * In case the ChatModerations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatModerationsUpdateInput, ChatModerationsUncheckedUpdateInput>
  }

  /**
   * ChatModerations delete
   */
  export type ChatModerationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatModerations
     */
    select?: ChatModerationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatModerations
     */
    omit?: ChatModerationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatModerationsInclude<ExtArgs> | null
    /**
     * Filter which ChatModerations to delete.
     */
    where: ChatModerationsWhereUniqueInput
  }

  /**
   * ChatModerations deleteMany
   */
  export type ChatModerationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatModerations to delete
     */
    where?: ChatModerationsWhereInput
    /**
     * Limit how many ChatModerations to delete.
     */
    limit?: number
  }

  /**
   * ChatModerations findRaw
   */
  export type ChatModerationsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ChatModerations aggregateRaw
   */
  export type ChatModerationsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ChatModerations without action
   */
  export type ChatModerationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatModerations
     */
    select?: ChatModerationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatModerations
     */
    omit?: ChatModerationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatModerationsInclude<ExtArgs> | null
  }


  /**
   * Model ChannelLinks
   */

  export type AggregateChannelLinks = {
    _count: ChannelLinksCountAggregateOutputType | null
    _min: ChannelLinksMinAggregateOutputType | null
    _max: ChannelLinksMaxAggregateOutputType | null
  }

  export type ChannelLinksMinAggregateOutputType = {
    id: string | null
    UUID: string | null
    ChannelId: string | null
    GuildId: string | null
  }

  export type ChannelLinksMaxAggregateOutputType = {
    id: string | null
    UUID: string | null
    ChannelId: string | null
    GuildId: string | null
  }

  export type ChannelLinksCountAggregateOutputType = {
    id: number
    UUID: number
    ChannelId: number
    WebhookUrls: number
    GuildId: number
    _all: number
  }


  export type ChannelLinksMinAggregateInputType = {
    id?: true
    UUID?: true
    ChannelId?: true
    GuildId?: true
  }

  export type ChannelLinksMaxAggregateInputType = {
    id?: true
    UUID?: true
    ChannelId?: true
    GuildId?: true
  }

  export type ChannelLinksCountAggregateInputType = {
    id?: true
    UUID?: true
    ChannelId?: true
    WebhookUrls?: true
    GuildId?: true
    _all?: true
  }

  export type ChannelLinksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelLinks to aggregate.
     */
    where?: ChannelLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelLinks to fetch.
     */
    orderBy?: ChannelLinksOrderByWithRelationInput | ChannelLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChannelLinks
    **/
    _count?: true | ChannelLinksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelLinksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelLinksMaxAggregateInputType
  }

  export type GetChannelLinksAggregateType<T extends ChannelLinksAggregateArgs> = {
        [P in keyof T & keyof AggregateChannelLinks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannelLinks[P]>
      : GetScalarType<T[P], AggregateChannelLinks[P]>
  }




  export type ChannelLinksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelLinksWhereInput
    orderBy?: ChannelLinksOrderByWithAggregationInput | ChannelLinksOrderByWithAggregationInput[]
    by: ChannelLinksScalarFieldEnum[] | ChannelLinksScalarFieldEnum
    having?: ChannelLinksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelLinksCountAggregateInputType | true
    _min?: ChannelLinksMinAggregateInputType
    _max?: ChannelLinksMaxAggregateInputType
  }

  export type ChannelLinksGroupByOutputType = {
    id: string
    UUID: string
    ChannelId: string
    WebhookUrls: string[]
    GuildId: string
    _count: ChannelLinksCountAggregateOutputType | null
    _min: ChannelLinksMinAggregateOutputType | null
    _max: ChannelLinksMaxAggregateOutputType | null
  }

  type GetChannelLinksGroupByPayload<T extends ChannelLinksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelLinksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelLinksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelLinksGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelLinksGroupByOutputType[P]>
        }
      >
    >


  export type ChannelLinksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    UUID?: boolean
    ChannelId?: boolean
    WebhookUrls?: boolean
    GuildId?: boolean
    SyncedChannelLinkMessage?: boolean | ChannelLinks$SyncedChannelLinkMessageArgs<ExtArgs>
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
    _count?: boolean | ChannelLinksCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channelLinks"]>



  export type ChannelLinksSelectScalar = {
    id?: boolean
    UUID?: boolean
    ChannelId?: boolean
    WebhookUrls?: boolean
    GuildId?: boolean
  }

  export type ChannelLinksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "UUID" | "ChannelId" | "WebhookUrls" | "GuildId", ExtArgs["result"]["channelLinks"]>
  export type ChannelLinksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SyncedChannelLinkMessage?: boolean | ChannelLinks$SyncedChannelLinkMessageArgs<ExtArgs>
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
    _count?: boolean | ChannelLinksCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ChannelLinksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChannelLinks"
    objects: {
      SyncedChannelLinkMessage: Prisma.$SyncedChannelLinkMessagesPayload<ExtArgs>[]
      Guilds: Prisma.$GuildsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      UUID: string
      ChannelId: string
      WebhookUrls: string[]
      GuildId: string
    }, ExtArgs["result"]["channelLinks"]>
    composites: {}
  }

  type ChannelLinksGetPayload<S extends boolean | null | undefined | ChannelLinksDefaultArgs> = $Result.GetResult<Prisma.$ChannelLinksPayload, S>

  type ChannelLinksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChannelLinksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChannelLinksCountAggregateInputType | true
    }

  export interface ChannelLinksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChannelLinks'], meta: { name: 'ChannelLinks' } }
    /**
     * Find zero or one ChannelLinks that matches the filter.
     * @param {ChannelLinksFindUniqueArgs} args - Arguments to find a ChannelLinks
     * @example
     * // Get one ChannelLinks
     * const channelLinks = await prisma.channelLinks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelLinksFindUniqueArgs>(args: SelectSubset<T, ChannelLinksFindUniqueArgs<ExtArgs>>): Prisma__ChannelLinksClient<$Result.GetResult<Prisma.$ChannelLinksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChannelLinks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChannelLinksFindUniqueOrThrowArgs} args - Arguments to find a ChannelLinks
     * @example
     * // Get one ChannelLinks
     * const channelLinks = await prisma.channelLinks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelLinksFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelLinksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelLinksClient<$Result.GetResult<Prisma.$ChannelLinksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChannelLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelLinksFindFirstArgs} args - Arguments to find a ChannelLinks
     * @example
     * // Get one ChannelLinks
     * const channelLinks = await prisma.channelLinks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelLinksFindFirstArgs>(args?: SelectSubset<T, ChannelLinksFindFirstArgs<ExtArgs>>): Prisma__ChannelLinksClient<$Result.GetResult<Prisma.$ChannelLinksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChannelLinks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelLinksFindFirstOrThrowArgs} args - Arguments to find a ChannelLinks
     * @example
     * // Get one ChannelLinks
     * const channelLinks = await prisma.channelLinks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelLinksFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelLinksFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelLinksClient<$Result.GetResult<Prisma.$ChannelLinksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChannelLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelLinksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChannelLinks
     * const channelLinks = await prisma.channelLinks.findMany()
     * 
     * // Get first 10 ChannelLinks
     * const channelLinks = await prisma.channelLinks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelLinksWithIdOnly = await prisma.channelLinks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelLinksFindManyArgs>(args?: SelectSubset<T, ChannelLinksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelLinksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChannelLinks.
     * @param {ChannelLinksCreateArgs} args - Arguments to create a ChannelLinks.
     * @example
     * // Create one ChannelLinks
     * const ChannelLinks = await prisma.channelLinks.create({
     *   data: {
     *     // ... data to create a ChannelLinks
     *   }
     * })
     * 
     */
    create<T extends ChannelLinksCreateArgs>(args: SelectSubset<T, ChannelLinksCreateArgs<ExtArgs>>): Prisma__ChannelLinksClient<$Result.GetResult<Prisma.$ChannelLinksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChannelLinks.
     * @param {ChannelLinksCreateManyArgs} args - Arguments to create many ChannelLinks.
     * @example
     * // Create many ChannelLinks
     * const channelLinks = await prisma.channelLinks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelLinksCreateManyArgs>(args?: SelectSubset<T, ChannelLinksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChannelLinks.
     * @param {ChannelLinksDeleteArgs} args - Arguments to delete one ChannelLinks.
     * @example
     * // Delete one ChannelLinks
     * const ChannelLinks = await prisma.channelLinks.delete({
     *   where: {
     *     // ... filter to delete one ChannelLinks
     *   }
     * })
     * 
     */
    delete<T extends ChannelLinksDeleteArgs>(args: SelectSubset<T, ChannelLinksDeleteArgs<ExtArgs>>): Prisma__ChannelLinksClient<$Result.GetResult<Prisma.$ChannelLinksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChannelLinks.
     * @param {ChannelLinksUpdateArgs} args - Arguments to update one ChannelLinks.
     * @example
     * // Update one ChannelLinks
     * const channelLinks = await prisma.channelLinks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelLinksUpdateArgs>(args: SelectSubset<T, ChannelLinksUpdateArgs<ExtArgs>>): Prisma__ChannelLinksClient<$Result.GetResult<Prisma.$ChannelLinksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChannelLinks.
     * @param {ChannelLinksDeleteManyArgs} args - Arguments to filter ChannelLinks to delete.
     * @example
     * // Delete a few ChannelLinks
     * const { count } = await prisma.channelLinks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelLinksDeleteManyArgs>(args?: SelectSubset<T, ChannelLinksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChannelLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelLinksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChannelLinks
     * const channelLinks = await prisma.channelLinks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelLinksUpdateManyArgs>(args: SelectSubset<T, ChannelLinksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChannelLinks.
     * @param {ChannelLinksUpsertArgs} args - Arguments to update or create a ChannelLinks.
     * @example
     * // Update or create a ChannelLinks
     * const channelLinks = await prisma.channelLinks.upsert({
     *   create: {
     *     // ... data to create a ChannelLinks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChannelLinks we want to update
     *   }
     * })
     */
    upsert<T extends ChannelLinksUpsertArgs>(args: SelectSubset<T, ChannelLinksUpsertArgs<ExtArgs>>): Prisma__ChannelLinksClient<$Result.GetResult<Prisma.$ChannelLinksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChannelLinks that matches the filter.
     * @param {ChannelLinksFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const channelLinks = await prisma.channelLinks.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ChannelLinksFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ChannelLinks.
     * @param {ChannelLinksAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const channelLinks = await prisma.channelLinks.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ChannelLinksAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ChannelLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelLinksCountArgs} args - Arguments to filter ChannelLinks to count.
     * @example
     * // Count the number of ChannelLinks
     * const count = await prisma.channelLinks.count({
     *   where: {
     *     // ... the filter for the ChannelLinks we want to count
     *   }
     * })
    **/
    count<T extends ChannelLinksCountArgs>(
      args?: Subset<T, ChannelLinksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelLinksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChannelLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelLinksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelLinksAggregateArgs>(args: Subset<T, ChannelLinksAggregateArgs>): Prisma.PrismaPromise<GetChannelLinksAggregateType<T>>

    /**
     * Group by ChannelLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelLinksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelLinksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelLinksGroupByArgs['orderBy'] }
        : { orderBy?: ChannelLinksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelLinksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelLinksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChannelLinks model
   */
  readonly fields: ChannelLinksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChannelLinks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelLinksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SyncedChannelLinkMessage<T extends ChannelLinks$SyncedChannelLinkMessageArgs<ExtArgs> = {}>(args?: Subset<T, ChannelLinks$SyncedChannelLinkMessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncedChannelLinkMessagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChannelLinks model
   */
  interface ChannelLinksFieldRefs {
    readonly id: FieldRef<"ChannelLinks", 'String'>
    readonly UUID: FieldRef<"ChannelLinks", 'String'>
    readonly ChannelId: FieldRef<"ChannelLinks", 'String'>
    readonly WebhookUrls: FieldRef<"ChannelLinks", 'String[]'>
    readonly GuildId: FieldRef<"ChannelLinks", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChannelLinks findUnique
   */
  export type ChannelLinksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelLinks
     */
    select?: ChannelLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelLinks
     */
    omit?: ChannelLinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelLinksInclude<ExtArgs> | null
    /**
     * Filter, which ChannelLinks to fetch.
     */
    where: ChannelLinksWhereUniqueInput
  }

  /**
   * ChannelLinks findUniqueOrThrow
   */
  export type ChannelLinksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelLinks
     */
    select?: ChannelLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelLinks
     */
    omit?: ChannelLinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelLinksInclude<ExtArgs> | null
    /**
     * Filter, which ChannelLinks to fetch.
     */
    where: ChannelLinksWhereUniqueInput
  }

  /**
   * ChannelLinks findFirst
   */
  export type ChannelLinksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelLinks
     */
    select?: ChannelLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelLinks
     */
    omit?: ChannelLinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelLinksInclude<ExtArgs> | null
    /**
     * Filter, which ChannelLinks to fetch.
     */
    where?: ChannelLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelLinks to fetch.
     */
    orderBy?: ChannelLinksOrderByWithRelationInput | ChannelLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelLinks.
     */
    cursor?: ChannelLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelLinks.
     */
    distinct?: ChannelLinksScalarFieldEnum | ChannelLinksScalarFieldEnum[]
  }

  /**
   * ChannelLinks findFirstOrThrow
   */
  export type ChannelLinksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelLinks
     */
    select?: ChannelLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelLinks
     */
    omit?: ChannelLinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelLinksInclude<ExtArgs> | null
    /**
     * Filter, which ChannelLinks to fetch.
     */
    where?: ChannelLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelLinks to fetch.
     */
    orderBy?: ChannelLinksOrderByWithRelationInput | ChannelLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelLinks.
     */
    cursor?: ChannelLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelLinks.
     */
    distinct?: ChannelLinksScalarFieldEnum | ChannelLinksScalarFieldEnum[]
  }

  /**
   * ChannelLinks findMany
   */
  export type ChannelLinksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelLinks
     */
    select?: ChannelLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelLinks
     */
    omit?: ChannelLinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelLinksInclude<ExtArgs> | null
    /**
     * Filter, which ChannelLinks to fetch.
     */
    where?: ChannelLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelLinks to fetch.
     */
    orderBy?: ChannelLinksOrderByWithRelationInput | ChannelLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChannelLinks.
     */
    cursor?: ChannelLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelLinks.
     */
    skip?: number
    distinct?: ChannelLinksScalarFieldEnum | ChannelLinksScalarFieldEnum[]
  }

  /**
   * ChannelLinks create
   */
  export type ChannelLinksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelLinks
     */
    select?: ChannelLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelLinks
     */
    omit?: ChannelLinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelLinksInclude<ExtArgs> | null
    /**
     * The data needed to create a ChannelLinks.
     */
    data: XOR<ChannelLinksCreateInput, ChannelLinksUncheckedCreateInput>
  }

  /**
   * ChannelLinks createMany
   */
  export type ChannelLinksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChannelLinks.
     */
    data: ChannelLinksCreateManyInput | ChannelLinksCreateManyInput[]
  }

  /**
   * ChannelLinks update
   */
  export type ChannelLinksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelLinks
     */
    select?: ChannelLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelLinks
     */
    omit?: ChannelLinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelLinksInclude<ExtArgs> | null
    /**
     * The data needed to update a ChannelLinks.
     */
    data: XOR<ChannelLinksUpdateInput, ChannelLinksUncheckedUpdateInput>
    /**
     * Choose, which ChannelLinks to update.
     */
    where: ChannelLinksWhereUniqueInput
  }

  /**
   * ChannelLinks updateMany
   */
  export type ChannelLinksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChannelLinks.
     */
    data: XOR<ChannelLinksUpdateManyMutationInput, ChannelLinksUncheckedUpdateManyInput>
    /**
     * Filter which ChannelLinks to update
     */
    where?: ChannelLinksWhereInput
    /**
     * Limit how many ChannelLinks to update.
     */
    limit?: number
  }

  /**
   * ChannelLinks upsert
   */
  export type ChannelLinksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelLinks
     */
    select?: ChannelLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelLinks
     */
    omit?: ChannelLinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelLinksInclude<ExtArgs> | null
    /**
     * The filter to search for the ChannelLinks to update in case it exists.
     */
    where: ChannelLinksWhereUniqueInput
    /**
     * In case the ChannelLinks found by the `where` argument doesn't exist, create a new ChannelLinks with this data.
     */
    create: XOR<ChannelLinksCreateInput, ChannelLinksUncheckedCreateInput>
    /**
     * In case the ChannelLinks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelLinksUpdateInput, ChannelLinksUncheckedUpdateInput>
  }

  /**
   * ChannelLinks delete
   */
  export type ChannelLinksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelLinks
     */
    select?: ChannelLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelLinks
     */
    omit?: ChannelLinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelLinksInclude<ExtArgs> | null
    /**
     * Filter which ChannelLinks to delete.
     */
    where: ChannelLinksWhereUniqueInput
  }

  /**
   * ChannelLinks deleteMany
   */
  export type ChannelLinksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelLinks to delete
     */
    where?: ChannelLinksWhereInput
    /**
     * Limit how many ChannelLinks to delete.
     */
    limit?: number
  }

  /**
   * ChannelLinks findRaw
   */
  export type ChannelLinksFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ChannelLinks aggregateRaw
   */
  export type ChannelLinksAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ChannelLinks.SyncedChannelLinkMessage
   */
  export type ChannelLinks$SyncedChannelLinkMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncedChannelLinkMessages
     */
    select?: SyncedChannelLinkMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncedChannelLinkMessages
     */
    omit?: SyncedChannelLinkMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncedChannelLinkMessagesInclude<ExtArgs> | null
    where?: SyncedChannelLinkMessagesWhereInput
    orderBy?: SyncedChannelLinkMessagesOrderByWithRelationInput | SyncedChannelLinkMessagesOrderByWithRelationInput[]
    cursor?: SyncedChannelLinkMessagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyncedChannelLinkMessagesScalarFieldEnum | SyncedChannelLinkMessagesScalarFieldEnum[]
  }

  /**
   * ChannelLinks without action
   */
  export type ChannelLinksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelLinks
     */
    select?: ChannelLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelLinks
     */
    omit?: ChannelLinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelLinksInclude<ExtArgs> | null
  }


  /**
   * Model SyncedChannelLinkMessages
   */

  export type AggregateSyncedChannelLinkMessages = {
    _count: SyncedChannelLinkMessagesCountAggregateOutputType | null
    _min: SyncedChannelLinkMessagesMinAggregateOutputType | null
    _max: SyncedChannelLinkMessagesMaxAggregateOutputType | null
  }

  export type SyncedChannelLinkMessagesMinAggregateOutputType = {
    id: string | null
    GuildId: string | null
    UserMessageId: string | null
    WebhookMessageId: string | null
    WebhookURL: string | null
    ChannelId: string | null
    ChannelLinkId: string | null
  }

  export type SyncedChannelLinkMessagesMaxAggregateOutputType = {
    id: string | null
    GuildId: string | null
    UserMessageId: string | null
    WebhookMessageId: string | null
    WebhookURL: string | null
    ChannelId: string | null
    ChannelLinkId: string | null
  }

  export type SyncedChannelLinkMessagesCountAggregateOutputType = {
    id: number
    GuildId: number
    UserMessageId: number
    WebhookMessageId: number
    WebhookURL: number
    ChannelId: number
    ChannelLinkId: number
    _all: number
  }


  export type SyncedChannelLinkMessagesMinAggregateInputType = {
    id?: true
    GuildId?: true
    UserMessageId?: true
    WebhookMessageId?: true
    WebhookURL?: true
    ChannelId?: true
    ChannelLinkId?: true
  }

  export type SyncedChannelLinkMessagesMaxAggregateInputType = {
    id?: true
    GuildId?: true
    UserMessageId?: true
    WebhookMessageId?: true
    WebhookURL?: true
    ChannelId?: true
    ChannelLinkId?: true
  }

  export type SyncedChannelLinkMessagesCountAggregateInputType = {
    id?: true
    GuildId?: true
    UserMessageId?: true
    WebhookMessageId?: true
    WebhookURL?: true
    ChannelId?: true
    ChannelLinkId?: true
    _all?: true
  }

  export type SyncedChannelLinkMessagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncedChannelLinkMessages to aggregate.
     */
    where?: SyncedChannelLinkMessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncedChannelLinkMessages to fetch.
     */
    orderBy?: SyncedChannelLinkMessagesOrderByWithRelationInput | SyncedChannelLinkMessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyncedChannelLinkMessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncedChannelLinkMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncedChannelLinkMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyncedChannelLinkMessages
    **/
    _count?: true | SyncedChannelLinkMessagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyncedChannelLinkMessagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyncedChannelLinkMessagesMaxAggregateInputType
  }

  export type GetSyncedChannelLinkMessagesAggregateType<T extends SyncedChannelLinkMessagesAggregateArgs> = {
        [P in keyof T & keyof AggregateSyncedChannelLinkMessages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyncedChannelLinkMessages[P]>
      : GetScalarType<T[P], AggregateSyncedChannelLinkMessages[P]>
  }




  export type SyncedChannelLinkMessagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncedChannelLinkMessagesWhereInput
    orderBy?: SyncedChannelLinkMessagesOrderByWithAggregationInput | SyncedChannelLinkMessagesOrderByWithAggregationInput[]
    by: SyncedChannelLinkMessagesScalarFieldEnum[] | SyncedChannelLinkMessagesScalarFieldEnum
    having?: SyncedChannelLinkMessagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyncedChannelLinkMessagesCountAggregateInputType | true
    _min?: SyncedChannelLinkMessagesMinAggregateInputType
    _max?: SyncedChannelLinkMessagesMaxAggregateInputType
  }

  export type SyncedChannelLinkMessagesGroupByOutputType = {
    id: string
    GuildId: string
    UserMessageId: string
    WebhookMessageId: string
    WebhookURL: string
    ChannelId: string
    ChannelLinkId: string
    _count: SyncedChannelLinkMessagesCountAggregateOutputType | null
    _min: SyncedChannelLinkMessagesMinAggregateOutputType | null
    _max: SyncedChannelLinkMessagesMaxAggregateOutputType | null
  }

  type GetSyncedChannelLinkMessagesGroupByPayload<T extends SyncedChannelLinkMessagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyncedChannelLinkMessagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyncedChannelLinkMessagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyncedChannelLinkMessagesGroupByOutputType[P]>
            : GetScalarType<T[P], SyncedChannelLinkMessagesGroupByOutputType[P]>
        }
      >
    >


  export type SyncedChannelLinkMessagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    GuildId?: boolean
    UserMessageId?: boolean
    WebhookMessageId?: boolean
    WebhookURL?: boolean
    ChannelId?: boolean
    ChannelLinkId?: boolean
    ChannelLinks?: boolean | ChannelLinksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syncedChannelLinkMessages"]>



  export type SyncedChannelLinkMessagesSelectScalar = {
    id?: boolean
    GuildId?: boolean
    UserMessageId?: boolean
    WebhookMessageId?: boolean
    WebhookURL?: boolean
    ChannelId?: boolean
    ChannelLinkId?: boolean
  }

  export type SyncedChannelLinkMessagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "GuildId" | "UserMessageId" | "WebhookMessageId" | "WebhookURL" | "ChannelId" | "ChannelLinkId", ExtArgs["result"]["syncedChannelLinkMessages"]>
  export type SyncedChannelLinkMessagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ChannelLinks?: boolean | ChannelLinksDefaultArgs<ExtArgs>
  }

  export type $SyncedChannelLinkMessagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyncedChannelLinkMessages"
    objects: {
      ChannelLinks: Prisma.$ChannelLinksPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      GuildId: string
      UserMessageId: string
      WebhookMessageId: string
      WebhookURL: string
      ChannelId: string
      ChannelLinkId: string
    }, ExtArgs["result"]["syncedChannelLinkMessages"]>
    composites: {}
  }

  type SyncedChannelLinkMessagesGetPayload<S extends boolean | null | undefined | SyncedChannelLinkMessagesDefaultArgs> = $Result.GetResult<Prisma.$SyncedChannelLinkMessagesPayload, S>

  type SyncedChannelLinkMessagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SyncedChannelLinkMessagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SyncedChannelLinkMessagesCountAggregateInputType | true
    }

  export interface SyncedChannelLinkMessagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyncedChannelLinkMessages'], meta: { name: 'SyncedChannelLinkMessages' } }
    /**
     * Find zero or one SyncedChannelLinkMessages that matches the filter.
     * @param {SyncedChannelLinkMessagesFindUniqueArgs} args - Arguments to find a SyncedChannelLinkMessages
     * @example
     * // Get one SyncedChannelLinkMessages
     * const syncedChannelLinkMessages = await prisma.syncedChannelLinkMessages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyncedChannelLinkMessagesFindUniqueArgs>(args: SelectSubset<T, SyncedChannelLinkMessagesFindUniqueArgs<ExtArgs>>): Prisma__SyncedChannelLinkMessagesClient<$Result.GetResult<Prisma.$SyncedChannelLinkMessagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SyncedChannelLinkMessages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SyncedChannelLinkMessagesFindUniqueOrThrowArgs} args - Arguments to find a SyncedChannelLinkMessages
     * @example
     * // Get one SyncedChannelLinkMessages
     * const syncedChannelLinkMessages = await prisma.syncedChannelLinkMessages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyncedChannelLinkMessagesFindUniqueOrThrowArgs>(args: SelectSubset<T, SyncedChannelLinkMessagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyncedChannelLinkMessagesClient<$Result.GetResult<Prisma.$SyncedChannelLinkMessagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncedChannelLinkMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncedChannelLinkMessagesFindFirstArgs} args - Arguments to find a SyncedChannelLinkMessages
     * @example
     * // Get one SyncedChannelLinkMessages
     * const syncedChannelLinkMessages = await prisma.syncedChannelLinkMessages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyncedChannelLinkMessagesFindFirstArgs>(args?: SelectSubset<T, SyncedChannelLinkMessagesFindFirstArgs<ExtArgs>>): Prisma__SyncedChannelLinkMessagesClient<$Result.GetResult<Prisma.$SyncedChannelLinkMessagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncedChannelLinkMessages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncedChannelLinkMessagesFindFirstOrThrowArgs} args - Arguments to find a SyncedChannelLinkMessages
     * @example
     * // Get one SyncedChannelLinkMessages
     * const syncedChannelLinkMessages = await prisma.syncedChannelLinkMessages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyncedChannelLinkMessagesFindFirstOrThrowArgs>(args?: SelectSubset<T, SyncedChannelLinkMessagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyncedChannelLinkMessagesClient<$Result.GetResult<Prisma.$SyncedChannelLinkMessagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SyncedChannelLinkMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncedChannelLinkMessagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyncedChannelLinkMessages
     * const syncedChannelLinkMessages = await prisma.syncedChannelLinkMessages.findMany()
     * 
     * // Get first 10 SyncedChannelLinkMessages
     * const syncedChannelLinkMessages = await prisma.syncedChannelLinkMessages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syncedChannelLinkMessagesWithIdOnly = await prisma.syncedChannelLinkMessages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyncedChannelLinkMessagesFindManyArgs>(args?: SelectSubset<T, SyncedChannelLinkMessagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncedChannelLinkMessagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SyncedChannelLinkMessages.
     * @param {SyncedChannelLinkMessagesCreateArgs} args - Arguments to create a SyncedChannelLinkMessages.
     * @example
     * // Create one SyncedChannelLinkMessages
     * const SyncedChannelLinkMessages = await prisma.syncedChannelLinkMessages.create({
     *   data: {
     *     // ... data to create a SyncedChannelLinkMessages
     *   }
     * })
     * 
     */
    create<T extends SyncedChannelLinkMessagesCreateArgs>(args: SelectSubset<T, SyncedChannelLinkMessagesCreateArgs<ExtArgs>>): Prisma__SyncedChannelLinkMessagesClient<$Result.GetResult<Prisma.$SyncedChannelLinkMessagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SyncedChannelLinkMessages.
     * @param {SyncedChannelLinkMessagesCreateManyArgs} args - Arguments to create many SyncedChannelLinkMessages.
     * @example
     * // Create many SyncedChannelLinkMessages
     * const syncedChannelLinkMessages = await prisma.syncedChannelLinkMessages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyncedChannelLinkMessagesCreateManyArgs>(args?: SelectSubset<T, SyncedChannelLinkMessagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SyncedChannelLinkMessages.
     * @param {SyncedChannelLinkMessagesDeleteArgs} args - Arguments to delete one SyncedChannelLinkMessages.
     * @example
     * // Delete one SyncedChannelLinkMessages
     * const SyncedChannelLinkMessages = await prisma.syncedChannelLinkMessages.delete({
     *   where: {
     *     // ... filter to delete one SyncedChannelLinkMessages
     *   }
     * })
     * 
     */
    delete<T extends SyncedChannelLinkMessagesDeleteArgs>(args: SelectSubset<T, SyncedChannelLinkMessagesDeleteArgs<ExtArgs>>): Prisma__SyncedChannelLinkMessagesClient<$Result.GetResult<Prisma.$SyncedChannelLinkMessagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SyncedChannelLinkMessages.
     * @param {SyncedChannelLinkMessagesUpdateArgs} args - Arguments to update one SyncedChannelLinkMessages.
     * @example
     * // Update one SyncedChannelLinkMessages
     * const syncedChannelLinkMessages = await prisma.syncedChannelLinkMessages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyncedChannelLinkMessagesUpdateArgs>(args: SelectSubset<T, SyncedChannelLinkMessagesUpdateArgs<ExtArgs>>): Prisma__SyncedChannelLinkMessagesClient<$Result.GetResult<Prisma.$SyncedChannelLinkMessagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SyncedChannelLinkMessages.
     * @param {SyncedChannelLinkMessagesDeleteManyArgs} args - Arguments to filter SyncedChannelLinkMessages to delete.
     * @example
     * // Delete a few SyncedChannelLinkMessages
     * const { count } = await prisma.syncedChannelLinkMessages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyncedChannelLinkMessagesDeleteManyArgs>(args?: SelectSubset<T, SyncedChannelLinkMessagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncedChannelLinkMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncedChannelLinkMessagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyncedChannelLinkMessages
     * const syncedChannelLinkMessages = await prisma.syncedChannelLinkMessages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyncedChannelLinkMessagesUpdateManyArgs>(args: SelectSubset<T, SyncedChannelLinkMessagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SyncedChannelLinkMessages.
     * @param {SyncedChannelLinkMessagesUpsertArgs} args - Arguments to update or create a SyncedChannelLinkMessages.
     * @example
     * // Update or create a SyncedChannelLinkMessages
     * const syncedChannelLinkMessages = await prisma.syncedChannelLinkMessages.upsert({
     *   create: {
     *     // ... data to create a SyncedChannelLinkMessages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyncedChannelLinkMessages we want to update
     *   }
     * })
     */
    upsert<T extends SyncedChannelLinkMessagesUpsertArgs>(args: SelectSubset<T, SyncedChannelLinkMessagesUpsertArgs<ExtArgs>>): Prisma__SyncedChannelLinkMessagesClient<$Result.GetResult<Prisma.$SyncedChannelLinkMessagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SyncedChannelLinkMessages that matches the filter.
     * @param {SyncedChannelLinkMessagesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const syncedChannelLinkMessages = await prisma.syncedChannelLinkMessages.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SyncedChannelLinkMessagesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SyncedChannelLinkMessages.
     * @param {SyncedChannelLinkMessagesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const syncedChannelLinkMessages = await prisma.syncedChannelLinkMessages.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SyncedChannelLinkMessagesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SyncedChannelLinkMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncedChannelLinkMessagesCountArgs} args - Arguments to filter SyncedChannelLinkMessages to count.
     * @example
     * // Count the number of SyncedChannelLinkMessages
     * const count = await prisma.syncedChannelLinkMessages.count({
     *   where: {
     *     // ... the filter for the SyncedChannelLinkMessages we want to count
     *   }
     * })
    **/
    count<T extends SyncedChannelLinkMessagesCountArgs>(
      args?: Subset<T, SyncedChannelLinkMessagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyncedChannelLinkMessagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyncedChannelLinkMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncedChannelLinkMessagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyncedChannelLinkMessagesAggregateArgs>(args: Subset<T, SyncedChannelLinkMessagesAggregateArgs>): Prisma.PrismaPromise<GetSyncedChannelLinkMessagesAggregateType<T>>

    /**
     * Group by SyncedChannelLinkMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncedChannelLinkMessagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyncedChannelLinkMessagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyncedChannelLinkMessagesGroupByArgs['orderBy'] }
        : { orderBy?: SyncedChannelLinkMessagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyncedChannelLinkMessagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyncedChannelLinkMessagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyncedChannelLinkMessages model
   */
  readonly fields: SyncedChannelLinkMessagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyncedChannelLinkMessages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyncedChannelLinkMessagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ChannelLinks<T extends ChannelLinksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChannelLinksDefaultArgs<ExtArgs>>): Prisma__ChannelLinksClient<$Result.GetResult<Prisma.$ChannelLinksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyncedChannelLinkMessages model
   */
  interface SyncedChannelLinkMessagesFieldRefs {
    readonly id: FieldRef<"SyncedChannelLinkMessages", 'String'>
    readonly GuildId: FieldRef<"SyncedChannelLinkMessages", 'String'>
    readonly UserMessageId: FieldRef<"SyncedChannelLinkMessages", 'String'>
    readonly WebhookMessageId: FieldRef<"SyncedChannelLinkMessages", 'String'>
    readonly WebhookURL: FieldRef<"SyncedChannelLinkMessages", 'String'>
    readonly ChannelId: FieldRef<"SyncedChannelLinkMessages", 'String'>
    readonly ChannelLinkId: FieldRef<"SyncedChannelLinkMessages", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SyncedChannelLinkMessages findUnique
   */
  export type SyncedChannelLinkMessagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncedChannelLinkMessages
     */
    select?: SyncedChannelLinkMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncedChannelLinkMessages
     */
    omit?: SyncedChannelLinkMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncedChannelLinkMessagesInclude<ExtArgs> | null
    /**
     * Filter, which SyncedChannelLinkMessages to fetch.
     */
    where: SyncedChannelLinkMessagesWhereUniqueInput
  }

  /**
   * SyncedChannelLinkMessages findUniqueOrThrow
   */
  export type SyncedChannelLinkMessagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncedChannelLinkMessages
     */
    select?: SyncedChannelLinkMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncedChannelLinkMessages
     */
    omit?: SyncedChannelLinkMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncedChannelLinkMessagesInclude<ExtArgs> | null
    /**
     * Filter, which SyncedChannelLinkMessages to fetch.
     */
    where: SyncedChannelLinkMessagesWhereUniqueInput
  }

  /**
   * SyncedChannelLinkMessages findFirst
   */
  export type SyncedChannelLinkMessagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncedChannelLinkMessages
     */
    select?: SyncedChannelLinkMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncedChannelLinkMessages
     */
    omit?: SyncedChannelLinkMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncedChannelLinkMessagesInclude<ExtArgs> | null
    /**
     * Filter, which SyncedChannelLinkMessages to fetch.
     */
    where?: SyncedChannelLinkMessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncedChannelLinkMessages to fetch.
     */
    orderBy?: SyncedChannelLinkMessagesOrderByWithRelationInput | SyncedChannelLinkMessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncedChannelLinkMessages.
     */
    cursor?: SyncedChannelLinkMessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncedChannelLinkMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncedChannelLinkMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncedChannelLinkMessages.
     */
    distinct?: SyncedChannelLinkMessagesScalarFieldEnum | SyncedChannelLinkMessagesScalarFieldEnum[]
  }

  /**
   * SyncedChannelLinkMessages findFirstOrThrow
   */
  export type SyncedChannelLinkMessagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncedChannelLinkMessages
     */
    select?: SyncedChannelLinkMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncedChannelLinkMessages
     */
    omit?: SyncedChannelLinkMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncedChannelLinkMessagesInclude<ExtArgs> | null
    /**
     * Filter, which SyncedChannelLinkMessages to fetch.
     */
    where?: SyncedChannelLinkMessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncedChannelLinkMessages to fetch.
     */
    orderBy?: SyncedChannelLinkMessagesOrderByWithRelationInput | SyncedChannelLinkMessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncedChannelLinkMessages.
     */
    cursor?: SyncedChannelLinkMessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncedChannelLinkMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncedChannelLinkMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncedChannelLinkMessages.
     */
    distinct?: SyncedChannelLinkMessagesScalarFieldEnum | SyncedChannelLinkMessagesScalarFieldEnum[]
  }

  /**
   * SyncedChannelLinkMessages findMany
   */
  export type SyncedChannelLinkMessagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncedChannelLinkMessages
     */
    select?: SyncedChannelLinkMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncedChannelLinkMessages
     */
    omit?: SyncedChannelLinkMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncedChannelLinkMessagesInclude<ExtArgs> | null
    /**
     * Filter, which SyncedChannelLinkMessages to fetch.
     */
    where?: SyncedChannelLinkMessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncedChannelLinkMessages to fetch.
     */
    orderBy?: SyncedChannelLinkMessagesOrderByWithRelationInput | SyncedChannelLinkMessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyncedChannelLinkMessages.
     */
    cursor?: SyncedChannelLinkMessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncedChannelLinkMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncedChannelLinkMessages.
     */
    skip?: number
    distinct?: SyncedChannelLinkMessagesScalarFieldEnum | SyncedChannelLinkMessagesScalarFieldEnum[]
  }

  /**
   * SyncedChannelLinkMessages create
   */
  export type SyncedChannelLinkMessagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncedChannelLinkMessages
     */
    select?: SyncedChannelLinkMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncedChannelLinkMessages
     */
    omit?: SyncedChannelLinkMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncedChannelLinkMessagesInclude<ExtArgs> | null
    /**
     * The data needed to create a SyncedChannelLinkMessages.
     */
    data: XOR<SyncedChannelLinkMessagesCreateInput, SyncedChannelLinkMessagesUncheckedCreateInput>
  }

  /**
   * SyncedChannelLinkMessages createMany
   */
  export type SyncedChannelLinkMessagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyncedChannelLinkMessages.
     */
    data: SyncedChannelLinkMessagesCreateManyInput | SyncedChannelLinkMessagesCreateManyInput[]
  }

  /**
   * SyncedChannelLinkMessages update
   */
  export type SyncedChannelLinkMessagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncedChannelLinkMessages
     */
    select?: SyncedChannelLinkMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncedChannelLinkMessages
     */
    omit?: SyncedChannelLinkMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncedChannelLinkMessagesInclude<ExtArgs> | null
    /**
     * The data needed to update a SyncedChannelLinkMessages.
     */
    data: XOR<SyncedChannelLinkMessagesUpdateInput, SyncedChannelLinkMessagesUncheckedUpdateInput>
    /**
     * Choose, which SyncedChannelLinkMessages to update.
     */
    where: SyncedChannelLinkMessagesWhereUniqueInput
  }

  /**
   * SyncedChannelLinkMessages updateMany
   */
  export type SyncedChannelLinkMessagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyncedChannelLinkMessages.
     */
    data: XOR<SyncedChannelLinkMessagesUpdateManyMutationInput, SyncedChannelLinkMessagesUncheckedUpdateManyInput>
    /**
     * Filter which SyncedChannelLinkMessages to update
     */
    where?: SyncedChannelLinkMessagesWhereInput
    /**
     * Limit how many SyncedChannelLinkMessages to update.
     */
    limit?: number
  }

  /**
   * SyncedChannelLinkMessages upsert
   */
  export type SyncedChannelLinkMessagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncedChannelLinkMessages
     */
    select?: SyncedChannelLinkMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncedChannelLinkMessages
     */
    omit?: SyncedChannelLinkMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncedChannelLinkMessagesInclude<ExtArgs> | null
    /**
     * The filter to search for the SyncedChannelLinkMessages to update in case it exists.
     */
    where: SyncedChannelLinkMessagesWhereUniqueInput
    /**
     * In case the SyncedChannelLinkMessages found by the `where` argument doesn't exist, create a new SyncedChannelLinkMessages with this data.
     */
    create: XOR<SyncedChannelLinkMessagesCreateInput, SyncedChannelLinkMessagesUncheckedCreateInput>
    /**
     * In case the SyncedChannelLinkMessages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyncedChannelLinkMessagesUpdateInput, SyncedChannelLinkMessagesUncheckedUpdateInput>
  }

  /**
   * SyncedChannelLinkMessages delete
   */
  export type SyncedChannelLinkMessagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncedChannelLinkMessages
     */
    select?: SyncedChannelLinkMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncedChannelLinkMessages
     */
    omit?: SyncedChannelLinkMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncedChannelLinkMessagesInclude<ExtArgs> | null
    /**
     * Filter which SyncedChannelLinkMessages to delete.
     */
    where: SyncedChannelLinkMessagesWhereUniqueInput
  }

  /**
   * SyncedChannelLinkMessages deleteMany
   */
  export type SyncedChannelLinkMessagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncedChannelLinkMessages to delete
     */
    where?: SyncedChannelLinkMessagesWhereInput
    /**
     * Limit how many SyncedChannelLinkMessages to delete.
     */
    limit?: number
  }

  /**
   * SyncedChannelLinkMessages findRaw
   */
  export type SyncedChannelLinkMessagesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SyncedChannelLinkMessages aggregateRaw
   */
  export type SyncedChannelLinkMessagesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SyncedChannelLinkMessages without action
   */
  export type SyncedChannelLinkMessagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncedChannelLinkMessages
     */
    select?: SyncedChannelLinkMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncedChannelLinkMessages
     */
    omit?: SyncedChannelLinkMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncedChannelLinkMessagesInclude<ExtArgs> | null
  }


  /**
   * Model DiscordAddons
   */

  export type AggregateDiscordAddons = {
    _count: DiscordAddonsCountAggregateOutputType | null
    _min: DiscordAddonsMinAggregateOutputType | null
    _max: DiscordAddonsMaxAggregateOutputType | null
  }

  export type DiscordAddonsMinAggregateOutputType = {
    id: string | null
    InvitesPaused: boolean | null
    GuildId: string | null
  }

  export type DiscordAddonsMaxAggregateOutputType = {
    id: string | null
    InvitesPaused: boolean | null
    GuildId: string | null
  }

  export type DiscordAddonsCountAggregateOutputType = {
    id: number
    OnlyMedia: number
    NoLinkEmbeds: number
    InvitesPaused: number
    GuildId: number
    _all: number
  }


  export type DiscordAddonsMinAggregateInputType = {
    id?: true
    InvitesPaused?: true
    GuildId?: true
  }

  export type DiscordAddonsMaxAggregateInputType = {
    id?: true
    InvitesPaused?: true
    GuildId?: true
  }

  export type DiscordAddonsCountAggregateInputType = {
    id?: true
    OnlyMedia?: true
    NoLinkEmbeds?: true
    InvitesPaused?: true
    GuildId?: true
    _all?: true
  }

  export type DiscordAddonsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiscordAddons to aggregate.
     */
    where?: DiscordAddonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscordAddons to fetch.
     */
    orderBy?: DiscordAddonsOrderByWithRelationInput | DiscordAddonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiscordAddonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscordAddons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscordAddons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiscordAddons
    **/
    _count?: true | DiscordAddonsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscordAddonsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscordAddonsMaxAggregateInputType
  }

  export type GetDiscordAddonsAggregateType<T extends DiscordAddonsAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscordAddons]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscordAddons[P]>
      : GetScalarType<T[P], AggregateDiscordAddons[P]>
  }




  export type DiscordAddonsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscordAddonsWhereInput
    orderBy?: DiscordAddonsOrderByWithAggregationInput | DiscordAddonsOrderByWithAggregationInput[]
    by: DiscordAddonsScalarFieldEnum[] | DiscordAddonsScalarFieldEnum
    having?: DiscordAddonsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscordAddonsCountAggregateInputType | true
    _min?: DiscordAddonsMinAggregateInputType
    _max?: DiscordAddonsMaxAggregateInputType
  }

  export type DiscordAddonsGroupByOutputType = {
    id: string
    OnlyMedia: string[]
    NoLinkEmbeds: string[]
    InvitesPaused: boolean
    GuildId: string
    _count: DiscordAddonsCountAggregateOutputType | null
    _min: DiscordAddonsMinAggregateOutputType | null
    _max: DiscordAddonsMaxAggregateOutputType | null
  }

  type GetDiscordAddonsGroupByPayload<T extends DiscordAddonsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiscordAddonsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscordAddonsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscordAddonsGroupByOutputType[P]>
            : GetScalarType<T[P], DiscordAddonsGroupByOutputType[P]>
        }
      >
    >


  export type DiscordAddonsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    OnlyMedia?: boolean
    NoLinkEmbeds?: boolean
    InvitesPaused?: boolean
    GuildId?: boolean
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discordAddons"]>



  export type DiscordAddonsSelectScalar = {
    id?: boolean
    OnlyMedia?: boolean
    NoLinkEmbeds?: boolean
    InvitesPaused?: boolean
    GuildId?: boolean
  }

  export type DiscordAddonsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "OnlyMedia" | "NoLinkEmbeds" | "InvitesPaused" | "GuildId", ExtArgs["result"]["discordAddons"]>
  export type DiscordAddonsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }

  export type $DiscordAddonsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DiscordAddons"
    objects: {
      Guilds: Prisma.$GuildsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      OnlyMedia: string[]
      NoLinkEmbeds: string[]
      InvitesPaused: boolean
      GuildId: string
    }, ExtArgs["result"]["discordAddons"]>
    composites: {}
  }

  type DiscordAddonsGetPayload<S extends boolean | null | undefined | DiscordAddonsDefaultArgs> = $Result.GetResult<Prisma.$DiscordAddonsPayload, S>

  type DiscordAddonsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DiscordAddonsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiscordAddonsCountAggregateInputType | true
    }

  export interface DiscordAddonsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DiscordAddons'], meta: { name: 'DiscordAddons' } }
    /**
     * Find zero or one DiscordAddons that matches the filter.
     * @param {DiscordAddonsFindUniqueArgs} args - Arguments to find a DiscordAddons
     * @example
     * // Get one DiscordAddons
     * const discordAddons = await prisma.discordAddons.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiscordAddonsFindUniqueArgs>(args: SelectSubset<T, DiscordAddonsFindUniqueArgs<ExtArgs>>): Prisma__DiscordAddonsClient<$Result.GetResult<Prisma.$DiscordAddonsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DiscordAddons that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiscordAddonsFindUniqueOrThrowArgs} args - Arguments to find a DiscordAddons
     * @example
     * // Get one DiscordAddons
     * const discordAddons = await prisma.discordAddons.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiscordAddonsFindUniqueOrThrowArgs>(args: SelectSubset<T, DiscordAddonsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiscordAddonsClient<$Result.GetResult<Prisma.$DiscordAddonsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DiscordAddons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordAddonsFindFirstArgs} args - Arguments to find a DiscordAddons
     * @example
     * // Get one DiscordAddons
     * const discordAddons = await prisma.discordAddons.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiscordAddonsFindFirstArgs>(args?: SelectSubset<T, DiscordAddonsFindFirstArgs<ExtArgs>>): Prisma__DiscordAddonsClient<$Result.GetResult<Prisma.$DiscordAddonsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DiscordAddons that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordAddonsFindFirstOrThrowArgs} args - Arguments to find a DiscordAddons
     * @example
     * // Get one DiscordAddons
     * const discordAddons = await prisma.discordAddons.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiscordAddonsFindFirstOrThrowArgs>(args?: SelectSubset<T, DiscordAddonsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiscordAddonsClient<$Result.GetResult<Prisma.$DiscordAddonsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DiscordAddons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordAddonsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiscordAddons
     * const discordAddons = await prisma.discordAddons.findMany()
     * 
     * // Get first 10 DiscordAddons
     * const discordAddons = await prisma.discordAddons.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discordAddonsWithIdOnly = await prisma.discordAddons.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiscordAddonsFindManyArgs>(args?: SelectSubset<T, DiscordAddonsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscordAddonsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DiscordAddons.
     * @param {DiscordAddonsCreateArgs} args - Arguments to create a DiscordAddons.
     * @example
     * // Create one DiscordAddons
     * const DiscordAddons = await prisma.discordAddons.create({
     *   data: {
     *     // ... data to create a DiscordAddons
     *   }
     * })
     * 
     */
    create<T extends DiscordAddonsCreateArgs>(args: SelectSubset<T, DiscordAddonsCreateArgs<ExtArgs>>): Prisma__DiscordAddonsClient<$Result.GetResult<Prisma.$DiscordAddonsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DiscordAddons.
     * @param {DiscordAddonsCreateManyArgs} args - Arguments to create many DiscordAddons.
     * @example
     * // Create many DiscordAddons
     * const discordAddons = await prisma.discordAddons.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiscordAddonsCreateManyArgs>(args?: SelectSubset<T, DiscordAddonsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DiscordAddons.
     * @param {DiscordAddonsDeleteArgs} args - Arguments to delete one DiscordAddons.
     * @example
     * // Delete one DiscordAddons
     * const DiscordAddons = await prisma.discordAddons.delete({
     *   where: {
     *     // ... filter to delete one DiscordAddons
     *   }
     * })
     * 
     */
    delete<T extends DiscordAddonsDeleteArgs>(args: SelectSubset<T, DiscordAddonsDeleteArgs<ExtArgs>>): Prisma__DiscordAddonsClient<$Result.GetResult<Prisma.$DiscordAddonsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DiscordAddons.
     * @param {DiscordAddonsUpdateArgs} args - Arguments to update one DiscordAddons.
     * @example
     * // Update one DiscordAddons
     * const discordAddons = await prisma.discordAddons.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiscordAddonsUpdateArgs>(args: SelectSubset<T, DiscordAddonsUpdateArgs<ExtArgs>>): Prisma__DiscordAddonsClient<$Result.GetResult<Prisma.$DiscordAddonsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DiscordAddons.
     * @param {DiscordAddonsDeleteManyArgs} args - Arguments to filter DiscordAddons to delete.
     * @example
     * // Delete a few DiscordAddons
     * const { count } = await prisma.discordAddons.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiscordAddonsDeleteManyArgs>(args?: SelectSubset<T, DiscordAddonsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscordAddons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordAddonsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiscordAddons
     * const discordAddons = await prisma.discordAddons.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiscordAddonsUpdateManyArgs>(args: SelectSubset<T, DiscordAddonsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DiscordAddons.
     * @param {DiscordAddonsUpsertArgs} args - Arguments to update or create a DiscordAddons.
     * @example
     * // Update or create a DiscordAddons
     * const discordAddons = await prisma.discordAddons.upsert({
     *   create: {
     *     // ... data to create a DiscordAddons
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiscordAddons we want to update
     *   }
     * })
     */
    upsert<T extends DiscordAddonsUpsertArgs>(args: SelectSubset<T, DiscordAddonsUpsertArgs<ExtArgs>>): Prisma__DiscordAddonsClient<$Result.GetResult<Prisma.$DiscordAddonsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DiscordAddons that matches the filter.
     * @param {DiscordAddonsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const discordAddons = await prisma.discordAddons.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DiscordAddonsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DiscordAddons.
     * @param {DiscordAddonsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const discordAddons = await prisma.discordAddons.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DiscordAddonsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DiscordAddons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordAddonsCountArgs} args - Arguments to filter DiscordAddons to count.
     * @example
     * // Count the number of DiscordAddons
     * const count = await prisma.discordAddons.count({
     *   where: {
     *     // ... the filter for the DiscordAddons we want to count
     *   }
     * })
    **/
    count<T extends DiscordAddonsCountArgs>(
      args?: Subset<T, DiscordAddonsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscordAddonsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiscordAddons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordAddonsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscordAddonsAggregateArgs>(args: Subset<T, DiscordAddonsAggregateArgs>): Prisma.PrismaPromise<GetDiscordAddonsAggregateType<T>>

    /**
     * Group by DiscordAddons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordAddonsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscordAddonsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscordAddonsGroupByArgs['orderBy'] }
        : { orderBy?: DiscordAddonsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscordAddonsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscordAddonsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DiscordAddons model
   */
  readonly fields: DiscordAddonsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DiscordAddons.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiscordAddonsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DiscordAddons model
   */
  interface DiscordAddonsFieldRefs {
    readonly id: FieldRef<"DiscordAddons", 'String'>
    readonly OnlyMedia: FieldRef<"DiscordAddons", 'String[]'>
    readonly NoLinkEmbeds: FieldRef<"DiscordAddons", 'String[]'>
    readonly InvitesPaused: FieldRef<"DiscordAddons", 'Boolean'>
    readonly GuildId: FieldRef<"DiscordAddons", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DiscordAddons findUnique
   */
  export type DiscordAddonsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAddons
     */
    select?: DiscordAddonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAddons
     */
    omit?: DiscordAddonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAddonsInclude<ExtArgs> | null
    /**
     * Filter, which DiscordAddons to fetch.
     */
    where: DiscordAddonsWhereUniqueInput
  }

  /**
   * DiscordAddons findUniqueOrThrow
   */
  export type DiscordAddonsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAddons
     */
    select?: DiscordAddonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAddons
     */
    omit?: DiscordAddonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAddonsInclude<ExtArgs> | null
    /**
     * Filter, which DiscordAddons to fetch.
     */
    where: DiscordAddonsWhereUniqueInput
  }

  /**
   * DiscordAddons findFirst
   */
  export type DiscordAddonsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAddons
     */
    select?: DiscordAddonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAddons
     */
    omit?: DiscordAddonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAddonsInclude<ExtArgs> | null
    /**
     * Filter, which DiscordAddons to fetch.
     */
    where?: DiscordAddonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscordAddons to fetch.
     */
    orderBy?: DiscordAddonsOrderByWithRelationInput | DiscordAddonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscordAddons.
     */
    cursor?: DiscordAddonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscordAddons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscordAddons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscordAddons.
     */
    distinct?: DiscordAddonsScalarFieldEnum | DiscordAddonsScalarFieldEnum[]
  }

  /**
   * DiscordAddons findFirstOrThrow
   */
  export type DiscordAddonsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAddons
     */
    select?: DiscordAddonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAddons
     */
    omit?: DiscordAddonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAddonsInclude<ExtArgs> | null
    /**
     * Filter, which DiscordAddons to fetch.
     */
    where?: DiscordAddonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscordAddons to fetch.
     */
    orderBy?: DiscordAddonsOrderByWithRelationInput | DiscordAddonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscordAddons.
     */
    cursor?: DiscordAddonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscordAddons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscordAddons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscordAddons.
     */
    distinct?: DiscordAddonsScalarFieldEnum | DiscordAddonsScalarFieldEnum[]
  }

  /**
   * DiscordAddons findMany
   */
  export type DiscordAddonsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAddons
     */
    select?: DiscordAddonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAddons
     */
    omit?: DiscordAddonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAddonsInclude<ExtArgs> | null
    /**
     * Filter, which DiscordAddons to fetch.
     */
    where?: DiscordAddonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscordAddons to fetch.
     */
    orderBy?: DiscordAddonsOrderByWithRelationInput | DiscordAddonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiscordAddons.
     */
    cursor?: DiscordAddonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscordAddons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscordAddons.
     */
    skip?: number
    distinct?: DiscordAddonsScalarFieldEnum | DiscordAddonsScalarFieldEnum[]
  }

  /**
   * DiscordAddons create
   */
  export type DiscordAddonsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAddons
     */
    select?: DiscordAddonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAddons
     */
    omit?: DiscordAddonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAddonsInclude<ExtArgs> | null
    /**
     * The data needed to create a DiscordAddons.
     */
    data: XOR<DiscordAddonsCreateInput, DiscordAddonsUncheckedCreateInput>
  }

  /**
   * DiscordAddons createMany
   */
  export type DiscordAddonsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DiscordAddons.
     */
    data: DiscordAddonsCreateManyInput | DiscordAddonsCreateManyInput[]
  }

  /**
   * DiscordAddons update
   */
  export type DiscordAddonsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAddons
     */
    select?: DiscordAddonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAddons
     */
    omit?: DiscordAddonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAddonsInclude<ExtArgs> | null
    /**
     * The data needed to update a DiscordAddons.
     */
    data: XOR<DiscordAddonsUpdateInput, DiscordAddonsUncheckedUpdateInput>
    /**
     * Choose, which DiscordAddons to update.
     */
    where: DiscordAddonsWhereUniqueInput
  }

  /**
   * DiscordAddons updateMany
   */
  export type DiscordAddonsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DiscordAddons.
     */
    data: XOR<DiscordAddonsUpdateManyMutationInput, DiscordAddonsUncheckedUpdateManyInput>
    /**
     * Filter which DiscordAddons to update
     */
    where?: DiscordAddonsWhereInput
    /**
     * Limit how many DiscordAddons to update.
     */
    limit?: number
  }

  /**
   * DiscordAddons upsert
   */
  export type DiscordAddonsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAddons
     */
    select?: DiscordAddonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAddons
     */
    omit?: DiscordAddonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAddonsInclude<ExtArgs> | null
    /**
     * The filter to search for the DiscordAddons to update in case it exists.
     */
    where: DiscordAddonsWhereUniqueInput
    /**
     * In case the DiscordAddons found by the `where` argument doesn't exist, create a new DiscordAddons with this data.
     */
    create: XOR<DiscordAddonsCreateInput, DiscordAddonsUncheckedCreateInput>
    /**
     * In case the DiscordAddons was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiscordAddonsUpdateInput, DiscordAddonsUncheckedUpdateInput>
  }

  /**
   * DiscordAddons delete
   */
  export type DiscordAddonsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAddons
     */
    select?: DiscordAddonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAddons
     */
    omit?: DiscordAddonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAddonsInclude<ExtArgs> | null
    /**
     * Filter which DiscordAddons to delete.
     */
    where: DiscordAddonsWhereUniqueInput
  }

  /**
   * DiscordAddons deleteMany
   */
  export type DiscordAddonsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiscordAddons to delete
     */
    where?: DiscordAddonsWhereInput
    /**
     * Limit how many DiscordAddons to delete.
     */
    limit?: number
  }

  /**
   * DiscordAddons findRaw
   */
  export type DiscordAddonsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DiscordAddons aggregateRaw
   */
  export type DiscordAddonsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DiscordAddons without action
   */
  export type DiscordAddonsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAddons
     */
    select?: DiscordAddonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAddons
     */
    omit?: DiscordAddonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAddonsInclude<ExtArgs> | null
  }


  /**
   * Model Giveaways
   */

  export type AggregateGiveaways = {
    _count: GiveawaysCountAggregateOutputType | null
    _avg: GiveawaysAvgAggregateOutputType | null
    _sum: GiveawaysSumAggregateOutputType | null
    _min: GiveawaysMinAggregateOutputType | null
    _max: GiveawaysMaxAggregateOutputType | null
  }

  export type GiveawaysAvgAggregateOutputType = {
    Winners: number | null
  }

  export type GiveawaysSumAggregateOutputType = {
    Winners: number | null
  }

  export type GiveawaysMinAggregateOutputType = {
    id: string | null
    UUID: string | null
    MessageId: string | null
    ChannelId: string | null
    Prize: string | null
    Winners: number | null
    Time: string | null
    CreatedAt: Date | null
    Ended: boolean | null
    EndedAt: Date | null
    EndedBy: string | null
    Paused: boolean | null
    EndedMessage: string | null
    Rerolled: boolean | null
    WinnerMessageTemplate: string | null
    HostedBy: string | null
    MessageTemplate: string | null
    Content: string | null
    GuildId: string | null
  }

  export type GiveawaysMaxAggregateOutputType = {
    id: string | null
    UUID: string | null
    MessageId: string | null
    ChannelId: string | null
    Prize: string | null
    Winners: number | null
    Time: string | null
    CreatedAt: Date | null
    Ended: boolean | null
    EndedAt: Date | null
    EndedBy: string | null
    Paused: boolean | null
    EndedMessage: string | null
    Rerolled: boolean | null
    WinnerMessageTemplate: string | null
    HostedBy: string | null
    MessageTemplate: string | null
    Content: string | null
    GuildId: string | null
  }

  export type GiveawaysCountAggregateOutputType = {
    id: number
    UUID: number
    MessageId: number
    ChannelId: number
    Prize: number
    Winners: number
    Time: number
    CreatedAt: number
    Ended: number
    EndedAt: number
    EndedBy: number
    Paused: number
    EndedMessage: number
    Rerolled: number
    WinnerIds: number
    WinnerMessageTemplate: number
    HostedBy: number
    MessageTemplate: number
    Content: number
    Entrys: number
    Requirements: number
    GuildId: number
    _all: number
  }


  export type GiveawaysAvgAggregateInputType = {
    Winners?: true
  }

  export type GiveawaysSumAggregateInputType = {
    Winners?: true
  }

  export type GiveawaysMinAggregateInputType = {
    id?: true
    UUID?: true
    MessageId?: true
    ChannelId?: true
    Prize?: true
    Winners?: true
    Time?: true
    CreatedAt?: true
    Ended?: true
    EndedAt?: true
    EndedBy?: true
    Paused?: true
    EndedMessage?: true
    Rerolled?: true
    WinnerMessageTemplate?: true
    HostedBy?: true
    MessageTemplate?: true
    Content?: true
    GuildId?: true
  }

  export type GiveawaysMaxAggregateInputType = {
    id?: true
    UUID?: true
    MessageId?: true
    ChannelId?: true
    Prize?: true
    Winners?: true
    Time?: true
    CreatedAt?: true
    Ended?: true
    EndedAt?: true
    EndedBy?: true
    Paused?: true
    EndedMessage?: true
    Rerolled?: true
    WinnerMessageTemplate?: true
    HostedBy?: true
    MessageTemplate?: true
    Content?: true
    GuildId?: true
  }

  export type GiveawaysCountAggregateInputType = {
    id?: true
    UUID?: true
    MessageId?: true
    ChannelId?: true
    Prize?: true
    Winners?: true
    Time?: true
    CreatedAt?: true
    Ended?: true
    EndedAt?: true
    EndedBy?: true
    Paused?: true
    EndedMessage?: true
    Rerolled?: true
    WinnerIds?: true
    WinnerMessageTemplate?: true
    HostedBy?: true
    MessageTemplate?: true
    Content?: true
    Entrys?: true
    Requirements?: true
    GuildId?: true
    _all?: true
  }

  export type GiveawaysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Giveaways to aggregate.
     */
    where?: GiveawaysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Giveaways to fetch.
     */
    orderBy?: GiveawaysOrderByWithRelationInput | GiveawaysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GiveawaysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Giveaways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Giveaways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Giveaways
    **/
    _count?: true | GiveawaysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GiveawaysAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GiveawaysSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GiveawaysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GiveawaysMaxAggregateInputType
  }

  export type GetGiveawaysAggregateType<T extends GiveawaysAggregateArgs> = {
        [P in keyof T & keyof AggregateGiveaways]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGiveaways[P]>
      : GetScalarType<T[P], AggregateGiveaways[P]>
  }




  export type GiveawaysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GiveawaysWhereInput
    orderBy?: GiveawaysOrderByWithAggregationInput | GiveawaysOrderByWithAggregationInput[]
    by: GiveawaysScalarFieldEnum[] | GiveawaysScalarFieldEnum
    having?: GiveawaysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GiveawaysCountAggregateInputType | true
    _avg?: GiveawaysAvgAggregateInputType
    _sum?: GiveawaysSumAggregateInputType
    _min?: GiveawaysMinAggregateInputType
    _max?: GiveawaysMaxAggregateInputType
  }

  export type GiveawaysGroupByOutputType = {
    id: string
    UUID: string
    MessageId: string
    ChannelId: string | null
    Prize: string
    Winners: number
    Time: string
    CreatedAt: Date
    Ended: boolean
    EndedAt: Date | null
    EndedBy: string | null
    Paused: boolean
    EndedMessage: string | null
    Rerolled: boolean
    WinnerIds: string[]
    WinnerMessageTemplate: string | null
    HostedBy: string
    MessageTemplate: string | null
    Content: string | null
    Entrys: string[]
    Requirements: string[]
    GuildId: string
    _count: GiveawaysCountAggregateOutputType | null
    _avg: GiveawaysAvgAggregateOutputType | null
    _sum: GiveawaysSumAggregateOutputType | null
    _min: GiveawaysMinAggregateOutputType | null
    _max: GiveawaysMaxAggregateOutputType | null
  }

  type GetGiveawaysGroupByPayload<T extends GiveawaysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GiveawaysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GiveawaysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GiveawaysGroupByOutputType[P]>
            : GetScalarType<T[P], GiveawaysGroupByOutputType[P]>
        }
      >
    >


  export type GiveawaysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    UUID?: boolean
    MessageId?: boolean
    ChannelId?: boolean
    Prize?: boolean
    Winners?: boolean
    Time?: boolean
    CreatedAt?: boolean
    Ended?: boolean
    EndedAt?: boolean
    EndedBy?: boolean
    Paused?: boolean
    EndedMessage?: boolean
    Rerolled?: boolean
    WinnerIds?: boolean
    WinnerMessageTemplate?: boolean
    HostedBy?: boolean
    MessageTemplate?: boolean
    Content?: boolean
    Entrys?: boolean
    Requirements?: boolean
    GuildId?: boolean
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["giveaways"]>



  export type GiveawaysSelectScalar = {
    id?: boolean
    UUID?: boolean
    MessageId?: boolean
    ChannelId?: boolean
    Prize?: boolean
    Winners?: boolean
    Time?: boolean
    CreatedAt?: boolean
    Ended?: boolean
    EndedAt?: boolean
    EndedBy?: boolean
    Paused?: boolean
    EndedMessage?: boolean
    Rerolled?: boolean
    WinnerIds?: boolean
    WinnerMessageTemplate?: boolean
    HostedBy?: boolean
    MessageTemplate?: boolean
    Content?: boolean
    Entrys?: boolean
    Requirements?: boolean
    GuildId?: boolean
  }

  export type GiveawaysOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "UUID" | "MessageId" | "ChannelId" | "Prize" | "Winners" | "Time" | "CreatedAt" | "Ended" | "EndedAt" | "EndedBy" | "Paused" | "EndedMessage" | "Rerolled" | "WinnerIds" | "WinnerMessageTemplate" | "HostedBy" | "MessageTemplate" | "Content" | "Entrys" | "Requirements" | "GuildId", ExtArgs["result"]["giveaways"]>
  export type GiveawaysInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }

  export type $GiveawaysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Giveaways"
    objects: {
      Guilds: Prisma.$GuildsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      UUID: string
      MessageId: string
      ChannelId: string | null
      Prize: string
      Winners: number
      Time: string
      CreatedAt: Date
      Ended: boolean
      EndedAt: Date | null
      EndedBy: string | null
      Paused: boolean
      EndedMessage: string | null
      Rerolled: boolean
      WinnerIds: string[]
      WinnerMessageTemplate: string | null
      HostedBy: string
      MessageTemplate: string | null
      Content: string | null
      Entrys: string[]
      Requirements: string[]
      GuildId: string
    }, ExtArgs["result"]["giveaways"]>
    composites: {}
  }

  type GiveawaysGetPayload<S extends boolean | null | undefined | GiveawaysDefaultArgs> = $Result.GetResult<Prisma.$GiveawaysPayload, S>

  type GiveawaysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GiveawaysFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GiveawaysCountAggregateInputType | true
    }

  export interface GiveawaysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Giveaways'], meta: { name: 'Giveaways' } }
    /**
     * Find zero or one Giveaways that matches the filter.
     * @param {GiveawaysFindUniqueArgs} args - Arguments to find a Giveaways
     * @example
     * // Get one Giveaways
     * const giveaways = await prisma.giveaways.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GiveawaysFindUniqueArgs>(args: SelectSubset<T, GiveawaysFindUniqueArgs<ExtArgs>>): Prisma__GiveawaysClient<$Result.GetResult<Prisma.$GiveawaysPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Giveaways that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GiveawaysFindUniqueOrThrowArgs} args - Arguments to find a Giveaways
     * @example
     * // Get one Giveaways
     * const giveaways = await prisma.giveaways.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GiveawaysFindUniqueOrThrowArgs>(args: SelectSubset<T, GiveawaysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GiveawaysClient<$Result.GetResult<Prisma.$GiveawaysPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Giveaways that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiveawaysFindFirstArgs} args - Arguments to find a Giveaways
     * @example
     * // Get one Giveaways
     * const giveaways = await prisma.giveaways.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GiveawaysFindFirstArgs>(args?: SelectSubset<T, GiveawaysFindFirstArgs<ExtArgs>>): Prisma__GiveawaysClient<$Result.GetResult<Prisma.$GiveawaysPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Giveaways that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiveawaysFindFirstOrThrowArgs} args - Arguments to find a Giveaways
     * @example
     * // Get one Giveaways
     * const giveaways = await prisma.giveaways.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GiveawaysFindFirstOrThrowArgs>(args?: SelectSubset<T, GiveawaysFindFirstOrThrowArgs<ExtArgs>>): Prisma__GiveawaysClient<$Result.GetResult<Prisma.$GiveawaysPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Giveaways that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiveawaysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Giveaways
     * const giveaways = await prisma.giveaways.findMany()
     * 
     * // Get first 10 Giveaways
     * const giveaways = await prisma.giveaways.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const giveawaysWithIdOnly = await prisma.giveaways.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GiveawaysFindManyArgs>(args?: SelectSubset<T, GiveawaysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GiveawaysPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Giveaways.
     * @param {GiveawaysCreateArgs} args - Arguments to create a Giveaways.
     * @example
     * // Create one Giveaways
     * const Giveaways = await prisma.giveaways.create({
     *   data: {
     *     // ... data to create a Giveaways
     *   }
     * })
     * 
     */
    create<T extends GiveawaysCreateArgs>(args: SelectSubset<T, GiveawaysCreateArgs<ExtArgs>>): Prisma__GiveawaysClient<$Result.GetResult<Prisma.$GiveawaysPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Giveaways.
     * @param {GiveawaysCreateManyArgs} args - Arguments to create many Giveaways.
     * @example
     * // Create many Giveaways
     * const giveaways = await prisma.giveaways.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GiveawaysCreateManyArgs>(args?: SelectSubset<T, GiveawaysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Giveaways.
     * @param {GiveawaysDeleteArgs} args - Arguments to delete one Giveaways.
     * @example
     * // Delete one Giveaways
     * const Giveaways = await prisma.giveaways.delete({
     *   where: {
     *     // ... filter to delete one Giveaways
     *   }
     * })
     * 
     */
    delete<T extends GiveawaysDeleteArgs>(args: SelectSubset<T, GiveawaysDeleteArgs<ExtArgs>>): Prisma__GiveawaysClient<$Result.GetResult<Prisma.$GiveawaysPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Giveaways.
     * @param {GiveawaysUpdateArgs} args - Arguments to update one Giveaways.
     * @example
     * // Update one Giveaways
     * const giveaways = await prisma.giveaways.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GiveawaysUpdateArgs>(args: SelectSubset<T, GiveawaysUpdateArgs<ExtArgs>>): Prisma__GiveawaysClient<$Result.GetResult<Prisma.$GiveawaysPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Giveaways.
     * @param {GiveawaysDeleteManyArgs} args - Arguments to filter Giveaways to delete.
     * @example
     * // Delete a few Giveaways
     * const { count } = await prisma.giveaways.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GiveawaysDeleteManyArgs>(args?: SelectSubset<T, GiveawaysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Giveaways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiveawaysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Giveaways
     * const giveaways = await prisma.giveaways.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GiveawaysUpdateManyArgs>(args: SelectSubset<T, GiveawaysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Giveaways.
     * @param {GiveawaysUpsertArgs} args - Arguments to update or create a Giveaways.
     * @example
     * // Update or create a Giveaways
     * const giveaways = await prisma.giveaways.upsert({
     *   create: {
     *     // ... data to create a Giveaways
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Giveaways we want to update
     *   }
     * })
     */
    upsert<T extends GiveawaysUpsertArgs>(args: SelectSubset<T, GiveawaysUpsertArgs<ExtArgs>>): Prisma__GiveawaysClient<$Result.GetResult<Prisma.$GiveawaysPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Giveaways that matches the filter.
     * @param {GiveawaysFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const giveaways = await prisma.giveaways.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: GiveawaysFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Giveaways.
     * @param {GiveawaysAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const giveaways = await prisma.giveaways.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: GiveawaysAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Giveaways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiveawaysCountArgs} args - Arguments to filter Giveaways to count.
     * @example
     * // Count the number of Giveaways
     * const count = await prisma.giveaways.count({
     *   where: {
     *     // ... the filter for the Giveaways we want to count
     *   }
     * })
    **/
    count<T extends GiveawaysCountArgs>(
      args?: Subset<T, GiveawaysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GiveawaysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Giveaways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiveawaysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GiveawaysAggregateArgs>(args: Subset<T, GiveawaysAggregateArgs>): Prisma.PrismaPromise<GetGiveawaysAggregateType<T>>

    /**
     * Group by Giveaways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiveawaysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GiveawaysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GiveawaysGroupByArgs['orderBy'] }
        : { orderBy?: GiveawaysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GiveawaysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGiveawaysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Giveaways model
   */
  readonly fields: GiveawaysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Giveaways.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GiveawaysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Giveaways model
   */
  interface GiveawaysFieldRefs {
    readonly id: FieldRef<"Giveaways", 'String'>
    readonly UUID: FieldRef<"Giveaways", 'String'>
    readonly MessageId: FieldRef<"Giveaways", 'String'>
    readonly ChannelId: FieldRef<"Giveaways", 'String'>
    readonly Prize: FieldRef<"Giveaways", 'String'>
    readonly Winners: FieldRef<"Giveaways", 'Int'>
    readonly Time: FieldRef<"Giveaways", 'String'>
    readonly CreatedAt: FieldRef<"Giveaways", 'DateTime'>
    readonly Ended: FieldRef<"Giveaways", 'Boolean'>
    readonly EndedAt: FieldRef<"Giveaways", 'DateTime'>
    readonly EndedBy: FieldRef<"Giveaways", 'String'>
    readonly Paused: FieldRef<"Giveaways", 'Boolean'>
    readonly EndedMessage: FieldRef<"Giveaways", 'String'>
    readonly Rerolled: FieldRef<"Giveaways", 'Boolean'>
    readonly WinnerIds: FieldRef<"Giveaways", 'String[]'>
    readonly WinnerMessageTemplate: FieldRef<"Giveaways", 'String'>
    readonly HostedBy: FieldRef<"Giveaways", 'String'>
    readonly MessageTemplate: FieldRef<"Giveaways", 'String'>
    readonly Content: FieldRef<"Giveaways", 'String'>
    readonly Entrys: FieldRef<"Giveaways", 'String[]'>
    readonly Requirements: FieldRef<"Giveaways", 'String[]'>
    readonly GuildId: FieldRef<"Giveaways", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Giveaways findUnique
   */
  export type GiveawaysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Giveaways
     */
    select?: GiveawaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Giveaways
     */
    omit?: GiveawaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiveawaysInclude<ExtArgs> | null
    /**
     * Filter, which Giveaways to fetch.
     */
    where: GiveawaysWhereUniqueInput
  }

  /**
   * Giveaways findUniqueOrThrow
   */
  export type GiveawaysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Giveaways
     */
    select?: GiveawaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Giveaways
     */
    omit?: GiveawaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiveawaysInclude<ExtArgs> | null
    /**
     * Filter, which Giveaways to fetch.
     */
    where: GiveawaysWhereUniqueInput
  }

  /**
   * Giveaways findFirst
   */
  export type GiveawaysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Giveaways
     */
    select?: GiveawaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Giveaways
     */
    omit?: GiveawaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiveawaysInclude<ExtArgs> | null
    /**
     * Filter, which Giveaways to fetch.
     */
    where?: GiveawaysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Giveaways to fetch.
     */
    orderBy?: GiveawaysOrderByWithRelationInput | GiveawaysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Giveaways.
     */
    cursor?: GiveawaysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Giveaways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Giveaways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Giveaways.
     */
    distinct?: GiveawaysScalarFieldEnum | GiveawaysScalarFieldEnum[]
  }

  /**
   * Giveaways findFirstOrThrow
   */
  export type GiveawaysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Giveaways
     */
    select?: GiveawaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Giveaways
     */
    omit?: GiveawaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiveawaysInclude<ExtArgs> | null
    /**
     * Filter, which Giveaways to fetch.
     */
    where?: GiveawaysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Giveaways to fetch.
     */
    orderBy?: GiveawaysOrderByWithRelationInput | GiveawaysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Giveaways.
     */
    cursor?: GiveawaysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Giveaways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Giveaways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Giveaways.
     */
    distinct?: GiveawaysScalarFieldEnum | GiveawaysScalarFieldEnum[]
  }

  /**
   * Giveaways findMany
   */
  export type GiveawaysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Giveaways
     */
    select?: GiveawaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Giveaways
     */
    omit?: GiveawaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiveawaysInclude<ExtArgs> | null
    /**
     * Filter, which Giveaways to fetch.
     */
    where?: GiveawaysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Giveaways to fetch.
     */
    orderBy?: GiveawaysOrderByWithRelationInput | GiveawaysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Giveaways.
     */
    cursor?: GiveawaysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Giveaways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Giveaways.
     */
    skip?: number
    distinct?: GiveawaysScalarFieldEnum | GiveawaysScalarFieldEnum[]
  }

  /**
   * Giveaways create
   */
  export type GiveawaysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Giveaways
     */
    select?: GiveawaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Giveaways
     */
    omit?: GiveawaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiveawaysInclude<ExtArgs> | null
    /**
     * The data needed to create a Giveaways.
     */
    data: XOR<GiveawaysCreateInput, GiveawaysUncheckedCreateInput>
  }

  /**
   * Giveaways createMany
   */
  export type GiveawaysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Giveaways.
     */
    data: GiveawaysCreateManyInput | GiveawaysCreateManyInput[]
  }

  /**
   * Giveaways update
   */
  export type GiveawaysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Giveaways
     */
    select?: GiveawaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Giveaways
     */
    omit?: GiveawaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiveawaysInclude<ExtArgs> | null
    /**
     * The data needed to update a Giveaways.
     */
    data: XOR<GiveawaysUpdateInput, GiveawaysUncheckedUpdateInput>
    /**
     * Choose, which Giveaways to update.
     */
    where: GiveawaysWhereUniqueInput
  }

  /**
   * Giveaways updateMany
   */
  export type GiveawaysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Giveaways.
     */
    data: XOR<GiveawaysUpdateManyMutationInput, GiveawaysUncheckedUpdateManyInput>
    /**
     * Filter which Giveaways to update
     */
    where?: GiveawaysWhereInput
    /**
     * Limit how many Giveaways to update.
     */
    limit?: number
  }

  /**
   * Giveaways upsert
   */
  export type GiveawaysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Giveaways
     */
    select?: GiveawaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Giveaways
     */
    omit?: GiveawaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiveawaysInclude<ExtArgs> | null
    /**
     * The filter to search for the Giveaways to update in case it exists.
     */
    where: GiveawaysWhereUniqueInput
    /**
     * In case the Giveaways found by the `where` argument doesn't exist, create a new Giveaways with this data.
     */
    create: XOR<GiveawaysCreateInput, GiveawaysUncheckedCreateInput>
    /**
     * In case the Giveaways was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GiveawaysUpdateInput, GiveawaysUncheckedUpdateInput>
  }

  /**
   * Giveaways delete
   */
  export type GiveawaysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Giveaways
     */
    select?: GiveawaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Giveaways
     */
    omit?: GiveawaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiveawaysInclude<ExtArgs> | null
    /**
     * Filter which Giveaways to delete.
     */
    where: GiveawaysWhereUniqueInput
  }

  /**
   * Giveaways deleteMany
   */
  export type GiveawaysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Giveaways to delete
     */
    where?: GiveawaysWhereInput
    /**
     * Limit how many Giveaways to delete.
     */
    limit?: number
  }

  /**
   * Giveaways findRaw
   */
  export type GiveawaysFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Giveaways aggregateRaw
   */
  export type GiveawaysAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Giveaways without action
   */
  export type GiveawaysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Giveaways
     */
    select?: GiveawaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Giveaways
     */
    omit?: GiveawaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiveawaysInclude<ExtArgs> | null
  }


  /**
   * Model TempVoices
   */

  export type AggregateTempVoices = {
    _count: TempVoicesCountAggregateOutputType | null
    _avg: TempVoicesAvgAggregateOutputType | null
    _sum: TempVoicesSumAggregateOutputType | null
    _min: TempVoicesMinAggregateOutputType | null
    _max: TempVoicesMaxAggregateOutputType | null
  }

  export type TempVoicesAvgAggregateOutputType = {
    PresetLimit: number | null
  }

  export type TempVoicesSumAggregateOutputType = {
    PresetLimit: number | null
  }

  export type TempVoicesMinAggregateOutputType = {
    id: string | null
    UUID: string | null
    Name: string | null
    JointoCreateChannel: string | null
    JointoCreateCategory: string | null
    Manage: boolean | null
    PresetLimit: number | null
    GuildId: string | null
  }

  export type TempVoicesMaxAggregateOutputType = {
    id: string | null
    UUID: string | null
    Name: string | null
    JointoCreateChannel: string | null
    JointoCreateCategory: string | null
    Manage: boolean | null
    PresetLimit: number | null
    GuildId: string | null
  }

  export type TempVoicesCountAggregateOutputType = {
    id: number
    UUID: number
    Name: number
    JointoCreateChannel: number
    JointoCreateCategory: number
    Manage: number
    PresetLimit: number
    GuildId: number
    _all: number
  }


  export type TempVoicesAvgAggregateInputType = {
    PresetLimit?: true
  }

  export type TempVoicesSumAggregateInputType = {
    PresetLimit?: true
  }

  export type TempVoicesMinAggregateInputType = {
    id?: true
    UUID?: true
    Name?: true
    JointoCreateChannel?: true
    JointoCreateCategory?: true
    Manage?: true
    PresetLimit?: true
    GuildId?: true
  }

  export type TempVoicesMaxAggregateInputType = {
    id?: true
    UUID?: true
    Name?: true
    JointoCreateChannel?: true
    JointoCreateCategory?: true
    Manage?: true
    PresetLimit?: true
    GuildId?: true
  }

  export type TempVoicesCountAggregateInputType = {
    id?: true
    UUID?: true
    Name?: true
    JointoCreateChannel?: true
    JointoCreateCategory?: true
    Manage?: true
    PresetLimit?: true
    GuildId?: true
    _all?: true
  }

  export type TempVoicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TempVoices to aggregate.
     */
    where?: TempVoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TempVoices to fetch.
     */
    orderBy?: TempVoicesOrderByWithRelationInput | TempVoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TempVoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TempVoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TempVoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TempVoices
    **/
    _count?: true | TempVoicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TempVoicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TempVoicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TempVoicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TempVoicesMaxAggregateInputType
  }

  export type GetTempVoicesAggregateType<T extends TempVoicesAggregateArgs> = {
        [P in keyof T & keyof AggregateTempVoices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTempVoices[P]>
      : GetScalarType<T[P], AggregateTempVoices[P]>
  }




  export type TempVoicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TempVoicesWhereInput
    orderBy?: TempVoicesOrderByWithAggregationInput | TempVoicesOrderByWithAggregationInput[]
    by: TempVoicesScalarFieldEnum[] | TempVoicesScalarFieldEnum
    having?: TempVoicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TempVoicesCountAggregateInputType | true
    _avg?: TempVoicesAvgAggregateInputType
    _sum?: TempVoicesSumAggregateInputType
    _min?: TempVoicesMinAggregateInputType
    _max?: TempVoicesMaxAggregateInputType
  }

  export type TempVoicesGroupByOutputType = {
    id: string
    UUID: string
    Name: string
    JointoCreateChannel: string
    JointoCreateCategory: string
    Manage: boolean
    PresetLimit: number
    GuildId: string
    _count: TempVoicesCountAggregateOutputType | null
    _avg: TempVoicesAvgAggregateOutputType | null
    _sum: TempVoicesSumAggregateOutputType | null
    _min: TempVoicesMinAggregateOutputType | null
    _max: TempVoicesMaxAggregateOutputType | null
  }

  type GetTempVoicesGroupByPayload<T extends TempVoicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TempVoicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TempVoicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TempVoicesGroupByOutputType[P]>
            : GetScalarType<T[P], TempVoicesGroupByOutputType[P]>
        }
      >
    >


  export type TempVoicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    UUID?: boolean
    Name?: boolean
    JointoCreateChannel?: boolean
    JointoCreateCategory?: boolean
    Manage?: boolean
    PresetLimit?: boolean
    GuildId?: boolean
    TempVoiceChannels?: boolean | TempVoices$TempVoiceChannelsArgs<ExtArgs>
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
    _count?: boolean | TempVoicesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tempVoices"]>



  export type TempVoicesSelectScalar = {
    id?: boolean
    UUID?: boolean
    Name?: boolean
    JointoCreateChannel?: boolean
    JointoCreateCategory?: boolean
    Manage?: boolean
    PresetLimit?: boolean
    GuildId?: boolean
  }

  export type TempVoicesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "UUID" | "Name" | "JointoCreateChannel" | "JointoCreateCategory" | "Manage" | "PresetLimit" | "GuildId", ExtArgs["result"]["tempVoices"]>
  export type TempVoicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TempVoiceChannels?: boolean | TempVoices$TempVoiceChannelsArgs<ExtArgs>
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
    _count?: boolean | TempVoicesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TempVoicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TempVoices"
    objects: {
      TempVoiceChannels: Prisma.$TempVoiceChannelsPayload<ExtArgs>[]
      Guilds: Prisma.$GuildsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      UUID: string
      Name: string
      JointoCreateChannel: string
      JointoCreateCategory: string
      Manage: boolean
      PresetLimit: number
      GuildId: string
    }, ExtArgs["result"]["tempVoices"]>
    composites: {}
  }

  type TempVoicesGetPayload<S extends boolean | null | undefined | TempVoicesDefaultArgs> = $Result.GetResult<Prisma.$TempVoicesPayload, S>

  type TempVoicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TempVoicesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TempVoicesCountAggregateInputType | true
    }

  export interface TempVoicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TempVoices'], meta: { name: 'TempVoices' } }
    /**
     * Find zero or one TempVoices that matches the filter.
     * @param {TempVoicesFindUniqueArgs} args - Arguments to find a TempVoices
     * @example
     * // Get one TempVoices
     * const tempVoices = await prisma.tempVoices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TempVoicesFindUniqueArgs>(args: SelectSubset<T, TempVoicesFindUniqueArgs<ExtArgs>>): Prisma__TempVoicesClient<$Result.GetResult<Prisma.$TempVoicesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TempVoices that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TempVoicesFindUniqueOrThrowArgs} args - Arguments to find a TempVoices
     * @example
     * // Get one TempVoices
     * const tempVoices = await prisma.tempVoices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TempVoicesFindUniqueOrThrowArgs>(args: SelectSubset<T, TempVoicesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TempVoicesClient<$Result.GetResult<Prisma.$TempVoicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TempVoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempVoicesFindFirstArgs} args - Arguments to find a TempVoices
     * @example
     * // Get one TempVoices
     * const tempVoices = await prisma.tempVoices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TempVoicesFindFirstArgs>(args?: SelectSubset<T, TempVoicesFindFirstArgs<ExtArgs>>): Prisma__TempVoicesClient<$Result.GetResult<Prisma.$TempVoicesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TempVoices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempVoicesFindFirstOrThrowArgs} args - Arguments to find a TempVoices
     * @example
     * // Get one TempVoices
     * const tempVoices = await prisma.tempVoices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TempVoicesFindFirstOrThrowArgs>(args?: SelectSubset<T, TempVoicesFindFirstOrThrowArgs<ExtArgs>>): Prisma__TempVoicesClient<$Result.GetResult<Prisma.$TempVoicesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TempVoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempVoicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TempVoices
     * const tempVoices = await prisma.tempVoices.findMany()
     * 
     * // Get first 10 TempVoices
     * const tempVoices = await prisma.tempVoices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tempVoicesWithIdOnly = await prisma.tempVoices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TempVoicesFindManyArgs>(args?: SelectSubset<T, TempVoicesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TempVoicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TempVoices.
     * @param {TempVoicesCreateArgs} args - Arguments to create a TempVoices.
     * @example
     * // Create one TempVoices
     * const TempVoices = await prisma.tempVoices.create({
     *   data: {
     *     // ... data to create a TempVoices
     *   }
     * })
     * 
     */
    create<T extends TempVoicesCreateArgs>(args: SelectSubset<T, TempVoicesCreateArgs<ExtArgs>>): Prisma__TempVoicesClient<$Result.GetResult<Prisma.$TempVoicesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TempVoices.
     * @param {TempVoicesCreateManyArgs} args - Arguments to create many TempVoices.
     * @example
     * // Create many TempVoices
     * const tempVoices = await prisma.tempVoices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TempVoicesCreateManyArgs>(args?: SelectSubset<T, TempVoicesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TempVoices.
     * @param {TempVoicesDeleteArgs} args - Arguments to delete one TempVoices.
     * @example
     * // Delete one TempVoices
     * const TempVoices = await prisma.tempVoices.delete({
     *   where: {
     *     // ... filter to delete one TempVoices
     *   }
     * })
     * 
     */
    delete<T extends TempVoicesDeleteArgs>(args: SelectSubset<T, TempVoicesDeleteArgs<ExtArgs>>): Prisma__TempVoicesClient<$Result.GetResult<Prisma.$TempVoicesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TempVoices.
     * @param {TempVoicesUpdateArgs} args - Arguments to update one TempVoices.
     * @example
     * // Update one TempVoices
     * const tempVoices = await prisma.tempVoices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TempVoicesUpdateArgs>(args: SelectSubset<T, TempVoicesUpdateArgs<ExtArgs>>): Prisma__TempVoicesClient<$Result.GetResult<Prisma.$TempVoicesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TempVoices.
     * @param {TempVoicesDeleteManyArgs} args - Arguments to filter TempVoices to delete.
     * @example
     * // Delete a few TempVoices
     * const { count } = await prisma.tempVoices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TempVoicesDeleteManyArgs>(args?: SelectSubset<T, TempVoicesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TempVoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempVoicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TempVoices
     * const tempVoices = await prisma.tempVoices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TempVoicesUpdateManyArgs>(args: SelectSubset<T, TempVoicesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TempVoices.
     * @param {TempVoicesUpsertArgs} args - Arguments to update or create a TempVoices.
     * @example
     * // Update or create a TempVoices
     * const tempVoices = await prisma.tempVoices.upsert({
     *   create: {
     *     // ... data to create a TempVoices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TempVoices we want to update
     *   }
     * })
     */
    upsert<T extends TempVoicesUpsertArgs>(args: SelectSubset<T, TempVoicesUpsertArgs<ExtArgs>>): Prisma__TempVoicesClient<$Result.GetResult<Prisma.$TempVoicesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TempVoices that matches the filter.
     * @param {TempVoicesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tempVoices = await prisma.tempVoices.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TempVoicesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TempVoices.
     * @param {TempVoicesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tempVoices = await prisma.tempVoices.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TempVoicesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TempVoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempVoicesCountArgs} args - Arguments to filter TempVoices to count.
     * @example
     * // Count the number of TempVoices
     * const count = await prisma.tempVoices.count({
     *   where: {
     *     // ... the filter for the TempVoices we want to count
     *   }
     * })
    **/
    count<T extends TempVoicesCountArgs>(
      args?: Subset<T, TempVoicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TempVoicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TempVoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempVoicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TempVoicesAggregateArgs>(args: Subset<T, TempVoicesAggregateArgs>): Prisma.PrismaPromise<GetTempVoicesAggregateType<T>>

    /**
     * Group by TempVoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempVoicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TempVoicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TempVoicesGroupByArgs['orderBy'] }
        : { orderBy?: TempVoicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TempVoicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTempVoicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TempVoices model
   */
  readonly fields: TempVoicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TempVoices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TempVoicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TempVoiceChannels<T extends TempVoices$TempVoiceChannelsArgs<ExtArgs> = {}>(args?: Subset<T, TempVoices$TempVoiceChannelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TempVoiceChannelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TempVoices model
   */
  interface TempVoicesFieldRefs {
    readonly id: FieldRef<"TempVoices", 'String'>
    readonly UUID: FieldRef<"TempVoices", 'String'>
    readonly Name: FieldRef<"TempVoices", 'String'>
    readonly JointoCreateChannel: FieldRef<"TempVoices", 'String'>
    readonly JointoCreateCategory: FieldRef<"TempVoices", 'String'>
    readonly Manage: FieldRef<"TempVoices", 'Boolean'>
    readonly PresetLimit: FieldRef<"TempVoices", 'Int'>
    readonly GuildId: FieldRef<"TempVoices", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TempVoices findUnique
   */
  export type TempVoicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempVoices
     */
    select?: TempVoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempVoices
     */
    omit?: TempVoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempVoicesInclude<ExtArgs> | null
    /**
     * Filter, which TempVoices to fetch.
     */
    where: TempVoicesWhereUniqueInput
  }

  /**
   * TempVoices findUniqueOrThrow
   */
  export type TempVoicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempVoices
     */
    select?: TempVoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempVoices
     */
    omit?: TempVoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempVoicesInclude<ExtArgs> | null
    /**
     * Filter, which TempVoices to fetch.
     */
    where: TempVoicesWhereUniqueInput
  }

  /**
   * TempVoices findFirst
   */
  export type TempVoicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempVoices
     */
    select?: TempVoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempVoices
     */
    omit?: TempVoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempVoicesInclude<ExtArgs> | null
    /**
     * Filter, which TempVoices to fetch.
     */
    where?: TempVoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TempVoices to fetch.
     */
    orderBy?: TempVoicesOrderByWithRelationInput | TempVoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TempVoices.
     */
    cursor?: TempVoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TempVoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TempVoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TempVoices.
     */
    distinct?: TempVoicesScalarFieldEnum | TempVoicesScalarFieldEnum[]
  }

  /**
   * TempVoices findFirstOrThrow
   */
  export type TempVoicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempVoices
     */
    select?: TempVoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempVoices
     */
    omit?: TempVoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempVoicesInclude<ExtArgs> | null
    /**
     * Filter, which TempVoices to fetch.
     */
    where?: TempVoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TempVoices to fetch.
     */
    orderBy?: TempVoicesOrderByWithRelationInput | TempVoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TempVoices.
     */
    cursor?: TempVoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TempVoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TempVoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TempVoices.
     */
    distinct?: TempVoicesScalarFieldEnum | TempVoicesScalarFieldEnum[]
  }

  /**
   * TempVoices findMany
   */
  export type TempVoicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempVoices
     */
    select?: TempVoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempVoices
     */
    omit?: TempVoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempVoicesInclude<ExtArgs> | null
    /**
     * Filter, which TempVoices to fetch.
     */
    where?: TempVoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TempVoices to fetch.
     */
    orderBy?: TempVoicesOrderByWithRelationInput | TempVoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TempVoices.
     */
    cursor?: TempVoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TempVoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TempVoices.
     */
    skip?: number
    distinct?: TempVoicesScalarFieldEnum | TempVoicesScalarFieldEnum[]
  }

  /**
   * TempVoices create
   */
  export type TempVoicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempVoices
     */
    select?: TempVoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempVoices
     */
    omit?: TempVoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempVoicesInclude<ExtArgs> | null
    /**
     * The data needed to create a TempVoices.
     */
    data: XOR<TempVoicesCreateInput, TempVoicesUncheckedCreateInput>
  }

  /**
   * TempVoices createMany
   */
  export type TempVoicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TempVoices.
     */
    data: TempVoicesCreateManyInput | TempVoicesCreateManyInput[]
  }

  /**
   * TempVoices update
   */
  export type TempVoicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempVoices
     */
    select?: TempVoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempVoices
     */
    omit?: TempVoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempVoicesInclude<ExtArgs> | null
    /**
     * The data needed to update a TempVoices.
     */
    data: XOR<TempVoicesUpdateInput, TempVoicesUncheckedUpdateInput>
    /**
     * Choose, which TempVoices to update.
     */
    where: TempVoicesWhereUniqueInput
  }

  /**
   * TempVoices updateMany
   */
  export type TempVoicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TempVoices.
     */
    data: XOR<TempVoicesUpdateManyMutationInput, TempVoicesUncheckedUpdateManyInput>
    /**
     * Filter which TempVoices to update
     */
    where?: TempVoicesWhereInput
    /**
     * Limit how many TempVoices to update.
     */
    limit?: number
  }

  /**
   * TempVoices upsert
   */
  export type TempVoicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempVoices
     */
    select?: TempVoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempVoices
     */
    omit?: TempVoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempVoicesInclude<ExtArgs> | null
    /**
     * The filter to search for the TempVoices to update in case it exists.
     */
    where: TempVoicesWhereUniqueInput
    /**
     * In case the TempVoices found by the `where` argument doesn't exist, create a new TempVoices with this data.
     */
    create: XOR<TempVoicesCreateInput, TempVoicesUncheckedCreateInput>
    /**
     * In case the TempVoices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TempVoicesUpdateInput, TempVoicesUncheckedUpdateInput>
  }

  /**
   * TempVoices delete
   */
  export type TempVoicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempVoices
     */
    select?: TempVoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempVoices
     */
    omit?: TempVoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempVoicesInclude<ExtArgs> | null
    /**
     * Filter which TempVoices to delete.
     */
    where: TempVoicesWhereUniqueInput
  }

  /**
   * TempVoices deleteMany
   */
  export type TempVoicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TempVoices to delete
     */
    where?: TempVoicesWhereInput
    /**
     * Limit how many TempVoices to delete.
     */
    limit?: number
  }

  /**
   * TempVoices findRaw
   */
  export type TempVoicesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TempVoices aggregateRaw
   */
  export type TempVoicesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TempVoices.TempVoiceChannels
   */
  export type TempVoices$TempVoiceChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempVoiceChannels
     */
    select?: TempVoiceChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempVoiceChannels
     */
    omit?: TempVoiceChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempVoiceChannelsInclude<ExtArgs> | null
    where?: TempVoiceChannelsWhereInput
    orderBy?: TempVoiceChannelsOrderByWithRelationInput | TempVoiceChannelsOrderByWithRelationInput[]
    cursor?: TempVoiceChannelsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TempVoiceChannelsScalarFieldEnum | TempVoiceChannelsScalarFieldEnum[]
  }

  /**
   * TempVoices without action
   */
  export type TempVoicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempVoices
     */
    select?: TempVoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempVoices
     */
    omit?: TempVoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempVoicesInclude<ExtArgs> | null
  }


  /**
   * Model TempVoiceChannels
   */

  export type AggregateTempVoiceChannels = {
    _count: TempVoiceChannelsCountAggregateOutputType | null
    _min: TempVoiceChannelsMinAggregateOutputType | null
    _max: TempVoiceChannelsMaxAggregateOutputType | null
  }

  export type TempVoiceChannelsMinAggregateOutputType = {
    id: string | null
    GuildId: string | null
    ChannelId: string | null
    OwnerId: string | null
    TempVoiceId: string | null
  }

  export type TempVoiceChannelsMaxAggregateOutputType = {
    id: string | null
    GuildId: string | null
    ChannelId: string | null
    OwnerId: string | null
    TempVoiceId: string | null
  }

  export type TempVoiceChannelsCountAggregateOutputType = {
    id: number
    GuildId: number
    ChannelId: number
    OwnerId: number
    TempVoiceId: number
    _all: number
  }


  export type TempVoiceChannelsMinAggregateInputType = {
    id?: true
    GuildId?: true
    ChannelId?: true
    OwnerId?: true
    TempVoiceId?: true
  }

  export type TempVoiceChannelsMaxAggregateInputType = {
    id?: true
    GuildId?: true
    ChannelId?: true
    OwnerId?: true
    TempVoiceId?: true
  }

  export type TempVoiceChannelsCountAggregateInputType = {
    id?: true
    GuildId?: true
    ChannelId?: true
    OwnerId?: true
    TempVoiceId?: true
    _all?: true
  }

  export type TempVoiceChannelsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TempVoiceChannels to aggregate.
     */
    where?: TempVoiceChannelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TempVoiceChannels to fetch.
     */
    orderBy?: TempVoiceChannelsOrderByWithRelationInput | TempVoiceChannelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TempVoiceChannelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TempVoiceChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TempVoiceChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TempVoiceChannels
    **/
    _count?: true | TempVoiceChannelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TempVoiceChannelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TempVoiceChannelsMaxAggregateInputType
  }

  export type GetTempVoiceChannelsAggregateType<T extends TempVoiceChannelsAggregateArgs> = {
        [P in keyof T & keyof AggregateTempVoiceChannels]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTempVoiceChannels[P]>
      : GetScalarType<T[P], AggregateTempVoiceChannels[P]>
  }




  export type TempVoiceChannelsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TempVoiceChannelsWhereInput
    orderBy?: TempVoiceChannelsOrderByWithAggregationInput | TempVoiceChannelsOrderByWithAggregationInput[]
    by: TempVoiceChannelsScalarFieldEnum[] | TempVoiceChannelsScalarFieldEnum
    having?: TempVoiceChannelsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TempVoiceChannelsCountAggregateInputType | true
    _min?: TempVoiceChannelsMinAggregateInputType
    _max?: TempVoiceChannelsMaxAggregateInputType
  }

  export type TempVoiceChannelsGroupByOutputType = {
    id: string
    GuildId: string
    ChannelId: string
    OwnerId: string
    TempVoiceId: string
    _count: TempVoiceChannelsCountAggregateOutputType | null
    _min: TempVoiceChannelsMinAggregateOutputType | null
    _max: TempVoiceChannelsMaxAggregateOutputType | null
  }

  type GetTempVoiceChannelsGroupByPayload<T extends TempVoiceChannelsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TempVoiceChannelsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TempVoiceChannelsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TempVoiceChannelsGroupByOutputType[P]>
            : GetScalarType<T[P], TempVoiceChannelsGroupByOutputType[P]>
        }
      >
    >


  export type TempVoiceChannelsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    GuildId?: boolean
    ChannelId?: boolean
    OwnerId?: boolean
    TempVoiceId?: boolean
    TempVoices?: boolean | TempVoicesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tempVoiceChannels"]>



  export type TempVoiceChannelsSelectScalar = {
    id?: boolean
    GuildId?: boolean
    ChannelId?: boolean
    OwnerId?: boolean
    TempVoiceId?: boolean
  }

  export type TempVoiceChannelsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "GuildId" | "ChannelId" | "OwnerId" | "TempVoiceId", ExtArgs["result"]["tempVoiceChannels"]>
  export type TempVoiceChannelsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TempVoices?: boolean | TempVoicesDefaultArgs<ExtArgs>
  }

  export type $TempVoiceChannelsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TempVoiceChannels"
    objects: {
      TempVoices: Prisma.$TempVoicesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      GuildId: string
      ChannelId: string
      OwnerId: string
      TempVoiceId: string
    }, ExtArgs["result"]["tempVoiceChannels"]>
    composites: {}
  }

  type TempVoiceChannelsGetPayload<S extends boolean | null | undefined | TempVoiceChannelsDefaultArgs> = $Result.GetResult<Prisma.$TempVoiceChannelsPayload, S>

  type TempVoiceChannelsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TempVoiceChannelsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TempVoiceChannelsCountAggregateInputType | true
    }

  export interface TempVoiceChannelsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TempVoiceChannels'], meta: { name: 'TempVoiceChannels' } }
    /**
     * Find zero or one TempVoiceChannels that matches the filter.
     * @param {TempVoiceChannelsFindUniqueArgs} args - Arguments to find a TempVoiceChannels
     * @example
     * // Get one TempVoiceChannels
     * const tempVoiceChannels = await prisma.tempVoiceChannels.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TempVoiceChannelsFindUniqueArgs>(args: SelectSubset<T, TempVoiceChannelsFindUniqueArgs<ExtArgs>>): Prisma__TempVoiceChannelsClient<$Result.GetResult<Prisma.$TempVoiceChannelsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TempVoiceChannels that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TempVoiceChannelsFindUniqueOrThrowArgs} args - Arguments to find a TempVoiceChannels
     * @example
     * // Get one TempVoiceChannels
     * const tempVoiceChannels = await prisma.tempVoiceChannels.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TempVoiceChannelsFindUniqueOrThrowArgs>(args: SelectSubset<T, TempVoiceChannelsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TempVoiceChannelsClient<$Result.GetResult<Prisma.$TempVoiceChannelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TempVoiceChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempVoiceChannelsFindFirstArgs} args - Arguments to find a TempVoiceChannels
     * @example
     * // Get one TempVoiceChannels
     * const tempVoiceChannels = await prisma.tempVoiceChannels.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TempVoiceChannelsFindFirstArgs>(args?: SelectSubset<T, TempVoiceChannelsFindFirstArgs<ExtArgs>>): Prisma__TempVoiceChannelsClient<$Result.GetResult<Prisma.$TempVoiceChannelsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TempVoiceChannels that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempVoiceChannelsFindFirstOrThrowArgs} args - Arguments to find a TempVoiceChannels
     * @example
     * // Get one TempVoiceChannels
     * const tempVoiceChannels = await prisma.tempVoiceChannels.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TempVoiceChannelsFindFirstOrThrowArgs>(args?: SelectSubset<T, TempVoiceChannelsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TempVoiceChannelsClient<$Result.GetResult<Prisma.$TempVoiceChannelsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TempVoiceChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempVoiceChannelsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TempVoiceChannels
     * const tempVoiceChannels = await prisma.tempVoiceChannels.findMany()
     * 
     * // Get first 10 TempVoiceChannels
     * const tempVoiceChannels = await prisma.tempVoiceChannels.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tempVoiceChannelsWithIdOnly = await prisma.tempVoiceChannels.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TempVoiceChannelsFindManyArgs>(args?: SelectSubset<T, TempVoiceChannelsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TempVoiceChannelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TempVoiceChannels.
     * @param {TempVoiceChannelsCreateArgs} args - Arguments to create a TempVoiceChannels.
     * @example
     * // Create one TempVoiceChannels
     * const TempVoiceChannels = await prisma.tempVoiceChannels.create({
     *   data: {
     *     // ... data to create a TempVoiceChannels
     *   }
     * })
     * 
     */
    create<T extends TempVoiceChannelsCreateArgs>(args: SelectSubset<T, TempVoiceChannelsCreateArgs<ExtArgs>>): Prisma__TempVoiceChannelsClient<$Result.GetResult<Prisma.$TempVoiceChannelsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TempVoiceChannels.
     * @param {TempVoiceChannelsCreateManyArgs} args - Arguments to create many TempVoiceChannels.
     * @example
     * // Create many TempVoiceChannels
     * const tempVoiceChannels = await prisma.tempVoiceChannels.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TempVoiceChannelsCreateManyArgs>(args?: SelectSubset<T, TempVoiceChannelsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TempVoiceChannels.
     * @param {TempVoiceChannelsDeleteArgs} args - Arguments to delete one TempVoiceChannels.
     * @example
     * // Delete one TempVoiceChannels
     * const TempVoiceChannels = await prisma.tempVoiceChannels.delete({
     *   where: {
     *     // ... filter to delete one TempVoiceChannels
     *   }
     * })
     * 
     */
    delete<T extends TempVoiceChannelsDeleteArgs>(args: SelectSubset<T, TempVoiceChannelsDeleteArgs<ExtArgs>>): Prisma__TempVoiceChannelsClient<$Result.GetResult<Prisma.$TempVoiceChannelsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TempVoiceChannels.
     * @param {TempVoiceChannelsUpdateArgs} args - Arguments to update one TempVoiceChannels.
     * @example
     * // Update one TempVoiceChannels
     * const tempVoiceChannels = await prisma.tempVoiceChannels.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TempVoiceChannelsUpdateArgs>(args: SelectSubset<T, TempVoiceChannelsUpdateArgs<ExtArgs>>): Prisma__TempVoiceChannelsClient<$Result.GetResult<Prisma.$TempVoiceChannelsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TempVoiceChannels.
     * @param {TempVoiceChannelsDeleteManyArgs} args - Arguments to filter TempVoiceChannels to delete.
     * @example
     * // Delete a few TempVoiceChannels
     * const { count } = await prisma.tempVoiceChannels.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TempVoiceChannelsDeleteManyArgs>(args?: SelectSubset<T, TempVoiceChannelsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TempVoiceChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempVoiceChannelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TempVoiceChannels
     * const tempVoiceChannels = await prisma.tempVoiceChannels.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TempVoiceChannelsUpdateManyArgs>(args: SelectSubset<T, TempVoiceChannelsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TempVoiceChannels.
     * @param {TempVoiceChannelsUpsertArgs} args - Arguments to update or create a TempVoiceChannels.
     * @example
     * // Update or create a TempVoiceChannels
     * const tempVoiceChannels = await prisma.tempVoiceChannels.upsert({
     *   create: {
     *     // ... data to create a TempVoiceChannels
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TempVoiceChannels we want to update
     *   }
     * })
     */
    upsert<T extends TempVoiceChannelsUpsertArgs>(args: SelectSubset<T, TempVoiceChannelsUpsertArgs<ExtArgs>>): Prisma__TempVoiceChannelsClient<$Result.GetResult<Prisma.$TempVoiceChannelsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TempVoiceChannels that matches the filter.
     * @param {TempVoiceChannelsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tempVoiceChannels = await prisma.tempVoiceChannels.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TempVoiceChannelsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TempVoiceChannels.
     * @param {TempVoiceChannelsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tempVoiceChannels = await prisma.tempVoiceChannels.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TempVoiceChannelsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TempVoiceChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempVoiceChannelsCountArgs} args - Arguments to filter TempVoiceChannels to count.
     * @example
     * // Count the number of TempVoiceChannels
     * const count = await prisma.tempVoiceChannels.count({
     *   where: {
     *     // ... the filter for the TempVoiceChannels we want to count
     *   }
     * })
    **/
    count<T extends TempVoiceChannelsCountArgs>(
      args?: Subset<T, TempVoiceChannelsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TempVoiceChannelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TempVoiceChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempVoiceChannelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TempVoiceChannelsAggregateArgs>(args: Subset<T, TempVoiceChannelsAggregateArgs>): Prisma.PrismaPromise<GetTempVoiceChannelsAggregateType<T>>

    /**
     * Group by TempVoiceChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempVoiceChannelsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TempVoiceChannelsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TempVoiceChannelsGroupByArgs['orderBy'] }
        : { orderBy?: TempVoiceChannelsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TempVoiceChannelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTempVoiceChannelsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TempVoiceChannels model
   */
  readonly fields: TempVoiceChannelsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TempVoiceChannels.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TempVoiceChannelsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TempVoices<T extends TempVoicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TempVoicesDefaultArgs<ExtArgs>>): Prisma__TempVoicesClient<$Result.GetResult<Prisma.$TempVoicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TempVoiceChannels model
   */
  interface TempVoiceChannelsFieldRefs {
    readonly id: FieldRef<"TempVoiceChannels", 'String'>
    readonly GuildId: FieldRef<"TempVoiceChannels", 'String'>
    readonly ChannelId: FieldRef<"TempVoiceChannels", 'String'>
    readonly OwnerId: FieldRef<"TempVoiceChannels", 'String'>
    readonly TempVoiceId: FieldRef<"TempVoiceChannels", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TempVoiceChannels findUnique
   */
  export type TempVoiceChannelsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempVoiceChannels
     */
    select?: TempVoiceChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempVoiceChannels
     */
    omit?: TempVoiceChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempVoiceChannelsInclude<ExtArgs> | null
    /**
     * Filter, which TempVoiceChannels to fetch.
     */
    where: TempVoiceChannelsWhereUniqueInput
  }

  /**
   * TempVoiceChannels findUniqueOrThrow
   */
  export type TempVoiceChannelsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempVoiceChannels
     */
    select?: TempVoiceChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempVoiceChannels
     */
    omit?: TempVoiceChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempVoiceChannelsInclude<ExtArgs> | null
    /**
     * Filter, which TempVoiceChannels to fetch.
     */
    where: TempVoiceChannelsWhereUniqueInput
  }

  /**
   * TempVoiceChannels findFirst
   */
  export type TempVoiceChannelsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempVoiceChannels
     */
    select?: TempVoiceChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempVoiceChannels
     */
    omit?: TempVoiceChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempVoiceChannelsInclude<ExtArgs> | null
    /**
     * Filter, which TempVoiceChannels to fetch.
     */
    where?: TempVoiceChannelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TempVoiceChannels to fetch.
     */
    orderBy?: TempVoiceChannelsOrderByWithRelationInput | TempVoiceChannelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TempVoiceChannels.
     */
    cursor?: TempVoiceChannelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TempVoiceChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TempVoiceChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TempVoiceChannels.
     */
    distinct?: TempVoiceChannelsScalarFieldEnum | TempVoiceChannelsScalarFieldEnum[]
  }

  /**
   * TempVoiceChannels findFirstOrThrow
   */
  export type TempVoiceChannelsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempVoiceChannels
     */
    select?: TempVoiceChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempVoiceChannels
     */
    omit?: TempVoiceChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempVoiceChannelsInclude<ExtArgs> | null
    /**
     * Filter, which TempVoiceChannels to fetch.
     */
    where?: TempVoiceChannelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TempVoiceChannels to fetch.
     */
    orderBy?: TempVoiceChannelsOrderByWithRelationInput | TempVoiceChannelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TempVoiceChannels.
     */
    cursor?: TempVoiceChannelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TempVoiceChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TempVoiceChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TempVoiceChannels.
     */
    distinct?: TempVoiceChannelsScalarFieldEnum | TempVoiceChannelsScalarFieldEnum[]
  }

  /**
   * TempVoiceChannels findMany
   */
  export type TempVoiceChannelsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempVoiceChannels
     */
    select?: TempVoiceChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempVoiceChannels
     */
    omit?: TempVoiceChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempVoiceChannelsInclude<ExtArgs> | null
    /**
     * Filter, which TempVoiceChannels to fetch.
     */
    where?: TempVoiceChannelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TempVoiceChannels to fetch.
     */
    orderBy?: TempVoiceChannelsOrderByWithRelationInput | TempVoiceChannelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TempVoiceChannels.
     */
    cursor?: TempVoiceChannelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TempVoiceChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TempVoiceChannels.
     */
    skip?: number
    distinct?: TempVoiceChannelsScalarFieldEnum | TempVoiceChannelsScalarFieldEnum[]
  }

  /**
   * TempVoiceChannels create
   */
  export type TempVoiceChannelsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempVoiceChannels
     */
    select?: TempVoiceChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempVoiceChannels
     */
    omit?: TempVoiceChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempVoiceChannelsInclude<ExtArgs> | null
    /**
     * The data needed to create a TempVoiceChannels.
     */
    data: XOR<TempVoiceChannelsCreateInput, TempVoiceChannelsUncheckedCreateInput>
  }

  /**
   * TempVoiceChannels createMany
   */
  export type TempVoiceChannelsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TempVoiceChannels.
     */
    data: TempVoiceChannelsCreateManyInput | TempVoiceChannelsCreateManyInput[]
  }

  /**
   * TempVoiceChannels update
   */
  export type TempVoiceChannelsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempVoiceChannels
     */
    select?: TempVoiceChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempVoiceChannels
     */
    omit?: TempVoiceChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempVoiceChannelsInclude<ExtArgs> | null
    /**
     * The data needed to update a TempVoiceChannels.
     */
    data: XOR<TempVoiceChannelsUpdateInput, TempVoiceChannelsUncheckedUpdateInput>
    /**
     * Choose, which TempVoiceChannels to update.
     */
    where: TempVoiceChannelsWhereUniqueInput
  }

  /**
   * TempVoiceChannels updateMany
   */
  export type TempVoiceChannelsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TempVoiceChannels.
     */
    data: XOR<TempVoiceChannelsUpdateManyMutationInput, TempVoiceChannelsUncheckedUpdateManyInput>
    /**
     * Filter which TempVoiceChannels to update
     */
    where?: TempVoiceChannelsWhereInput
    /**
     * Limit how many TempVoiceChannels to update.
     */
    limit?: number
  }

  /**
   * TempVoiceChannels upsert
   */
  export type TempVoiceChannelsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempVoiceChannels
     */
    select?: TempVoiceChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempVoiceChannels
     */
    omit?: TempVoiceChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempVoiceChannelsInclude<ExtArgs> | null
    /**
     * The filter to search for the TempVoiceChannels to update in case it exists.
     */
    where: TempVoiceChannelsWhereUniqueInput
    /**
     * In case the TempVoiceChannels found by the `where` argument doesn't exist, create a new TempVoiceChannels with this data.
     */
    create: XOR<TempVoiceChannelsCreateInput, TempVoiceChannelsUncheckedCreateInput>
    /**
     * In case the TempVoiceChannels was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TempVoiceChannelsUpdateInput, TempVoiceChannelsUncheckedUpdateInput>
  }

  /**
   * TempVoiceChannels delete
   */
  export type TempVoiceChannelsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempVoiceChannels
     */
    select?: TempVoiceChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempVoiceChannels
     */
    omit?: TempVoiceChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempVoiceChannelsInclude<ExtArgs> | null
    /**
     * Filter which TempVoiceChannels to delete.
     */
    where: TempVoiceChannelsWhereUniqueInput
  }

  /**
   * TempVoiceChannels deleteMany
   */
  export type TempVoiceChannelsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TempVoiceChannels to delete
     */
    where?: TempVoiceChannelsWhereInput
    /**
     * Limit how many TempVoiceChannels to delete.
     */
    limit?: number
  }

  /**
   * TempVoiceChannels findRaw
   */
  export type TempVoiceChannelsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TempVoiceChannels aggregateRaw
   */
  export type TempVoiceChannelsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TempVoiceChannels without action
   */
  export type TempVoiceChannelsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempVoiceChannels
     */
    select?: TempVoiceChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempVoiceChannels
     */
    omit?: TempVoiceChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempVoiceChannelsInclude<ExtArgs> | null
  }


  /**
   * Model GuildLeaveSetups
   */

  export type AggregateGuildLeaveSetups = {
    _count: GuildLeaveSetupsCountAggregateOutputType | null
    _min: GuildLeaveSetupsMinAggregateOutputType | null
    _max: GuildLeaveSetupsMaxAggregateOutputType | null
  }

  export type GuildLeaveSetupsMinAggregateOutputType = {
    id: string | null
    MessageTemplateId: string | null
    ChannelId: string | null
    Image: boolean | null
    GuildId: string | null
  }

  export type GuildLeaveSetupsMaxAggregateOutputType = {
    id: string | null
    MessageTemplateId: string | null
    ChannelId: string | null
    Image: boolean | null
    GuildId: string | null
  }

  export type GuildLeaveSetupsCountAggregateOutputType = {
    id: number
    MessageTemplateId: number
    ChannelId: number
    Image: number
    GuildId: number
    _all: number
  }


  export type GuildLeaveSetupsMinAggregateInputType = {
    id?: true
    MessageTemplateId?: true
    ChannelId?: true
    Image?: true
    GuildId?: true
  }

  export type GuildLeaveSetupsMaxAggregateInputType = {
    id?: true
    MessageTemplateId?: true
    ChannelId?: true
    Image?: true
    GuildId?: true
  }

  export type GuildLeaveSetupsCountAggregateInputType = {
    id?: true
    MessageTemplateId?: true
    ChannelId?: true
    Image?: true
    GuildId?: true
    _all?: true
  }

  export type GuildLeaveSetupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildLeaveSetups to aggregate.
     */
    where?: GuildLeaveSetupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildLeaveSetups to fetch.
     */
    orderBy?: GuildLeaveSetupsOrderByWithRelationInput | GuildLeaveSetupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuildLeaveSetupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildLeaveSetups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildLeaveSetups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuildLeaveSetups
    **/
    _count?: true | GuildLeaveSetupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildLeaveSetupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildLeaveSetupsMaxAggregateInputType
  }

  export type GetGuildLeaveSetupsAggregateType<T extends GuildLeaveSetupsAggregateArgs> = {
        [P in keyof T & keyof AggregateGuildLeaveSetups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuildLeaveSetups[P]>
      : GetScalarType<T[P], AggregateGuildLeaveSetups[P]>
  }




  export type GuildLeaveSetupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildLeaveSetupsWhereInput
    orderBy?: GuildLeaveSetupsOrderByWithAggregationInput | GuildLeaveSetupsOrderByWithAggregationInput[]
    by: GuildLeaveSetupsScalarFieldEnum[] | GuildLeaveSetupsScalarFieldEnum
    having?: GuildLeaveSetupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildLeaveSetupsCountAggregateInputType | true
    _min?: GuildLeaveSetupsMinAggregateInputType
    _max?: GuildLeaveSetupsMaxAggregateInputType
  }

  export type GuildLeaveSetupsGroupByOutputType = {
    id: string
    MessageTemplateId: string | null
    ChannelId: string
    Image: boolean | null
    GuildId: string
    _count: GuildLeaveSetupsCountAggregateOutputType | null
    _min: GuildLeaveSetupsMinAggregateOutputType | null
    _max: GuildLeaveSetupsMaxAggregateOutputType | null
  }

  type GetGuildLeaveSetupsGroupByPayload<T extends GuildLeaveSetupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildLeaveSetupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildLeaveSetupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildLeaveSetupsGroupByOutputType[P]>
            : GetScalarType<T[P], GuildLeaveSetupsGroupByOutputType[P]>
        }
      >
    >


  export type GuildLeaveSetupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    MessageTemplateId?: boolean
    ChannelId?: boolean
    Image?: boolean
    ImageData?: boolean | WelcomeLeaveImageDataDefaultArgs<ExtArgs>
    GuildId?: boolean
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guildLeaveSetups"]>



  export type GuildLeaveSetupsSelectScalar = {
    id?: boolean
    MessageTemplateId?: boolean
    ChannelId?: boolean
    Image?: boolean
    GuildId?: boolean
  }

  export type GuildLeaveSetupsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "MessageTemplateId" | "ChannelId" | "Image" | "ImageData" | "GuildId", ExtArgs["result"]["guildLeaveSetups"]>
  export type GuildLeaveSetupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }

  export type $GuildLeaveSetupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GuildLeaveSetups"
    objects: {
      Guilds: Prisma.$GuildsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      MessageTemplateId: string | null
      ChannelId: string
      Image: boolean | null
      GuildId: string
    }, ExtArgs["result"]["guildLeaveSetups"]>
    composites: {
      ImageData: Prisma.$WelcomeLeaveImageDataPayload | null
    }
  }

  type GuildLeaveSetupsGetPayload<S extends boolean | null | undefined | GuildLeaveSetupsDefaultArgs> = $Result.GetResult<Prisma.$GuildLeaveSetupsPayload, S>

  type GuildLeaveSetupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuildLeaveSetupsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuildLeaveSetupsCountAggregateInputType | true
    }

  export interface GuildLeaveSetupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GuildLeaveSetups'], meta: { name: 'GuildLeaveSetups' } }
    /**
     * Find zero or one GuildLeaveSetups that matches the filter.
     * @param {GuildLeaveSetupsFindUniqueArgs} args - Arguments to find a GuildLeaveSetups
     * @example
     * // Get one GuildLeaveSetups
     * const guildLeaveSetups = await prisma.guildLeaveSetups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuildLeaveSetupsFindUniqueArgs>(args: SelectSubset<T, GuildLeaveSetupsFindUniqueArgs<ExtArgs>>): Prisma__GuildLeaveSetupsClient<$Result.GetResult<Prisma.$GuildLeaveSetupsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GuildLeaveSetups that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuildLeaveSetupsFindUniqueOrThrowArgs} args - Arguments to find a GuildLeaveSetups
     * @example
     * // Get one GuildLeaveSetups
     * const guildLeaveSetups = await prisma.guildLeaveSetups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuildLeaveSetupsFindUniqueOrThrowArgs>(args: SelectSubset<T, GuildLeaveSetupsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuildLeaveSetupsClient<$Result.GetResult<Prisma.$GuildLeaveSetupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuildLeaveSetups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildLeaveSetupsFindFirstArgs} args - Arguments to find a GuildLeaveSetups
     * @example
     * // Get one GuildLeaveSetups
     * const guildLeaveSetups = await prisma.guildLeaveSetups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuildLeaveSetupsFindFirstArgs>(args?: SelectSubset<T, GuildLeaveSetupsFindFirstArgs<ExtArgs>>): Prisma__GuildLeaveSetupsClient<$Result.GetResult<Prisma.$GuildLeaveSetupsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuildLeaveSetups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildLeaveSetupsFindFirstOrThrowArgs} args - Arguments to find a GuildLeaveSetups
     * @example
     * // Get one GuildLeaveSetups
     * const guildLeaveSetups = await prisma.guildLeaveSetups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuildLeaveSetupsFindFirstOrThrowArgs>(args?: SelectSubset<T, GuildLeaveSetupsFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuildLeaveSetupsClient<$Result.GetResult<Prisma.$GuildLeaveSetupsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuildLeaveSetups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildLeaveSetupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuildLeaveSetups
     * const guildLeaveSetups = await prisma.guildLeaveSetups.findMany()
     * 
     * // Get first 10 GuildLeaveSetups
     * const guildLeaveSetups = await prisma.guildLeaveSetups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildLeaveSetupsWithIdOnly = await prisma.guildLeaveSetups.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuildLeaveSetupsFindManyArgs>(args?: SelectSubset<T, GuildLeaveSetupsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildLeaveSetupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GuildLeaveSetups.
     * @param {GuildLeaveSetupsCreateArgs} args - Arguments to create a GuildLeaveSetups.
     * @example
     * // Create one GuildLeaveSetups
     * const GuildLeaveSetups = await prisma.guildLeaveSetups.create({
     *   data: {
     *     // ... data to create a GuildLeaveSetups
     *   }
     * })
     * 
     */
    create<T extends GuildLeaveSetupsCreateArgs>(args: SelectSubset<T, GuildLeaveSetupsCreateArgs<ExtArgs>>): Prisma__GuildLeaveSetupsClient<$Result.GetResult<Prisma.$GuildLeaveSetupsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GuildLeaveSetups.
     * @param {GuildLeaveSetupsCreateManyArgs} args - Arguments to create many GuildLeaveSetups.
     * @example
     * // Create many GuildLeaveSetups
     * const guildLeaveSetups = await prisma.guildLeaveSetups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuildLeaveSetupsCreateManyArgs>(args?: SelectSubset<T, GuildLeaveSetupsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GuildLeaveSetups.
     * @param {GuildLeaveSetupsDeleteArgs} args - Arguments to delete one GuildLeaveSetups.
     * @example
     * // Delete one GuildLeaveSetups
     * const GuildLeaveSetups = await prisma.guildLeaveSetups.delete({
     *   where: {
     *     // ... filter to delete one GuildLeaveSetups
     *   }
     * })
     * 
     */
    delete<T extends GuildLeaveSetupsDeleteArgs>(args: SelectSubset<T, GuildLeaveSetupsDeleteArgs<ExtArgs>>): Prisma__GuildLeaveSetupsClient<$Result.GetResult<Prisma.$GuildLeaveSetupsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GuildLeaveSetups.
     * @param {GuildLeaveSetupsUpdateArgs} args - Arguments to update one GuildLeaveSetups.
     * @example
     * // Update one GuildLeaveSetups
     * const guildLeaveSetups = await prisma.guildLeaveSetups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuildLeaveSetupsUpdateArgs>(args: SelectSubset<T, GuildLeaveSetupsUpdateArgs<ExtArgs>>): Prisma__GuildLeaveSetupsClient<$Result.GetResult<Prisma.$GuildLeaveSetupsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GuildLeaveSetups.
     * @param {GuildLeaveSetupsDeleteManyArgs} args - Arguments to filter GuildLeaveSetups to delete.
     * @example
     * // Delete a few GuildLeaveSetups
     * const { count } = await prisma.guildLeaveSetups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuildLeaveSetupsDeleteManyArgs>(args?: SelectSubset<T, GuildLeaveSetupsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuildLeaveSetups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildLeaveSetupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuildLeaveSetups
     * const guildLeaveSetups = await prisma.guildLeaveSetups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuildLeaveSetupsUpdateManyArgs>(args: SelectSubset<T, GuildLeaveSetupsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GuildLeaveSetups.
     * @param {GuildLeaveSetupsUpsertArgs} args - Arguments to update or create a GuildLeaveSetups.
     * @example
     * // Update or create a GuildLeaveSetups
     * const guildLeaveSetups = await prisma.guildLeaveSetups.upsert({
     *   create: {
     *     // ... data to create a GuildLeaveSetups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuildLeaveSetups we want to update
     *   }
     * })
     */
    upsert<T extends GuildLeaveSetupsUpsertArgs>(args: SelectSubset<T, GuildLeaveSetupsUpsertArgs<ExtArgs>>): Prisma__GuildLeaveSetupsClient<$Result.GetResult<Prisma.$GuildLeaveSetupsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuildLeaveSetups that matches the filter.
     * @param {GuildLeaveSetupsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const guildLeaveSetups = await prisma.guildLeaveSetups.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: GuildLeaveSetupsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a GuildLeaveSetups.
     * @param {GuildLeaveSetupsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const guildLeaveSetups = await prisma.guildLeaveSetups.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: GuildLeaveSetupsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of GuildLeaveSetups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildLeaveSetupsCountArgs} args - Arguments to filter GuildLeaveSetups to count.
     * @example
     * // Count the number of GuildLeaveSetups
     * const count = await prisma.guildLeaveSetups.count({
     *   where: {
     *     // ... the filter for the GuildLeaveSetups we want to count
     *   }
     * })
    **/
    count<T extends GuildLeaveSetupsCountArgs>(
      args?: Subset<T, GuildLeaveSetupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildLeaveSetupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuildLeaveSetups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildLeaveSetupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildLeaveSetupsAggregateArgs>(args: Subset<T, GuildLeaveSetupsAggregateArgs>): Prisma.PrismaPromise<GetGuildLeaveSetupsAggregateType<T>>

    /**
     * Group by GuildLeaveSetups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildLeaveSetupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildLeaveSetupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildLeaveSetupsGroupByArgs['orderBy'] }
        : { orderBy?: GuildLeaveSetupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildLeaveSetupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildLeaveSetupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GuildLeaveSetups model
   */
  readonly fields: GuildLeaveSetupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuildLeaveSetups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuildLeaveSetupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GuildLeaveSetups model
   */
  interface GuildLeaveSetupsFieldRefs {
    readonly id: FieldRef<"GuildLeaveSetups", 'String'>
    readonly MessageTemplateId: FieldRef<"GuildLeaveSetups", 'String'>
    readonly ChannelId: FieldRef<"GuildLeaveSetups", 'String'>
    readonly Image: FieldRef<"GuildLeaveSetups", 'Boolean'>
    readonly GuildId: FieldRef<"GuildLeaveSetups", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GuildLeaveSetups findUnique
   */
  export type GuildLeaveSetupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLeaveSetups
     */
    select?: GuildLeaveSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLeaveSetups
     */
    omit?: GuildLeaveSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLeaveSetupsInclude<ExtArgs> | null
    /**
     * Filter, which GuildLeaveSetups to fetch.
     */
    where: GuildLeaveSetupsWhereUniqueInput
  }

  /**
   * GuildLeaveSetups findUniqueOrThrow
   */
  export type GuildLeaveSetupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLeaveSetups
     */
    select?: GuildLeaveSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLeaveSetups
     */
    omit?: GuildLeaveSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLeaveSetupsInclude<ExtArgs> | null
    /**
     * Filter, which GuildLeaveSetups to fetch.
     */
    where: GuildLeaveSetupsWhereUniqueInput
  }

  /**
   * GuildLeaveSetups findFirst
   */
  export type GuildLeaveSetupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLeaveSetups
     */
    select?: GuildLeaveSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLeaveSetups
     */
    omit?: GuildLeaveSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLeaveSetupsInclude<ExtArgs> | null
    /**
     * Filter, which GuildLeaveSetups to fetch.
     */
    where?: GuildLeaveSetupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildLeaveSetups to fetch.
     */
    orderBy?: GuildLeaveSetupsOrderByWithRelationInput | GuildLeaveSetupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildLeaveSetups.
     */
    cursor?: GuildLeaveSetupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildLeaveSetups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildLeaveSetups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildLeaveSetups.
     */
    distinct?: GuildLeaveSetupsScalarFieldEnum | GuildLeaveSetupsScalarFieldEnum[]
  }

  /**
   * GuildLeaveSetups findFirstOrThrow
   */
  export type GuildLeaveSetupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLeaveSetups
     */
    select?: GuildLeaveSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLeaveSetups
     */
    omit?: GuildLeaveSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLeaveSetupsInclude<ExtArgs> | null
    /**
     * Filter, which GuildLeaveSetups to fetch.
     */
    where?: GuildLeaveSetupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildLeaveSetups to fetch.
     */
    orderBy?: GuildLeaveSetupsOrderByWithRelationInput | GuildLeaveSetupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildLeaveSetups.
     */
    cursor?: GuildLeaveSetupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildLeaveSetups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildLeaveSetups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildLeaveSetups.
     */
    distinct?: GuildLeaveSetupsScalarFieldEnum | GuildLeaveSetupsScalarFieldEnum[]
  }

  /**
   * GuildLeaveSetups findMany
   */
  export type GuildLeaveSetupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLeaveSetups
     */
    select?: GuildLeaveSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLeaveSetups
     */
    omit?: GuildLeaveSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLeaveSetupsInclude<ExtArgs> | null
    /**
     * Filter, which GuildLeaveSetups to fetch.
     */
    where?: GuildLeaveSetupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildLeaveSetups to fetch.
     */
    orderBy?: GuildLeaveSetupsOrderByWithRelationInput | GuildLeaveSetupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuildLeaveSetups.
     */
    cursor?: GuildLeaveSetupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildLeaveSetups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildLeaveSetups.
     */
    skip?: number
    distinct?: GuildLeaveSetupsScalarFieldEnum | GuildLeaveSetupsScalarFieldEnum[]
  }

  /**
   * GuildLeaveSetups create
   */
  export type GuildLeaveSetupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLeaveSetups
     */
    select?: GuildLeaveSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLeaveSetups
     */
    omit?: GuildLeaveSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLeaveSetupsInclude<ExtArgs> | null
    /**
     * The data needed to create a GuildLeaveSetups.
     */
    data: XOR<GuildLeaveSetupsCreateInput, GuildLeaveSetupsUncheckedCreateInput>
  }

  /**
   * GuildLeaveSetups createMany
   */
  export type GuildLeaveSetupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GuildLeaveSetups.
     */
    data: GuildLeaveSetupsCreateManyInput | GuildLeaveSetupsCreateManyInput[]
  }

  /**
   * GuildLeaveSetups update
   */
  export type GuildLeaveSetupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLeaveSetups
     */
    select?: GuildLeaveSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLeaveSetups
     */
    omit?: GuildLeaveSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLeaveSetupsInclude<ExtArgs> | null
    /**
     * The data needed to update a GuildLeaveSetups.
     */
    data: XOR<GuildLeaveSetupsUpdateInput, GuildLeaveSetupsUncheckedUpdateInput>
    /**
     * Choose, which GuildLeaveSetups to update.
     */
    where: GuildLeaveSetupsWhereUniqueInput
  }

  /**
   * GuildLeaveSetups updateMany
   */
  export type GuildLeaveSetupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GuildLeaveSetups.
     */
    data: XOR<GuildLeaveSetupsUpdateManyMutationInput, GuildLeaveSetupsUncheckedUpdateManyInput>
    /**
     * Filter which GuildLeaveSetups to update
     */
    where?: GuildLeaveSetupsWhereInput
    /**
     * Limit how many GuildLeaveSetups to update.
     */
    limit?: number
  }

  /**
   * GuildLeaveSetups upsert
   */
  export type GuildLeaveSetupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLeaveSetups
     */
    select?: GuildLeaveSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLeaveSetups
     */
    omit?: GuildLeaveSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLeaveSetupsInclude<ExtArgs> | null
    /**
     * The filter to search for the GuildLeaveSetups to update in case it exists.
     */
    where: GuildLeaveSetupsWhereUniqueInput
    /**
     * In case the GuildLeaveSetups found by the `where` argument doesn't exist, create a new GuildLeaveSetups with this data.
     */
    create: XOR<GuildLeaveSetupsCreateInput, GuildLeaveSetupsUncheckedCreateInput>
    /**
     * In case the GuildLeaveSetups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuildLeaveSetupsUpdateInput, GuildLeaveSetupsUncheckedUpdateInput>
  }

  /**
   * GuildLeaveSetups delete
   */
  export type GuildLeaveSetupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLeaveSetups
     */
    select?: GuildLeaveSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLeaveSetups
     */
    omit?: GuildLeaveSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLeaveSetupsInclude<ExtArgs> | null
    /**
     * Filter which GuildLeaveSetups to delete.
     */
    where: GuildLeaveSetupsWhereUniqueInput
  }

  /**
   * GuildLeaveSetups deleteMany
   */
  export type GuildLeaveSetupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildLeaveSetups to delete
     */
    where?: GuildLeaveSetupsWhereInput
    /**
     * Limit how many GuildLeaveSetups to delete.
     */
    limit?: number
  }

  /**
   * GuildLeaveSetups findRaw
   */
  export type GuildLeaveSetupsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GuildLeaveSetups aggregateRaw
   */
  export type GuildLeaveSetupsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GuildLeaveSetups without action
   */
  export type GuildLeaveSetupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLeaveSetups
     */
    select?: GuildLeaveSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLeaveSetups
     */
    omit?: GuildLeaveSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLeaveSetupsInclude<ExtArgs> | null
  }


  /**
   * Model GuildWelcomeSetups
   */

  export type AggregateGuildWelcomeSetups = {
    _count: GuildWelcomeSetupsCountAggregateOutputType | null
    _min: GuildWelcomeSetupsMinAggregateOutputType | null
    _max: GuildWelcomeSetupsMaxAggregateOutputType | null
  }

  export type GuildWelcomeSetupsMinAggregateOutputType = {
    id: string | null
    MessageTemplateId: string | null
    ChannelId: string | null
    Image: boolean | null
    GuildId: string | null
  }

  export type GuildWelcomeSetupsMaxAggregateOutputType = {
    id: string | null
    MessageTemplateId: string | null
    ChannelId: string | null
    Image: boolean | null
    GuildId: string | null
  }

  export type GuildWelcomeSetupsCountAggregateOutputType = {
    id: number
    MessageTemplateId: number
    ChannelId: number
    Image: number
    GuildId: number
    _all: number
  }


  export type GuildWelcomeSetupsMinAggregateInputType = {
    id?: true
    MessageTemplateId?: true
    ChannelId?: true
    Image?: true
    GuildId?: true
  }

  export type GuildWelcomeSetupsMaxAggregateInputType = {
    id?: true
    MessageTemplateId?: true
    ChannelId?: true
    Image?: true
    GuildId?: true
  }

  export type GuildWelcomeSetupsCountAggregateInputType = {
    id?: true
    MessageTemplateId?: true
    ChannelId?: true
    Image?: true
    GuildId?: true
    _all?: true
  }

  export type GuildWelcomeSetupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildWelcomeSetups to aggregate.
     */
    where?: GuildWelcomeSetupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildWelcomeSetups to fetch.
     */
    orderBy?: GuildWelcomeSetupsOrderByWithRelationInput | GuildWelcomeSetupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuildWelcomeSetupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildWelcomeSetups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildWelcomeSetups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuildWelcomeSetups
    **/
    _count?: true | GuildWelcomeSetupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildWelcomeSetupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildWelcomeSetupsMaxAggregateInputType
  }

  export type GetGuildWelcomeSetupsAggregateType<T extends GuildWelcomeSetupsAggregateArgs> = {
        [P in keyof T & keyof AggregateGuildWelcomeSetups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuildWelcomeSetups[P]>
      : GetScalarType<T[P], AggregateGuildWelcomeSetups[P]>
  }




  export type GuildWelcomeSetupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildWelcomeSetupsWhereInput
    orderBy?: GuildWelcomeSetupsOrderByWithAggregationInput | GuildWelcomeSetupsOrderByWithAggregationInput[]
    by: GuildWelcomeSetupsScalarFieldEnum[] | GuildWelcomeSetupsScalarFieldEnum
    having?: GuildWelcomeSetupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildWelcomeSetupsCountAggregateInputType | true
    _min?: GuildWelcomeSetupsMinAggregateInputType
    _max?: GuildWelcomeSetupsMaxAggregateInputType
  }

  export type GuildWelcomeSetupsGroupByOutputType = {
    id: string
    MessageTemplateId: string
    ChannelId: string
    Image: boolean
    GuildId: string
    _count: GuildWelcomeSetupsCountAggregateOutputType | null
    _min: GuildWelcomeSetupsMinAggregateOutputType | null
    _max: GuildWelcomeSetupsMaxAggregateOutputType | null
  }

  type GetGuildWelcomeSetupsGroupByPayload<T extends GuildWelcomeSetupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildWelcomeSetupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildWelcomeSetupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildWelcomeSetupsGroupByOutputType[P]>
            : GetScalarType<T[P], GuildWelcomeSetupsGroupByOutputType[P]>
        }
      >
    >


  export type GuildWelcomeSetupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    MessageTemplateId?: boolean
    ChannelId?: boolean
    Image?: boolean
    ImageData?: boolean | WelcomeLeaveImageDataDefaultArgs<ExtArgs>
    GuildId?: boolean
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guildWelcomeSetups"]>



  export type GuildWelcomeSetupsSelectScalar = {
    id?: boolean
    MessageTemplateId?: boolean
    ChannelId?: boolean
    Image?: boolean
    GuildId?: boolean
  }

  export type GuildWelcomeSetupsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "MessageTemplateId" | "ChannelId" | "Image" | "ImageData" | "GuildId", ExtArgs["result"]["guildWelcomeSetups"]>
  export type GuildWelcomeSetupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }

  export type $GuildWelcomeSetupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GuildWelcomeSetups"
    objects: {
      Guilds: Prisma.$GuildsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      MessageTemplateId: string
      ChannelId: string
      Image: boolean
      GuildId: string
    }, ExtArgs["result"]["guildWelcomeSetups"]>
    composites: {
      ImageData: Prisma.$WelcomeLeaveImageDataPayload
    }
  }

  type GuildWelcomeSetupsGetPayload<S extends boolean | null | undefined | GuildWelcomeSetupsDefaultArgs> = $Result.GetResult<Prisma.$GuildWelcomeSetupsPayload, S>

  type GuildWelcomeSetupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuildWelcomeSetupsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuildWelcomeSetupsCountAggregateInputType | true
    }

  export interface GuildWelcomeSetupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GuildWelcomeSetups'], meta: { name: 'GuildWelcomeSetups' } }
    /**
     * Find zero or one GuildWelcomeSetups that matches the filter.
     * @param {GuildWelcomeSetupsFindUniqueArgs} args - Arguments to find a GuildWelcomeSetups
     * @example
     * // Get one GuildWelcomeSetups
     * const guildWelcomeSetups = await prisma.guildWelcomeSetups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuildWelcomeSetupsFindUniqueArgs>(args: SelectSubset<T, GuildWelcomeSetupsFindUniqueArgs<ExtArgs>>): Prisma__GuildWelcomeSetupsClient<$Result.GetResult<Prisma.$GuildWelcomeSetupsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GuildWelcomeSetups that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuildWelcomeSetupsFindUniqueOrThrowArgs} args - Arguments to find a GuildWelcomeSetups
     * @example
     * // Get one GuildWelcomeSetups
     * const guildWelcomeSetups = await prisma.guildWelcomeSetups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuildWelcomeSetupsFindUniqueOrThrowArgs>(args: SelectSubset<T, GuildWelcomeSetupsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuildWelcomeSetupsClient<$Result.GetResult<Prisma.$GuildWelcomeSetupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuildWelcomeSetups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildWelcomeSetupsFindFirstArgs} args - Arguments to find a GuildWelcomeSetups
     * @example
     * // Get one GuildWelcomeSetups
     * const guildWelcomeSetups = await prisma.guildWelcomeSetups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuildWelcomeSetupsFindFirstArgs>(args?: SelectSubset<T, GuildWelcomeSetupsFindFirstArgs<ExtArgs>>): Prisma__GuildWelcomeSetupsClient<$Result.GetResult<Prisma.$GuildWelcomeSetupsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuildWelcomeSetups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildWelcomeSetupsFindFirstOrThrowArgs} args - Arguments to find a GuildWelcomeSetups
     * @example
     * // Get one GuildWelcomeSetups
     * const guildWelcomeSetups = await prisma.guildWelcomeSetups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuildWelcomeSetupsFindFirstOrThrowArgs>(args?: SelectSubset<T, GuildWelcomeSetupsFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuildWelcomeSetupsClient<$Result.GetResult<Prisma.$GuildWelcomeSetupsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuildWelcomeSetups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildWelcomeSetupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuildWelcomeSetups
     * const guildWelcomeSetups = await prisma.guildWelcomeSetups.findMany()
     * 
     * // Get first 10 GuildWelcomeSetups
     * const guildWelcomeSetups = await prisma.guildWelcomeSetups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildWelcomeSetupsWithIdOnly = await prisma.guildWelcomeSetups.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuildWelcomeSetupsFindManyArgs>(args?: SelectSubset<T, GuildWelcomeSetupsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildWelcomeSetupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GuildWelcomeSetups.
     * @param {GuildWelcomeSetupsCreateArgs} args - Arguments to create a GuildWelcomeSetups.
     * @example
     * // Create one GuildWelcomeSetups
     * const GuildWelcomeSetups = await prisma.guildWelcomeSetups.create({
     *   data: {
     *     // ... data to create a GuildWelcomeSetups
     *   }
     * })
     * 
     */
    create<T extends GuildWelcomeSetupsCreateArgs>(args: SelectSubset<T, GuildWelcomeSetupsCreateArgs<ExtArgs>>): Prisma__GuildWelcomeSetupsClient<$Result.GetResult<Prisma.$GuildWelcomeSetupsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GuildWelcomeSetups.
     * @param {GuildWelcomeSetupsCreateManyArgs} args - Arguments to create many GuildWelcomeSetups.
     * @example
     * // Create many GuildWelcomeSetups
     * const guildWelcomeSetups = await prisma.guildWelcomeSetups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuildWelcomeSetupsCreateManyArgs>(args?: SelectSubset<T, GuildWelcomeSetupsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GuildWelcomeSetups.
     * @param {GuildWelcomeSetupsDeleteArgs} args - Arguments to delete one GuildWelcomeSetups.
     * @example
     * // Delete one GuildWelcomeSetups
     * const GuildWelcomeSetups = await prisma.guildWelcomeSetups.delete({
     *   where: {
     *     // ... filter to delete one GuildWelcomeSetups
     *   }
     * })
     * 
     */
    delete<T extends GuildWelcomeSetupsDeleteArgs>(args: SelectSubset<T, GuildWelcomeSetupsDeleteArgs<ExtArgs>>): Prisma__GuildWelcomeSetupsClient<$Result.GetResult<Prisma.$GuildWelcomeSetupsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GuildWelcomeSetups.
     * @param {GuildWelcomeSetupsUpdateArgs} args - Arguments to update one GuildWelcomeSetups.
     * @example
     * // Update one GuildWelcomeSetups
     * const guildWelcomeSetups = await prisma.guildWelcomeSetups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuildWelcomeSetupsUpdateArgs>(args: SelectSubset<T, GuildWelcomeSetupsUpdateArgs<ExtArgs>>): Prisma__GuildWelcomeSetupsClient<$Result.GetResult<Prisma.$GuildWelcomeSetupsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GuildWelcomeSetups.
     * @param {GuildWelcomeSetupsDeleteManyArgs} args - Arguments to filter GuildWelcomeSetups to delete.
     * @example
     * // Delete a few GuildWelcomeSetups
     * const { count } = await prisma.guildWelcomeSetups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuildWelcomeSetupsDeleteManyArgs>(args?: SelectSubset<T, GuildWelcomeSetupsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuildWelcomeSetups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildWelcomeSetupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuildWelcomeSetups
     * const guildWelcomeSetups = await prisma.guildWelcomeSetups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuildWelcomeSetupsUpdateManyArgs>(args: SelectSubset<T, GuildWelcomeSetupsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GuildWelcomeSetups.
     * @param {GuildWelcomeSetupsUpsertArgs} args - Arguments to update or create a GuildWelcomeSetups.
     * @example
     * // Update or create a GuildWelcomeSetups
     * const guildWelcomeSetups = await prisma.guildWelcomeSetups.upsert({
     *   create: {
     *     // ... data to create a GuildWelcomeSetups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuildWelcomeSetups we want to update
     *   }
     * })
     */
    upsert<T extends GuildWelcomeSetupsUpsertArgs>(args: SelectSubset<T, GuildWelcomeSetupsUpsertArgs<ExtArgs>>): Prisma__GuildWelcomeSetupsClient<$Result.GetResult<Prisma.$GuildWelcomeSetupsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuildWelcomeSetups that matches the filter.
     * @param {GuildWelcomeSetupsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const guildWelcomeSetups = await prisma.guildWelcomeSetups.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: GuildWelcomeSetupsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a GuildWelcomeSetups.
     * @param {GuildWelcomeSetupsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const guildWelcomeSetups = await prisma.guildWelcomeSetups.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: GuildWelcomeSetupsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of GuildWelcomeSetups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildWelcomeSetupsCountArgs} args - Arguments to filter GuildWelcomeSetups to count.
     * @example
     * // Count the number of GuildWelcomeSetups
     * const count = await prisma.guildWelcomeSetups.count({
     *   where: {
     *     // ... the filter for the GuildWelcomeSetups we want to count
     *   }
     * })
    **/
    count<T extends GuildWelcomeSetupsCountArgs>(
      args?: Subset<T, GuildWelcomeSetupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildWelcomeSetupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuildWelcomeSetups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildWelcomeSetupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildWelcomeSetupsAggregateArgs>(args: Subset<T, GuildWelcomeSetupsAggregateArgs>): Prisma.PrismaPromise<GetGuildWelcomeSetupsAggregateType<T>>

    /**
     * Group by GuildWelcomeSetups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildWelcomeSetupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildWelcomeSetupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildWelcomeSetupsGroupByArgs['orderBy'] }
        : { orderBy?: GuildWelcomeSetupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildWelcomeSetupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildWelcomeSetupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GuildWelcomeSetups model
   */
  readonly fields: GuildWelcomeSetupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuildWelcomeSetups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuildWelcomeSetupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GuildWelcomeSetups model
   */
  interface GuildWelcomeSetupsFieldRefs {
    readonly id: FieldRef<"GuildWelcomeSetups", 'String'>
    readonly MessageTemplateId: FieldRef<"GuildWelcomeSetups", 'String'>
    readonly ChannelId: FieldRef<"GuildWelcomeSetups", 'String'>
    readonly Image: FieldRef<"GuildWelcomeSetups", 'Boolean'>
    readonly GuildId: FieldRef<"GuildWelcomeSetups", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GuildWelcomeSetups findUnique
   */
  export type GuildWelcomeSetupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildWelcomeSetups
     */
    select?: GuildWelcomeSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildWelcomeSetups
     */
    omit?: GuildWelcomeSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildWelcomeSetupsInclude<ExtArgs> | null
    /**
     * Filter, which GuildWelcomeSetups to fetch.
     */
    where: GuildWelcomeSetupsWhereUniqueInput
  }

  /**
   * GuildWelcomeSetups findUniqueOrThrow
   */
  export type GuildWelcomeSetupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildWelcomeSetups
     */
    select?: GuildWelcomeSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildWelcomeSetups
     */
    omit?: GuildWelcomeSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildWelcomeSetupsInclude<ExtArgs> | null
    /**
     * Filter, which GuildWelcomeSetups to fetch.
     */
    where: GuildWelcomeSetupsWhereUniqueInput
  }

  /**
   * GuildWelcomeSetups findFirst
   */
  export type GuildWelcomeSetupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildWelcomeSetups
     */
    select?: GuildWelcomeSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildWelcomeSetups
     */
    omit?: GuildWelcomeSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildWelcomeSetupsInclude<ExtArgs> | null
    /**
     * Filter, which GuildWelcomeSetups to fetch.
     */
    where?: GuildWelcomeSetupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildWelcomeSetups to fetch.
     */
    orderBy?: GuildWelcomeSetupsOrderByWithRelationInput | GuildWelcomeSetupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildWelcomeSetups.
     */
    cursor?: GuildWelcomeSetupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildWelcomeSetups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildWelcomeSetups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildWelcomeSetups.
     */
    distinct?: GuildWelcomeSetupsScalarFieldEnum | GuildWelcomeSetupsScalarFieldEnum[]
  }

  /**
   * GuildWelcomeSetups findFirstOrThrow
   */
  export type GuildWelcomeSetupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildWelcomeSetups
     */
    select?: GuildWelcomeSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildWelcomeSetups
     */
    omit?: GuildWelcomeSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildWelcomeSetupsInclude<ExtArgs> | null
    /**
     * Filter, which GuildWelcomeSetups to fetch.
     */
    where?: GuildWelcomeSetupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildWelcomeSetups to fetch.
     */
    orderBy?: GuildWelcomeSetupsOrderByWithRelationInput | GuildWelcomeSetupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildWelcomeSetups.
     */
    cursor?: GuildWelcomeSetupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildWelcomeSetups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildWelcomeSetups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildWelcomeSetups.
     */
    distinct?: GuildWelcomeSetupsScalarFieldEnum | GuildWelcomeSetupsScalarFieldEnum[]
  }

  /**
   * GuildWelcomeSetups findMany
   */
  export type GuildWelcomeSetupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildWelcomeSetups
     */
    select?: GuildWelcomeSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildWelcomeSetups
     */
    omit?: GuildWelcomeSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildWelcomeSetupsInclude<ExtArgs> | null
    /**
     * Filter, which GuildWelcomeSetups to fetch.
     */
    where?: GuildWelcomeSetupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildWelcomeSetups to fetch.
     */
    orderBy?: GuildWelcomeSetupsOrderByWithRelationInput | GuildWelcomeSetupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuildWelcomeSetups.
     */
    cursor?: GuildWelcomeSetupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildWelcomeSetups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildWelcomeSetups.
     */
    skip?: number
    distinct?: GuildWelcomeSetupsScalarFieldEnum | GuildWelcomeSetupsScalarFieldEnum[]
  }

  /**
   * GuildWelcomeSetups create
   */
  export type GuildWelcomeSetupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildWelcomeSetups
     */
    select?: GuildWelcomeSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildWelcomeSetups
     */
    omit?: GuildWelcomeSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildWelcomeSetupsInclude<ExtArgs> | null
    /**
     * The data needed to create a GuildWelcomeSetups.
     */
    data: XOR<GuildWelcomeSetupsCreateInput, GuildWelcomeSetupsUncheckedCreateInput>
  }

  /**
   * GuildWelcomeSetups createMany
   */
  export type GuildWelcomeSetupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GuildWelcomeSetups.
     */
    data: GuildWelcomeSetupsCreateManyInput | GuildWelcomeSetupsCreateManyInput[]
  }

  /**
   * GuildWelcomeSetups update
   */
  export type GuildWelcomeSetupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildWelcomeSetups
     */
    select?: GuildWelcomeSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildWelcomeSetups
     */
    omit?: GuildWelcomeSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildWelcomeSetupsInclude<ExtArgs> | null
    /**
     * The data needed to update a GuildWelcomeSetups.
     */
    data: XOR<GuildWelcomeSetupsUpdateInput, GuildWelcomeSetupsUncheckedUpdateInput>
    /**
     * Choose, which GuildWelcomeSetups to update.
     */
    where: GuildWelcomeSetupsWhereUniqueInput
  }

  /**
   * GuildWelcomeSetups updateMany
   */
  export type GuildWelcomeSetupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GuildWelcomeSetups.
     */
    data: XOR<GuildWelcomeSetupsUpdateManyMutationInput, GuildWelcomeSetupsUncheckedUpdateManyInput>
    /**
     * Filter which GuildWelcomeSetups to update
     */
    where?: GuildWelcomeSetupsWhereInput
    /**
     * Limit how many GuildWelcomeSetups to update.
     */
    limit?: number
  }

  /**
   * GuildWelcomeSetups upsert
   */
  export type GuildWelcomeSetupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildWelcomeSetups
     */
    select?: GuildWelcomeSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildWelcomeSetups
     */
    omit?: GuildWelcomeSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildWelcomeSetupsInclude<ExtArgs> | null
    /**
     * The filter to search for the GuildWelcomeSetups to update in case it exists.
     */
    where: GuildWelcomeSetupsWhereUniqueInput
    /**
     * In case the GuildWelcomeSetups found by the `where` argument doesn't exist, create a new GuildWelcomeSetups with this data.
     */
    create: XOR<GuildWelcomeSetupsCreateInput, GuildWelcomeSetupsUncheckedCreateInput>
    /**
     * In case the GuildWelcomeSetups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuildWelcomeSetupsUpdateInput, GuildWelcomeSetupsUncheckedUpdateInput>
  }

  /**
   * GuildWelcomeSetups delete
   */
  export type GuildWelcomeSetupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildWelcomeSetups
     */
    select?: GuildWelcomeSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildWelcomeSetups
     */
    omit?: GuildWelcomeSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildWelcomeSetupsInclude<ExtArgs> | null
    /**
     * Filter which GuildWelcomeSetups to delete.
     */
    where: GuildWelcomeSetupsWhereUniqueInput
  }

  /**
   * GuildWelcomeSetups deleteMany
   */
  export type GuildWelcomeSetupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildWelcomeSetups to delete
     */
    where?: GuildWelcomeSetupsWhereInput
    /**
     * Limit how many GuildWelcomeSetups to delete.
     */
    limit?: number
  }

  /**
   * GuildWelcomeSetups findRaw
   */
  export type GuildWelcomeSetupsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GuildWelcomeSetups aggregateRaw
   */
  export type GuildWelcomeSetupsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GuildWelcomeSetups without action
   */
  export type GuildWelcomeSetupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildWelcomeSetups
     */
    select?: GuildWelcomeSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildWelcomeSetups
     */
    omit?: GuildWelcomeSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildWelcomeSetupsInclude<ExtArgs> | null
  }


  /**
   * Model GuildLoggings
   */

  export type AggregateGuildLoggings = {
    _count: GuildLoggingsCountAggregateOutputType | null
    _min: GuildLoggingsMinAggregateOutputType | null
    _max: GuildLoggingsMaxAggregateOutputType | null
  }

  export type GuildLoggingsMinAggregateOutputType = {
    id: string | null
    AutoMod: string | null
    Channel: string | null
    Emoji: string | null
    Guild: string | null
    Integration: string | null
    Invite: string | null
    Member: string | null
    Message: string | null
    Moderation: string | null
    Reaction: string | null
    Role: string | null
    SoundBoard: string | null
    Sticker: string | null
    Thread: string | null
    Voice: string | null
    Webhook: string | null
    Ban: string | null
    Kick: string | null
    Poll: string | null
    Stage: string | null
    Event: string | null
    GuildId: string | null
  }

  export type GuildLoggingsMaxAggregateOutputType = {
    id: string | null
    AutoMod: string | null
    Channel: string | null
    Emoji: string | null
    Guild: string | null
    Integration: string | null
    Invite: string | null
    Member: string | null
    Message: string | null
    Moderation: string | null
    Reaction: string | null
    Role: string | null
    SoundBoard: string | null
    Sticker: string | null
    Thread: string | null
    Voice: string | null
    Webhook: string | null
    Ban: string | null
    Kick: string | null
    Poll: string | null
    Stage: string | null
    Event: string | null
    GuildId: string | null
  }

  export type GuildLoggingsCountAggregateOutputType = {
    id: number
    AutoMod: number
    Channel: number
    Emoji: number
    Guild: number
    Integration: number
    Invite: number
    Member: number
    Message: number
    Moderation: number
    Reaction: number
    Role: number
    SoundBoard: number
    Sticker: number
    Thread: number
    Voice: number
    Webhook: number
    Ban: number
    Kick: number
    Poll: number
    Stage: number
    Event: number
    GuildId: number
    _all: number
  }


  export type GuildLoggingsMinAggregateInputType = {
    id?: true
    AutoMod?: true
    Channel?: true
    Emoji?: true
    Guild?: true
    Integration?: true
    Invite?: true
    Member?: true
    Message?: true
    Moderation?: true
    Reaction?: true
    Role?: true
    SoundBoard?: true
    Sticker?: true
    Thread?: true
    Voice?: true
    Webhook?: true
    Ban?: true
    Kick?: true
    Poll?: true
    Stage?: true
    Event?: true
    GuildId?: true
  }

  export type GuildLoggingsMaxAggregateInputType = {
    id?: true
    AutoMod?: true
    Channel?: true
    Emoji?: true
    Guild?: true
    Integration?: true
    Invite?: true
    Member?: true
    Message?: true
    Moderation?: true
    Reaction?: true
    Role?: true
    SoundBoard?: true
    Sticker?: true
    Thread?: true
    Voice?: true
    Webhook?: true
    Ban?: true
    Kick?: true
    Poll?: true
    Stage?: true
    Event?: true
    GuildId?: true
  }

  export type GuildLoggingsCountAggregateInputType = {
    id?: true
    AutoMod?: true
    Channel?: true
    Emoji?: true
    Guild?: true
    Integration?: true
    Invite?: true
    Member?: true
    Message?: true
    Moderation?: true
    Reaction?: true
    Role?: true
    SoundBoard?: true
    Sticker?: true
    Thread?: true
    Voice?: true
    Webhook?: true
    Ban?: true
    Kick?: true
    Poll?: true
    Stage?: true
    Event?: true
    GuildId?: true
    _all?: true
  }

  export type GuildLoggingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildLoggings to aggregate.
     */
    where?: GuildLoggingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildLoggings to fetch.
     */
    orderBy?: GuildLoggingsOrderByWithRelationInput | GuildLoggingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuildLoggingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildLoggings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildLoggings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuildLoggings
    **/
    _count?: true | GuildLoggingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildLoggingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildLoggingsMaxAggregateInputType
  }

  export type GetGuildLoggingsAggregateType<T extends GuildLoggingsAggregateArgs> = {
        [P in keyof T & keyof AggregateGuildLoggings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuildLoggings[P]>
      : GetScalarType<T[P], AggregateGuildLoggings[P]>
  }




  export type GuildLoggingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildLoggingsWhereInput
    orderBy?: GuildLoggingsOrderByWithAggregationInput | GuildLoggingsOrderByWithAggregationInput[]
    by: GuildLoggingsScalarFieldEnum[] | GuildLoggingsScalarFieldEnum
    having?: GuildLoggingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildLoggingsCountAggregateInputType | true
    _min?: GuildLoggingsMinAggregateInputType
    _max?: GuildLoggingsMaxAggregateInputType
  }

  export type GuildLoggingsGroupByOutputType = {
    id: string
    AutoMod: string | null
    Channel: string | null
    Emoji: string | null
    Guild: string | null
    Integration: string | null
    Invite: string | null
    Member: string | null
    Message: string | null
    Moderation: string | null
    Reaction: string | null
    Role: string | null
    SoundBoard: string | null
    Sticker: string | null
    Thread: string | null
    Voice: string | null
    Webhook: string | null
    Ban: string | null
    Kick: string | null
    Poll: string | null
    Stage: string | null
    Event: string | null
    GuildId: string
    _count: GuildLoggingsCountAggregateOutputType | null
    _min: GuildLoggingsMinAggregateOutputType | null
    _max: GuildLoggingsMaxAggregateOutputType | null
  }

  type GetGuildLoggingsGroupByPayload<T extends GuildLoggingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildLoggingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildLoggingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildLoggingsGroupByOutputType[P]>
            : GetScalarType<T[P], GuildLoggingsGroupByOutputType[P]>
        }
      >
    >


  export type GuildLoggingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    AutoMod?: boolean
    Channel?: boolean
    Emoji?: boolean
    Guild?: boolean
    Integration?: boolean
    Invite?: boolean
    Member?: boolean
    Message?: boolean
    Moderation?: boolean
    Reaction?: boolean
    Role?: boolean
    SoundBoard?: boolean
    Sticker?: boolean
    Thread?: boolean
    Voice?: boolean
    Webhook?: boolean
    Ban?: boolean
    Kick?: boolean
    Poll?: boolean
    Stage?: boolean
    Event?: boolean
    GuildId?: boolean
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guildLoggings"]>



  export type GuildLoggingsSelectScalar = {
    id?: boolean
    AutoMod?: boolean
    Channel?: boolean
    Emoji?: boolean
    Guild?: boolean
    Integration?: boolean
    Invite?: boolean
    Member?: boolean
    Message?: boolean
    Moderation?: boolean
    Reaction?: boolean
    Role?: boolean
    SoundBoard?: boolean
    Sticker?: boolean
    Thread?: boolean
    Voice?: boolean
    Webhook?: boolean
    Ban?: boolean
    Kick?: boolean
    Poll?: boolean
    Stage?: boolean
    Event?: boolean
    GuildId?: boolean
  }

  export type GuildLoggingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "AutoMod" | "Channel" | "Emoji" | "Guild" | "Integration" | "Invite" | "Member" | "Message" | "Moderation" | "Reaction" | "Role" | "SoundBoard" | "Sticker" | "Thread" | "Voice" | "Webhook" | "Ban" | "Kick" | "Poll" | "Stage" | "Event" | "GuildId", ExtArgs["result"]["guildLoggings"]>
  export type GuildLoggingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }

  export type $GuildLoggingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GuildLoggings"
    objects: {
      Guilds: Prisma.$GuildsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      AutoMod: string | null
      Channel: string | null
      Emoji: string | null
      Guild: string | null
      Integration: string | null
      Invite: string | null
      Member: string | null
      Message: string | null
      Moderation: string | null
      Reaction: string | null
      Role: string | null
      SoundBoard: string | null
      Sticker: string | null
      Thread: string | null
      Voice: string | null
      Webhook: string | null
      Ban: string | null
      Kick: string | null
      Poll: string | null
      Stage: string | null
      Event: string | null
      GuildId: string
    }, ExtArgs["result"]["guildLoggings"]>
    composites: {}
  }

  type GuildLoggingsGetPayload<S extends boolean | null | undefined | GuildLoggingsDefaultArgs> = $Result.GetResult<Prisma.$GuildLoggingsPayload, S>

  type GuildLoggingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuildLoggingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuildLoggingsCountAggregateInputType | true
    }

  export interface GuildLoggingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GuildLoggings'], meta: { name: 'GuildLoggings' } }
    /**
     * Find zero or one GuildLoggings that matches the filter.
     * @param {GuildLoggingsFindUniqueArgs} args - Arguments to find a GuildLoggings
     * @example
     * // Get one GuildLoggings
     * const guildLoggings = await prisma.guildLoggings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuildLoggingsFindUniqueArgs>(args: SelectSubset<T, GuildLoggingsFindUniqueArgs<ExtArgs>>): Prisma__GuildLoggingsClient<$Result.GetResult<Prisma.$GuildLoggingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GuildLoggings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuildLoggingsFindUniqueOrThrowArgs} args - Arguments to find a GuildLoggings
     * @example
     * // Get one GuildLoggings
     * const guildLoggings = await prisma.guildLoggings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuildLoggingsFindUniqueOrThrowArgs>(args: SelectSubset<T, GuildLoggingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuildLoggingsClient<$Result.GetResult<Prisma.$GuildLoggingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuildLoggings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildLoggingsFindFirstArgs} args - Arguments to find a GuildLoggings
     * @example
     * // Get one GuildLoggings
     * const guildLoggings = await prisma.guildLoggings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuildLoggingsFindFirstArgs>(args?: SelectSubset<T, GuildLoggingsFindFirstArgs<ExtArgs>>): Prisma__GuildLoggingsClient<$Result.GetResult<Prisma.$GuildLoggingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuildLoggings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildLoggingsFindFirstOrThrowArgs} args - Arguments to find a GuildLoggings
     * @example
     * // Get one GuildLoggings
     * const guildLoggings = await prisma.guildLoggings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuildLoggingsFindFirstOrThrowArgs>(args?: SelectSubset<T, GuildLoggingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuildLoggingsClient<$Result.GetResult<Prisma.$GuildLoggingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuildLoggings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildLoggingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuildLoggings
     * const guildLoggings = await prisma.guildLoggings.findMany()
     * 
     * // Get first 10 GuildLoggings
     * const guildLoggings = await prisma.guildLoggings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildLoggingsWithIdOnly = await prisma.guildLoggings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuildLoggingsFindManyArgs>(args?: SelectSubset<T, GuildLoggingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildLoggingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GuildLoggings.
     * @param {GuildLoggingsCreateArgs} args - Arguments to create a GuildLoggings.
     * @example
     * // Create one GuildLoggings
     * const GuildLoggings = await prisma.guildLoggings.create({
     *   data: {
     *     // ... data to create a GuildLoggings
     *   }
     * })
     * 
     */
    create<T extends GuildLoggingsCreateArgs>(args: SelectSubset<T, GuildLoggingsCreateArgs<ExtArgs>>): Prisma__GuildLoggingsClient<$Result.GetResult<Prisma.$GuildLoggingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GuildLoggings.
     * @param {GuildLoggingsCreateManyArgs} args - Arguments to create many GuildLoggings.
     * @example
     * // Create many GuildLoggings
     * const guildLoggings = await prisma.guildLoggings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuildLoggingsCreateManyArgs>(args?: SelectSubset<T, GuildLoggingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GuildLoggings.
     * @param {GuildLoggingsDeleteArgs} args - Arguments to delete one GuildLoggings.
     * @example
     * // Delete one GuildLoggings
     * const GuildLoggings = await prisma.guildLoggings.delete({
     *   where: {
     *     // ... filter to delete one GuildLoggings
     *   }
     * })
     * 
     */
    delete<T extends GuildLoggingsDeleteArgs>(args: SelectSubset<T, GuildLoggingsDeleteArgs<ExtArgs>>): Prisma__GuildLoggingsClient<$Result.GetResult<Prisma.$GuildLoggingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GuildLoggings.
     * @param {GuildLoggingsUpdateArgs} args - Arguments to update one GuildLoggings.
     * @example
     * // Update one GuildLoggings
     * const guildLoggings = await prisma.guildLoggings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuildLoggingsUpdateArgs>(args: SelectSubset<T, GuildLoggingsUpdateArgs<ExtArgs>>): Prisma__GuildLoggingsClient<$Result.GetResult<Prisma.$GuildLoggingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GuildLoggings.
     * @param {GuildLoggingsDeleteManyArgs} args - Arguments to filter GuildLoggings to delete.
     * @example
     * // Delete a few GuildLoggings
     * const { count } = await prisma.guildLoggings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuildLoggingsDeleteManyArgs>(args?: SelectSubset<T, GuildLoggingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuildLoggings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildLoggingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuildLoggings
     * const guildLoggings = await prisma.guildLoggings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuildLoggingsUpdateManyArgs>(args: SelectSubset<T, GuildLoggingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GuildLoggings.
     * @param {GuildLoggingsUpsertArgs} args - Arguments to update or create a GuildLoggings.
     * @example
     * // Update or create a GuildLoggings
     * const guildLoggings = await prisma.guildLoggings.upsert({
     *   create: {
     *     // ... data to create a GuildLoggings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuildLoggings we want to update
     *   }
     * })
     */
    upsert<T extends GuildLoggingsUpsertArgs>(args: SelectSubset<T, GuildLoggingsUpsertArgs<ExtArgs>>): Prisma__GuildLoggingsClient<$Result.GetResult<Prisma.$GuildLoggingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuildLoggings that matches the filter.
     * @param {GuildLoggingsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const guildLoggings = await prisma.guildLoggings.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: GuildLoggingsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a GuildLoggings.
     * @param {GuildLoggingsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const guildLoggings = await prisma.guildLoggings.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: GuildLoggingsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of GuildLoggings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildLoggingsCountArgs} args - Arguments to filter GuildLoggings to count.
     * @example
     * // Count the number of GuildLoggings
     * const count = await prisma.guildLoggings.count({
     *   where: {
     *     // ... the filter for the GuildLoggings we want to count
     *   }
     * })
    **/
    count<T extends GuildLoggingsCountArgs>(
      args?: Subset<T, GuildLoggingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildLoggingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuildLoggings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildLoggingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildLoggingsAggregateArgs>(args: Subset<T, GuildLoggingsAggregateArgs>): Prisma.PrismaPromise<GetGuildLoggingsAggregateType<T>>

    /**
     * Group by GuildLoggings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildLoggingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildLoggingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildLoggingsGroupByArgs['orderBy'] }
        : { orderBy?: GuildLoggingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildLoggingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildLoggingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GuildLoggings model
   */
  readonly fields: GuildLoggingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuildLoggings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuildLoggingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GuildLoggings model
   */
  interface GuildLoggingsFieldRefs {
    readonly id: FieldRef<"GuildLoggings", 'String'>
    readonly AutoMod: FieldRef<"GuildLoggings", 'String'>
    readonly Channel: FieldRef<"GuildLoggings", 'String'>
    readonly Emoji: FieldRef<"GuildLoggings", 'String'>
    readonly Guild: FieldRef<"GuildLoggings", 'String'>
    readonly Integration: FieldRef<"GuildLoggings", 'String'>
    readonly Invite: FieldRef<"GuildLoggings", 'String'>
    readonly Member: FieldRef<"GuildLoggings", 'String'>
    readonly Message: FieldRef<"GuildLoggings", 'String'>
    readonly Moderation: FieldRef<"GuildLoggings", 'String'>
    readonly Reaction: FieldRef<"GuildLoggings", 'String'>
    readonly Role: FieldRef<"GuildLoggings", 'String'>
    readonly SoundBoard: FieldRef<"GuildLoggings", 'String'>
    readonly Sticker: FieldRef<"GuildLoggings", 'String'>
    readonly Thread: FieldRef<"GuildLoggings", 'String'>
    readonly Voice: FieldRef<"GuildLoggings", 'String'>
    readonly Webhook: FieldRef<"GuildLoggings", 'String'>
    readonly Ban: FieldRef<"GuildLoggings", 'String'>
    readonly Kick: FieldRef<"GuildLoggings", 'String'>
    readonly Poll: FieldRef<"GuildLoggings", 'String'>
    readonly Stage: FieldRef<"GuildLoggings", 'String'>
    readonly Event: FieldRef<"GuildLoggings", 'String'>
    readonly GuildId: FieldRef<"GuildLoggings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GuildLoggings findUnique
   */
  export type GuildLoggingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLoggings
     */
    select?: GuildLoggingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLoggings
     */
    omit?: GuildLoggingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLoggingsInclude<ExtArgs> | null
    /**
     * Filter, which GuildLoggings to fetch.
     */
    where: GuildLoggingsWhereUniqueInput
  }

  /**
   * GuildLoggings findUniqueOrThrow
   */
  export type GuildLoggingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLoggings
     */
    select?: GuildLoggingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLoggings
     */
    omit?: GuildLoggingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLoggingsInclude<ExtArgs> | null
    /**
     * Filter, which GuildLoggings to fetch.
     */
    where: GuildLoggingsWhereUniqueInput
  }

  /**
   * GuildLoggings findFirst
   */
  export type GuildLoggingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLoggings
     */
    select?: GuildLoggingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLoggings
     */
    omit?: GuildLoggingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLoggingsInclude<ExtArgs> | null
    /**
     * Filter, which GuildLoggings to fetch.
     */
    where?: GuildLoggingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildLoggings to fetch.
     */
    orderBy?: GuildLoggingsOrderByWithRelationInput | GuildLoggingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildLoggings.
     */
    cursor?: GuildLoggingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildLoggings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildLoggings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildLoggings.
     */
    distinct?: GuildLoggingsScalarFieldEnum | GuildLoggingsScalarFieldEnum[]
  }

  /**
   * GuildLoggings findFirstOrThrow
   */
  export type GuildLoggingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLoggings
     */
    select?: GuildLoggingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLoggings
     */
    omit?: GuildLoggingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLoggingsInclude<ExtArgs> | null
    /**
     * Filter, which GuildLoggings to fetch.
     */
    where?: GuildLoggingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildLoggings to fetch.
     */
    orderBy?: GuildLoggingsOrderByWithRelationInput | GuildLoggingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildLoggings.
     */
    cursor?: GuildLoggingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildLoggings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildLoggings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildLoggings.
     */
    distinct?: GuildLoggingsScalarFieldEnum | GuildLoggingsScalarFieldEnum[]
  }

  /**
   * GuildLoggings findMany
   */
  export type GuildLoggingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLoggings
     */
    select?: GuildLoggingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLoggings
     */
    omit?: GuildLoggingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLoggingsInclude<ExtArgs> | null
    /**
     * Filter, which GuildLoggings to fetch.
     */
    where?: GuildLoggingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildLoggings to fetch.
     */
    orderBy?: GuildLoggingsOrderByWithRelationInput | GuildLoggingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuildLoggings.
     */
    cursor?: GuildLoggingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildLoggings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildLoggings.
     */
    skip?: number
    distinct?: GuildLoggingsScalarFieldEnum | GuildLoggingsScalarFieldEnum[]
  }

  /**
   * GuildLoggings create
   */
  export type GuildLoggingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLoggings
     */
    select?: GuildLoggingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLoggings
     */
    omit?: GuildLoggingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLoggingsInclude<ExtArgs> | null
    /**
     * The data needed to create a GuildLoggings.
     */
    data: XOR<GuildLoggingsCreateInput, GuildLoggingsUncheckedCreateInput>
  }

  /**
   * GuildLoggings createMany
   */
  export type GuildLoggingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GuildLoggings.
     */
    data: GuildLoggingsCreateManyInput | GuildLoggingsCreateManyInput[]
  }

  /**
   * GuildLoggings update
   */
  export type GuildLoggingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLoggings
     */
    select?: GuildLoggingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLoggings
     */
    omit?: GuildLoggingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLoggingsInclude<ExtArgs> | null
    /**
     * The data needed to update a GuildLoggings.
     */
    data: XOR<GuildLoggingsUpdateInput, GuildLoggingsUncheckedUpdateInput>
    /**
     * Choose, which GuildLoggings to update.
     */
    where: GuildLoggingsWhereUniqueInput
  }

  /**
   * GuildLoggings updateMany
   */
  export type GuildLoggingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GuildLoggings.
     */
    data: XOR<GuildLoggingsUpdateManyMutationInput, GuildLoggingsUncheckedUpdateManyInput>
    /**
     * Filter which GuildLoggings to update
     */
    where?: GuildLoggingsWhereInput
    /**
     * Limit how many GuildLoggings to update.
     */
    limit?: number
  }

  /**
   * GuildLoggings upsert
   */
  export type GuildLoggingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLoggings
     */
    select?: GuildLoggingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLoggings
     */
    omit?: GuildLoggingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLoggingsInclude<ExtArgs> | null
    /**
     * The filter to search for the GuildLoggings to update in case it exists.
     */
    where: GuildLoggingsWhereUniqueInput
    /**
     * In case the GuildLoggings found by the `where` argument doesn't exist, create a new GuildLoggings with this data.
     */
    create: XOR<GuildLoggingsCreateInput, GuildLoggingsUncheckedCreateInput>
    /**
     * In case the GuildLoggings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuildLoggingsUpdateInput, GuildLoggingsUncheckedUpdateInput>
  }

  /**
   * GuildLoggings delete
   */
  export type GuildLoggingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLoggings
     */
    select?: GuildLoggingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLoggings
     */
    omit?: GuildLoggingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLoggingsInclude<ExtArgs> | null
    /**
     * Filter which GuildLoggings to delete.
     */
    where: GuildLoggingsWhereUniqueInput
  }

  /**
   * GuildLoggings deleteMany
   */
  export type GuildLoggingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildLoggings to delete
     */
    where?: GuildLoggingsWhereInput
    /**
     * Limit how many GuildLoggings to delete.
     */
    limit?: number
  }

  /**
   * GuildLoggings findRaw
   */
  export type GuildLoggingsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GuildLoggings aggregateRaw
   */
  export type GuildLoggingsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GuildLoggings without action
   */
  export type GuildLoggingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLoggings
     */
    select?: GuildLoggingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLoggings
     */
    omit?: GuildLoggingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLoggingsInclude<ExtArgs> | null
  }


  /**
   * Model GuildLoggers
   */

  export type AggregateGuildLoggers = {
    _count: GuildLoggersCountAggregateOutputType | null
    _min: GuildLoggersMinAggregateOutputType | null
    _max: GuildLoggersMaxAggregateOutputType | null
  }

  export type GuildLoggersMinAggregateOutputType = {
    id: string | null
    UUID: string | null
    LogMessage: string | null
    LogJSON: string | null
    GuildId: string | null
  }

  export type GuildLoggersMaxAggregateOutputType = {
    id: string | null
    UUID: string | null
    LogMessage: string | null
    LogJSON: string | null
    GuildId: string | null
  }

  export type GuildLoggersCountAggregateOutputType = {
    id: number
    UUID: number
    Notes: number
    LogMessage: number
    LogJSON: number
    GuildId: number
    _all: number
  }


  export type GuildLoggersMinAggregateInputType = {
    id?: true
    UUID?: true
    LogMessage?: true
    LogJSON?: true
    GuildId?: true
  }

  export type GuildLoggersMaxAggregateInputType = {
    id?: true
    UUID?: true
    LogMessage?: true
    LogJSON?: true
    GuildId?: true
  }

  export type GuildLoggersCountAggregateInputType = {
    id?: true
    UUID?: true
    Notes?: true
    LogMessage?: true
    LogJSON?: true
    GuildId?: true
    _all?: true
  }

  export type GuildLoggersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildLoggers to aggregate.
     */
    where?: GuildLoggersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildLoggers to fetch.
     */
    orderBy?: GuildLoggersOrderByWithRelationInput | GuildLoggersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuildLoggersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildLoggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildLoggers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuildLoggers
    **/
    _count?: true | GuildLoggersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildLoggersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildLoggersMaxAggregateInputType
  }

  export type GetGuildLoggersAggregateType<T extends GuildLoggersAggregateArgs> = {
        [P in keyof T & keyof AggregateGuildLoggers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuildLoggers[P]>
      : GetScalarType<T[P], AggregateGuildLoggers[P]>
  }




  export type GuildLoggersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildLoggersWhereInput
    orderBy?: GuildLoggersOrderByWithAggregationInput | GuildLoggersOrderByWithAggregationInput[]
    by: GuildLoggersScalarFieldEnum[] | GuildLoggersScalarFieldEnum
    having?: GuildLoggersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildLoggersCountAggregateInputType | true
    _min?: GuildLoggersMinAggregateInputType
    _max?: GuildLoggersMaxAggregateInputType
  }

  export type GuildLoggersGroupByOutputType = {
    id: string
    UUID: string
    Notes: string[]
    LogMessage: string
    LogJSON: string
    GuildId: string
    _count: GuildLoggersCountAggregateOutputType | null
    _min: GuildLoggersMinAggregateOutputType | null
    _max: GuildLoggersMaxAggregateOutputType | null
  }

  type GetGuildLoggersGroupByPayload<T extends GuildLoggersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildLoggersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildLoggersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildLoggersGroupByOutputType[P]>
            : GetScalarType<T[P], GuildLoggersGroupByOutputType[P]>
        }
      >
    >


  export type GuildLoggersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    UUID?: boolean
    Notes?: boolean
    LogMessage?: boolean
    LogJSON?: boolean
    GuildId?: boolean
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guildLoggers"]>



  export type GuildLoggersSelectScalar = {
    id?: boolean
    UUID?: boolean
    Notes?: boolean
    LogMessage?: boolean
    LogJSON?: boolean
    GuildId?: boolean
  }

  export type GuildLoggersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "UUID" | "Notes" | "LogMessage" | "LogJSON" | "GuildId", ExtArgs["result"]["guildLoggers"]>
  export type GuildLoggersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }

  export type $GuildLoggersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GuildLoggers"
    objects: {
      Guilds: Prisma.$GuildsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      UUID: string
      Notes: string[]
      LogMessage: string
      LogJSON: string
      GuildId: string
    }, ExtArgs["result"]["guildLoggers"]>
    composites: {}
  }

  type GuildLoggersGetPayload<S extends boolean | null | undefined | GuildLoggersDefaultArgs> = $Result.GetResult<Prisma.$GuildLoggersPayload, S>

  type GuildLoggersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuildLoggersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuildLoggersCountAggregateInputType | true
    }

  export interface GuildLoggersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GuildLoggers'], meta: { name: 'GuildLoggers' } }
    /**
     * Find zero or one GuildLoggers that matches the filter.
     * @param {GuildLoggersFindUniqueArgs} args - Arguments to find a GuildLoggers
     * @example
     * // Get one GuildLoggers
     * const guildLoggers = await prisma.guildLoggers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuildLoggersFindUniqueArgs>(args: SelectSubset<T, GuildLoggersFindUniqueArgs<ExtArgs>>): Prisma__GuildLoggersClient<$Result.GetResult<Prisma.$GuildLoggersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GuildLoggers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuildLoggersFindUniqueOrThrowArgs} args - Arguments to find a GuildLoggers
     * @example
     * // Get one GuildLoggers
     * const guildLoggers = await prisma.guildLoggers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuildLoggersFindUniqueOrThrowArgs>(args: SelectSubset<T, GuildLoggersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuildLoggersClient<$Result.GetResult<Prisma.$GuildLoggersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuildLoggers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildLoggersFindFirstArgs} args - Arguments to find a GuildLoggers
     * @example
     * // Get one GuildLoggers
     * const guildLoggers = await prisma.guildLoggers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuildLoggersFindFirstArgs>(args?: SelectSubset<T, GuildLoggersFindFirstArgs<ExtArgs>>): Prisma__GuildLoggersClient<$Result.GetResult<Prisma.$GuildLoggersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuildLoggers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildLoggersFindFirstOrThrowArgs} args - Arguments to find a GuildLoggers
     * @example
     * // Get one GuildLoggers
     * const guildLoggers = await prisma.guildLoggers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuildLoggersFindFirstOrThrowArgs>(args?: SelectSubset<T, GuildLoggersFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuildLoggersClient<$Result.GetResult<Prisma.$GuildLoggersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuildLoggers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildLoggersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuildLoggers
     * const guildLoggers = await prisma.guildLoggers.findMany()
     * 
     * // Get first 10 GuildLoggers
     * const guildLoggers = await prisma.guildLoggers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildLoggersWithIdOnly = await prisma.guildLoggers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuildLoggersFindManyArgs>(args?: SelectSubset<T, GuildLoggersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildLoggersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GuildLoggers.
     * @param {GuildLoggersCreateArgs} args - Arguments to create a GuildLoggers.
     * @example
     * // Create one GuildLoggers
     * const GuildLoggers = await prisma.guildLoggers.create({
     *   data: {
     *     // ... data to create a GuildLoggers
     *   }
     * })
     * 
     */
    create<T extends GuildLoggersCreateArgs>(args: SelectSubset<T, GuildLoggersCreateArgs<ExtArgs>>): Prisma__GuildLoggersClient<$Result.GetResult<Prisma.$GuildLoggersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GuildLoggers.
     * @param {GuildLoggersCreateManyArgs} args - Arguments to create many GuildLoggers.
     * @example
     * // Create many GuildLoggers
     * const guildLoggers = await prisma.guildLoggers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuildLoggersCreateManyArgs>(args?: SelectSubset<T, GuildLoggersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GuildLoggers.
     * @param {GuildLoggersDeleteArgs} args - Arguments to delete one GuildLoggers.
     * @example
     * // Delete one GuildLoggers
     * const GuildLoggers = await prisma.guildLoggers.delete({
     *   where: {
     *     // ... filter to delete one GuildLoggers
     *   }
     * })
     * 
     */
    delete<T extends GuildLoggersDeleteArgs>(args: SelectSubset<T, GuildLoggersDeleteArgs<ExtArgs>>): Prisma__GuildLoggersClient<$Result.GetResult<Prisma.$GuildLoggersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GuildLoggers.
     * @param {GuildLoggersUpdateArgs} args - Arguments to update one GuildLoggers.
     * @example
     * // Update one GuildLoggers
     * const guildLoggers = await prisma.guildLoggers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuildLoggersUpdateArgs>(args: SelectSubset<T, GuildLoggersUpdateArgs<ExtArgs>>): Prisma__GuildLoggersClient<$Result.GetResult<Prisma.$GuildLoggersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GuildLoggers.
     * @param {GuildLoggersDeleteManyArgs} args - Arguments to filter GuildLoggers to delete.
     * @example
     * // Delete a few GuildLoggers
     * const { count } = await prisma.guildLoggers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuildLoggersDeleteManyArgs>(args?: SelectSubset<T, GuildLoggersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuildLoggers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildLoggersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuildLoggers
     * const guildLoggers = await prisma.guildLoggers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuildLoggersUpdateManyArgs>(args: SelectSubset<T, GuildLoggersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GuildLoggers.
     * @param {GuildLoggersUpsertArgs} args - Arguments to update or create a GuildLoggers.
     * @example
     * // Update or create a GuildLoggers
     * const guildLoggers = await prisma.guildLoggers.upsert({
     *   create: {
     *     // ... data to create a GuildLoggers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuildLoggers we want to update
     *   }
     * })
     */
    upsert<T extends GuildLoggersUpsertArgs>(args: SelectSubset<T, GuildLoggersUpsertArgs<ExtArgs>>): Prisma__GuildLoggersClient<$Result.GetResult<Prisma.$GuildLoggersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuildLoggers that matches the filter.
     * @param {GuildLoggersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const guildLoggers = await prisma.guildLoggers.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: GuildLoggersFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a GuildLoggers.
     * @param {GuildLoggersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const guildLoggers = await prisma.guildLoggers.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: GuildLoggersAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of GuildLoggers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildLoggersCountArgs} args - Arguments to filter GuildLoggers to count.
     * @example
     * // Count the number of GuildLoggers
     * const count = await prisma.guildLoggers.count({
     *   where: {
     *     // ... the filter for the GuildLoggers we want to count
     *   }
     * })
    **/
    count<T extends GuildLoggersCountArgs>(
      args?: Subset<T, GuildLoggersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildLoggersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuildLoggers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildLoggersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildLoggersAggregateArgs>(args: Subset<T, GuildLoggersAggregateArgs>): Prisma.PrismaPromise<GetGuildLoggersAggregateType<T>>

    /**
     * Group by GuildLoggers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildLoggersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildLoggersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildLoggersGroupByArgs['orderBy'] }
        : { orderBy?: GuildLoggersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildLoggersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildLoggersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GuildLoggers model
   */
  readonly fields: GuildLoggersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuildLoggers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuildLoggersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GuildLoggers model
   */
  interface GuildLoggersFieldRefs {
    readonly id: FieldRef<"GuildLoggers", 'String'>
    readonly UUID: FieldRef<"GuildLoggers", 'String'>
    readonly Notes: FieldRef<"GuildLoggers", 'String[]'>
    readonly LogMessage: FieldRef<"GuildLoggers", 'String'>
    readonly LogJSON: FieldRef<"GuildLoggers", 'String'>
    readonly GuildId: FieldRef<"GuildLoggers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GuildLoggers findUnique
   */
  export type GuildLoggersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLoggers
     */
    select?: GuildLoggersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLoggers
     */
    omit?: GuildLoggersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLoggersInclude<ExtArgs> | null
    /**
     * Filter, which GuildLoggers to fetch.
     */
    where: GuildLoggersWhereUniqueInput
  }

  /**
   * GuildLoggers findUniqueOrThrow
   */
  export type GuildLoggersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLoggers
     */
    select?: GuildLoggersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLoggers
     */
    omit?: GuildLoggersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLoggersInclude<ExtArgs> | null
    /**
     * Filter, which GuildLoggers to fetch.
     */
    where: GuildLoggersWhereUniqueInput
  }

  /**
   * GuildLoggers findFirst
   */
  export type GuildLoggersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLoggers
     */
    select?: GuildLoggersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLoggers
     */
    omit?: GuildLoggersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLoggersInclude<ExtArgs> | null
    /**
     * Filter, which GuildLoggers to fetch.
     */
    where?: GuildLoggersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildLoggers to fetch.
     */
    orderBy?: GuildLoggersOrderByWithRelationInput | GuildLoggersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildLoggers.
     */
    cursor?: GuildLoggersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildLoggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildLoggers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildLoggers.
     */
    distinct?: GuildLoggersScalarFieldEnum | GuildLoggersScalarFieldEnum[]
  }

  /**
   * GuildLoggers findFirstOrThrow
   */
  export type GuildLoggersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLoggers
     */
    select?: GuildLoggersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLoggers
     */
    omit?: GuildLoggersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLoggersInclude<ExtArgs> | null
    /**
     * Filter, which GuildLoggers to fetch.
     */
    where?: GuildLoggersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildLoggers to fetch.
     */
    orderBy?: GuildLoggersOrderByWithRelationInput | GuildLoggersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildLoggers.
     */
    cursor?: GuildLoggersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildLoggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildLoggers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildLoggers.
     */
    distinct?: GuildLoggersScalarFieldEnum | GuildLoggersScalarFieldEnum[]
  }

  /**
   * GuildLoggers findMany
   */
  export type GuildLoggersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLoggers
     */
    select?: GuildLoggersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLoggers
     */
    omit?: GuildLoggersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLoggersInclude<ExtArgs> | null
    /**
     * Filter, which GuildLoggers to fetch.
     */
    where?: GuildLoggersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildLoggers to fetch.
     */
    orderBy?: GuildLoggersOrderByWithRelationInput | GuildLoggersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuildLoggers.
     */
    cursor?: GuildLoggersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildLoggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildLoggers.
     */
    skip?: number
    distinct?: GuildLoggersScalarFieldEnum | GuildLoggersScalarFieldEnum[]
  }

  /**
   * GuildLoggers create
   */
  export type GuildLoggersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLoggers
     */
    select?: GuildLoggersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLoggers
     */
    omit?: GuildLoggersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLoggersInclude<ExtArgs> | null
    /**
     * The data needed to create a GuildLoggers.
     */
    data: XOR<GuildLoggersCreateInput, GuildLoggersUncheckedCreateInput>
  }

  /**
   * GuildLoggers createMany
   */
  export type GuildLoggersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GuildLoggers.
     */
    data: GuildLoggersCreateManyInput | GuildLoggersCreateManyInput[]
  }

  /**
   * GuildLoggers update
   */
  export type GuildLoggersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLoggers
     */
    select?: GuildLoggersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLoggers
     */
    omit?: GuildLoggersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLoggersInclude<ExtArgs> | null
    /**
     * The data needed to update a GuildLoggers.
     */
    data: XOR<GuildLoggersUpdateInput, GuildLoggersUncheckedUpdateInput>
    /**
     * Choose, which GuildLoggers to update.
     */
    where: GuildLoggersWhereUniqueInput
  }

  /**
   * GuildLoggers updateMany
   */
  export type GuildLoggersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GuildLoggers.
     */
    data: XOR<GuildLoggersUpdateManyMutationInput, GuildLoggersUncheckedUpdateManyInput>
    /**
     * Filter which GuildLoggers to update
     */
    where?: GuildLoggersWhereInput
    /**
     * Limit how many GuildLoggers to update.
     */
    limit?: number
  }

  /**
   * GuildLoggers upsert
   */
  export type GuildLoggersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLoggers
     */
    select?: GuildLoggersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLoggers
     */
    omit?: GuildLoggersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLoggersInclude<ExtArgs> | null
    /**
     * The filter to search for the GuildLoggers to update in case it exists.
     */
    where: GuildLoggersWhereUniqueInput
    /**
     * In case the GuildLoggers found by the `where` argument doesn't exist, create a new GuildLoggers with this data.
     */
    create: XOR<GuildLoggersCreateInput, GuildLoggersUncheckedCreateInput>
    /**
     * In case the GuildLoggers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuildLoggersUpdateInput, GuildLoggersUncheckedUpdateInput>
  }

  /**
   * GuildLoggers delete
   */
  export type GuildLoggersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLoggers
     */
    select?: GuildLoggersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLoggers
     */
    omit?: GuildLoggersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLoggersInclude<ExtArgs> | null
    /**
     * Filter which GuildLoggers to delete.
     */
    where: GuildLoggersWhereUniqueInput
  }

  /**
   * GuildLoggers deleteMany
   */
  export type GuildLoggersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildLoggers to delete
     */
    where?: GuildLoggersWhereInput
    /**
     * Limit how many GuildLoggers to delete.
     */
    limit?: number
  }

  /**
   * GuildLoggers findRaw
   */
  export type GuildLoggersFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GuildLoggers aggregateRaw
   */
  export type GuildLoggersAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GuildLoggers without action
   */
  export type GuildLoggersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildLoggers
     */
    select?: GuildLoggersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildLoggers
     */
    omit?: GuildLoggersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildLoggersInclude<ExtArgs> | null
  }


  /**
   * Model MessageTemplates
   */

  export type AggregateMessageTemplates = {
    _count: MessageTemplatesCountAggregateOutputType | null
    _min: MessageTemplatesMinAggregateOutputType | null
    _max: MessageTemplatesMaxAggregateOutputType | null
  }

  export type MessageTemplatesMinAggregateOutputType = {
    id: string | null
    Content: string | null
    EmbedJSON: string | null
    Name: string | null
    GuildId: string | null
  }

  export type MessageTemplatesMaxAggregateOutputType = {
    id: string | null
    Content: string | null
    EmbedJSON: string | null
    Name: string | null
    GuildId: string | null
  }

  export type MessageTemplatesCountAggregateOutputType = {
    id: number
    Content: number
    EmbedJSON: number
    OtherEmbeds: number
    Name: number
    GuildId: number
    _all: number
  }


  export type MessageTemplatesMinAggregateInputType = {
    id?: true
    Content?: true
    EmbedJSON?: true
    Name?: true
    GuildId?: true
  }

  export type MessageTemplatesMaxAggregateInputType = {
    id?: true
    Content?: true
    EmbedJSON?: true
    Name?: true
    GuildId?: true
  }

  export type MessageTemplatesCountAggregateInputType = {
    id?: true
    Content?: true
    EmbedJSON?: true
    OtherEmbeds?: true
    Name?: true
    GuildId?: true
    _all?: true
  }

  export type MessageTemplatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageTemplates to aggregate.
     */
    where?: MessageTemplatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplatesOrderByWithRelationInput | MessageTemplatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageTemplatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageTemplates
    **/
    _count?: true | MessageTemplatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageTemplatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageTemplatesMaxAggregateInputType
  }

  export type GetMessageTemplatesAggregateType<T extends MessageTemplatesAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageTemplates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageTemplates[P]>
      : GetScalarType<T[P], AggregateMessageTemplates[P]>
  }




  export type MessageTemplatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageTemplatesWhereInput
    orderBy?: MessageTemplatesOrderByWithAggregationInput | MessageTemplatesOrderByWithAggregationInput[]
    by: MessageTemplatesScalarFieldEnum[] | MessageTemplatesScalarFieldEnum
    having?: MessageTemplatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageTemplatesCountAggregateInputType | true
    _min?: MessageTemplatesMinAggregateInputType
    _max?: MessageTemplatesMaxAggregateInputType
  }

  export type MessageTemplatesGroupByOutputType = {
    id: string
    Content: string | null
    EmbedJSON: string | null
    OtherEmbeds: string[]
    Name: string
    GuildId: string
    _count: MessageTemplatesCountAggregateOutputType | null
    _min: MessageTemplatesMinAggregateOutputType | null
    _max: MessageTemplatesMaxAggregateOutputType | null
  }

  type GetMessageTemplatesGroupByPayload<T extends MessageTemplatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageTemplatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageTemplatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageTemplatesGroupByOutputType[P]>
            : GetScalarType<T[P], MessageTemplatesGroupByOutputType[P]>
        }
      >
    >


  export type MessageTemplatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Content?: boolean
    EmbedJSON?: boolean
    OtherEmbeds?: boolean
    Name?: boolean
    GuildId?: boolean
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageTemplates"]>



  export type MessageTemplatesSelectScalar = {
    id?: boolean
    Content?: boolean
    EmbedJSON?: boolean
    OtherEmbeds?: boolean
    Name?: boolean
    GuildId?: boolean
  }

  export type MessageTemplatesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Content" | "EmbedJSON" | "OtherEmbeds" | "Name" | "GuildId", ExtArgs["result"]["messageTemplates"]>
  export type MessageTemplatesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }

  export type $MessageTemplatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageTemplates"
    objects: {
      Guilds: Prisma.$GuildsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Content: string | null
      EmbedJSON: string | null
      OtherEmbeds: string[]
      Name: string
      GuildId: string
    }, ExtArgs["result"]["messageTemplates"]>
    composites: {}
  }

  type MessageTemplatesGetPayload<S extends boolean | null | undefined | MessageTemplatesDefaultArgs> = $Result.GetResult<Prisma.$MessageTemplatesPayload, S>

  type MessageTemplatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageTemplatesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageTemplatesCountAggregateInputType | true
    }

  export interface MessageTemplatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageTemplates'], meta: { name: 'MessageTemplates' } }
    /**
     * Find zero or one MessageTemplates that matches the filter.
     * @param {MessageTemplatesFindUniqueArgs} args - Arguments to find a MessageTemplates
     * @example
     * // Get one MessageTemplates
     * const messageTemplates = await prisma.messageTemplates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageTemplatesFindUniqueArgs>(args: SelectSubset<T, MessageTemplatesFindUniqueArgs<ExtArgs>>): Prisma__MessageTemplatesClient<$Result.GetResult<Prisma.$MessageTemplatesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageTemplates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageTemplatesFindUniqueOrThrowArgs} args - Arguments to find a MessageTemplates
     * @example
     * // Get one MessageTemplates
     * const messageTemplates = await prisma.messageTemplates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageTemplatesFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageTemplatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageTemplatesClient<$Result.GetResult<Prisma.$MessageTemplatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplatesFindFirstArgs} args - Arguments to find a MessageTemplates
     * @example
     * // Get one MessageTemplates
     * const messageTemplates = await prisma.messageTemplates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageTemplatesFindFirstArgs>(args?: SelectSubset<T, MessageTemplatesFindFirstArgs<ExtArgs>>): Prisma__MessageTemplatesClient<$Result.GetResult<Prisma.$MessageTemplatesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageTemplates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplatesFindFirstOrThrowArgs} args - Arguments to find a MessageTemplates
     * @example
     * // Get one MessageTemplates
     * const messageTemplates = await prisma.messageTemplates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageTemplatesFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageTemplatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageTemplatesClient<$Result.GetResult<Prisma.$MessageTemplatesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageTemplates
     * const messageTemplates = await prisma.messageTemplates.findMany()
     * 
     * // Get first 10 MessageTemplates
     * const messageTemplates = await prisma.messageTemplates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageTemplatesWithIdOnly = await prisma.messageTemplates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageTemplatesFindManyArgs>(args?: SelectSubset<T, MessageTemplatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageTemplatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageTemplates.
     * @param {MessageTemplatesCreateArgs} args - Arguments to create a MessageTemplates.
     * @example
     * // Create one MessageTemplates
     * const MessageTemplates = await prisma.messageTemplates.create({
     *   data: {
     *     // ... data to create a MessageTemplates
     *   }
     * })
     * 
     */
    create<T extends MessageTemplatesCreateArgs>(args: SelectSubset<T, MessageTemplatesCreateArgs<ExtArgs>>): Prisma__MessageTemplatesClient<$Result.GetResult<Prisma.$MessageTemplatesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageTemplates.
     * @param {MessageTemplatesCreateManyArgs} args - Arguments to create many MessageTemplates.
     * @example
     * // Create many MessageTemplates
     * const messageTemplates = await prisma.messageTemplates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageTemplatesCreateManyArgs>(args?: SelectSubset<T, MessageTemplatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MessageTemplates.
     * @param {MessageTemplatesDeleteArgs} args - Arguments to delete one MessageTemplates.
     * @example
     * // Delete one MessageTemplates
     * const MessageTemplates = await prisma.messageTemplates.delete({
     *   where: {
     *     // ... filter to delete one MessageTemplates
     *   }
     * })
     * 
     */
    delete<T extends MessageTemplatesDeleteArgs>(args: SelectSubset<T, MessageTemplatesDeleteArgs<ExtArgs>>): Prisma__MessageTemplatesClient<$Result.GetResult<Prisma.$MessageTemplatesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageTemplates.
     * @param {MessageTemplatesUpdateArgs} args - Arguments to update one MessageTemplates.
     * @example
     * // Update one MessageTemplates
     * const messageTemplates = await prisma.messageTemplates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageTemplatesUpdateArgs>(args: SelectSubset<T, MessageTemplatesUpdateArgs<ExtArgs>>): Prisma__MessageTemplatesClient<$Result.GetResult<Prisma.$MessageTemplatesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageTemplates.
     * @param {MessageTemplatesDeleteManyArgs} args - Arguments to filter MessageTemplates to delete.
     * @example
     * // Delete a few MessageTemplates
     * const { count } = await prisma.messageTemplates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageTemplatesDeleteManyArgs>(args?: SelectSubset<T, MessageTemplatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageTemplates
     * const messageTemplates = await prisma.messageTemplates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageTemplatesUpdateManyArgs>(args: SelectSubset<T, MessageTemplatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageTemplates.
     * @param {MessageTemplatesUpsertArgs} args - Arguments to update or create a MessageTemplates.
     * @example
     * // Update or create a MessageTemplates
     * const messageTemplates = await prisma.messageTemplates.upsert({
     *   create: {
     *     // ... data to create a MessageTemplates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageTemplates we want to update
     *   }
     * })
     */
    upsert<T extends MessageTemplatesUpsertArgs>(args: SelectSubset<T, MessageTemplatesUpsertArgs<ExtArgs>>): Prisma__MessageTemplatesClient<$Result.GetResult<Prisma.$MessageTemplatesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageTemplates that matches the filter.
     * @param {MessageTemplatesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const messageTemplates = await prisma.messageTemplates.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MessageTemplatesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a MessageTemplates.
     * @param {MessageTemplatesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const messageTemplates = await prisma.messageTemplates.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MessageTemplatesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of MessageTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplatesCountArgs} args - Arguments to filter MessageTemplates to count.
     * @example
     * // Count the number of MessageTemplates
     * const count = await prisma.messageTemplates.count({
     *   where: {
     *     // ... the filter for the MessageTemplates we want to count
     *   }
     * })
    **/
    count<T extends MessageTemplatesCountArgs>(
      args?: Subset<T, MessageTemplatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageTemplatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageTemplatesAggregateArgs>(args: Subset<T, MessageTemplatesAggregateArgs>): Prisma.PrismaPromise<GetMessageTemplatesAggregateType<T>>

    /**
     * Group by MessageTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageTemplatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageTemplatesGroupByArgs['orderBy'] }
        : { orderBy?: MessageTemplatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageTemplatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageTemplatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageTemplates model
   */
  readonly fields: MessageTemplatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageTemplates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageTemplatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageTemplates model
   */
  interface MessageTemplatesFieldRefs {
    readonly id: FieldRef<"MessageTemplates", 'String'>
    readonly Content: FieldRef<"MessageTemplates", 'String'>
    readonly EmbedJSON: FieldRef<"MessageTemplates", 'String'>
    readonly OtherEmbeds: FieldRef<"MessageTemplates", 'String[]'>
    readonly Name: FieldRef<"MessageTemplates", 'String'>
    readonly GuildId: FieldRef<"MessageTemplates", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MessageTemplates findUnique
   */
  export type MessageTemplatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplates
     */
    select?: MessageTemplatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplates
     */
    omit?: MessageTemplatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplatesInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplates to fetch.
     */
    where: MessageTemplatesWhereUniqueInput
  }

  /**
   * MessageTemplates findUniqueOrThrow
   */
  export type MessageTemplatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplates
     */
    select?: MessageTemplatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplates
     */
    omit?: MessageTemplatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplatesInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplates to fetch.
     */
    where: MessageTemplatesWhereUniqueInput
  }

  /**
   * MessageTemplates findFirst
   */
  export type MessageTemplatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplates
     */
    select?: MessageTemplatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplates
     */
    omit?: MessageTemplatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplatesInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplates to fetch.
     */
    where?: MessageTemplatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplatesOrderByWithRelationInput | MessageTemplatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageTemplates.
     */
    cursor?: MessageTemplatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageTemplates.
     */
    distinct?: MessageTemplatesScalarFieldEnum | MessageTemplatesScalarFieldEnum[]
  }

  /**
   * MessageTemplates findFirstOrThrow
   */
  export type MessageTemplatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplates
     */
    select?: MessageTemplatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplates
     */
    omit?: MessageTemplatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplatesInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplates to fetch.
     */
    where?: MessageTemplatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplatesOrderByWithRelationInput | MessageTemplatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageTemplates.
     */
    cursor?: MessageTemplatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageTemplates.
     */
    distinct?: MessageTemplatesScalarFieldEnum | MessageTemplatesScalarFieldEnum[]
  }

  /**
   * MessageTemplates findMany
   */
  export type MessageTemplatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplates
     */
    select?: MessageTemplatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplates
     */
    omit?: MessageTemplatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplatesInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplates to fetch.
     */
    where?: MessageTemplatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplatesOrderByWithRelationInput | MessageTemplatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageTemplates.
     */
    cursor?: MessageTemplatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    distinct?: MessageTemplatesScalarFieldEnum | MessageTemplatesScalarFieldEnum[]
  }

  /**
   * MessageTemplates create
   */
  export type MessageTemplatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplates
     */
    select?: MessageTemplatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplates
     */
    omit?: MessageTemplatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplatesInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageTemplates.
     */
    data: XOR<MessageTemplatesCreateInput, MessageTemplatesUncheckedCreateInput>
  }

  /**
   * MessageTemplates createMany
   */
  export type MessageTemplatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageTemplates.
     */
    data: MessageTemplatesCreateManyInput | MessageTemplatesCreateManyInput[]
  }

  /**
   * MessageTemplates update
   */
  export type MessageTemplatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplates
     */
    select?: MessageTemplatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplates
     */
    omit?: MessageTemplatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplatesInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageTemplates.
     */
    data: XOR<MessageTemplatesUpdateInput, MessageTemplatesUncheckedUpdateInput>
    /**
     * Choose, which MessageTemplates to update.
     */
    where: MessageTemplatesWhereUniqueInput
  }

  /**
   * MessageTemplates updateMany
   */
  export type MessageTemplatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageTemplates.
     */
    data: XOR<MessageTemplatesUpdateManyMutationInput, MessageTemplatesUncheckedUpdateManyInput>
    /**
     * Filter which MessageTemplates to update
     */
    where?: MessageTemplatesWhereInput
    /**
     * Limit how many MessageTemplates to update.
     */
    limit?: number
  }

  /**
   * MessageTemplates upsert
   */
  export type MessageTemplatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplates
     */
    select?: MessageTemplatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplates
     */
    omit?: MessageTemplatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplatesInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageTemplates to update in case it exists.
     */
    where: MessageTemplatesWhereUniqueInput
    /**
     * In case the MessageTemplates found by the `where` argument doesn't exist, create a new MessageTemplates with this data.
     */
    create: XOR<MessageTemplatesCreateInput, MessageTemplatesUncheckedCreateInput>
    /**
     * In case the MessageTemplates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageTemplatesUpdateInput, MessageTemplatesUncheckedUpdateInput>
  }

  /**
   * MessageTemplates delete
   */
  export type MessageTemplatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplates
     */
    select?: MessageTemplatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplates
     */
    omit?: MessageTemplatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplatesInclude<ExtArgs> | null
    /**
     * Filter which MessageTemplates to delete.
     */
    where: MessageTemplatesWhereUniqueInput
  }

  /**
   * MessageTemplates deleteMany
   */
  export type MessageTemplatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageTemplates to delete
     */
    where?: MessageTemplatesWhereInput
    /**
     * Limit how many MessageTemplates to delete.
     */
    limit?: number
  }

  /**
   * MessageTemplates findRaw
   */
  export type MessageTemplatesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MessageTemplates aggregateRaw
   */
  export type MessageTemplatesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MessageTemplates without action
   */
  export type MessageTemplatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplates
     */
    select?: MessageTemplatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplates
     */
    omit?: MessageTemplatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplatesInclude<ExtArgs> | null
  }


  /**
   * Model Permissions
   */

  export type AggregatePermissions = {
    _count: PermissionsCountAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  export type PermissionsMinAggregateOutputType = {
    id: string | null
    GuildId: string | null
  }

  export type PermissionsMaxAggregateOutputType = {
    id: string | null
    GuildId: string | null
  }

  export type PermissionsCountAggregateOutputType = {
    id: number
    GuildId: number
    _all: number
  }


  export type PermissionsMinAggregateInputType = {
    id?: true
    GuildId?: true
  }

  export type PermissionsMaxAggregateInputType = {
    id?: true
    GuildId?: true
  }

  export type PermissionsCountAggregateInputType = {
    id?: true
    GuildId?: true
    _all?: true
  }

  export type PermissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to aggregate.
     */
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionsMaxAggregateInputType
  }

  export type GetPermissionsAggregateType<T extends PermissionsAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermissions[P]>
      : GetScalarType<T[P], AggregatePermissions[P]>
  }




  export type PermissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionsWhereInput
    orderBy?: PermissionsOrderByWithAggregationInput | PermissionsOrderByWithAggregationInput[]
    by: PermissionsScalarFieldEnum[] | PermissionsScalarFieldEnum
    having?: PermissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionsCountAggregateInputType | true
    _min?: PermissionsMinAggregateInputType
    _max?: PermissionsMaxAggregateInputType
  }

  export type PermissionsGroupByOutputType = {
    id: string
    GuildId: string
    _count: PermissionsCountAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  type GetPermissionsGroupByPayload<T extends PermissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
        }
      >
    >


  export type PermissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Permissions?: boolean | PermissionDataDefaultArgs<ExtArgs>
    GuildId?: boolean
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissions"]>



  export type PermissionsSelectScalar = {
    id?: boolean
    GuildId?: boolean
  }

  export type PermissionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Permissions" | "GuildId", ExtArgs["result"]["permissions"]>
  export type PermissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }

  export type $PermissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permissions"
    objects: {
      Guilds: Prisma.$GuildsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      GuildId: string
    }, ExtArgs["result"]["permissions"]>
    composites: {
      Permissions: Prisma.$PermissionDataPayload[]
    }
  }

  type PermissionsGetPayload<S extends boolean | null | undefined | PermissionsDefaultArgs> = $Result.GetResult<Prisma.$PermissionsPayload, S>

  type PermissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionsCountAggregateInputType | true
    }

  export interface PermissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permissions'], meta: { name: 'Permissions' } }
    /**
     * Find zero or one Permissions that matches the filter.
     * @param {PermissionsFindUniqueArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionsFindUniqueArgs>(args: SelectSubset<T, PermissionsFindUniqueArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permissions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionsFindUniqueOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsFindFirstArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionsFindFirstArgs>(args?: SelectSubset<T, PermissionsFindFirstArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsFindFirstOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permissions.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionsWithIdOnly = await prisma.permissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionsFindManyArgs>(args?: SelectSubset<T, PermissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permissions.
     * @param {PermissionsCreateArgs} args - Arguments to create a Permissions.
     * @example
     * // Create one Permissions
     * const Permissions = await prisma.permissions.create({
     *   data: {
     *     // ... data to create a Permissions
     *   }
     * })
     * 
     */
    create<T extends PermissionsCreateArgs>(args: SelectSubset<T, PermissionsCreateArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionsCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permissions = await prisma.permissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionsCreateManyArgs>(args?: SelectSubset<T, PermissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permissions.
     * @param {PermissionsDeleteArgs} args - Arguments to delete one Permissions.
     * @example
     * // Delete one Permissions
     * const Permissions = await prisma.permissions.delete({
     *   where: {
     *     // ... filter to delete one Permissions
     *   }
     * })
     * 
     */
    delete<T extends PermissionsDeleteArgs>(args: SelectSubset<T, PermissionsDeleteArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permissions.
     * @param {PermissionsUpdateArgs} args - Arguments to update one Permissions.
     * @example
     * // Update one Permissions
     * const permissions = await prisma.permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionsUpdateArgs>(args: SelectSubset<T, PermissionsUpdateArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionsDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionsDeleteManyArgs>(args?: SelectSubset<T, PermissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permissions = await prisma.permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionsUpdateManyArgs>(args: SelectSubset<T, PermissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permissions.
     * @param {PermissionsUpsertArgs} args - Arguments to update or create a Permissions.
     * @example
     * // Update or create a Permissions
     * const permissions = await prisma.permissions.upsert({
     *   create: {
     *     // ... data to create a Permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permissions we want to update
     *   }
     * })
     */
    upsert<T extends PermissionsUpsertArgs>(args: SelectSubset<T, PermissionsUpsertArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * @param {PermissionsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const permissions = await prisma.permissions.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PermissionsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Permissions.
     * @param {PermissionsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const permissions = await prisma.permissions.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PermissionsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permissions.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionsCountArgs>(
      args?: Subset<T, PermissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionsAggregateArgs>(args: Subset<T, PermissionsAggregateArgs>): Prisma.PrismaPromise<GetPermissionsAggregateType<T>>

    /**
     * Group by Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionsGroupByArgs['orderBy'] }
        : { orderBy?: PermissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permissions model
   */
  readonly fields: PermissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permissions model
   */
  interface PermissionsFieldRefs {
    readonly id: FieldRef<"Permissions", 'String'>
    readonly GuildId: FieldRef<"Permissions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Permissions findUnique
   */
  export type PermissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where: PermissionsWhereUniqueInput
  }

  /**
   * Permissions findUniqueOrThrow
   */
  export type PermissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where: PermissionsWhereUniqueInput
  }

  /**
   * Permissions findFirst
   */
  export type PermissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * Permissions findFirstOrThrow
   */
  export type PermissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * Permissions findMany
   */
  export type PermissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * Permissions create
   */
  export type PermissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Permissions.
     */
    data: XOR<PermissionsCreateInput, PermissionsUncheckedCreateInput>
  }

  /**
   * Permissions createMany
   */
  export type PermissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionsCreateManyInput | PermissionsCreateManyInput[]
  }

  /**
   * Permissions update
   */
  export type PermissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Permissions.
     */
    data: XOR<PermissionsUpdateInput, PermissionsUncheckedUpdateInput>
    /**
     * Choose, which Permissions to update.
     */
    where: PermissionsWhereUniqueInput
  }

  /**
   * Permissions updateMany
   */
  export type PermissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionsUpdateManyMutationInput, PermissionsUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionsWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permissions upsert
   */
  export type PermissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Permissions to update in case it exists.
     */
    where: PermissionsWhereUniqueInput
    /**
     * In case the Permissions found by the `where` argument doesn't exist, create a new Permissions with this data.
     */
    create: XOR<PermissionsCreateInput, PermissionsUncheckedCreateInput>
    /**
     * In case the Permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionsUpdateInput, PermissionsUncheckedUpdateInput>
  }

  /**
   * Permissions delete
   */
  export type PermissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter which Permissions to delete.
     */
    where: PermissionsWhereUniqueInput
  }

  /**
   * Permissions deleteMany
   */
  export type PermissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionsWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permissions findRaw
   */
  export type PermissionsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Permissions aggregateRaw
   */
  export type PermissionsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Permissions without action
   */
  export type PermissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
  }


  /**
   * Model ReactionRoles
   */

  export type AggregateReactionRoles = {
    _count: ReactionRolesCountAggregateOutputType | null
    _min: ReactionRolesMinAggregateOutputType | null
    _max: ReactionRolesMaxAggregateOutputType | null
  }

  export type ReactionRolesMinAggregateOutputType = {
    id: string | null
    UUID: string | null
    MessageId: string | null
    ChannelId: string | null
    AddMessage: string | null
    RemoveMessage: string | null
    Emoji: string | null
    GuildId: string | null
  }

  export type ReactionRolesMaxAggregateOutputType = {
    id: string | null
    UUID: string | null
    MessageId: string | null
    ChannelId: string | null
    AddMessage: string | null
    RemoveMessage: string | null
    Emoji: string | null
    GuildId: string | null
  }

  export type ReactionRolesCountAggregateOutputType = {
    id: number
    UUID: number
    Roles: number
    MessageId: number
    ChannelId: number
    AddMessage: number
    RemoveMessage: number
    Emoji: number
    GuildId: number
    _all: number
  }


  export type ReactionRolesMinAggregateInputType = {
    id?: true
    UUID?: true
    MessageId?: true
    ChannelId?: true
    AddMessage?: true
    RemoveMessage?: true
    Emoji?: true
    GuildId?: true
  }

  export type ReactionRolesMaxAggregateInputType = {
    id?: true
    UUID?: true
    MessageId?: true
    ChannelId?: true
    AddMessage?: true
    RemoveMessage?: true
    Emoji?: true
    GuildId?: true
  }

  export type ReactionRolesCountAggregateInputType = {
    id?: true
    UUID?: true
    Roles?: true
    MessageId?: true
    ChannelId?: true
    AddMessage?: true
    RemoveMessage?: true
    Emoji?: true
    GuildId?: true
    _all?: true
  }

  export type ReactionRolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReactionRoles to aggregate.
     */
    where?: ReactionRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReactionRoles to fetch.
     */
    orderBy?: ReactionRolesOrderByWithRelationInput | ReactionRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReactionRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReactionRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReactionRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReactionRoles
    **/
    _count?: true | ReactionRolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReactionRolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReactionRolesMaxAggregateInputType
  }

  export type GetReactionRolesAggregateType<T extends ReactionRolesAggregateArgs> = {
        [P in keyof T & keyof AggregateReactionRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReactionRoles[P]>
      : GetScalarType<T[P], AggregateReactionRoles[P]>
  }




  export type ReactionRolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactionRolesWhereInput
    orderBy?: ReactionRolesOrderByWithAggregationInput | ReactionRolesOrderByWithAggregationInput[]
    by: ReactionRolesScalarFieldEnum[] | ReactionRolesScalarFieldEnum
    having?: ReactionRolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReactionRolesCountAggregateInputType | true
    _min?: ReactionRolesMinAggregateInputType
    _max?: ReactionRolesMaxAggregateInputType
  }

  export type ReactionRolesGroupByOutputType = {
    id: string
    UUID: string
    Roles: string[]
    MessageId: string | null
    ChannelId: string | null
    AddMessage: string | null
    RemoveMessage: string | null
    Emoji: string | null
    GuildId: string
    _count: ReactionRolesCountAggregateOutputType | null
    _min: ReactionRolesMinAggregateOutputType | null
    _max: ReactionRolesMaxAggregateOutputType | null
  }

  type GetReactionRolesGroupByPayload<T extends ReactionRolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReactionRolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReactionRolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReactionRolesGroupByOutputType[P]>
            : GetScalarType<T[P], ReactionRolesGroupByOutputType[P]>
        }
      >
    >


  export type ReactionRolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    UUID?: boolean
    Roles?: boolean
    MessageId?: boolean
    ChannelId?: boolean
    AddMessage?: boolean
    RemoveMessage?: boolean
    Button?: boolean | ReactionRoleButtonDefaultArgs<ExtArgs>
    SelectMenu?: boolean | ReactionRoleSelectmenuDefaultArgs<ExtArgs>
    Emoji?: boolean
    GuildId?: boolean
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reactionRoles"]>



  export type ReactionRolesSelectScalar = {
    id?: boolean
    UUID?: boolean
    Roles?: boolean
    MessageId?: boolean
    ChannelId?: boolean
    AddMessage?: boolean
    RemoveMessage?: boolean
    Emoji?: boolean
    GuildId?: boolean
  }

  export type ReactionRolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "UUID" | "Roles" | "MessageId" | "ChannelId" | "AddMessage" | "RemoveMessage" | "Button" | "SelectMenu" | "Emoji" | "GuildId", ExtArgs["result"]["reactionRoles"]>
  export type ReactionRolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }

  export type $ReactionRolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReactionRoles"
    objects: {
      Guilds: Prisma.$GuildsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      UUID: string
      Roles: string[]
      MessageId: string | null
      ChannelId: string | null
      AddMessage: string | null
      RemoveMessage: string | null
      Emoji: string | null
      GuildId: string
    }, ExtArgs["result"]["reactionRoles"]>
    composites: {
      Button: Prisma.$ReactionRoleButtonPayload | null
      SelectMenu: Prisma.$ReactionRoleSelectmenuPayload | null
    }
  }

  type ReactionRolesGetPayload<S extends boolean | null | undefined | ReactionRolesDefaultArgs> = $Result.GetResult<Prisma.$ReactionRolesPayload, S>

  type ReactionRolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReactionRolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReactionRolesCountAggregateInputType | true
    }

  export interface ReactionRolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReactionRoles'], meta: { name: 'ReactionRoles' } }
    /**
     * Find zero or one ReactionRoles that matches the filter.
     * @param {ReactionRolesFindUniqueArgs} args - Arguments to find a ReactionRoles
     * @example
     * // Get one ReactionRoles
     * const reactionRoles = await prisma.reactionRoles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReactionRolesFindUniqueArgs>(args: SelectSubset<T, ReactionRolesFindUniqueArgs<ExtArgs>>): Prisma__ReactionRolesClient<$Result.GetResult<Prisma.$ReactionRolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReactionRoles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReactionRolesFindUniqueOrThrowArgs} args - Arguments to find a ReactionRoles
     * @example
     * // Get one ReactionRoles
     * const reactionRoles = await prisma.reactionRoles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReactionRolesFindUniqueOrThrowArgs>(args: SelectSubset<T, ReactionRolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReactionRolesClient<$Result.GetResult<Prisma.$ReactionRolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReactionRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionRolesFindFirstArgs} args - Arguments to find a ReactionRoles
     * @example
     * // Get one ReactionRoles
     * const reactionRoles = await prisma.reactionRoles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReactionRolesFindFirstArgs>(args?: SelectSubset<T, ReactionRolesFindFirstArgs<ExtArgs>>): Prisma__ReactionRolesClient<$Result.GetResult<Prisma.$ReactionRolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReactionRoles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionRolesFindFirstOrThrowArgs} args - Arguments to find a ReactionRoles
     * @example
     * // Get one ReactionRoles
     * const reactionRoles = await prisma.reactionRoles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReactionRolesFindFirstOrThrowArgs>(args?: SelectSubset<T, ReactionRolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReactionRolesClient<$Result.GetResult<Prisma.$ReactionRolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReactionRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionRolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReactionRoles
     * const reactionRoles = await prisma.reactionRoles.findMany()
     * 
     * // Get first 10 ReactionRoles
     * const reactionRoles = await prisma.reactionRoles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reactionRolesWithIdOnly = await prisma.reactionRoles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReactionRolesFindManyArgs>(args?: SelectSubset<T, ReactionRolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionRolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReactionRoles.
     * @param {ReactionRolesCreateArgs} args - Arguments to create a ReactionRoles.
     * @example
     * // Create one ReactionRoles
     * const ReactionRoles = await prisma.reactionRoles.create({
     *   data: {
     *     // ... data to create a ReactionRoles
     *   }
     * })
     * 
     */
    create<T extends ReactionRolesCreateArgs>(args: SelectSubset<T, ReactionRolesCreateArgs<ExtArgs>>): Prisma__ReactionRolesClient<$Result.GetResult<Prisma.$ReactionRolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReactionRoles.
     * @param {ReactionRolesCreateManyArgs} args - Arguments to create many ReactionRoles.
     * @example
     * // Create many ReactionRoles
     * const reactionRoles = await prisma.reactionRoles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReactionRolesCreateManyArgs>(args?: SelectSubset<T, ReactionRolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReactionRoles.
     * @param {ReactionRolesDeleteArgs} args - Arguments to delete one ReactionRoles.
     * @example
     * // Delete one ReactionRoles
     * const ReactionRoles = await prisma.reactionRoles.delete({
     *   where: {
     *     // ... filter to delete one ReactionRoles
     *   }
     * })
     * 
     */
    delete<T extends ReactionRolesDeleteArgs>(args: SelectSubset<T, ReactionRolesDeleteArgs<ExtArgs>>): Prisma__ReactionRolesClient<$Result.GetResult<Prisma.$ReactionRolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReactionRoles.
     * @param {ReactionRolesUpdateArgs} args - Arguments to update one ReactionRoles.
     * @example
     * // Update one ReactionRoles
     * const reactionRoles = await prisma.reactionRoles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReactionRolesUpdateArgs>(args: SelectSubset<T, ReactionRolesUpdateArgs<ExtArgs>>): Prisma__ReactionRolesClient<$Result.GetResult<Prisma.$ReactionRolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReactionRoles.
     * @param {ReactionRolesDeleteManyArgs} args - Arguments to filter ReactionRoles to delete.
     * @example
     * // Delete a few ReactionRoles
     * const { count } = await prisma.reactionRoles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReactionRolesDeleteManyArgs>(args?: SelectSubset<T, ReactionRolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReactionRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionRolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReactionRoles
     * const reactionRoles = await prisma.reactionRoles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReactionRolesUpdateManyArgs>(args: SelectSubset<T, ReactionRolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReactionRoles.
     * @param {ReactionRolesUpsertArgs} args - Arguments to update or create a ReactionRoles.
     * @example
     * // Update or create a ReactionRoles
     * const reactionRoles = await prisma.reactionRoles.upsert({
     *   create: {
     *     // ... data to create a ReactionRoles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReactionRoles we want to update
     *   }
     * })
     */
    upsert<T extends ReactionRolesUpsertArgs>(args: SelectSubset<T, ReactionRolesUpsertArgs<ExtArgs>>): Prisma__ReactionRolesClient<$Result.GetResult<Prisma.$ReactionRolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReactionRoles that matches the filter.
     * @param {ReactionRolesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const reactionRoles = await prisma.reactionRoles.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ReactionRolesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ReactionRoles.
     * @param {ReactionRolesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const reactionRoles = await prisma.reactionRoles.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ReactionRolesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ReactionRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionRolesCountArgs} args - Arguments to filter ReactionRoles to count.
     * @example
     * // Count the number of ReactionRoles
     * const count = await prisma.reactionRoles.count({
     *   where: {
     *     // ... the filter for the ReactionRoles we want to count
     *   }
     * })
    **/
    count<T extends ReactionRolesCountArgs>(
      args?: Subset<T, ReactionRolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReactionRolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReactionRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionRolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReactionRolesAggregateArgs>(args: Subset<T, ReactionRolesAggregateArgs>): Prisma.PrismaPromise<GetReactionRolesAggregateType<T>>

    /**
     * Group by ReactionRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionRolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReactionRolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReactionRolesGroupByArgs['orderBy'] }
        : { orderBy?: ReactionRolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReactionRolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReactionRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReactionRoles model
   */
  readonly fields: ReactionRolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReactionRoles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReactionRolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReactionRoles model
   */
  interface ReactionRolesFieldRefs {
    readonly id: FieldRef<"ReactionRoles", 'String'>
    readonly UUID: FieldRef<"ReactionRoles", 'String'>
    readonly Roles: FieldRef<"ReactionRoles", 'String[]'>
    readonly MessageId: FieldRef<"ReactionRoles", 'String'>
    readonly ChannelId: FieldRef<"ReactionRoles", 'String'>
    readonly AddMessage: FieldRef<"ReactionRoles", 'String'>
    readonly RemoveMessage: FieldRef<"ReactionRoles", 'String'>
    readonly Emoji: FieldRef<"ReactionRoles", 'String'>
    readonly GuildId: FieldRef<"ReactionRoles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReactionRoles findUnique
   */
  export type ReactionRolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReactionRoles
     */
    select?: ReactionRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReactionRoles
     */
    omit?: ReactionRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionRolesInclude<ExtArgs> | null
    /**
     * Filter, which ReactionRoles to fetch.
     */
    where: ReactionRolesWhereUniqueInput
  }

  /**
   * ReactionRoles findUniqueOrThrow
   */
  export type ReactionRolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReactionRoles
     */
    select?: ReactionRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReactionRoles
     */
    omit?: ReactionRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionRolesInclude<ExtArgs> | null
    /**
     * Filter, which ReactionRoles to fetch.
     */
    where: ReactionRolesWhereUniqueInput
  }

  /**
   * ReactionRoles findFirst
   */
  export type ReactionRolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReactionRoles
     */
    select?: ReactionRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReactionRoles
     */
    omit?: ReactionRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionRolesInclude<ExtArgs> | null
    /**
     * Filter, which ReactionRoles to fetch.
     */
    where?: ReactionRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReactionRoles to fetch.
     */
    orderBy?: ReactionRolesOrderByWithRelationInput | ReactionRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReactionRoles.
     */
    cursor?: ReactionRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReactionRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReactionRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReactionRoles.
     */
    distinct?: ReactionRolesScalarFieldEnum | ReactionRolesScalarFieldEnum[]
  }

  /**
   * ReactionRoles findFirstOrThrow
   */
  export type ReactionRolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReactionRoles
     */
    select?: ReactionRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReactionRoles
     */
    omit?: ReactionRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionRolesInclude<ExtArgs> | null
    /**
     * Filter, which ReactionRoles to fetch.
     */
    where?: ReactionRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReactionRoles to fetch.
     */
    orderBy?: ReactionRolesOrderByWithRelationInput | ReactionRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReactionRoles.
     */
    cursor?: ReactionRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReactionRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReactionRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReactionRoles.
     */
    distinct?: ReactionRolesScalarFieldEnum | ReactionRolesScalarFieldEnum[]
  }

  /**
   * ReactionRoles findMany
   */
  export type ReactionRolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReactionRoles
     */
    select?: ReactionRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReactionRoles
     */
    omit?: ReactionRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionRolesInclude<ExtArgs> | null
    /**
     * Filter, which ReactionRoles to fetch.
     */
    where?: ReactionRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReactionRoles to fetch.
     */
    orderBy?: ReactionRolesOrderByWithRelationInput | ReactionRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReactionRoles.
     */
    cursor?: ReactionRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReactionRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReactionRoles.
     */
    skip?: number
    distinct?: ReactionRolesScalarFieldEnum | ReactionRolesScalarFieldEnum[]
  }

  /**
   * ReactionRoles create
   */
  export type ReactionRolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReactionRoles
     */
    select?: ReactionRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReactionRoles
     */
    omit?: ReactionRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionRolesInclude<ExtArgs> | null
    /**
     * The data needed to create a ReactionRoles.
     */
    data: XOR<ReactionRolesCreateInput, ReactionRolesUncheckedCreateInput>
  }

  /**
   * ReactionRoles createMany
   */
  export type ReactionRolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReactionRoles.
     */
    data: ReactionRolesCreateManyInput | ReactionRolesCreateManyInput[]
  }

  /**
   * ReactionRoles update
   */
  export type ReactionRolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReactionRoles
     */
    select?: ReactionRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReactionRoles
     */
    omit?: ReactionRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionRolesInclude<ExtArgs> | null
    /**
     * The data needed to update a ReactionRoles.
     */
    data: XOR<ReactionRolesUpdateInput, ReactionRolesUncheckedUpdateInput>
    /**
     * Choose, which ReactionRoles to update.
     */
    where: ReactionRolesWhereUniqueInput
  }

  /**
   * ReactionRoles updateMany
   */
  export type ReactionRolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReactionRoles.
     */
    data: XOR<ReactionRolesUpdateManyMutationInput, ReactionRolesUncheckedUpdateManyInput>
    /**
     * Filter which ReactionRoles to update
     */
    where?: ReactionRolesWhereInput
    /**
     * Limit how many ReactionRoles to update.
     */
    limit?: number
  }

  /**
   * ReactionRoles upsert
   */
  export type ReactionRolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReactionRoles
     */
    select?: ReactionRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReactionRoles
     */
    omit?: ReactionRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionRolesInclude<ExtArgs> | null
    /**
     * The filter to search for the ReactionRoles to update in case it exists.
     */
    where: ReactionRolesWhereUniqueInput
    /**
     * In case the ReactionRoles found by the `where` argument doesn't exist, create a new ReactionRoles with this data.
     */
    create: XOR<ReactionRolesCreateInput, ReactionRolesUncheckedCreateInput>
    /**
     * In case the ReactionRoles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReactionRolesUpdateInput, ReactionRolesUncheckedUpdateInput>
  }

  /**
   * ReactionRoles delete
   */
  export type ReactionRolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReactionRoles
     */
    select?: ReactionRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReactionRoles
     */
    omit?: ReactionRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionRolesInclude<ExtArgs> | null
    /**
     * Filter which ReactionRoles to delete.
     */
    where: ReactionRolesWhereUniqueInput
  }

  /**
   * ReactionRoles deleteMany
   */
  export type ReactionRolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReactionRoles to delete
     */
    where?: ReactionRolesWhereInput
    /**
     * Limit how many ReactionRoles to delete.
     */
    limit?: number
  }

  /**
   * ReactionRoles findRaw
   */
  export type ReactionRolesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ReactionRoles aggregateRaw
   */
  export type ReactionRolesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ReactionRoles without action
   */
  export type ReactionRolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReactionRoles
     */
    select?: ReactionRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReactionRoles
     */
    omit?: ReactionRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionRolesInclude<ExtArgs> | null
  }


  /**
   * Model Securitys
   */

  export type AggregateSecuritys = {
    _count: SecuritysCountAggregateOutputType | null
    _avg: SecuritysAvgAggregateOutputType | null
    _sum: SecuritysSumAggregateOutputType | null
    _min: SecuritysMinAggregateOutputType | null
    _max: SecuritysMaxAggregateOutputType | null
  }

  export type SecuritysAvgAggregateOutputType = {
    MaxAccountAge: number | null
  }

  export type SecuritysSumAggregateOutputType = {
    MaxAccountAge: number | null
  }

  export type SecuritysMinAggregateOutputType = {
    id: string | null
    InviteLoggingActive: string | null
    MaxAccountAge: number | null
    GuildId: string | null
  }

  export type SecuritysMaxAggregateOutputType = {
    id: string | null
    InviteLoggingActive: string | null
    MaxAccountAge: number | null
    GuildId: string | null
  }

  export type SecuritysCountAggregateOutputType = {
    id: number
    InviteLoggingActive: number
    MaxAccountAge: number
    GuildId: number
    _all: number
  }


  export type SecuritysAvgAggregateInputType = {
    MaxAccountAge?: true
  }

  export type SecuritysSumAggregateInputType = {
    MaxAccountAge?: true
  }

  export type SecuritysMinAggregateInputType = {
    id?: true
    InviteLoggingActive?: true
    MaxAccountAge?: true
    GuildId?: true
  }

  export type SecuritysMaxAggregateInputType = {
    id?: true
    InviteLoggingActive?: true
    MaxAccountAge?: true
    GuildId?: true
  }

  export type SecuritysCountAggregateInputType = {
    id?: true
    InviteLoggingActive?: true
    MaxAccountAge?: true
    GuildId?: true
    _all?: true
  }

  export type SecuritysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Securitys to aggregate.
     */
    where?: SecuritysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Securitys to fetch.
     */
    orderBy?: SecuritysOrderByWithRelationInput | SecuritysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecuritysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Securitys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Securitys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Securitys
    **/
    _count?: true | SecuritysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SecuritysAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SecuritysSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecuritysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecuritysMaxAggregateInputType
  }

  export type GetSecuritysAggregateType<T extends SecuritysAggregateArgs> = {
        [P in keyof T & keyof AggregateSecuritys]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecuritys[P]>
      : GetScalarType<T[P], AggregateSecuritys[P]>
  }




  export type SecuritysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecuritysWhereInput
    orderBy?: SecuritysOrderByWithAggregationInput | SecuritysOrderByWithAggregationInput[]
    by: SecuritysScalarFieldEnum[] | SecuritysScalarFieldEnum
    having?: SecuritysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecuritysCountAggregateInputType | true
    _avg?: SecuritysAvgAggregateInputType
    _sum?: SecuritysSumAggregateInputType
    _min?: SecuritysMinAggregateInputType
    _max?: SecuritysMaxAggregateInputType
  }

  export type SecuritysGroupByOutputType = {
    id: string
    InviteLoggingActive: string | null
    MaxAccountAge: number | null
    GuildId: string
    _count: SecuritysCountAggregateOutputType | null
    _avg: SecuritysAvgAggregateOutputType | null
    _sum: SecuritysSumAggregateOutputType | null
    _min: SecuritysMinAggregateOutputType | null
    _max: SecuritysMaxAggregateOutputType | null
  }

  type GetSecuritysGroupByPayload<T extends SecuritysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecuritysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecuritysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecuritysGroupByOutputType[P]>
            : GetScalarType<T[P], SecuritysGroupByOutputType[P]>
        }
      >
    >


  export type SecuritysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    InviteLoggingActive?: boolean
    MaxAccountAge?: boolean
    GuildId?: boolean
    VerificationGates?: boolean | Securitys$VerificationGatesArgs<ExtArgs>
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
    _count?: boolean | SecuritysCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["securitys"]>



  export type SecuritysSelectScalar = {
    id?: boolean
    InviteLoggingActive?: boolean
    MaxAccountAge?: boolean
    GuildId?: boolean
  }

  export type SecuritysOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "InviteLoggingActive" | "MaxAccountAge" | "GuildId", ExtArgs["result"]["securitys"]>
  export type SecuritysInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VerificationGates?: boolean | Securitys$VerificationGatesArgs<ExtArgs>
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
    _count?: boolean | SecuritysCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SecuritysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Securitys"
    objects: {
      VerificationGates: Prisma.$VerificationGatesPayload<ExtArgs>[]
      Guilds: Prisma.$GuildsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      InviteLoggingActive: string | null
      MaxAccountAge: number | null
      GuildId: string
    }, ExtArgs["result"]["securitys"]>
    composites: {}
  }

  type SecuritysGetPayload<S extends boolean | null | undefined | SecuritysDefaultArgs> = $Result.GetResult<Prisma.$SecuritysPayload, S>

  type SecuritysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SecuritysFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SecuritysCountAggregateInputType | true
    }

  export interface SecuritysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Securitys'], meta: { name: 'Securitys' } }
    /**
     * Find zero or one Securitys that matches the filter.
     * @param {SecuritysFindUniqueArgs} args - Arguments to find a Securitys
     * @example
     * // Get one Securitys
     * const securitys = await prisma.securitys.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SecuritysFindUniqueArgs>(args: SelectSubset<T, SecuritysFindUniqueArgs<ExtArgs>>): Prisma__SecuritysClient<$Result.GetResult<Prisma.$SecuritysPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Securitys that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SecuritysFindUniqueOrThrowArgs} args - Arguments to find a Securitys
     * @example
     * // Get one Securitys
     * const securitys = await prisma.securitys.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SecuritysFindUniqueOrThrowArgs>(args: SelectSubset<T, SecuritysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SecuritysClient<$Result.GetResult<Prisma.$SecuritysPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Securitys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritysFindFirstArgs} args - Arguments to find a Securitys
     * @example
     * // Get one Securitys
     * const securitys = await prisma.securitys.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SecuritysFindFirstArgs>(args?: SelectSubset<T, SecuritysFindFirstArgs<ExtArgs>>): Prisma__SecuritysClient<$Result.GetResult<Prisma.$SecuritysPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Securitys that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritysFindFirstOrThrowArgs} args - Arguments to find a Securitys
     * @example
     * // Get one Securitys
     * const securitys = await prisma.securitys.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SecuritysFindFirstOrThrowArgs>(args?: SelectSubset<T, SecuritysFindFirstOrThrowArgs<ExtArgs>>): Prisma__SecuritysClient<$Result.GetResult<Prisma.$SecuritysPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Securitys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Securitys
     * const securitys = await prisma.securitys.findMany()
     * 
     * // Get first 10 Securitys
     * const securitys = await prisma.securitys.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securitysWithIdOnly = await prisma.securitys.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SecuritysFindManyArgs>(args?: SelectSubset<T, SecuritysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecuritysPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Securitys.
     * @param {SecuritysCreateArgs} args - Arguments to create a Securitys.
     * @example
     * // Create one Securitys
     * const Securitys = await prisma.securitys.create({
     *   data: {
     *     // ... data to create a Securitys
     *   }
     * })
     * 
     */
    create<T extends SecuritysCreateArgs>(args: SelectSubset<T, SecuritysCreateArgs<ExtArgs>>): Prisma__SecuritysClient<$Result.GetResult<Prisma.$SecuritysPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Securitys.
     * @param {SecuritysCreateManyArgs} args - Arguments to create many Securitys.
     * @example
     * // Create many Securitys
     * const securitys = await prisma.securitys.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SecuritysCreateManyArgs>(args?: SelectSubset<T, SecuritysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Securitys.
     * @param {SecuritysDeleteArgs} args - Arguments to delete one Securitys.
     * @example
     * // Delete one Securitys
     * const Securitys = await prisma.securitys.delete({
     *   where: {
     *     // ... filter to delete one Securitys
     *   }
     * })
     * 
     */
    delete<T extends SecuritysDeleteArgs>(args: SelectSubset<T, SecuritysDeleteArgs<ExtArgs>>): Prisma__SecuritysClient<$Result.GetResult<Prisma.$SecuritysPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Securitys.
     * @param {SecuritysUpdateArgs} args - Arguments to update one Securitys.
     * @example
     * // Update one Securitys
     * const securitys = await prisma.securitys.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SecuritysUpdateArgs>(args: SelectSubset<T, SecuritysUpdateArgs<ExtArgs>>): Prisma__SecuritysClient<$Result.GetResult<Prisma.$SecuritysPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Securitys.
     * @param {SecuritysDeleteManyArgs} args - Arguments to filter Securitys to delete.
     * @example
     * // Delete a few Securitys
     * const { count } = await prisma.securitys.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SecuritysDeleteManyArgs>(args?: SelectSubset<T, SecuritysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Securitys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Securitys
     * const securitys = await prisma.securitys.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SecuritysUpdateManyArgs>(args: SelectSubset<T, SecuritysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Securitys.
     * @param {SecuritysUpsertArgs} args - Arguments to update or create a Securitys.
     * @example
     * // Update or create a Securitys
     * const securitys = await prisma.securitys.upsert({
     *   create: {
     *     // ... data to create a Securitys
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Securitys we want to update
     *   }
     * })
     */
    upsert<T extends SecuritysUpsertArgs>(args: SelectSubset<T, SecuritysUpsertArgs<ExtArgs>>): Prisma__SecuritysClient<$Result.GetResult<Prisma.$SecuritysPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Securitys that matches the filter.
     * @param {SecuritysFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const securitys = await prisma.securitys.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SecuritysFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Securitys.
     * @param {SecuritysAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const securitys = await prisma.securitys.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SecuritysAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Securitys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritysCountArgs} args - Arguments to filter Securitys to count.
     * @example
     * // Count the number of Securitys
     * const count = await prisma.securitys.count({
     *   where: {
     *     // ... the filter for the Securitys we want to count
     *   }
     * })
    **/
    count<T extends SecuritysCountArgs>(
      args?: Subset<T, SecuritysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecuritysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Securitys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecuritysAggregateArgs>(args: Subset<T, SecuritysAggregateArgs>): Prisma.PrismaPromise<GetSecuritysAggregateType<T>>

    /**
     * Group by Securitys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecuritysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecuritysGroupByArgs['orderBy'] }
        : { orderBy?: SecuritysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecuritysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecuritysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Securitys model
   */
  readonly fields: SecuritysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Securitys.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecuritysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    VerificationGates<T extends Securitys$VerificationGatesArgs<ExtArgs> = {}>(args?: Subset<T, Securitys$VerificationGatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationGatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Securitys model
   */
  interface SecuritysFieldRefs {
    readonly id: FieldRef<"Securitys", 'String'>
    readonly InviteLoggingActive: FieldRef<"Securitys", 'String'>
    readonly MaxAccountAge: FieldRef<"Securitys", 'Int'>
    readonly GuildId: FieldRef<"Securitys", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Securitys findUnique
   */
  export type SecuritysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Securitys
     */
    select?: SecuritysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Securitys
     */
    omit?: SecuritysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecuritysInclude<ExtArgs> | null
    /**
     * Filter, which Securitys to fetch.
     */
    where: SecuritysWhereUniqueInput
  }

  /**
   * Securitys findUniqueOrThrow
   */
  export type SecuritysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Securitys
     */
    select?: SecuritysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Securitys
     */
    omit?: SecuritysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecuritysInclude<ExtArgs> | null
    /**
     * Filter, which Securitys to fetch.
     */
    where: SecuritysWhereUniqueInput
  }

  /**
   * Securitys findFirst
   */
  export type SecuritysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Securitys
     */
    select?: SecuritysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Securitys
     */
    omit?: SecuritysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecuritysInclude<ExtArgs> | null
    /**
     * Filter, which Securitys to fetch.
     */
    where?: SecuritysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Securitys to fetch.
     */
    orderBy?: SecuritysOrderByWithRelationInput | SecuritysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Securitys.
     */
    cursor?: SecuritysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Securitys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Securitys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Securitys.
     */
    distinct?: SecuritysScalarFieldEnum | SecuritysScalarFieldEnum[]
  }

  /**
   * Securitys findFirstOrThrow
   */
  export type SecuritysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Securitys
     */
    select?: SecuritysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Securitys
     */
    omit?: SecuritysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecuritysInclude<ExtArgs> | null
    /**
     * Filter, which Securitys to fetch.
     */
    where?: SecuritysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Securitys to fetch.
     */
    orderBy?: SecuritysOrderByWithRelationInput | SecuritysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Securitys.
     */
    cursor?: SecuritysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Securitys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Securitys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Securitys.
     */
    distinct?: SecuritysScalarFieldEnum | SecuritysScalarFieldEnum[]
  }

  /**
   * Securitys findMany
   */
  export type SecuritysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Securitys
     */
    select?: SecuritysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Securitys
     */
    omit?: SecuritysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecuritysInclude<ExtArgs> | null
    /**
     * Filter, which Securitys to fetch.
     */
    where?: SecuritysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Securitys to fetch.
     */
    orderBy?: SecuritysOrderByWithRelationInput | SecuritysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Securitys.
     */
    cursor?: SecuritysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Securitys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Securitys.
     */
    skip?: number
    distinct?: SecuritysScalarFieldEnum | SecuritysScalarFieldEnum[]
  }

  /**
   * Securitys create
   */
  export type SecuritysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Securitys
     */
    select?: SecuritysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Securitys
     */
    omit?: SecuritysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecuritysInclude<ExtArgs> | null
    /**
     * The data needed to create a Securitys.
     */
    data: XOR<SecuritysCreateInput, SecuritysUncheckedCreateInput>
  }

  /**
   * Securitys createMany
   */
  export type SecuritysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Securitys.
     */
    data: SecuritysCreateManyInput | SecuritysCreateManyInput[]
  }

  /**
   * Securitys update
   */
  export type SecuritysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Securitys
     */
    select?: SecuritysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Securitys
     */
    omit?: SecuritysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecuritysInclude<ExtArgs> | null
    /**
     * The data needed to update a Securitys.
     */
    data: XOR<SecuritysUpdateInput, SecuritysUncheckedUpdateInput>
    /**
     * Choose, which Securitys to update.
     */
    where: SecuritysWhereUniqueInput
  }

  /**
   * Securitys updateMany
   */
  export type SecuritysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Securitys.
     */
    data: XOR<SecuritysUpdateManyMutationInput, SecuritysUncheckedUpdateManyInput>
    /**
     * Filter which Securitys to update
     */
    where?: SecuritysWhereInput
    /**
     * Limit how many Securitys to update.
     */
    limit?: number
  }

  /**
   * Securitys upsert
   */
  export type SecuritysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Securitys
     */
    select?: SecuritysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Securitys
     */
    omit?: SecuritysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecuritysInclude<ExtArgs> | null
    /**
     * The filter to search for the Securitys to update in case it exists.
     */
    where: SecuritysWhereUniqueInput
    /**
     * In case the Securitys found by the `where` argument doesn't exist, create a new Securitys with this data.
     */
    create: XOR<SecuritysCreateInput, SecuritysUncheckedCreateInput>
    /**
     * In case the Securitys was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecuritysUpdateInput, SecuritysUncheckedUpdateInput>
  }

  /**
   * Securitys delete
   */
  export type SecuritysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Securitys
     */
    select?: SecuritysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Securitys
     */
    omit?: SecuritysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecuritysInclude<ExtArgs> | null
    /**
     * Filter which Securitys to delete.
     */
    where: SecuritysWhereUniqueInput
  }

  /**
   * Securitys deleteMany
   */
  export type SecuritysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Securitys to delete
     */
    where?: SecuritysWhereInput
    /**
     * Limit how many Securitys to delete.
     */
    limit?: number
  }

  /**
   * Securitys findRaw
   */
  export type SecuritysFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Securitys aggregateRaw
   */
  export type SecuritysAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Securitys.VerificationGates
   */
  export type Securitys$VerificationGatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationGates
     */
    select?: VerificationGatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationGates
     */
    omit?: VerificationGatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationGatesInclude<ExtArgs> | null
    where?: VerificationGatesWhereInput
    orderBy?: VerificationGatesOrderByWithRelationInput | VerificationGatesOrderByWithRelationInput[]
    cursor?: VerificationGatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerificationGatesScalarFieldEnum | VerificationGatesScalarFieldEnum[]
  }

  /**
   * Securitys without action
   */
  export type SecuritysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Securitys
     */
    select?: SecuritysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Securitys
     */
    omit?: SecuritysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecuritysInclude<ExtArgs> | null
  }


  /**
   * Model VerificationGates
   */

  export type AggregateVerificationGates = {
    _count: VerificationGatesCountAggregateOutputType | null
    _min: VerificationGatesMinAggregateOutputType | null
    _max: VerificationGatesMaxAggregateOutputType | null
  }

  export type VerificationGatesMinAggregateOutputType = {
    id: string | null
    UUID: string | null
    ChannelId: string | null
    MessageId: string | null
    Action: string | null
    ActionType: string | null
    CreatedAt: Date | null
    Active: boolean | null
    SecurityId: string | null
  }

  export type VerificationGatesMaxAggregateOutputType = {
    id: string | null
    UUID: string | null
    ChannelId: string | null
    MessageId: string | null
    Action: string | null
    ActionType: string | null
    CreatedAt: Date | null
    Active: boolean | null
    SecurityId: string | null
  }

  export type VerificationGatesCountAggregateOutputType = {
    id: number
    UUID: number
    ChannelId: number
    MessageId: number
    Action: number
    ActionType: number
    Roles: number
    VerifiedUsers: number
    CreatedAt: number
    Active: number
    SecurityId: number
    _all: number
  }


  export type VerificationGatesMinAggregateInputType = {
    id?: true
    UUID?: true
    ChannelId?: true
    MessageId?: true
    Action?: true
    ActionType?: true
    CreatedAt?: true
    Active?: true
    SecurityId?: true
  }

  export type VerificationGatesMaxAggregateInputType = {
    id?: true
    UUID?: true
    ChannelId?: true
    MessageId?: true
    Action?: true
    ActionType?: true
    CreatedAt?: true
    Active?: true
    SecurityId?: true
  }

  export type VerificationGatesCountAggregateInputType = {
    id?: true
    UUID?: true
    ChannelId?: true
    MessageId?: true
    Action?: true
    ActionType?: true
    Roles?: true
    VerifiedUsers?: true
    CreatedAt?: true
    Active?: true
    SecurityId?: true
    _all?: true
  }

  export type VerificationGatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationGates to aggregate.
     */
    where?: VerificationGatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationGates to fetch.
     */
    orderBy?: VerificationGatesOrderByWithRelationInput | VerificationGatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationGatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationGates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationGates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationGates
    **/
    _count?: true | VerificationGatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationGatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationGatesMaxAggregateInputType
  }

  export type GetVerificationGatesAggregateType<T extends VerificationGatesAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationGates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationGates[P]>
      : GetScalarType<T[P], AggregateVerificationGates[P]>
  }




  export type VerificationGatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationGatesWhereInput
    orderBy?: VerificationGatesOrderByWithAggregationInput | VerificationGatesOrderByWithAggregationInput[]
    by: VerificationGatesScalarFieldEnum[] | VerificationGatesScalarFieldEnum
    having?: VerificationGatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationGatesCountAggregateInputType | true
    _min?: VerificationGatesMinAggregateInputType
    _max?: VerificationGatesMaxAggregateInputType
  }

  export type VerificationGatesGroupByOutputType = {
    id: string
    UUID: string
    ChannelId: string
    MessageId: string
    Action: string | null
    ActionType: string | null
    Roles: string[]
    VerifiedUsers: string[]
    CreatedAt: Date
    Active: boolean | null
    SecurityId: string
    _count: VerificationGatesCountAggregateOutputType | null
    _min: VerificationGatesMinAggregateOutputType | null
    _max: VerificationGatesMaxAggregateOutputType | null
  }

  type GetVerificationGatesGroupByPayload<T extends VerificationGatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGatesGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGatesGroupByOutputType[P]>
        }
      >
    >


  export type VerificationGatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    UUID?: boolean
    ChannelId?: boolean
    MessageId?: boolean
    Action?: boolean
    ActionType?: boolean
    Roles?: boolean
    VerifiedUsers?: boolean
    CreatedAt?: boolean
    Active?: boolean
    SecurityId?: boolean
    ChannelPermissions?: boolean | VerificationGates$ChannelPermissionsArgs<ExtArgs>
    VerificationGates?: boolean | SecuritysDefaultArgs<ExtArgs>
    _count?: boolean | VerificationGatesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verificationGates"]>



  export type VerificationGatesSelectScalar = {
    id?: boolean
    UUID?: boolean
    ChannelId?: boolean
    MessageId?: boolean
    Action?: boolean
    ActionType?: boolean
    Roles?: boolean
    VerifiedUsers?: boolean
    CreatedAt?: boolean
    Active?: boolean
    SecurityId?: boolean
  }

  export type VerificationGatesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "UUID" | "ChannelId" | "MessageId" | "Action" | "ActionType" | "Roles" | "VerifiedUsers" | "CreatedAt" | "Active" | "SecurityId", ExtArgs["result"]["verificationGates"]>
  export type VerificationGatesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ChannelPermissions?: boolean | VerificationGates$ChannelPermissionsArgs<ExtArgs>
    VerificationGates?: boolean | SecuritysDefaultArgs<ExtArgs>
    _count?: boolean | VerificationGatesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $VerificationGatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationGates"
    objects: {
      ChannelPermissions: Prisma.$VerificationGatesPermissionPayload<ExtArgs>[]
      VerificationGates: Prisma.$SecuritysPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      UUID: string
      ChannelId: string
      MessageId: string
      Action: string | null
      ActionType: string | null
      Roles: string[]
      VerifiedUsers: string[]
      CreatedAt: Date
      Active: boolean | null
      SecurityId: string
    }, ExtArgs["result"]["verificationGates"]>
    composites: {}
  }

  type VerificationGatesGetPayload<S extends boolean | null | undefined | VerificationGatesDefaultArgs> = $Result.GetResult<Prisma.$VerificationGatesPayload, S>

  type VerificationGatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationGatesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationGatesCountAggregateInputType | true
    }

  export interface VerificationGatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationGates'], meta: { name: 'VerificationGates' } }
    /**
     * Find zero or one VerificationGates that matches the filter.
     * @param {VerificationGatesFindUniqueArgs} args - Arguments to find a VerificationGates
     * @example
     * // Get one VerificationGates
     * const verificationGates = await prisma.verificationGates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationGatesFindUniqueArgs>(args: SelectSubset<T, VerificationGatesFindUniqueArgs<ExtArgs>>): Prisma__VerificationGatesClient<$Result.GetResult<Prisma.$VerificationGatesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationGates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationGatesFindUniqueOrThrowArgs} args - Arguments to find a VerificationGates
     * @example
     * // Get one VerificationGates
     * const verificationGates = await prisma.verificationGates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationGatesFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationGatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationGatesClient<$Result.GetResult<Prisma.$VerificationGatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationGates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGatesFindFirstArgs} args - Arguments to find a VerificationGates
     * @example
     * // Get one VerificationGates
     * const verificationGates = await prisma.verificationGates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationGatesFindFirstArgs>(args?: SelectSubset<T, VerificationGatesFindFirstArgs<ExtArgs>>): Prisma__VerificationGatesClient<$Result.GetResult<Prisma.$VerificationGatesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationGates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGatesFindFirstOrThrowArgs} args - Arguments to find a VerificationGates
     * @example
     * // Get one VerificationGates
     * const verificationGates = await prisma.verificationGates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationGatesFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationGatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationGatesClient<$Result.GetResult<Prisma.$VerificationGatesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationGates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationGates
     * const verificationGates = await prisma.verificationGates.findMany()
     * 
     * // Get first 10 VerificationGates
     * const verificationGates = await prisma.verificationGates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationGatesWithIdOnly = await prisma.verificationGates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationGatesFindManyArgs>(args?: SelectSubset<T, VerificationGatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationGatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationGates.
     * @param {VerificationGatesCreateArgs} args - Arguments to create a VerificationGates.
     * @example
     * // Create one VerificationGates
     * const VerificationGates = await prisma.verificationGates.create({
     *   data: {
     *     // ... data to create a VerificationGates
     *   }
     * })
     * 
     */
    create<T extends VerificationGatesCreateArgs>(args: SelectSubset<T, VerificationGatesCreateArgs<ExtArgs>>): Prisma__VerificationGatesClient<$Result.GetResult<Prisma.$VerificationGatesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationGates.
     * @param {VerificationGatesCreateManyArgs} args - Arguments to create many VerificationGates.
     * @example
     * // Create many VerificationGates
     * const verificationGates = await prisma.verificationGates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationGatesCreateManyArgs>(args?: SelectSubset<T, VerificationGatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VerificationGates.
     * @param {VerificationGatesDeleteArgs} args - Arguments to delete one VerificationGates.
     * @example
     * // Delete one VerificationGates
     * const VerificationGates = await prisma.verificationGates.delete({
     *   where: {
     *     // ... filter to delete one VerificationGates
     *   }
     * })
     * 
     */
    delete<T extends VerificationGatesDeleteArgs>(args: SelectSubset<T, VerificationGatesDeleteArgs<ExtArgs>>): Prisma__VerificationGatesClient<$Result.GetResult<Prisma.$VerificationGatesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationGates.
     * @param {VerificationGatesUpdateArgs} args - Arguments to update one VerificationGates.
     * @example
     * // Update one VerificationGates
     * const verificationGates = await prisma.verificationGates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationGatesUpdateArgs>(args: SelectSubset<T, VerificationGatesUpdateArgs<ExtArgs>>): Prisma__VerificationGatesClient<$Result.GetResult<Prisma.$VerificationGatesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationGates.
     * @param {VerificationGatesDeleteManyArgs} args - Arguments to filter VerificationGates to delete.
     * @example
     * // Delete a few VerificationGates
     * const { count } = await prisma.verificationGates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationGatesDeleteManyArgs>(args?: SelectSubset<T, VerificationGatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationGates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationGates
     * const verificationGates = await prisma.verificationGates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationGatesUpdateManyArgs>(args: SelectSubset<T, VerificationGatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationGates.
     * @param {VerificationGatesUpsertArgs} args - Arguments to update or create a VerificationGates.
     * @example
     * // Update or create a VerificationGates
     * const verificationGates = await prisma.verificationGates.upsert({
     *   create: {
     *     // ... data to create a VerificationGates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationGates we want to update
     *   }
     * })
     */
    upsert<T extends VerificationGatesUpsertArgs>(args: SelectSubset<T, VerificationGatesUpsertArgs<ExtArgs>>): Prisma__VerificationGatesClient<$Result.GetResult<Prisma.$VerificationGatesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationGates that matches the filter.
     * @param {VerificationGatesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const verificationGates = await prisma.verificationGates.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: VerificationGatesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a VerificationGates.
     * @param {VerificationGatesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const verificationGates = await prisma.verificationGates.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: VerificationGatesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of VerificationGates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGatesCountArgs} args - Arguments to filter VerificationGates to count.
     * @example
     * // Count the number of VerificationGates
     * const count = await prisma.verificationGates.count({
     *   where: {
     *     // ... the filter for the VerificationGates we want to count
     *   }
     * })
    **/
    count<T extends VerificationGatesCountArgs>(
      args?: Subset<T, VerificationGatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationGatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationGates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationGatesAggregateArgs>(args: Subset<T, VerificationGatesAggregateArgs>): Prisma.PrismaPromise<GetVerificationGatesAggregateType<T>>

    /**
     * Group by VerificationGates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGatesGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationGates model
   */
  readonly fields: VerificationGatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationGates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationGatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ChannelPermissions<T extends VerificationGates$ChannelPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, VerificationGates$ChannelPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationGatesPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    VerificationGates<T extends SecuritysDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SecuritysDefaultArgs<ExtArgs>>): Prisma__SecuritysClient<$Result.GetResult<Prisma.$SecuritysPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationGates model
   */
  interface VerificationGatesFieldRefs {
    readonly id: FieldRef<"VerificationGates", 'String'>
    readonly UUID: FieldRef<"VerificationGates", 'String'>
    readonly ChannelId: FieldRef<"VerificationGates", 'String'>
    readonly MessageId: FieldRef<"VerificationGates", 'String'>
    readonly Action: FieldRef<"VerificationGates", 'String'>
    readonly ActionType: FieldRef<"VerificationGates", 'String'>
    readonly Roles: FieldRef<"VerificationGates", 'String[]'>
    readonly VerifiedUsers: FieldRef<"VerificationGates", 'String[]'>
    readonly CreatedAt: FieldRef<"VerificationGates", 'DateTime'>
    readonly Active: FieldRef<"VerificationGates", 'Boolean'>
    readonly SecurityId: FieldRef<"VerificationGates", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VerificationGates findUnique
   */
  export type VerificationGatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationGates
     */
    select?: VerificationGatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationGates
     */
    omit?: VerificationGatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationGatesInclude<ExtArgs> | null
    /**
     * Filter, which VerificationGates to fetch.
     */
    where: VerificationGatesWhereUniqueInput
  }

  /**
   * VerificationGates findUniqueOrThrow
   */
  export type VerificationGatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationGates
     */
    select?: VerificationGatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationGates
     */
    omit?: VerificationGatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationGatesInclude<ExtArgs> | null
    /**
     * Filter, which VerificationGates to fetch.
     */
    where: VerificationGatesWhereUniqueInput
  }

  /**
   * VerificationGates findFirst
   */
  export type VerificationGatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationGates
     */
    select?: VerificationGatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationGates
     */
    omit?: VerificationGatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationGatesInclude<ExtArgs> | null
    /**
     * Filter, which VerificationGates to fetch.
     */
    where?: VerificationGatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationGates to fetch.
     */
    orderBy?: VerificationGatesOrderByWithRelationInput | VerificationGatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationGates.
     */
    cursor?: VerificationGatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationGates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationGates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationGates.
     */
    distinct?: VerificationGatesScalarFieldEnum | VerificationGatesScalarFieldEnum[]
  }

  /**
   * VerificationGates findFirstOrThrow
   */
  export type VerificationGatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationGates
     */
    select?: VerificationGatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationGates
     */
    omit?: VerificationGatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationGatesInclude<ExtArgs> | null
    /**
     * Filter, which VerificationGates to fetch.
     */
    where?: VerificationGatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationGates to fetch.
     */
    orderBy?: VerificationGatesOrderByWithRelationInput | VerificationGatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationGates.
     */
    cursor?: VerificationGatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationGates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationGates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationGates.
     */
    distinct?: VerificationGatesScalarFieldEnum | VerificationGatesScalarFieldEnum[]
  }

  /**
   * VerificationGates findMany
   */
  export type VerificationGatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationGates
     */
    select?: VerificationGatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationGates
     */
    omit?: VerificationGatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationGatesInclude<ExtArgs> | null
    /**
     * Filter, which VerificationGates to fetch.
     */
    where?: VerificationGatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationGates to fetch.
     */
    orderBy?: VerificationGatesOrderByWithRelationInput | VerificationGatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationGates.
     */
    cursor?: VerificationGatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationGates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationGates.
     */
    skip?: number
    distinct?: VerificationGatesScalarFieldEnum | VerificationGatesScalarFieldEnum[]
  }

  /**
   * VerificationGates create
   */
  export type VerificationGatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationGates
     */
    select?: VerificationGatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationGates
     */
    omit?: VerificationGatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationGatesInclude<ExtArgs> | null
    /**
     * The data needed to create a VerificationGates.
     */
    data: XOR<VerificationGatesCreateInput, VerificationGatesUncheckedCreateInput>
  }

  /**
   * VerificationGates createMany
   */
  export type VerificationGatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationGates.
     */
    data: VerificationGatesCreateManyInput | VerificationGatesCreateManyInput[]
  }

  /**
   * VerificationGates update
   */
  export type VerificationGatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationGates
     */
    select?: VerificationGatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationGates
     */
    omit?: VerificationGatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationGatesInclude<ExtArgs> | null
    /**
     * The data needed to update a VerificationGates.
     */
    data: XOR<VerificationGatesUpdateInput, VerificationGatesUncheckedUpdateInput>
    /**
     * Choose, which VerificationGates to update.
     */
    where: VerificationGatesWhereUniqueInput
  }

  /**
   * VerificationGates updateMany
   */
  export type VerificationGatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationGates.
     */
    data: XOR<VerificationGatesUpdateManyMutationInput, VerificationGatesUncheckedUpdateManyInput>
    /**
     * Filter which VerificationGates to update
     */
    where?: VerificationGatesWhereInput
    /**
     * Limit how many VerificationGates to update.
     */
    limit?: number
  }

  /**
   * VerificationGates upsert
   */
  export type VerificationGatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationGates
     */
    select?: VerificationGatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationGates
     */
    omit?: VerificationGatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationGatesInclude<ExtArgs> | null
    /**
     * The filter to search for the VerificationGates to update in case it exists.
     */
    where: VerificationGatesWhereUniqueInput
    /**
     * In case the VerificationGates found by the `where` argument doesn't exist, create a new VerificationGates with this data.
     */
    create: XOR<VerificationGatesCreateInput, VerificationGatesUncheckedCreateInput>
    /**
     * In case the VerificationGates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationGatesUpdateInput, VerificationGatesUncheckedUpdateInput>
  }

  /**
   * VerificationGates delete
   */
  export type VerificationGatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationGates
     */
    select?: VerificationGatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationGates
     */
    omit?: VerificationGatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationGatesInclude<ExtArgs> | null
    /**
     * Filter which VerificationGates to delete.
     */
    where: VerificationGatesWhereUniqueInput
  }

  /**
   * VerificationGates deleteMany
   */
  export type VerificationGatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationGates to delete
     */
    where?: VerificationGatesWhereInput
    /**
     * Limit how many VerificationGates to delete.
     */
    limit?: number
  }

  /**
   * VerificationGates findRaw
   */
  export type VerificationGatesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * VerificationGates aggregateRaw
   */
  export type VerificationGatesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * VerificationGates.ChannelPermissions
   */
  export type VerificationGates$ChannelPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationGatesPermission
     */
    select?: VerificationGatesPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationGatesPermission
     */
    omit?: VerificationGatesPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationGatesPermissionInclude<ExtArgs> | null
    where?: VerificationGatesPermissionWhereInput
    orderBy?: VerificationGatesPermissionOrderByWithRelationInput | VerificationGatesPermissionOrderByWithRelationInput[]
    cursor?: VerificationGatesPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerificationGatesPermissionScalarFieldEnum | VerificationGatesPermissionScalarFieldEnum[]
  }

  /**
   * VerificationGates without action
   */
  export type VerificationGatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationGates
     */
    select?: VerificationGatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationGates
     */
    omit?: VerificationGatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationGatesInclude<ExtArgs> | null
  }


  /**
   * Model VerificationGatesPermission
   */

  export type AggregateVerificationGatesPermission = {
    _count: VerificationGatesPermissionCountAggregateOutputType | null
    _min: VerificationGatesPermissionMinAggregateOutputType | null
    _max: VerificationGatesPermissionMaxAggregateOutputType | null
  }

  export type VerificationGatesPermissionMinAggregateOutputType = {
    id: string | null
    ChannelId: string | null
    VerificationGateId: string | null
  }

  export type VerificationGatesPermissionMaxAggregateOutputType = {
    id: string | null
    ChannelId: string | null
    VerificationGateId: string | null
  }

  export type VerificationGatesPermissionCountAggregateOutputType = {
    id: number
    Permission: number
    ChannelId: number
    VerificationGateId: number
    _all: number
  }


  export type VerificationGatesPermissionMinAggregateInputType = {
    id?: true
    ChannelId?: true
    VerificationGateId?: true
  }

  export type VerificationGatesPermissionMaxAggregateInputType = {
    id?: true
    ChannelId?: true
    VerificationGateId?: true
  }

  export type VerificationGatesPermissionCountAggregateInputType = {
    id?: true
    Permission?: true
    ChannelId?: true
    VerificationGateId?: true
    _all?: true
  }

  export type VerificationGatesPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationGatesPermission to aggregate.
     */
    where?: VerificationGatesPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationGatesPermissions to fetch.
     */
    orderBy?: VerificationGatesPermissionOrderByWithRelationInput | VerificationGatesPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationGatesPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationGatesPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationGatesPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationGatesPermissions
    **/
    _count?: true | VerificationGatesPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationGatesPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationGatesPermissionMaxAggregateInputType
  }

  export type GetVerificationGatesPermissionAggregateType<T extends VerificationGatesPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationGatesPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationGatesPermission[P]>
      : GetScalarType<T[P], AggregateVerificationGatesPermission[P]>
  }




  export type VerificationGatesPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationGatesPermissionWhereInput
    orderBy?: VerificationGatesPermissionOrderByWithAggregationInput | VerificationGatesPermissionOrderByWithAggregationInput[]
    by: VerificationGatesPermissionScalarFieldEnum[] | VerificationGatesPermissionScalarFieldEnum
    having?: VerificationGatesPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationGatesPermissionCountAggregateInputType | true
    _min?: VerificationGatesPermissionMinAggregateInputType
    _max?: VerificationGatesPermissionMaxAggregateInputType
  }

  export type VerificationGatesPermissionGroupByOutputType = {
    id: string
    Permission: string[]
    ChannelId: string
    VerificationGateId: string
    _count: VerificationGatesPermissionCountAggregateOutputType | null
    _min: VerificationGatesPermissionMinAggregateOutputType | null
    _max: VerificationGatesPermissionMaxAggregateOutputType | null
  }

  type GetVerificationGatesPermissionGroupByPayload<T extends VerificationGatesPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGatesPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGatesPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGatesPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGatesPermissionGroupByOutputType[P]>
        }
      >
    >


  export type VerificationGatesPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Permission?: boolean
    ChannelId?: boolean
    VerificationGateId?: boolean
    VerificationGates?: boolean | VerificationGatesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verificationGatesPermission"]>



  export type VerificationGatesPermissionSelectScalar = {
    id?: boolean
    Permission?: boolean
    ChannelId?: boolean
    VerificationGateId?: boolean
  }

  export type VerificationGatesPermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Permission" | "ChannelId" | "VerificationGateId", ExtArgs["result"]["verificationGatesPermission"]>
  export type VerificationGatesPermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VerificationGates?: boolean | VerificationGatesDefaultArgs<ExtArgs>
  }

  export type $VerificationGatesPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationGatesPermission"
    objects: {
      VerificationGates: Prisma.$VerificationGatesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Permission: string[]
      ChannelId: string
      VerificationGateId: string
    }, ExtArgs["result"]["verificationGatesPermission"]>
    composites: {}
  }

  type VerificationGatesPermissionGetPayload<S extends boolean | null | undefined | VerificationGatesPermissionDefaultArgs> = $Result.GetResult<Prisma.$VerificationGatesPermissionPayload, S>

  type VerificationGatesPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationGatesPermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationGatesPermissionCountAggregateInputType | true
    }

  export interface VerificationGatesPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationGatesPermission'], meta: { name: 'VerificationGatesPermission' } }
    /**
     * Find zero or one VerificationGatesPermission that matches the filter.
     * @param {VerificationGatesPermissionFindUniqueArgs} args - Arguments to find a VerificationGatesPermission
     * @example
     * // Get one VerificationGatesPermission
     * const verificationGatesPermission = await prisma.verificationGatesPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationGatesPermissionFindUniqueArgs>(args: SelectSubset<T, VerificationGatesPermissionFindUniqueArgs<ExtArgs>>): Prisma__VerificationGatesPermissionClient<$Result.GetResult<Prisma.$VerificationGatesPermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationGatesPermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationGatesPermissionFindUniqueOrThrowArgs} args - Arguments to find a VerificationGatesPermission
     * @example
     * // Get one VerificationGatesPermission
     * const verificationGatesPermission = await prisma.verificationGatesPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationGatesPermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationGatesPermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationGatesPermissionClient<$Result.GetResult<Prisma.$VerificationGatesPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationGatesPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGatesPermissionFindFirstArgs} args - Arguments to find a VerificationGatesPermission
     * @example
     * // Get one VerificationGatesPermission
     * const verificationGatesPermission = await prisma.verificationGatesPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationGatesPermissionFindFirstArgs>(args?: SelectSubset<T, VerificationGatesPermissionFindFirstArgs<ExtArgs>>): Prisma__VerificationGatesPermissionClient<$Result.GetResult<Prisma.$VerificationGatesPermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationGatesPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGatesPermissionFindFirstOrThrowArgs} args - Arguments to find a VerificationGatesPermission
     * @example
     * // Get one VerificationGatesPermission
     * const verificationGatesPermission = await prisma.verificationGatesPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationGatesPermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationGatesPermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationGatesPermissionClient<$Result.GetResult<Prisma.$VerificationGatesPermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationGatesPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGatesPermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationGatesPermissions
     * const verificationGatesPermissions = await prisma.verificationGatesPermission.findMany()
     * 
     * // Get first 10 VerificationGatesPermissions
     * const verificationGatesPermissions = await prisma.verificationGatesPermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationGatesPermissionWithIdOnly = await prisma.verificationGatesPermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationGatesPermissionFindManyArgs>(args?: SelectSubset<T, VerificationGatesPermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationGatesPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationGatesPermission.
     * @param {VerificationGatesPermissionCreateArgs} args - Arguments to create a VerificationGatesPermission.
     * @example
     * // Create one VerificationGatesPermission
     * const VerificationGatesPermission = await prisma.verificationGatesPermission.create({
     *   data: {
     *     // ... data to create a VerificationGatesPermission
     *   }
     * })
     * 
     */
    create<T extends VerificationGatesPermissionCreateArgs>(args: SelectSubset<T, VerificationGatesPermissionCreateArgs<ExtArgs>>): Prisma__VerificationGatesPermissionClient<$Result.GetResult<Prisma.$VerificationGatesPermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationGatesPermissions.
     * @param {VerificationGatesPermissionCreateManyArgs} args - Arguments to create many VerificationGatesPermissions.
     * @example
     * // Create many VerificationGatesPermissions
     * const verificationGatesPermission = await prisma.verificationGatesPermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationGatesPermissionCreateManyArgs>(args?: SelectSubset<T, VerificationGatesPermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VerificationGatesPermission.
     * @param {VerificationGatesPermissionDeleteArgs} args - Arguments to delete one VerificationGatesPermission.
     * @example
     * // Delete one VerificationGatesPermission
     * const VerificationGatesPermission = await prisma.verificationGatesPermission.delete({
     *   where: {
     *     // ... filter to delete one VerificationGatesPermission
     *   }
     * })
     * 
     */
    delete<T extends VerificationGatesPermissionDeleteArgs>(args: SelectSubset<T, VerificationGatesPermissionDeleteArgs<ExtArgs>>): Prisma__VerificationGatesPermissionClient<$Result.GetResult<Prisma.$VerificationGatesPermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationGatesPermission.
     * @param {VerificationGatesPermissionUpdateArgs} args - Arguments to update one VerificationGatesPermission.
     * @example
     * // Update one VerificationGatesPermission
     * const verificationGatesPermission = await prisma.verificationGatesPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationGatesPermissionUpdateArgs>(args: SelectSubset<T, VerificationGatesPermissionUpdateArgs<ExtArgs>>): Prisma__VerificationGatesPermissionClient<$Result.GetResult<Prisma.$VerificationGatesPermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationGatesPermissions.
     * @param {VerificationGatesPermissionDeleteManyArgs} args - Arguments to filter VerificationGatesPermissions to delete.
     * @example
     * // Delete a few VerificationGatesPermissions
     * const { count } = await prisma.verificationGatesPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationGatesPermissionDeleteManyArgs>(args?: SelectSubset<T, VerificationGatesPermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationGatesPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGatesPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationGatesPermissions
     * const verificationGatesPermission = await prisma.verificationGatesPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationGatesPermissionUpdateManyArgs>(args: SelectSubset<T, VerificationGatesPermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationGatesPermission.
     * @param {VerificationGatesPermissionUpsertArgs} args - Arguments to update or create a VerificationGatesPermission.
     * @example
     * // Update or create a VerificationGatesPermission
     * const verificationGatesPermission = await prisma.verificationGatesPermission.upsert({
     *   create: {
     *     // ... data to create a VerificationGatesPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationGatesPermission we want to update
     *   }
     * })
     */
    upsert<T extends VerificationGatesPermissionUpsertArgs>(args: SelectSubset<T, VerificationGatesPermissionUpsertArgs<ExtArgs>>): Prisma__VerificationGatesPermissionClient<$Result.GetResult<Prisma.$VerificationGatesPermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationGatesPermissions that matches the filter.
     * @param {VerificationGatesPermissionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const verificationGatesPermission = await prisma.verificationGatesPermission.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: VerificationGatesPermissionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a VerificationGatesPermission.
     * @param {VerificationGatesPermissionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const verificationGatesPermission = await prisma.verificationGatesPermission.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: VerificationGatesPermissionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of VerificationGatesPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGatesPermissionCountArgs} args - Arguments to filter VerificationGatesPermissions to count.
     * @example
     * // Count the number of VerificationGatesPermissions
     * const count = await prisma.verificationGatesPermission.count({
     *   where: {
     *     // ... the filter for the VerificationGatesPermissions we want to count
     *   }
     * })
    **/
    count<T extends VerificationGatesPermissionCountArgs>(
      args?: Subset<T, VerificationGatesPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationGatesPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationGatesPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGatesPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationGatesPermissionAggregateArgs>(args: Subset<T, VerificationGatesPermissionAggregateArgs>): Prisma.PrismaPromise<GetVerificationGatesPermissionAggregateType<T>>

    /**
     * Group by VerificationGatesPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGatesPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGatesPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGatesPermissionGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGatesPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGatesPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGatesPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationGatesPermission model
   */
  readonly fields: VerificationGatesPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationGatesPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationGatesPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    VerificationGates<T extends VerificationGatesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VerificationGatesDefaultArgs<ExtArgs>>): Prisma__VerificationGatesClient<$Result.GetResult<Prisma.$VerificationGatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationGatesPermission model
   */
  interface VerificationGatesPermissionFieldRefs {
    readonly id: FieldRef<"VerificationGatesPermission", 'String'>
    readonly Permission: FieldRef<"VerificationGatesPermission", 'String[]'>
    readonly ChannelId: FieldRef<"VerificationGatesPermission", 'String'>
    readonly VerificationGateId: FieldRef<"VerificationGatesPermission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VerificationGatesPermission findUnique
   */
  export type VerificationGatesPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationGatesPermission
     */
    select?: VerificationGatesPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationGatesPermission
     */
    omit?: VerificationGatesPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationGatesPermissionInclude<ExtArgs> | null
    /**
     * Filter, which VerificationGatesPermission to fetch.
     */
    where: VerificationGatesPermissionWhereUniqueInput
  }

  /**
   * VerificationGatesPermission findUniqueOrThrow
   */
  export type VerificationGatesPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationGatesPermission
     */
    select?: VerificationGatesPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationGatesPermission
     */
    omit?: VerificationGatesPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationGatesPermissionInclude<ExtArgs> | null
    /**
     * Filter, which VerificationGatesPermission to fetch.
     */
    where: VerificationGatesPermissionWhereUniqueInput
  }

  /**
   * VerificationGatesPermission findFirst
   */
  export type VerificationGatesPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationGatesPermission
     */
    select?: VerificationGatesPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationGatesPermission
     */
    omit?: VerificationGatesPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationGatesPermissionInclude<ExtArgs> | null
    /**
     * Filter, which VerificationGatesPermission to fetch.
     */
    where?: VerificationGatesPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationGatesPermissions to fetch.
     */
    orderBy?: VerificationGatesPermissionOrderByWithRelationInput | VerificationGatesPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationGatesPermissions.
     */
    cursor?: VerificationGatesPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationGatesPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationGatesPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationGatesPermissions.
     */
    distinct?: VerificationGatesPermissionScalarFieldEnum | VerificationGatesPermissionScalarFieldEnum[]
  }

  /**
   * VerificationGatesPermission findFirstOrThrow
   */
  export type VerificationGatesPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationGatesPermission
     */
    select?: VerificationGatesPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationGatesPermission
     */
    omit?: VerificationGatesPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationGatesPermissionInclude<ExtArgs> | null
    /**
     * Filter, which VerificationGatesPermission to fetch.
     */
    where?: VerificationGatesPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationGatesPermissions to fetch.
     */
    orderBy?: VerificationGatesPermissionOrderByWithRelationInput | VerificationGatesPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationGatesPermissions.
     */
    cursor?: VerificationGatesPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationGatesPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationGatesPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationGatesPermissions.
     */
    distinct?: VerificationGatesPermissionScalarFieldEnum | VerificationGatesPermissionScalarFieldEnum[]
  }

  /**
   * VerificationGatesPermission findMany
   */
  export type VerificationGatesPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationGatesPermission
     */
    select?: VerificationGatesPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationGatesPermission
     */
    omit?: VerificationGatesPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationGatesPermissionInclude<ExtArgs> | null
    /**
     * Filter, which VerificationGatesPermissions to fetch.
     */
    where?: VerificationGatesPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationGatesPermissions to fetch.
     */
    orderBy?: VerificationGatesPermissionOrderByWithRelationInput | VerificationGatesPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationGatesPermissions.
     */
    cursor?: VerificationGatesPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationGatesPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationGatesPermissions.
     */
    skip?: number
    distinct?: VerificationGatesPermissionScalarFieldEnum | VerificationGatesPermissionScalarFieldEnum[]
  }

  /**
   * VerificationGatesPermission create
   */
  export type VerificationGatesPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationGatesPermission
     */
    select?: VerificationGatesPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationGatesPermission
     */
    omit?: VerificationGatesPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationGatesPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a VerificationGatesPermission.
     */
    data: XOR<VerificationGatesPermissionCreateInput, VerificationGatesPermissionUncheckedCreateInput>
  }

  /**
   * VerificationGatesPermission createMany
   */
  export type VerificationGatesPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationGatesPermissions.
     */
    data: VerificationGatesPermissionCreateManyInput | VerificationGatesPermissionCreateManyInput[]
  }

  /**
   * VerificationGatesPermission update
   */
  export type VerificationGatesPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationGatesPermission
     */
    select?: VerificationGatesPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationGatesPermission
     */
    omit?: VerificationGatesPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationGatesPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a VerificationGatesPermission.
     */
    data: XOR<VerificationGatesPermissionUpdateInput, VerificationGatesPermissionUncheckedUpdateInput>
    /**
     * Choose, which VerificationGatesPermission to update.
     */
    where: VerificationGatesPermissionWhereUniqueInput
  }

  /**
   * VerificationGatesPermission updateMany
   */
  export type VerificationGatesPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationGatesPermissions.
     */
    data: XOR<VerificationGatesPermissionUpdateManyMutationInput, VerificationGatesPermissionUncheckedUpdateManyInput>
    /**
     * Filter which VerificationGatesPermissions to update
     */
    where?: VerificationGatesPermissionWhereInput
    /**
     * Limit how many VerificationGatesPermissions to update.
     */
    limit?: number
  }

  /**
   * VerificationGatesPermission upsert
   */
  export type VerificationGatesPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationGatesPermission
     */
    select?: VerificationGatesPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationGatesPermission
     */
    omit?: VerificationGatesPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationGatesPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the VerificationGatesPermission to update in case it exists.
     */
    where: VerificationGatesPermissionWhereUniqueInput
    /**
     * In case the VerificationGatesPermission found by the `where` argument doesn't exist, create a new VerificationGatesPermission with this data.
     */
    create: XOR<VerificationGatesPermissionCreateInput, VerificationGatesPermissionUncheckedCreateInput>
    /**
     * In case the VerificationGatesPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationGatesPermissionUpdateInput, VerificationGatesPermissionUncheckedUpdateInput>
  }

  /**
   * VerificationGatesPermission delete
   */
  export type VerificationGatesPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationGatesPermission
     */
    select?: VerificationGatesPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationGatesPermission
     */
    omit?: VerificationGatesPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationGatesPermissionInclude<ExtArgs> | null
    /**
     * Filter which VerificationGatesPermission to delete.
     */
    where: VerificationGatesPermissionWhereUniqueInput
  }

  /**
   * VerificationGatesPermission deleteMany
   */
  export type VerificationGatesPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationGatesPermissions to delete
     */
    where?: VerificationGatesPermissionWhereInput
    /**
     * Limit how many VerificationGatesPermissions to delete.
     */
    limit?: number
  }

  /**
   * VerificationGatesPermission findRaw
   */
  export type VerificationGatesPermissionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * VerificationGatesPermission aggregateRaw
   */
  export type VerificationGatesPermissionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * VerificationGatesPermission without action
   */
  export type VerificationGatesPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationGatesPermission
     */
    select?: VerificationGatesPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationGatesPermission
     */
    omit?: VerificationGatesPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationGatesPermissionInclude<ExtArgs> | null
  }


  /**
   * Model SpotifyNotifications
   */

  export type AggregateSpotifyNotifications = {
    _count: SpotifyNotificationsCountAggregateOutputType | null
    _min: SpotifyNotificationsMinAggregateOutputType | null
    _max: SpotifyNotificationsMaxAggregateOutputType | null
  }

  export type SpotifyNotificationsMinAggregateOutputType = {
    id: string | null
    ShowId: string | null
    ChannelId: string | null
    MessageTemplateId: string | null
    UUID: string | null
    GuildId: string | null
  }

  export type SpotifyNotificationsMaxAggregateOutputType = {
    id: string | null
    ShowId: string | null
    ChannelId: string | null
    MessageTemplateId: string | null
    UUID: string | null
    GuildId: string | null
  }

  export type SpotifyNotificationsCountAggregateOutputType = {
    id: number
    ShowId: number
    ChannelId: number
    Latests: number
    MessageTemplateId: number
    PingRoles: number
    UUID: number
    GuildId: number
    _all: number
  }


  export type SpotifyNotificationsMinAggregateInputType = {
    id?: true
    ShowId?: true
    ChannelId?: true
    MessageTemplateId?: true
    UUID?: true
    GuildId?: true
  }

  export type SpotifyNotificationsMaxAggregateInputType = {
    id?: true
    ShowId?: true
    ChannelId?: true
    MessageTemplateId?: true
    UUID?: true
    GuildId?: true
  }

  export type SpotifyNotificationsCountAggregateInputType = {
    id?: true
    ShowId?: true
    ChannelId?: true
    Latests?: true
    MessageTemplateId?: true
    PingRoles?: true
    UUID?: true
    GuildId?: true
    _all?: true
  }

  export type SpotifyNotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpotifyNotifications to aggregate.
     */
    where?: SpotifyNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpotifyNotifications to fetch.
     */
    orderBy?: SpotifyNotificationsOrderByWithRelationInput | SpotifyNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpotifyNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpotifyNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpotifyNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpotifyNotifications
    **/
    _count?: true | SpotifyNotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpotifyNotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpotifyNotificationsMaxAggregateInputType
  }

  export type GetSpotifyNotificationsAggregateType<T extends SpotifyNotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateSpotifyNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpotifyNotifications[P]>
      : GetScalarType<T[P], AggregateSpotifyNotifications[P]>
  }




  export type SpotifyNotificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpotifyNotificationsWhereInput
    orderBy?: SpotifyNotificationsOrderByWithAggregationInput | SpotifyNotificationsOrderByWithAggregationInput[]
    by: SpotifyNotificationsScalarFieldEnum[] | SpotifyNotificationsScalarFieldEnum
    having?: SpotifyNotificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpotifyNotificationsCountAggregateInputType | true
    _min?: SpotifyNotificationsMinAggregateInputType
    _max?: SpotifyNotificationsMaxAggregateInputType
  }

  export type SpotifyNotificationsGroupByOutputType = {
    id: string
    ShowId: string
    ChannelId: string
    Latests: string[]
    MessageTemplateId: string
    PingRoles: string[]
    UUID: string
    GuildId: string
    _count: SpotifyNotificationsCountAggregateOutputType | null
    _min: SpotifyNotificationsMinAggregateOutputType | null
    _max: SpotifyNotificationsMaxAggregateOutputType | null
  }

  type GetSpotifyNotificationsGroupByPayload<T extends SpotifyNotificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpotifyNotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpotifyNotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpotifyNotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], SpotifyNotificationsGroupByOutputType[P]>
        }
      >
    >


  export type SpotifyNotificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ShowId?: boolean
    ChannelId?: boolean
    Latests?: boolean
    MessageTemplateId?: boolean
    PingRoles?: boolean
    UUID?: boolean
    GuildId?: boolean
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spotifyNotifications"]>



  export type SpotifyNotificationsSelectScalar = {
    id?: boolean
    ShowId?: boolean
    ChannelId?: boolean
    Latests?: boolean
    MessageTemplateId?: boolean
    PingRoles?: boolean
    UUID?: boolean
    GuildId?: boolean
  }

  export type SpotifyNotificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ShowId" | "ChannelId" | "Latests" | "MessageTemplateId" | "PingRoles" | "UUID" | "GuildId", ExtArgs["result"]["spotifyNotifications"]>
  export type SpotifyNotificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }

  export type $SpotifyNotificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpotifyNotifications"
    objects: {
      Guilds: Prisma.$GuildsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ShowId: string
      ChannelId: string
      Latests: string[]
      MessageTemplateId: string
      PingRoles: string[]
      UUID: string
      GuildId: string
    }, ExtArgs["result"]["spotifyNotifications"]>
    composites: {}
  }

  type SpotifyNotificationsGetPayload<S extends boolean | null | undefined | SpotifyNotificationsDefaultArgs> = $Result.GetResult<Prisma.$SpotifyNotificationsPayload, S>

  type SpotifyNotificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpotifyNotificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpotifyNotificationsCountAggregateInputType | true
    }

  export interface SpotifyNotificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpotifyNotifications'], meta: { name: 'SpotifyNotifications' } }
    /**
     * Find zero or one SpotifyNotifications that matches the filter.
     * @param {SpotifyNotificationsFindUniqueArgs} args - Arguments to find a SpotifyNotifications
     * @example
     * // Get one SpotifyNotifications
     * const spotifyNotifications = await prisma.spotifyNotifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpotifyNotificationsFindUniqueArgs>(args: SelectSubset<T, SpotifyNotificationsFindUniqueArgs<ExtArgs>>): Prisma__SpotifyNotificationsClient<$Result.GetResult<Prisma.$SpotifyNotificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpotifyNotifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpotifyNotificationsFindUniqueOrThrowArgs} args - Arguments to find a SpotifyNotifications
     * @example
     * // Get one SpotifyNotifications
     * const spotifyNotifications = await prisma.spotifyNotifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpotifyNotificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, SpotifyNotificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpotifyNotificationsClient<$Result.GetResult<Prisma.$SpotifyNotificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpotifyNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpotifyNotificationsFindFirstArgs} args - Arguments to find a SpotifyNotifications
     * @example
     * // Get one SpotifyNotifications
     * const spotifyNotifications = await prisma.spotifyNotifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpotifyNotificationsFindFirstArgs>(args?: SelectSubset<T, SpotifyNotificationsFindFirstArgs<ExtArgs>>): Prisma__SpotifyNotificationsClient<$Result.GetResult<Prisma.$SpotifyNotificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpotifyNotifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpotifyNotificationsFindFirstOrThrowArgs} args - Arguments to find a SpotifyNotifications
     * @example
     * // Get one SpotifyNotifications
     * const spotifyNotifications = await prisma.spotifyNotifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpotifyNotificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, SpotifyNotificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpotifyNotificationsClient<$Result.GetResult<Prisma.$SpotifyNotificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpotifyNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpotifyNotificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpotifyNotifications
     * const spotifyNotifications = await prisma.spotifyNotifications.findMany()
     * 
     * // Get first 10 SpotifyNotifications
     * const spotifyNotifications = await prisma.spotifyNotifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spotifyNotificationsWithIdOnly = await prisma.spotifyNotifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpotifyNotificationsFindManyArgs>(args?: SelectSubset<T, SpotifyNotificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpotifyNotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpotifyNotifications.
     * @param {SpotifyNotificationsCreateArgs} args - Arguments to create a SpotifyNotifications.
     * @example
     * // Create one SpotifyNotifications
     * const SpotifyNotifications = await prisma.spotifyNotifications.create({
     *   data: {
     *     // ... data to create a SpotifyNotifications
     *   }
     * })
     * 
     */
    create<T extends SpotifyNotificationsCreateArgs>(args: SelectSubset<T, SpotifyNotificationsCreateArgs<ExtArgs>>): Prisma__SpotifyNotificationsClient<$Result.GetResult<Prisma.$SpotifyNotificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpotifyNotifications.
     * @param {SpotifyNotificationsCreateManyArgs} args - Arguments to create many SpotifyNotifications.
     * @example
     * // Create many SpotifyNotifications
     * const spotifyNotifications = await prisma.spotifyNotifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpotifyNotificationsCreateManyArgs>(args?: SelectSubset<T, SpotifyNotificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SpotifyNotifications.
     * @param {SpotifyNotificationsDeleteArgs} args - Arguments to delete one SpotifyNotifications.
     * @example
     * // Delete one SpotifyNotifications
     * const SpotifyNotifications = await prisma.spotifyNotifications.delete({
     *   where: {
     *     // ... filter to delete one SpotifyNotifications
     *   }
     * })
     * 
     */
    delete<T extends SpotifyNotificationsDeleteArgs>(args: SelectSubset<T, SpotifyNotificationsDeleteArgs<ExtArgs>>): Prisma__SpotifyNotificationsClient<$Result.GetResult<Prisma.$SpotifyNotificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpotifyNotifications.
     * @param {SpotifyNotificationsUpdateArgs} args - Arguments to update one SpotifyNotifications.
     * @example
     * // Update one SpotifyNotifications
     * const spotifyNotifications = await prisma.spotifyNotifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpotifyNotificationsUpdateArgs>(args: SelectSubset<T, SpotifyNotificationsUpdateArgs<ExtArgs>>): Prisma__SpotifyNotificationsClient<$Result.GetResult<Prisma.$SpotifyNotificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpotifyNotifications.
     * @param {SpotifyNotificationsDeleteManyArgs} args - Arguments to filter SpotifyNotifications to delete.
     * @example
     * // Delete a few SpotifyNotifications
     * const { count } = await prisma.spotifyNotifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpotifyNotificationsDeleteManyArgs>(args?: SelectSubset<T, SpotifyNotificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpotifyNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpotifyNotificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpotifyNotifications
     * const spotifyNotifications = await prisma.spotifyNotifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpotifyNotificationsUpdateManyArgs>(args: SelectSubset<T, SpotifyNotificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpotifyNotifications.
     * @param {SpotifyNotificationsUpsertArgs} args - Arguments to update or create a SpotifyNotifications.
     * @example
     * // Update or create a SpotifyNotifications
     * const spotifyNotifications = await prisma.spotifyNotifications.upsert({
     *   create: {
     *     // ... data to create a SpotifyNotifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpotifyNotifications we want to update
     *   }
     * })
     */
    upsert<T extends SpotifyNotificationsUpsertArgs>(args: SelectSubset<T, SpotifyNotificationsUpsertArgs<ExtArgs>>): Prisma__SpotifyNotificationsClient<$Result.GetResult<Prisma.$SpotifyNotificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpotifyNotifications that matches the filter.
     * @param {SpotifyNotificationsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const spotifyNotifications = await prisma.spotifyNotifications.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SpotifyNotificationsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SpotifyNotifications.
     * @param {SpotifyNotificationsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const spotifyNotifications = await prisma.spotifyNotifications.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SpotifyNotificationsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SpotifyNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpotifyNotificationsCountArgs} args - Arguments to filter SpotifyNotifications to count.
     * @example
     * // Count the number of SpotifyNotifications
     * const count = await prisma.spotifyNotifications.count({
     *   where: {
     *     // ... the filter for the SpotifyNotifications we want to count
     *   }
     * })
    **/
    count<T extends SpotifyNotificationsCountArgs>(
      args?: Subset<T, SpotifyNotificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpotifyNotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpotifyNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpotifyNotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpotifyNotificationsAggregateArgs>(args: Subset<T, SpotifyNotificationsAggregateArgs>): Prisma.PrismaPromise<GetSpotifyNotificationsAggregateType<T>>

    /**
     * Group by SpotifyNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpotifyNotificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpotifyNotificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpotifyNotificationsGroupByArgs['orderBy'] }
        : { orderBy?: SpotifyNotificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpotifyNotificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpotifyNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpotifyNotifications model
   */
  readonly fields: SpotifyNotificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpotifyNotifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpotifyNotificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpotifyNotifications model
   */
  interface SpotifyNotificationsFieldRefs {
    readonly id: FieldRef<"SpotifyNotifications", 'String'>
    readonly ShowId: FieldRef<"SpotifyNotifications", 'String'>
    readonly ChannelId: FieldRef<"SpotifyNotifications", 'String'>
    readonly Latests: FieldRef<"SpotifyNotifications", 'String[]'>
    readonly MessageTemplateId: FieldRef<"SpotifyNotifications", 'String'>
    readonly PingRoles: FieldRef<"SpotifyNotifications", 'String[]'>
    readonly UUID: FieldRef<"SpotifyNotifications", 'String'>
    readonly GuildId: FieldRef<"SpotifyNotifications", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SpotifyNotifications findUnique
   */
  export type SpotifyNotificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpotifyNotifications
     */
    select?: SpotifyNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpotifyNotifications
     */
    omit?: SpotifyNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpotifyNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which SpotifyNotifications to fetch.
     */
    where: SpotifyNotificationsWhereUniqueInput
  }

  /**
   * SpotifyNotifications findUniqueOrThrow
   */
  export type SpotifyNotificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpotifyNotifications
     */
    select?: SpotifyNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpotifyNotifications
     */
    omit?: SpotifyNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpotifyNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which SpotifyNotifications to fetch.
     */
    where: SpotifyNotificationsWhereUniqueInput
  }

  /**
   * SpotifyNotifications findFirst
   */
  export type SpotifyNotificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpotifyNotifications
     */
    select?: SpotifyNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpotifyNotifications
     */
    omit?: SpotifyNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpotifyNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which SpotifyNotifications to fetch.
     */
    where?: SpotifyNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpotifyNotifications to fetch.
     */
    orderBy?: SpotifyNotificationsOrderByWithRelationInput | SpotifyNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpotifyNotifications.
     */
    cursor?: SpotifyNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpotifyNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpotifyNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpotifyNotifications.
     */
    distinct?: SpotifyNotificationsScalarFieldEnum | SpotifyNotificationsScalarFieldEnum[]
  }

  /**
   * SpotifyNotifications findFirstOrThrow
   */
  export type SpotifyNotificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpotifyNotifications
     */
    select?: SpotifyNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpotifyNotifications
     */
    omit?: SpotifyNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpotifyNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which SpotifyNotifications to fetch.
     */
    where?: SpotifyNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpotifyNotifications to fetch.
     */
    orderBy?: SpotifyNotificationsOrderByWithRelationInput | SpotifyNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpotifyNotifications.
     */
    cursor?: SpotifyNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpotifyNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpotifyNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpotifyNotifications.
     */
    distinct?: SpotifyNotificationsScalarFieldEnum | SpotifyNotificationsScalarFieldEnum[]
  }

  /**
   * SpotifyNotifications findMany
   */
  export type SpotifyNotificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpotifyNotifications
     */
    select?: SpotifyNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpotifyNotifications
     */
    omit?: SpotifyNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpotifyNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which SpotifyNotifications to fetch.
     */
    where?: SpotifyNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpotifyNotifications to fetch.
     */
    orderBy?: SpotifyNotificationsOrderByWithRelationInput | SpotifyNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpotifyNotifications.
     */
    cursor?: SpotifyNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpotifyNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpotifyNotifications.
     */
    skip?: number
    distinct?: SpotifyNotificationsScalarFieldEnum | SpotifyNotificationsScalarFieldEnum[]
  }

  /**
   * SpotifyNotifications create
   */
  export type SpotifyNotificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpotifyNotifications
     */
    select?: SpotifyNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpotifyNotifications
     */
    omit?: SpotifyNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpotifyNotificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a SpotifyNotifications.
     */
    data: XOR<SpotifyNotificationsCreateInput, SpotifyNotificationsUncheckedCreateInput>
  }

  /**
   * SpotifyNotifications createMany
   */
  export type SpotifyNotificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpotifyNotifications.
     */
    data: SpotifyNotificationsCreateManyInput | SpotifyNotificationsCreateManyInput[]
  }

  /**
   * SpotifyNotifications update
   */
  export type SpotifyNotificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpotifyNotifications
     */
    select?: SpotifyNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpotifyNotifications
     */
    omit?: SpotifyNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpotifyNotificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a SpotifyNotifications.
     */
    data: XOR<SpotifyNotificationsUpdateInput, SpotifyNotificationsUncheckedUpdateInput>
    /**
     * Choose, which SpotifyNotifications to update.
     */
    where: SpotifyNotificationsWhereUniqueInput
  }

  /**
   * SpotifyNotifications updateMany
   */
  export type SpotifyNotificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpotifyNotifications.
     */
    data: XOR<SpotifyNotificationsUpdateManyMutationInput, SpotifyNotificationsUncheckedUpdateManyInput>
    /**
     * Filter which SpotifyNotifications to update
     */
    where?: SpotifyNotificationsWhereInput
    /**
     * Limit how many SpotifyNotifications to update.
     */
    limit?: number
  }

  /**
   * SpotifyNotifications upsert
   */
  export type SpotifyNotificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpotifyNotifications
     */
    select?: SpotifyNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpotifyNotifications
     */
    omit?: SpotifyNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpotifyNotificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the SpotifyNotifications to update in case it exists.
     */
    where: SpotifyNotificationsWhereUniqueInput
    /**
     * In case the SpotifyNotifications found by the `where` argument doesn't exist, create a new SpotifyNotifications with this data.
     */
    create: XOR<SpotifyNotificationsCreateInput, SpotifyNotificationsUncheckedCreateInput>
    /**
     * In case the SpotifyNotifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpotifyNotificationsUpdateInput, SpotifyNotificationsUncheckedUpdateInput>
  }

  /**
   * SpotifyNotifications delete
   */
  export type SpotifyNotificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpotifyNotifications
     */
    select?: SpotifyNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpotifyNotifications
     */
    omit?: SpotifyNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpotifyNotificationsInclude<ExtArgs> | null
    /**
     * Filter which SpotifyNotifications to delete.
     */
    where: SpotifyNotificationsWhereUniqueInput
  }

  /**
   * SpotifyNotifications deleteMany
   */
  export type SpotifyNotificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpotifyNotifications to delete
     */
    where?: SpotifyNotificationsWhereInput
    /**
     * Limit how many SpotifyNotifications to delete.
     */
    limit?: number
  }

  /**
   * SpotifyNotifications findRaw
   */
  export type SpotifyNotificationsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SpotifyNotifications aggregateRaw
   */
  export type SpotifyNotificationsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SpotifyNotifications without action
   */
  export type SpotifyNotificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpotifyNotifications
     */
    select?: SpotifyNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpotifyNotifications
     */
    omit?: SpotifyNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpotifyNotificationsInclude<ExtArgs> | null
  }


  /**
   * Model Tags
   */

  export type AggregateTags = {
    _count: TagsCountAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  export type TagsMinAggregateOutputType = {
    id: string | null
    UUID: string | null
    TagId: string | null
    MessageId: string | null
    IsShlashCommand: boolean | null
    ShlashCommandId: string | null
    IsTextInputCommand: boolean | null
    IsEnabled: boolean | null
    PermissionRoleId: string | null
    CommandDescription: string | null
    GuildId: string | null
  }

  export type TagsMaxAggregateOutputType = {
    id: string | null
    UUID: string | null
    TagId: string | null
    MessageId: string | null
    IsShlashCommand: boolean | null
    ShlashCommandId: string | null
    IsTextInputCommand: boolean | null
    IsEnabled: boolean | null
    PermissionRoleId: string | null
    CommandDescription: string | null
    GuildId: string | null
  }

  export type TagsCountAggregateOutputType = {
    id: number
    UUID: number
    TagId: number
    MessageId: number
    IsShlashCommand: number
    ShlashCommandId: number
    IsTextInputCommand: number
    IsEnabled: number
    PermissionRoleId: number
    CommandDescription: number
    FilterTextFromMessages: number
    GuildId: number
    _all: number
  }


  export type TagsMinAggregateInputType = {
    id?: true
    UUID?: true
    TagId?: true
    MessageId?: true
    IsShlashCommand?: true
    ShlashCommandId?: true
    IsTextInputCommand?: true
    IsEnabled?: true
    PermissionRoleId?: true
    CommandDescription?: true
    GuildId?: true
  }

  export type TagsMaxAggregateInputType = {
    id?: true
    UUID?: true
    TagId?: true
    MessageId?: true
    IsShlashCommand?: true
    ShlashCommandId?: true
    IsTextInputCommand?: true
    IsEnabled?: true
    PermissionRoleId?: true
    CommandDescription?: true
    GuildId?: true
  }

  export type TagsCountAggregateInputType = {
    id?: true
    UUID?: true
    TagId?: true
    MessageId?: true
    IsShlashCommand?: true
    ShlashCommandId?: true
    IsTextInputCommand?: true
    IsEnabled?: true
    PermissionRoleId?: true
    CommandDescription?: true
    FilterTextFromMessages?: true
    GuildId?: true
    _all?: true
  }

  export type TagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to aggregate.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagsMaxAggregateInputType
  }

  export type GetTagsAggregateType<T extends TagsAggregateArgs> = {
        [P in keyof T & keyof AggregateTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTags[P]>
      : GetScalarType<T[P], AggregateTags[P]>
  }




  export type TagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagsWhereInput
    orderBy?: TagsOrderByWithAggregationInput | TagsOrderByWithAggregationInput[]
    by: TagsScalarFieldEnum[] | TagsScalarFieldEnum
    having?: TagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagsCountAggregateInputType | true
    _min?: TagsMinAggregateInputType
    _max?: TagsMaxAggregateInputType
  }

  export type TagsGroupByOutputType = {
    id: string
    UUID: string
    TagId: string
    MessageId: string
    IsShlashCommand: boolean
    ShlashCommandId: string
    IsTextInputCommand: boolean
    IsEnabled: boolean
    PermissionRoleId: string | null
    CommandDescription: string | null
    FilterTextFromMessages: string[]
    GuildId: string
    _count: TagsCountAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  type GetTagsGroupByPayload<T extends TagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagsGroupByOutputType[P]>
            : GetScalarType<T[P], TagsGroupByOutputType[P]>
        }
      >
    >


  export type TagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    UUID?: boolean
    TagId?: boolean
    MessageId?: boolean
    IsShlashCommand?: boolean
    ShlashCommandId?: boolean
    IsTextInputCommand?: boolean
    IsEnabled?: boolean
    PermissionRoleId?: boolean
    CommandDescription?: boolean
    FilterTextFromMessages?: boolean
    GuildId?: boolean
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tags"]>



  export type TagsSelectScalar = {
    id?: boolean
    UUID?: boolean
    TagId?: boolean
    MessageId?: boolean
    IsShlashCommand?: boolean
    ShlashCommandId?: boolean
    IsTextInputCommand?: boolean
    IsEnabled?: boolean
    PermissionRoleId?: boolean
    CommandDescription?: boolean
    FilterTextFromMessages?: boolean
    GuildId?: boolean
  }

  export type TagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "UUID" | "TagId" | "MessageId" | "IsShlashCommand" | "ShlashCommandId" | "IsTextInputCommand" | "IsEnabled" | "PermissionRoleId" | "CommandDescription" | "FilterTextFromMessages" | "GuildId", ExtArgs["result"]["tags"]>
  export type TagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }

  export type $TagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tags"
    objects: {
      Guilds: Prisma.$GuildsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      UUID: string
      TagId: string
      MessageId: string
      IsShlashCommand: boolean
      ShlashCommandId: string
      IsTextInputCommand: boolean
      IsEnabled: boolean
      PermissionRoleId: string | null
      CommandDescription: string | null
      FilterTextFromMessages: string[]
      GuildId: string
    }, ExtArgs["result"]["tags"]>
    composites: {}
  }

  type TagsGetPayload<S extends boolean | null | undefined | TagsDefaultArgs> = $Result.GetResult<Prisma.$TagsPayload, S>

  type TagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagsCountAggregateInputType | true
    }

  export interface TagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tags'], meta: { name: 'Tags' } }
    /**
     * Find zero or one Tags that matches the filter.
     * @param {TagsFindUniqueArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagsFindUniqueArgs>(args: SelectSubset<T, TagsFindUniqueArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagsFindUniqueOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagsFindUniqueOrThrowArgs>(args: SelectSubset<T, TagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindFirstArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagsFindFirstArgs>(args?: SelectSubset<T, TagsFindFirstArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindFirstOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagsFindFirstOrThrowArgs>(args?: SelectSubset<T, TagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tags.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagsWithIdOnly = await prisma.tags.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagsFindManyArgs>(args?: SelectSubset<T, TagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tags.
     * @param {TagsCreateArgs} args - Arguments to create a Tags.
     * @example
     * // Create one Tags
     * const Tags = await prisma.tags.create({
     *   data: {
     *     // ... data to create a Tags
     *   }
     * })
     * 
     */
    create<T extends TagsCreateArgs>(args: SelectSubset<T, TagsCreateArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagsCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tags = await prisma.tags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagsCreateManyArgs>(args?: SelectSubset<T, TagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tags.
     * @param {TagsDeleteArgs} args - Arguments to delete one Tags.
     * @example
     * // Delete one Tags
     * const Tags = await prisma.tags.delete({
     *   where: {
     *     // ... filter to delete one Tags
     *   }
     * })
     * 
     */
    delete<T extends TagsDeleteArgs>(args: SelectSubset<T, TagsDeleteArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tags.
     * @param {TagsUpdateArgs} args - Arguments to update one Tags.
     * @example
     * // Update one Tags
     * const tags = await prisma.tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagsUpdateArgs>(args: SelectSubset<T, TagsUpdateArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagsDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagsDeleteManyArgs>(args?: SelectSubset<T, TagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tags = await prisma.tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagsUpdateManyArgs>(args: SelectSubset<T, TagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tags.
     * @param {TagsUpsertArgs} args - Arguments to update or create a Tags.
     * @example
     * // Update or create a Tags
     * const tags = await prisma.tags.upsert({
     *   create: {
     *     // ... data to create a Tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tags we want to update
     *   }
     * })
     */
    upsert<T extends TagsUpsertArgs>(args: SelectSubset<T, TagsUpsertArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * @param {TagsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tags = await prisma.tags.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TagsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Tags.
     * @param {TagsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tags = await prisma.tags.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TagsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tags.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagsCountArgs>(
      args?: Subset<T, TagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagsAggregateArgs>(args: Subset<T, TagsAggregateArgs>): Prisma.PrismaPromise<GetTagsAggregateType<T>>

    /**
     * Group by Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagsGroupByArgs['orderBy'] }
        : { orderBy?: TagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tags model
   */
  readonly fields: TagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tags model
   */
  interface TagsFieldRefs {
    readonly id: FieldRef<"Tags", 'String'>
    readonly UUID: FieldRef<"Tags", 'String'>
    readonly TagId: FieldRef<"Tags", 'String'>
    readonly MessageId: FieldRef<"Tags", 'String'>
    readonly IsShlashCommand: FieldRef<"Tags", 'Boolean'>
    readonly ShlashCommandId: FieldRef<"Tags", 'String'>
    readonly IsTextInputCommand: FieldRef<"Tags", 'Boolean'>
    readonly IsEnabled: FieldRef<"Tags", 'Boolean'>
    readonly PermissionRoleId: FieldRef<"Tags", 'String'>
    readonly CommandDescription: FieldRef<"Tags", 'String'>
    readonly FilterTextFromMessages: FieldRef<"Tags", 'String[]'>
    readonly GuildId: FieldRef<"Tags", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tags findUnique
   */
  export type TagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags findUniqueOrThrow
   */
  export type TagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags findFirst
   */
  export type TagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags findFirstOrThrow
   */
  export type TagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags findMany
   */
  export type TagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags create
   */
  export type TagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * The data needed to create a Tags.
     */
    data: XOR<TagsCreateInput, TagsUncheckedCreateInput>
  }

  /**
   * Tags createMany
   */
  export type TagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagsCreateManyInput | TagsCreateManyInput[]
  }

  /**
   * Tags update
   */
  export type TagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * The data needed to update a Tags.
     */
    data: XOR<TagsUpdateInput, TagsUncheckedUpdateInput>
    /**
     * Choose, which Tags to update.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags updateMany
   */
  export type TagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagsUpdateManyMutationInput, TagsUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagsWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tags upsert
   */
  export type TagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * The filter to search for the Tags to update in case it exists.
     */
    where: TagsWhereUniqueInput
    /**
     * In case the Tags found by the `where` argument doesn't exist, create a new Tags with this data.
     */
    create: XOR<TagsCreateInput, TagsUncheckedCreateInput>
    /**
     * In case the Tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagsUpdateInput, TagsUncheckedUpdateInput>
  }

  /**
   * Tags delete
   */
  export type TagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter which Tags to delete.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags deleteMany
   */
  export type TagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagsWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tags findRaw
   */
  export type TagsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Tags aggregateRaw
   */
  export type TagsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Tags without action
   */
  export type TagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
  }


  /**
   * Model TicketSetups
   */

  export type AggregateTicketSetups = {
    _count: TicketSetupsCountAggregateOutputType | null
    _avg: TicketSetupsAvgAggregateOutputType | null
    _sum: TicketSetupsSumAggregateOutputType | null
    _min: TicketSetupsMinAggregateOutputType | null
    _max: TicketSetupsMaxAggregateOutputType | null
  }

  export type TicketSetupsAvgAggregateOutputType = {
    ChannelType: number | null
    TicketLimit: number | null
    TicketCreationCooldownPerUser: number | null
    AutoCloseAfterInactivity: number | null
  }

  export type TicketSetupsSumAggregateOutputType = {
    ChannelType: number | null
    TicketLimit: number | null
    TicketCreationCooldownPerUser: number | null
    AutoCloseAfterInactivity: number | null
  }

  export type TicketSetupsMinAggregateOutputType = {
    id: string | null
    CategoryId: string | null
    CustomId: string | null
    TicketChannelName: string | null
    ChannelType: number | null
    MessageTempleateId: string | null
    TranscriptChannelId: string | null
    HasModal: boolean | null
    UserDMWhenCloseMessageTemplateId: string | null
    TicketLimit: number | null
    WithTicketFeedback: boolean | null
    TicketFeedbackChannelId: string | null
    ModalTitle: string | null
    TicketCreationCooldownPerUser: number | null
    AutoCloseAfterInactivity: number | null
    AutoAssignHandler: string | null
    AutoReplyMessageTemplateId: string | null
    OpenTicketWithCommand: boolean | null
    SlashCommandId: string | null
    TextCommandName: string | null
    SendTranscriptToUser: boolean | null
    GuildId: string | null
  }

  export type TicketSetupsMaxAggregateOutputType = {
    id: string | null
    CategoryId: string | null
    CustomId: string | null
    TicketChannelName: string | null
    ChannelType: number | null
    MessageTempleateId: string | null
    TranscriptChannelId: string | null
    HasModal: boolean | null
    UserDMWhenCloseMessageTemplateId: string | null
    TicketLimit: number | null
    WithTicketFeedback: boolean | null
    TicketFeedbackChannelId: string | null
    ModalTitle: string | null
    TicketCreationCooldownPerUser: number | null
    AutoCloseAfterInactivity: number | null
    AutoAssignHandler: string | null
    AutoReplyMessageTemplateId: string | null
    OpenTicketWithCommand: boolean | null
    SlashCommandId: string | null
    TextCommandName: string | null
    SendTranscriptToUser: boolean | null
    GuildId: string | null
  }

  export type TicketSetupsCountAggregateOutputType = {
    id: number
    CategoryId: number
    Handlers: number
    HandlerWithShadowPing: number
    CustomId: number
    TicketChannelName: number
    ChannelType: number
    MessageTempleateId: number
    TicketBlacklistRoles: number
    TranscriptChannelId: number
    HasModal: number
    UserDMWhenCloseMessageTemplateId: number
    TicketLimit: number
    WithTicketFeedback: number
    TicketFeedbackChannelId: number
    ModalTitle: number
    TicketCreationCooldownPerUser: number
    AutoCloseAfterInactivity: number
    AutoAssignHandler: number
    AutoReplyMessageTemplateId: number
    RequiredRoles: number
    OpenTicketWithCommand: number
    SlashCommandId: number
    TextCommandName: number
    SendTranscriptToUser: number
    GuildId: number
    _all: number
  }


  export type TicketSetupsAvgAggregateInputType = {
    ChannelType?: true
    TicketLimit?: true
    TicketCreationCooldownPerUser?: true
    AutoCloseAfterInactivity?: true
  }

  export type TicketSetupsSumAggregateInputType = {
    ChannelType?: true
    TicketLimit?: true
    TicketCreationCooldownPerUser?: true
    AutoCloseAfterInactivity?: true
  }

  export type TicketSetupsMinAggregateInputType = {
    id?: true
    CategoryId?: true
    CustomId?: true
    TicketChannelName?: true
    ChannelType?: true
    MessageTempleateId?: true
    TranscriptChannelId?: true
    HasModal?: true
    UserDMWhenCloseMessageTemplateId?: true
    TicketLimit?: true
    WithTicketFeedback?: true
    TicketFeedbackChannelId?: true
    ModalTitle?: true
    TicketCreationCooldownPerUser?: true
    AutoCloseAfterInactivity?: true
    AutoAssignHandler?: true
    AutoReplyMessageTemplateId?: true
    OpenTicketWithCommand?: true
    SlashCommandId?: true
    TextCommandName?: true
    SendTranscriptToUser?: true
    GuildId?: true
  }

  export type TicketSetupsMaxAggregateInputType = {
    id?: true
    CategoryId?: true
    CustomId?: true
    TicketChannelName?: true
    ChannelType?: true
    MessageTempleateId?: true
    TranscriptChannelId?: true
    HasModal?: true
    UserDMWhenCloseMessageTemplateId?: true
    TicketLimit?: true
    WithTicketFeedback?: true
    TicketFeedbackChannelId?: true
    ModalTitle?: true
    TicketCreationCooldownPerUser?: true
    AutoCloseAfterInactivity?: true
    AutoAssignHandler?: true
    AutoReplyMessageTemplateId?: true
    OpenTicketWithCommand?: true
    SlashCommandId?: true
    TextCommandName?: true
    SendTranscriptToUser?: true
    GuildId?: true
  }

  export type TicketSetupsCountAggregateInputType = {
    id?: true
    CategoryId?: true
    Handlers?: true
    HandlerWithShadowPing?: true
    CustomId?: true
    TicketChannelName?: true
    ChannelType?: true
    MessageTempleateId?: true
    TicketBlacklistRoles?: true
    TranscriptChannelId?: true
    HasModal?: true
    UserDMWhenCloseMessageTemplateId?: true
    TicketLimit?: true
    WithTicketFeedback?: true
    TicketFeedbackChannelId?: true
    ModalTitle?: true
    TicketCreationCooldownPerUser?: true
    AutoCloseAfterInactivity?: true
    AutoAssignHandler?: true
    AutoReplyMessageTemplateId?: true
    RequiredRoles?: true
    OpenTicketWithCommand?: true
    SlashCommandId?: true
    TextCommandName?: true
    SendTranscriptToUser?: true
    GuildId?: true
    _all?: true
  }

  export type TicketSetupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketSetups to aggregate.
     */
    where?: TicketSetupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketSetups to fetch.
     */
    orderBy?: TicketSetupsOrderByWithRelationInput | TicketSetupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketSetupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketSetups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketSetups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketSetups
    **/
    _count?: true | TicketSetupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketSetupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketSetupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketSetupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketSetupsMaxAggregateInputType
  }

  export type GetTicketSetupsAggregateType<T extends TicketSetupsAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketSetups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketSetups[P]>
      : GetScalarType<T[P], AggregateTicketSetups[P]>
  }




  export type TicketSetupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketSetupsWhereInput
    orderBy?: TicketSetupsOrderByWithAggregationInput | TicketSetupsOrderByWithAggregationInput[]
    by: TicketSetupsScalarFieldEnum[] | TicketSetupsScalarFieldEnum
    having?: TicketSetupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketSetupsCountAggregateInputType | true
    _avg?: TicketSetupsAvgAggregateInputType
    _sum?: TicketSetupsSumAggregateInputType
    _min?: TicketSetupsMinAggregateInputType
    _max?: TicketSetupsMaxAggregateInputType
  }

  export type TicketSetupsGroupByOutputType = {
    id: string
    CategoryId: string | null
    Handlers: string[]
    HandlerWithShadowPing: string[]
    CustomId: string
    TicketChannelName: string | null
    ChannelType: number | null
    MessageTempleateId: string | null
    TicketBlacklistRoles: string[]
    TranscriptChannelId: string | null
    HasModal: boolean | null
    UserDMWhenCloseMessageTemplateId: string | null
    TicketLimit: number | null
    WithTicketFeedback: boolean | null
    TicketFeedbackChannelId: string | null
    ModalTitle: string | null
    TicketCreationCooldownPerUser: number | null
    AutoCloseAfterInactivity: number | null
    AutoAssignHandler: string | null
    AutoReplyMessageTemplateId: string | null
    RequiredRoles: string[]
    OpenTicketWithCommand: boolean | null
    SlashCommandId: string | null
    TextCommandName: string | null
    SendTranscriptToUser: boolean | null
    GuildId: string
    _count: TicketSetupsCountAggregateOutputType | null
    _avg: TicketSetupsAvgAggregateOutputType | null
    _sum: TicketSetupsSumAggregateOutputType | null
    _min: TicketSetupsMinAggregateOutputType | null
    _max: TicketSetupsMaxAggregateOutputType | null
  }

  type GetTicketSetupsGroupByPayload<T extends TicketSetupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketSetupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketSetupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketSetupsGroupByOutputType[P]>
            : GetScalarType<T[P], TicketSetupsGroupByOutputType[P]>
        }
      >
    >


  export type TicketSetupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    CategoryId?: boolean
    Handlers?: boolean
    HandlerWithShadowPing?: boolean
    CustomId?: boolean
    TicketChannelName?: boolean
    ChannelType?: boolean
    MessageTempleateId?: boolean
    TicketBlacklistRoles?: boolean
    TranscriptChannelId?: boolean
    HasModal?: boolean
    UserDMWhenCloseMessageTemplateId?: boolean
    TicketLimit?: boolean
    WithTicketFeedback?: boolean
    TicketFeedbackChannelId?: boolean
    ModalTitle?: boolean
    TicketCreationCooldownPerUser?: boolean
    AutoCloseAfterInactivity?: boolean
    AutoAssignHandler?: boolean
    AutoReplyMessageTemplateId?: boolean
    RequiredRoles?: boolean
    OpenTicketWithCommand?: boolean
    SlashCommandId?: boolean
    TextCommandName?: boolean
    SendTranscriptToUser?: boolean
    GuildId?: boolean
    ModalOptions?: boolean | TicketSetups$ModalOptionsArgs<ExtArgs>
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
    Tickets?: boolean | TicketSetups$TicketsArgs<ExtArgs>
    _count?: boolean | TicketSetupsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketSetups"]>



  export type TicketSetupsSelectScalar = {
    id?: boolean
    CategoryId?: boolean
    Handlers?: boolean
    HandlerWithShadowPing?: boolean
    CustomId?: boolean
    TicketChannelName?: boolean
    ChannelType?: boolean
    MessageTempleateId?: boolean
    TicketBlacklistRoles?: boolean
    TranscriptChannelId?: boolean
    HasModal?: boolean
    UserDMWhenCloseMessageTemplateId?: boolean
    TicketLimit?: boolean
    WithTicketFeedback?: boolean
    TicketFeedbackChannelId?: boolean
    ModalTitle?: boolean
    TicketCreationCooldownPerUser?: boolean
    AutoCloseAfterInactivity?: boolean
    AutoAssignHandler?: boolean
    AutoReplyMessageTemplateId?: boolean
    RequiredRoles?: boolean
    OpenTicketWithCommand?: boolean
    SlashCommandId?: boolean
    TextCommandName?: boolean
    SendTranscriptToUser?: boolean
    GuildId?: boolean
  }

  export type TicketSetupsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "CategoryId" | "Handlers" | "HandlerWithShadowPing" | "CustomId" | "TicketChannelName" | "ChannelType" | "MessageTempleateId" | "TicketBlacklistRoles" | "TranscriptChannelId" | "HasModal" | "UserDMWhenCloseMessageTemplateId" | "TicketLimit" | "WithTicketFeedback" | "TicketFeedbackChannelId" | "ModalTitle" | "TicketCreationCooldownPerUser" | "AutoCloseAfterInactivity" | "AutoAssignHandler" | "AutoReplyMessageTemplateId" | "RequiredRoles" | "OpenTicketWithCommand" | "SlashCommandId" | "TextCommandName" | "SendTranscriptToUser" | "GuildId", ExtArgs["result"]["ticketSetups"]>
  export type TicketSetupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ModalOptions?: boolean | TicketSetups$ModalOptionsArgs<ExtArgs>
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
    Tickets?: boolean | TicketSetups$TicketsArgs<ExtArgs>
    _count?: boolean | TicketSetupsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TicketSetupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketSetups"
    objects: {
      ModalOptions: Prisma.$TicketModalDataPayload<ExtArgs>[]
      Guilds: Prisma.$GuildsPayload<ExtArgs>
      Tickets: Prisma.$TicketsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      CategoryId: string | null
      Handlers: string[]
      HandlerWithShadowPing: string[]
      CustomId: string
      TicketChannelName: string | null
      ChannelType: number | null
      MessageTempleateId: string | null
      TicketBlacklistRoles: string[]
      TranscriptChannelId: string | null
      HasModal: boolean | null
      UserDMWhenCloseMessageTemplateId: string | null
      TicketLimit: number | null
      WithTicketFeedback: boolean | null
      TicketFeedbackChannelId: string | null
      ModalTitle: string | null
      TicketCreationCooldownPerUser: number | null
      AutoCloseAfterInactivity: number | null
      AutoAssignHandler: string | null
      AutoReplyMessageTemplateId: string | null
      RequiredRoles: string[]
      OpenTicketWithCommand: boolean | null
      SlashCommandId: string | null
      TextCommandName: string | null
      SendTranscriptToUser: boolean | null
      GuildId: string
    }, ExtArgs["result"]["ticketSetups"]>
    composites: {}
  }

  type TicketSetupsGetPayload<S extends boolean | null | undefined | TicketSetupsDefaultArgs> = $Result.GetResult<Prisma.$TicketSetupsPayload, S>

  type TicketSetupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketSetupsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketSetupsCountAggregateInputType | true
    }

  export interface TicketSetupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketSetups'], meta: { name: 'TicketSetups' } }
    /**
     * Find zero or one TicketSetups that matches the filter.
     * @param {TicketSetupsFindUniqueArgs} args - Arguments to find a TicketSetups
     * @example
     * // Get one TicketSetups
     * const ticketSetups = await prisma.ticketSetups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketSetupsFindUniqueArgs>(args: SelectSubset<T, TicketSetupsFindUniqueArgs<ExtArgs>>): Prisma__TicketSetupsClient<$Result.GetResult<Prisma.$TicketSetupsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketSetups that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketSetupsFindUniqueOrThrowArgs} args - Arguments to find a TicketSetups
     * @example
     * // Get one TicketSetups
     * const ticketSetups = await prisma.ticketSetups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketSetupsFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketSetupsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketSetupsClient<$Result.GetResult<Prisma.$TicketSetupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketSetups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketSetupsFindFirstArgs} args - Arguments to find a TicketSetups
     * @example
     * // Get one TicketSetups
     * const ticketSetups = await prisma.ticketSetups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketSetupsFindFirstArgs>(args?: SelectSubset<T, TicketSetupsFindFirstArgs<ExtArgs>>): Prisma__TicketSetupsClient<$Result.GetResult<Prisma.$TicketSetupsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketSetups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketSetupsFindFirstOrThrowArgs} args - Arguments to find a TicketSetups
     * @example
     * // Get one TicketSetups
     * const ticketSetups = await prisma.ticketSetups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketSetupsFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketSetupsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketSetupsClient<$Result.GetResult<Prisma.$TicketSetupsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketSetups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketSetupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketSetups
     * const ticketSetups = await prisma.ticketSetups.findMany()
     * 
     * // Get first 10 TicketSetups
     * const ticketSetups = await prisma.ticketSetups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketSetupsWithIdOnly = await prisma.ticketSetups.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketSetupsFindManyArgs>(args?: SelectSubset<T, TicketSetupsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketSetupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketSetups.
     * @param {TicketSetupsCreateArgs} args - Arguments to create a TicketSetups.
     * @example
     * // Create one TicketSetups
     * const TicketSetups = await prisma.ticketSetups.create({
     *   data: {
     *     // ... data to create a TicketSetups
     *   }
     * })
     * 
     */
    create<T extends TicketSetupsCreateArgs>(args: SelectSubset<T, TicketSetupsCreateArgs<ExtArgs>>): Prisma__TicketSetupsClient<$Result.GetResult<Prisma.$TicketSetupsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketSetups.
     * @param {TicketSetupsCreateManyArgs} args - Arguments to create many TicketSetups.
     * @example
     * // Create many TicketSetups
     * const ticketSetups = await prisma.ticketSetups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketSetupsCreateManyArgs>(args?: SelectSubset<T, TicketSetupsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TicketSetups.
     * @param {TicketSetupsDeleteArgs} args - Arguments to delete one TicketSetups.
     * @example
     * // Delete one TicketSetups
     * const TicketSetups = await prisma.ticketSetups.delete({
     *   where: {
     *     // ... filter to delete one TicketSetups
     *   }
     * })
     * 
     */
    delete<T extends TicketSetupsDeleteArgs>(args: SelectSubset<T, TicketSetupsDeleteArgs<ExtArgs>>): Prisma__TicketSetupsClient<$Result.GetResult<Prisma.$TicketSetupsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketSetups.
     * @param {TicketSetupsUpdateArgs} args - Arguments to update one TicketSetups.
     * @example
     * // Update one TicketSetups
     * const ticketSetups = await prisma.ticketSetups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketSetupsUpdateArgs>(args: SelectSubset<T, TicketSetupsUpdateArgs<ExtArgs>>): Prisma__TicketSetupsClient<$Result.GetResult<Prisma.$TicketSetupsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketSetups.
     * @param {TicketSetupsDeleteManyArgs} args - Arguments to filter TicketSetups to delete.
     * @example
     * // Delete a few TicketSetups
     * const { count } = await prisma.ticketSetups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketSetupsDeleteManyArgs>(args?: SelectSubset<T, TicketSetupsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketSetups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketSetupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketSetups
     * const ticketSetups = await prisma.ticketSetups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketSetupsUpdateManyArgs>(args: SelectSubset<T, TicketSetupsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TicketSetups.
     * @param {TicketSetupsUpsertArgs} args - Arguments to update or create a TicketSetups.
     * @example
     * // Update or create a TicketSetups
     * const ticketSetups = await prisma.ticketSetups.upsert({
     *   create: {
     *     // ... data to create a TicketSetups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketSetups we want to update
     *   }
     * })
     */
    upsert<T extends TicketSetupsUpsertArgs>(args: SelectSubset<T, TicketSetupsUpsertArgs<ExtArgs>>): Prisma__TicketSetupsClient<$Result.GetResult<Prisma.$TicketSetupsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketSetups that matches the filter.
     * @param {TicketSetupsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const ticketSetups = await prisma.ticketSetups.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TicketSetupsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TicketSetups.
     * @param {TicketSetupsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const ticketSetups = await prisma.ticketSetups.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TicketSetupsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TicketSetups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketSetupsCountArgs} args - Arguments to filter TicketSetups to count.
     * @example
     * // Count the number of TicketSetups
     * const count = await prisma.ticketSetups.count({
     *   where: {
     *     // ... the filter for the TicketSetups we want to count
     *   }
     * })
    **/
    count<T extends TicketSetupsCountArgs>(
      args?: Subset<T, TicketSetupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketSetupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketSetups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketSetupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketSetupsAggregateArgs>(args: Subset<T, TicketSetupsAggregateArgs>): Prisma.PrismaPromise<GetTicketSetupsAggregateType<T>>

    /**
     * Group by TicketSetups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketSetupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketSetupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketSetupsGroupByArgs['orderBy'] }
        : { orderBy?: TicketSetupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketSetupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketSetupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketSetups model
   */
  readonly fields: TicketSetupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketSetups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketSetupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ModalOptions<T extends TicketSetups$ModalOptionsArgs<ExtArgs> = {}>(args?: Subset<T, TicketSetups$ModalOptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketModalDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Tickets<T extends TicketSetups$TicketsArgs<ExtArgs> = {}>(args?: Subset<T, TicketSetups$TicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketSetups model
   */
  interface TicketSetupsFieldRefs {
    readonly id: FieldRef<"TicketSetups", 'String'>
    readonly CategoryId: FieldRef<"TicketSetups", 'String'>
    readonly Handlers: FieldRef<"TicketSetups", 'String[]'>
    readonly HandlerWithShadowPing: FieldRef<"TicketSetups", 'String[]'>
    readonly CustomId: FieldRef<"TicketSetups", 'String'>
    readonly TicketChannelName: FieldRef<"TicketSetups", 'String'>
    readonly ChannelType: FieldRef<"TicketSetups", 'Int'>
    readonly MessageTempleateId: FieldRef<"TicketSetups", 'String'>
    readonly TicketBlacklistRoles: FieldRef<"TicketSetups", 'String[]'>
    readonly TranscriptChannelId: FieldRef<"TicketSetups", 'String'>
    readonly HasModal: FieldRef<"TicketSetups", 'Boolean'>
    readonly UserDMWhenCloseMessageTemplateId: FieldRef<"TicketSetups", 'String'>
    readonly TicketLimit: FieldRef<"TicketSetups", 'Int'>
    readonly WithTicketFeedback: FieldRef<"TicketSetups", 'Boolean'>
    readonly TicketFeedbackChannelId: FieldRef<"TicketSetups", 'String'>
    readonly ModalTitle: FieldRef<"TicketSetups", 'String'>
    readonly TicketCreationCooldownPerUser: FieldRef<"TicketSetups", 'Int'>
    readonly AutoCloseAfterInactivity: FieldRef<"TicketSetups", 'Int'>
    readonly AutoAssignHandler: FieldRef<"TicketSetups", 'String'>
    readonly AutoReplyMessageTemplateId: FieldRef<"TicketSetups", 'String'>
    readonly RequiredRoles: FieldRef<"TicketSetups", 'String[]'>
    readonly OpenTicketWithCommand: FieldRef<"TicketSetups", 'Boolean'>
    readonly SlashCommandId: FieldRef<"TicketSetups", 'String'>
    readonly TextCommandName: FieldRef<"TicketSetups", 'String'>
    readonly SendTranscriptToUser: FieldRef<"TicketSetups", 'Boolean'>
    readonly GuildId: FieldRef<"TicketSetups", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TicketSetups findUnique
   */
  export type TicketSetupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSetups
     */
    select?: TicketSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketSetups
     */
    omit?: TicketSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketSetupsInclude<ExtArgs> | null
    /**
     * Filter, which TicketSetups to fetch.
     */
    where: TicketSetupsWhereUniqueInput
  }

  /**
   * TicketSetups findUniqueOrThrow
   */
  export type TicketSetupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSetups
     */
    select?: TicketSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketSetups
     */
    omit?: TicketSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketSetupsInclude<ExtArgs> | null
    /**
     * Filter, which TicketSetups to fetch.
     */
    where: TicketSetupsWhereUniqueInput
  }

  /**
   * TicketSetups findFirst
   */
  export type TicketSetupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSetups
     */
    select?: TicketSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketSetups
     */
    omit?: TicketSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketSetupsInclude<ExtArgs> | null
    /**
     * Filter, which TicketSetups to fetch.
     */
    where?: TicketSetupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketSetups to fetch.
     */
    orderBy?: TicketSetupsOrderByWithRelationInput | TicketSetupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketSetups.
     */
    cursor?: TicketSetupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketSetups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketSetups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketSetups.
     */
    distinct?: TicketSetupsScalarFieldEnum | TicketSetupsScalarFieldEnum[]
  }

  /**
   * TicketSetups findFirstOrThrow
   */
  export type TicketSetupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSetups
     */
    select?: TicketSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketSetups
     */
    omit?: TicketSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketSetupsInclude<ExtArgs> | null
    /**
     * Filter, which TicketSetups to fetch.
     */
    where?: TicketSetupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketSetups to fetch.
     */
    orderBy?: TicketSetupsOrderByWithRelationInput | TicketSetupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketSetups.
     */
    cursor?: TicketSetupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketSetups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketSetups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketSetups.
     */
    distinct?: TicketSetupsScalarFieldEnum | TicketSetupsScalarFieldEnum[]
  }

  /**
   * TicketSetups findMany
   */
  export type TicketSetupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSetups
     */
    select?: TicketSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketSetups
     */
    omit?: TicketSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketSetupsInclude<ExtArgs> | null
    /**
     * Filter, which TicketSetups to fetch.
     */
    where?: TicketSetupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketSetups to fetch.
     */
    orderBy?: TicketSetupsOrderByWithRelationInput | TicketSetupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketSetups.
     */
    cursor?: TicketSetupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketSetups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketSetups.
     */
    skip?: number
    distinct?: TicketSetupsScalarFieldEnum | TicketSetupsScalarFieldEnum[]
  }

  /**
   * TicketSetups create
   */
  export type TicketSetupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSetups
     */
    select?: TicketSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketSetups
     */
    omit?: TicketSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketSetupsInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketSetups.
     */
    data: XOR<TicketSetupsCreateInput, TicketSetupsUncheckedCreateInput>
  }

  /**
   * TicketSetups createMany
   */
  export type TicketSetupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketSetups.
     */
    data: TicketSetupsCreateManyInput | TicketSetupsCreateManyInput[]
  }

  /**
   * TicketSetups update
   */
  export type TicketSetupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSetups
     */
    select?: TicketSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketSetups
     */
    omit?: TicketSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketSetupsInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketSetups.
     */
    data: XOR<TicketSetupsUpdateInput, TicketSetupsUncheckedUpdateInput>
    /**
     * Choose, which TicketSetups to update.
     */
    where: TicketSetupsWhereUniqueInput
  }

  /**
   * TicketSetups updateMany
   */
  export type TicketSetupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketSetups.
     */
    data: XOR<TicketSetupsUpdateManyMutationInput, TicketSetupsUncheckedUpdateManyInput>
    /**
     * Filter which TicketSetups to update
     */
    where?: TicketSetupsWhereInput
    /**
     * Limit how many TicketSetups to update.
     */
    limit?: number
  }

  /**
   * TicketSetups upsert
   */
  export type TicketSetupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSetups
     */
    select?: TicketSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketSetups
     */
    omit?: TicketSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketSetupsInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketSetups to update in case it exists.
     */
    where: TicketSetupsWhereUniqueInput
    /**
     * In case the TicketSetups found by the `where` argument doesn't exist, create a new TicketSetups with this data.
     */
    create: XOR<TicketSetupsCreateInput, TicketSetupsUncheckedCreateInput>
    /**
     * In case the TicketSetups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketSetupsUpdateInput, TicketSetupsUncheckedUpdateInput>
  }

  /**
   * TicketSetups delete
   */
  export type TicketSetupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSetups
     */
    select?: TicketSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketSetups
     */
    omit?: TicketSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketSetupsInclude<ExtArgs> | null
    /**
     * Filter which TicketSetups to delete.
     */
    where: TicketSetupsWhereUniqueInput
  }

  /**
   * TicketSetups deleteMany
   */
  export type TicketSetupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketSetups to delete
     */
    where?: TicketSetupsWhereInput
    /**
     * Limit how many TicketSetups to delete.
     */
    limit?: number
  }

  /**
   * TicketSetups findRaw
   */
  export type TicketSetupsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TicketSetups aggregateRaw
   */
  export type TicketSetupsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TicketSetups.ModalOptions
   */
  export type TicketSetups$ModalOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketModalData
     */
    select?: TicketModalDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketModalData
     */
    omit?: TicketModalDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketModalDataInclude<ExtArgs> | null
    where?: TicketModalDataWhereInput
    orderBy?: TicketModalDataOrderByWithRelationInput | TicketModalDataOrderByWithRelationInput[]
    cursor?: TicketModalDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketModalDataScalarFieldEnum | TicketModalDataScalarFieldEnum[]
  }

  /**
   * TicketSetups.Tickets
   */
  export type TicketSetups$TicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    where?: TicketsWhereInput
    orderBy?: TicketsOrderByWithRelationInput | TicketsOrderByWithRelationInput[]
    cursor?: TicketsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * TicketSetups without action
   */
  export type TicketSetupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSetups
     */
    select?: TicketSetupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketSetups
     */
    omit?: TicketSetupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketSetupsInclude<ExtArgs> | null
  }


  /**
   * Model TicketModalData
   */

  export type AggregateTicketModalData = {
    _count: TicketModalDataCountAggregateOutputType | null
    _avg: TicketModalDataAvgAggregateOutputType | null
    _sum: TicketModalDataSumAggregateOutputType | null
    _min: TicketModalDataMinAggregateOutputType | null
    _max: TicketModalDataMaxAggregateOutputType | null
  }

  export type TicketModalDataAvgAggregateOutputType = {
    Type: number | null
  }

  export type TicketModalDataSumAggregateOutputType = {
    Type: number | null
  }

  export type TicketModalDataMinAggregateOutputType = {
    id: string | null
    Name: string | null
    Placeholder: string | null
    Type: number | null
    TicketSetupId: string | null
  }

  export type TicketModalDataMaxAggregateOutputType = {
    id: string | null
    Name: string | null
    Placeholder: string | null
    Type: number | null
    TicketSetupId: string | null
  }

  export type TicketModalDataCountAggregateOutputType = {
    id: number
    Name: number
    Placeholder: number
    Type: number
    TicketSetupId: number
    _all: number
  }


  export type TicketModalDataAvgAggregateInputType = {
    Type?: true
  }

  export type TicketModalDataSumAggregateInputType = {
    Type?: true
  }

  export type TicketModalDataMinAggregateInputType = {
    id?: true
    Name?: true
    Placeholder?: true
    Type?: true
    TicketSetupId?: true
  }

  export type TicketModalDataMaxAggregateInputType = {
    id?: true
    Name?: true
    Placeholder?: true
    Type?: true
    TicketSetupId?: true
  }

  export type TicketModalDataCountAggregateInputType = {
    id?: true
    Name?: true
    Placeholder?: true
    Type?: true
    TicketSetupId?: true
    _all?: true
  }

  export type TicketModalDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketModalData to aggregate.
     */
    where?: TicketModalDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketModalData to fetch.
     */
    orderBy?: TicketModalDataOrderByWithRelationInput | TicketModalDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketModalDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketModalData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketModalData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketModalData
    **/
    _count?: true | TicketModalDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketModalDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketModalDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketModalDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketModalDataMaxAggregateInputType
  }

  export type GetTicketModalDataAggregateType<T extends TicketModalDataAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketModalData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketModalData[P]>
      : GetScalarType<T[P], AggregateTicketModalData[P]>
  }




  export type TicketModalDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketModalDataWhereInput
    orderBy?: TicketModalDataOrderByWithAggregationInput | TicketModalDataOrderByWithAggregationInput[]
    by: TicketModalDataScalarFieldEnum[] | TicketModalDataScalarFieldEnum
    having?: TicketModalDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketModalDataCountAggregateInputType | true
    _avg?: TicketModalDataAvgAggregateInputType
    _sum?: TicketModalDataSumAggregateInputType
    _min?: TicketModalDataMinAggregateInputType
    _max?: TicketModalDataMaxAggregateInputType
  }

  export type TicketModalDataGroupByOutputType = {
    id: string
    Name: string
    Placeholder: string
    Type: number
    TicketSetupId: string
    _count: TicketModalDataCountAggregateOutputType | null
    _avg: TicketModalDataAvgAggregateOutputType | null
    _sum: TicketModalDataSumAggregateOutputType | null
    _min: TicketModalDataMinAggregateOutputType | null
    _max: TicketModalDataMaxAggregateOutputType | null
  }

  type GetTicketModalDataGroupByPayload<T extends TicketModalDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketModalDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketModalDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketModalDataGroupByOutputType[P]>
            : GetScalarType<T[P], TicketModalDataGroupByOutputType[P]>
        }
      >
    >


  export type TicketModalDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Name?: boolean
    Placeholder?: boolean
    Type?: boolean
    TicketSetupId?: boolean
    TicketSetup?: boolean | TicketSetupsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketModalData"]>



  export type TicketModalDataSelectScalar = {
    id?: boolean
    Name?: boolean
    Placeholder?: boolean
    Type?: boolean
    TicketSetupId?: boolean
  }

  export type TicketModalDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Name" | "Placeholder" | "Type" | "TicketSetupId", ExtArgs["result"]["ticketModalData"]>
  export type TicketModalDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TicketSetup?: boolean | TicketSetupsDefaultArgs<ExtArgs>
  }

  export type $TicketModalDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketModalData"
    objects: {
      TicketSetup: Prisma.$TicketSetupsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Name: string
      Placeholder: string
      Type: number
      TicketSetupId: string
    }, ExtArgs["result"]["ticketModalData"]>
    composites: {}
  }

  type TicketModalDataGetPayload<S extends boolean | null | undefined | TicketModalDataDefaultArgs> = $Result.GetResult<Prisma.$TicketModalDataPayload, S>

  type TicketModalDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketModalDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketModalDataCountAggregateInputType | true
    }

  export interface TicketModalDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketModalData'], meta: { name: 'TicketModalData' } }
    /**
     * Find zero or one TicketModalData that matches the filter.
     * @param {TicketModalDataFindUniqueArgs} args - Arguments to find a TicketModalData
     * @example
     * // Get one TicketModalData
     * const ticketModalData = await prisma.ticketModalData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketModalDataFindUniqueArgs>(args: SelectSubset<T, TicketModalDataFindUniqueArgs<ExtArgs>>): Prisma__TicketModalDataClient<$Result.GetResult<Prisma.$TicketModalDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketModalData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketModalDataFindUniqueOrThrowArgs} args - Arguments to find a TicketModalData
     * @example
     * // Get one TicketModalData
     * const ticketModalData = await prisma.ticketModalData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketModalDataFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketModalDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketModalDataClient<$Result.GetResult<Prisma.$TicketModalDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketModalData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketModalDataFindFirstArgs} args - Arguments to find a TicketModalData
     * @example
     * // Get one TicketModalData
     * const ticketModalData = await prisma.ticketModalData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketModalDataFindFirstArgs>(args?: SelectSubset<T, TicketModalDataFindFirstArgs<ExtArgs>>): Prisma__TicketModalDataClient<$Result.GetResult<Prisma.$TicketModalDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketModalData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketModalDataFindFirstOrThrowArgs} args - Arguments to find a TicketModalData
     * @example
     * // Get one TicketModalData
     * const ticketModalData = await prisma.ticketModalData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketModalDataFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketModalDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketModalDataClient<$Result.GetResult<Prisma.$TicketModalDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketModalData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketModalDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketModalData
     * const ticketModalData = await prisma.ticketModalData.findMany()
     * 
     * // Get first 10 TicketModalData
     * const ticketModalData = await prisma.ticketModalData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketModalDataWithIdOnly = await prisma.ticketModalData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketModalDataFindManyArgs>(args?: SelectSubset<T, TicketModalDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketModalDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketModalData.
     * @param {TicketModalDataCreateArgs} args - Arguments to create a TicketModalData.
     * @example
     * // Create one TicketModalData
     * const TicketModalData = await prisma.ticketModalData.create({
     *   data: {
     *     // ... data to create a TicketModalData
     *   }
     * })
     * 
     */
    create<T extends TicketModalDataCreateArgs>(args: SelectSubset<T, TicketModalDataCreateArgs<ExtArgs>>): Prisma__TicketModalDataClient<$Result.GetResult<Prisma.$TicketModalDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketModalData.
     * @param {TicketModalDataCreateManyArgs} args - Arguments to create many TicketModalData.
     * @example
     * // Create many TicketModalData
     * const ticketModalData = await prisma.ticketModalData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketModalDataCreateManyArgs>(args?: SelectSubset<T, TicketModalDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TicketModalData.
     * @param {TicketModalDataDeleteArgs} args - Arguments to delete one TicketModalData.
     * @example
     * // Delete one TicketModalData
     * const TicketModalData = await prisma.ticketModalData.delete({
     *   where: {
     *     // ... filter to delete one TicketModalData
     *   }
     * })
     * 
     */
    delete<T extends TicketModalDataDeleteArgs>(args: SelectSubset<T, TicketModalDataDeleteArgs<ExtArgs>>): Prisma__TicketModalDataClient<$Result.GetResult<Prisma.$TicketModalDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketModalData.
     * @param {TicketModalDataUpdateArgs} args - Arguments to update one TicketModalData.
     * @example
     * // Update one TicketModalData
     * const ticketModalData = await prisma.ticketModalData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketModalDataUpdateArgs>(args: SelectSubset<T, TicketModalDataUpdateArgs<ExtArgs>>): Prisma__TicketModalDataClient<$Result.GetResult<Prisma.$TicketModalDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketModalData.
     * @param {TicketModalDataDeleteManyArgs} args - Arguments to filter TicketModalData to delete.
     * @example
     * // Delete a few TicketModalData
     * const { count } = await prisma.ticketModalData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketModalDataDeleteManyArgs>(args?: SelectSubset<T, TicketModalDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketModalData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketModalDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketModalData
     * const ticketModalData = await prisma.ticketModalData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketModalDataUpdateManyArgs>(args: SelectSubset<T, TicketModalDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TicketModalData.
     * @param {TicketModalDataUpsertArgs} args - Arguments to update or create a TicketModalData.
     * @example
     * // Update or create a TicketModalData
     * const ticketModalData = await prisma.ticketModalData.upsert({
     *   create: {
     *     // ... data to create a TicketModalData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketModalData we want to update
     *   }
     * })
     */
    upsert<T extends TicketModalDataUpsertArgs>(args: SelectSubset<T, TicketModalDataUpsertArgs<ExtArgs>>): Prisma__TicketModalDataClient<$Result.GetResult<Prisma.$TicketModalDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketModalData that matches the filter.
     * @param {TicketModalDataFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const ticketModalData = await prisma.ticketModalData.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TicketModalDataFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TicketModalData.
     * @param {TicketModalDataAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const ticketModalData = await prisma.ticketModalData.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TicketModalDataAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TicketModalData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketModalDataCountArgs} args - Arguments to filter TicketModalData to count.
     * @example
     * // Count the number of TicketModalData
     * const count = await prisma.ticketModalData.count({
     *   where: {
     *     // ... the filter for the TicketModalData we want to count
     *   }
     * })
    **/
    count<T extends TicketModalDataCountArgs>(
      args?: Subset<T, TicketModalDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketModalDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketModalData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketModalDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketModalDataAggregateArgs>(args: Subset<T, TicketModalDataAggregateArgs>): Prisma.PrismaPromise<GetTicketModalDataAggregateType<T>>

    /**
     * Group by TicketModalData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketModalDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketModalDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketModalDataGroupByArgs['orderBy'] }
        : { orderBy?: TicketModalDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketModalDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketModalDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketModalData model
   */
  readonly fields: TicketModalDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketModalData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketModalDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TicketSetup<T extends TicketSetupsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketSetupsDefaultArgs<ExtArgs>>): Prisma__TicketSetupsClient<$Result.GetResult<Prisma.$TicketSetupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketModalData model
   */
  interface TicketModalDataFieldRefs {
    readonly id: FieldRef<"TicketModalData", 'String'>
    readonly Name: FieldRef<"TicketModalData", 'String'>
    readonly Placeholder: FieldRef<"TicketModalData", 'String'>
    readonly Type: FieldRef<"TicketModalData", 'Int'>
    readonly TicketSetupId: FieldRef<"TicketModalData", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TicketModalData findUnique
   */
  export type TicketModalDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketModalData
     */
    select?: TicketModalDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketModalData
     */
    omit?: TicketModalDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketModalDataInclude<ExtArgs> | null
    /**
     * Filter, which TicketModalData to fetch.
     */
    where: TicketModalDataWhereUniqueInput
  }

  /**
   * TicketModalData findUniqueOrThrow
   */
  export type TicketModalDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketModalData
     */
    select?: TicketModalDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketModalData
     */
    omit?: TicketModalDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketModalDataInclude<ExtArgs> | null
    /**
     * Filter, which TicketModalData to fetch.
     */
    where: TicketModalDataWhereUniqueInput
  }

  /**
   * TicketModalData findFirst
   */
  export type TicketModalDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketModalData
     */
    select?: TicketModalDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketModalData
     */
    omit?: TicketModalDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketModalDataInclude<ExtArgs> | null
    /**
     * Filter, which TicketModalData to fetch.
     */
    where?: TicketModalDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketModalData to fetch.
     */
    orderBy?: TicketModalDataOrderByWithRelationInput | TicketModalDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketModalData.
     */
    cursor?: TicketModalDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketModalData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketModalData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketModalData.
     */
    distinct?: TicketModalDataScalarFieldEnum | TicketModalDataScalarFieldEnum[]
  }

  /**
   * TicketModalData findFirstOrThrow
   */
  export type TicketModalDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketModalData
     */
    select?: TicketModalDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketModalData
     */
    omit?: TicketModalDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketModalDataInclude<ExtArgs> | null
    /**
     * Filter, which TicketModalData to fetch.
     */
    where?: TicketModalDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketModalData to fetch.
     */
    orderBy?: TicketModalDataOrderByWithRelationInput | TicketModalDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketModalData.
     */
    cursor?: TicketModalDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketModalData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketModalData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketModalData.
     */
    distinct?: TicketModalDataScalarFieldEnum | TicketModalDataScalarFieldEnum[]
  }

  /**
   * TicketModalData findMany
   */
  export type TicketModalDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketModalData
     */
    select?: TicketModalDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketModalData
     */
    omit?: TicketModalDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketModalDataInclude<ExtArgs> | null
    /**
     * Filter, which TicketModalData to fetch.
     */
    where?: TicketModalDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketModalData to fetch.
     */
    orderBy?: TicketModalDataOrderByWithRelationInput | TicketModalDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketModalData.
     */
    cursor?: TicketModalDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketModalData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketModalData.
     */
    skip?: number
    distinct?: TicketModalDataScalarFieldEnum | TicketModalDataScalarFieldEnum[]
  }

  /**
   * TicketModalData create
   */
  export type TicketModalDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketModalData
     */
    select?: TicketModalDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketModalData
     */
    omit?: TicketModalDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketModalDataInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketModalData.
     */
    data: XOR<TicketModalDataCreateInput, TicketModalDataUncheckedCreateInput>
  }

  /**
   * TicketModalData createMany
   */
  export type TicketModalDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketModalData.
     */
    data: TicketModalDataCreateManyInput | TicketModalDataCreateManyInput[]
  }

  /**
   * TicketModalData update
   */
  export type TicketModalDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketModalData
     */
    select?: TicketModalDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketModalData
     */
    omit?: TicketModalDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketModalDataInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketModalData.
     */
    data: XOR<TicketModalDataUpdateInput, TicketModalDataUncheckedUpdateInput>
    /**
     * Choose, which TicketModalData to update.
     */
    where: TicketModalDataWhereUniqueInput
  }

  /**
   * TicketModalData updateMany
   */
  export type TicketModalDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketModalData.
     */
    data: XOR<TicketModalDataUpdateManyMutationInput, TicketModalDataUncheckedUpdateManyInput>
    /**
     * Filter which TicketModalData to update
     */
    where?: TicketModalDataWhereInput
    /**
     * Limit how many TicketModalData to update.
     */
    limit?: number
  }

  /**
   * TicketModalData upsert
   */
  export type TicketModalDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketModalData
     */
    select?: TicketModalDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketModalData
     */
    omit?: TicketModalDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketModalDataInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketModalData to update in case it exists.
     */
    where: TicketModalDataWhereUniqueInput
    /**
     * In case the TicketModalData found by the `where` argument doesn't exist, create a new TicketModalData with this data.
     */
    create: XOR<TicketModalDataCreateInput, TicketModalDataUncheckedCreateInput>
    /**
     * In case the TicketModalData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketModalDataUpdateInput, TicketModalDataUncheckedUpdateInput>
  }

  /**
   * TicketModalData delete
   */
  export type TicketModalDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketModalData
     */
    select?: TicketModalDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketModalData
     */
    omit?: TicketModalDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketModalDataInclude<ExtArgs> | null
    /**
     * Filter which TicketModalData to delete.
     */
    where: TicketModalDataWhereUniqueInput
  }

  /**
   * TicketModalData deleteMany
   */
  export type TicketModalDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketModalData to delete
     */
    where?: TicketModalDataWhereInput
    /**
     * Limit how many TicketModalData to delete.
     */
    limit?: number
  }

  /**
   * TicketModalData findRaw
   */
  export type TicketModalDataFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TicketModalData aggregateRaw
   */
  export type TicketModalDataAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TicketModalData without action
   */
  export type TicketModalDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketModalData
     */
    select?: TicketModalDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketModalData
     */
    omit?: TicketModalDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketModalDataInclude<ExtArgs> | null
  }


  /**
   * Model TicketHandlers
   */

  export type AggregateTicketHandlers = {
    _count: TicketHandlersCountAggregateOutputType | null
    _min: TicketHandlersMinAggregateOutputType | null
    _max: TicketHandlersMaxAggregateOutputType | null
  }

  export type TicketHandlersMinAggregateOutputType = {
    id: string | null
    DiscordRoleId: string | null
    TicketPermission: string | null
  }

  export type TicketHandlersMaxAggregateOutputType = {
    id: string | null
    DiscordRoleId: string | null
    TicketPermission: string | null
  }

  export type TicketHandlersCountAggregateOutputType = {
    id: number
    DiscordRoleId: number
    TicketPermission: number
    AddedDiscordPermission: number
    RemovedDiscordPermission: number
    _all: number
  }


  export type TicketHandlersMinAggregateInputType = {
    id?: true
    DiscordRoleId?: true
    TicketPermission?: true
  }

  export type TicketHandlersMaxAggregateInputType = {
    id?: true
    DiscordRoleId?: true
    TicketPermission?: true
  }

  export type TicketHandlersCountAggregateInputType = {
    id?: true
    DiscordRoleId?: true
    TicketPermission?: true
    AddedDiscordPermission?: true
    RemovedDiscordPermission?: true
    _all?: true
  }

  export type TicketHandlersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketHandlers to aggregate.
     */
    where?: TicketHandlersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketHandlers to fetch.
     */
    orderBy?: TicketHandlersOrderByWithRelationInput | TicketHandlersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketHandlersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketHandlers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketHandlers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketHandlers
    **/
    _count?: true | TicketHandlersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketHandlersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketHandlersMaxAggregateInputType
  }

  export type GetTicketHandlersAggregateType<T extends TicketHandlersAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketHandlers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketHandlers[P]>
      : GetScalarType<T[P], AggregateTicketHandlers[P]>
  }




  export type TicketHandlersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketHandlersWhereInput
    orderBy?: TicketHandlersOrderByWithAggregationInput | TicketHandlersOrderByWithAggregationInput[]
    by: TicketHandlersScalarFieldEnum[] | TicketHandlersScalarFieldEnum
    having?: TicketHandlersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketHandlersCountAggregateInputType | true
    _min?: TicketHandlersMinAggregateInputType
    _max?: TicketHandlersMaxAggregateInputType
  }

  export type TicketHandlersGroupByOutputType = {
    id: string
    DiscordRoleId: string
    TicketPermission: string | null
    AddedDiscordPermission: string[]
    RemovedDiscordPermission: string[]
    _count: TicketHandlersCountAggregateOutputType | null
    _min: TicketHandlersMinAggregateOutputType | null
    _max: TicketHandlersMaxAggregateOutputType | null
  }

  type GetTicketHandlersGroupByPayload<T extends TicketHandlersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketHandlersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketHandlersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketHandlersGroupByOutputType[P]>
            : GetScalarType<T[P], TicketHandlersGroupByOutputType[P]>
        }
      >
    >


  export type TicketHandlersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    DiscordRoleId?: boolean
    TicketPermission?: boolean
    AddedDiscordPermission?: boolean
    RemovedDiscordPermission?: boolean
  }, ExtArgs["result"]["ticketHandlers"]>



  export type TicketHandlersSelectScalar = {
    id?: boolean
    DiscordRoleId?: boolean
    TicketPermission?: boolean
    AddedDiscordPermission?: boolean
    RemovedDiscordPermission?: boolean
  }

  export type TicketHandlersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "DiscordRoleId" | "TicketPermission" | "AddedDiscordPermission" | "RemovedDiscordPermission", ExtArgs["result"]["ticketHandlers"]>

  export type $TicketHandlersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketHandlers"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      DiscordRoleId: string
      TicketPermission: string | null
      AddedDiscordPermission: string[]
      RemovedDiscordPermission: string[]
    }, ExtArgs["result"]["ticketHandlers"]>
    composites: {}
  }

  type TicketHandlersGetPayload<S extends boolean | null | undefined | TicketHandlersDefaultArgs> = $Result.GetResult<Prisma.$TicketHandlersPayload, S>

  type TicketHandlersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketHandlersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketHandlersCountAggregateInputType | true
    }

  export interface TicketHandlersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketHandlers'], meta: { name: 'TicketHandlers' } }
    /**
     * Find zero or one TicketHandlers that matches the filter.
     * @param {TicketHandlersFindUniqueArgs} args - Arguments to find a TicketHandlers
     * @example
     * // Get one TicketHandlers
     * const ticketHandlers = await prisma.ticketHandlers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketHandlersFindUniqueArgs>(args: SelectSubset<T, TicketHandlersFindUniqueArgs<ExtArgs>>): Prisma__TicketHandlersClient<$Result.GetResult<Prisma.$TicketHandlersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketHandlers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketHandlersFindUniqueOrThrowArgs} args - Arguments to find a TicketHandlers
     * @example
     * // Get one TicketHandlers
     * const ticketHandlers = await prisma.ticketHandlers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketHandlersFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketHandlersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketHandlersClient<$Result.GetResult<Prisma.$TicketHandlersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketHandlers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketHandlersFindFirstArgs} args - Arguments to find a TicketHandlers
     * @example
     * // Get one TicketHandlers
     * const ticketHandlers = await prisma.ticketHandlers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketHandlersFindFirstArgs>(args?: SelectSubset<T, TicketHandlersFindFirstArgs<ExtArgs>>): Prisma__TicketHandlersClient<$Result.GetResult<Prisma.$TicketHandlersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketHandlers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketHandlersFindFirstOrThrowArgs} args - Arguments to find a TicketHandlers
     * @example
     * // Get one TicketHandlers
     * const ticketHandlers = await prisma.ticketHandlers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketHandlersFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketHandlersFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketHandlersClient<$Result.GetResult<Prisma.$TicketHandlersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketHandlers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketHandlersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketHandlers
     * const ticketHandlers = await prisma.ticketHandlers.findMany()
     * 
     * // Get first 10 TicketHandlers
     * const ticketHandlers = await prisma.ticketHandlers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketHandlersWithIdOnly = await prisma.ticketHandlers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketHandlersFindManyArgs>(args?: SelectSubset<T, TicketHandlersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketHandlersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketHandlers.
     * @param {TicketHandlersCreateArgs} args - Arguments to create a TicketHandlers.
     * @example
     * // Create one TicketHandlers
     * const TicketHandlers = await prisma.ticketHandlers.create({
     *   data: {
     *     // ... data to create a TicketHandlers
     *   }
     * })
     * 
     */
    create<T extends TicketHandlersCreateArgs>(args: SelectSubset<T, TicketHandlersCreateArgs<ExtArgs>>): Prisma__TicketHandlersClient<$Result.GetResult<Prisma.$TicketHandlersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketHandlers.
     * @param {TicketHandlersCreateManyArgs} args - Arguments to create many TicketHandlers.
     * @example
     * // Create many TicketHandlers
     * const ticketHandlers = await prisma.ticketHandlers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketHandlersCreateManyArgs>(args?: SelectSubset<T, TicketHandlersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TicketHandlers.
     * @param {TicketHandlersDeleteArgs} args - Arguments to delete one TicketHandlers.
     * @example
     * // Delete one TicketHandlers
     * const TicketHandlers = await prisma.ticketHandlers.delete({
     *   where: {
     *     // ... filter to delete one TicketHandlers
     *   }
     * })
     * 
     */
    delete<T extends TicketHandlersDeleteArgs>(args: SelectSubset<T, TicketHandlersDeleteArgs<ExtArgs>>): Prisma__TicketHandlersClient<$Result.GetResult<Prisma.$TicketHandlersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketHandlers.
     * @param {TicketHandlersUpdateArgs} args - Arguments to update one TicketHandlers.
     * @example
     * // Update one TicketHandlers
     * const ticketHandlers = await prisma.ticketHandlers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketHandlersUpdateArgs>(args: SelectSubset<T, TicketHandlersUpdateArgs<ExtArgs>>): Prisma__TicketHandlersClient<$Result.GetResult<Prisma.$TicketHandlersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketHandlers.
     * @param {TicketHandlersDeleteManyArgs} args - Arguments to filter TicketHandlers to delete.
     * @example
     * // Delete a few TicketHandlers
     * const { count } = await prisma.ticketHandlers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketHandlersDeleteManyArgs>(args?: SelectSubset<T, TicketHandlersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketHandlers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketHandlersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketHandlers
     * const ticketHandlers = await prisma.ticketHandlers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketHandlersUpdateManyArgs>(args: SelectSubset<T, TicketHandlersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TicketHandlers.
     * @param {TicketHandlersUpsertArgs} args - Arguments to update or create a TicketHandlers.
     * @example
     * // Update or create a TicketHandlers
     * const ticketHandlers = await prisma.ticketHandlers.upsert({
     *   create: {
     *     // ... data to create a TicketHandlers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketHandlers we want to update
     *   }
     * })
     */
    upsert<T extends TicketHandlersUpsertArgs>(args: SelectSubset<T, TicketHandlersUpsertArgs<ExtArgs>>): Prisma__TicketHandlersClient<$Result.GetResult<Prisma.$TicketHandlersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketHandlers that matches the filter.
     * @param {TicketHandlersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const ticketHandlers = await prisma.ticketHandlers.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TicketHandlersFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TicketHandlers.
     * @param {TicketHandlersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const ticketHandlers = await prisma.ticketHandlers.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TicketHandlersAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TicketHandlers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketHandlersCountArgs} args - Arguments to filter TicketHandlers to count.
     * @example
     * // Count the number of TicketHandlers
     * const count = await prisma.ticketHandlers.count({
     *   where: {
     *     // ... the filter for the TicketHandlers we want to count
     *   }
     * })
    **/
    count<T extends TicketHandlersCountArgs>(
      args?: Subset<T, TicketHandlersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketHandlersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketHandlers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketHandlersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketHandlersAggregateArgs>(args: Subset<T, TicketHandlersAggregateArgs>): Prisma.PrismaPromise<GetTicketHandlersAggregateType<T>>

    /**
     * Group by TicketHandlers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketHandlersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketHandlersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketHandlersGroupByArgs['orderBy'] }
        : { orderBy?: TicketHandlersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketHandlersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketHandlersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketHandlers model
   */
  readonly fields: TicketHandlersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketHandlers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketHandlersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketHandlers model
   */
  interface TicketHandlersFieldRefs {
    readonly id: FieldRef<"TicketHandlers", 'String'>
    readonly DiscordRoleId: FieldRef<"TicketHandlers", 'String'>
    readonly TicketPermission: FieldRef<"TicketHandlers", 'String'>
    readonly AddedDiscordPermission: FieldRef<"TicketHandlers", 'String[]'>
    readonly RemovedDiscordPermission: FieldRef<"TicketHandlers", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * TicketHandlers findUnique
   */
  export type TicketHandlersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHandlers
     */
    select?: TicketHandlersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHandlers
     */
    omit?: TicketHandlersOmit<ExtArgs> | null
    /**
     * Filter, which TicketHandlers to fetch.
     */
    where: TicketHandlersWhereUniqueInput
  }

  /**
   * TicketHandlers findUniqueOrThrow
   */
  export type TicketHandlersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHandlers
     */
    select?: TicketHandlersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHandlers
     */
    omit?: TicketHandlersOmit<ExtArgs> | null
    /**
     * Filter, which TicketHandlers to fetch.
     */
    where: TicketHandlersWhereUniqueInput
  }

  /**
   * TicketHandlers findFirst
   */
  export type TicketHandlersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHandlers
     */
    select?: TicketHandlersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHandlers
     */
    omit?: TicketHandlersOmit<ExtArgs> | null
    /**
     * Filter, which TicketHandlers to fetch.
     */
    where?: TicketHandlersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketHandlers to fetch.
     */
    orderBy?: TicketHandlersOrderByWithRelationInput | TicketHandlersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketHandlers.
     */
    cursor?: TicketHandlersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketHandlers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketHandlers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketHandlers.
     */
    distinct?: TicketHandlersScalarFieldEnum | TicketHandlersScalarFieldEnum[]
  }

  /**
   * TicketHandlers findFirstOrThrow
   */
  export type TicketHandlersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHandlers
     */
    select?: TicketHandlersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHandlers
     */
    omit?: TicketHandlersOmit<ExtArgs> | null
    /**
     * Filter, which TicketHandlers to fetch.
     */
    where?: TicketHandlersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketHandlers to fetch.
     */
    orderBy?: TicketHandlersOrderByWithRelationInput | TicketHandlersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketHandlers.
     */
    cursor?: TicketHandlersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketHandlers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketHandlers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketHandlers.
     */
    distinct?: TicketHandlersScalarFieldEnum | TicketHandlersScalarFieldEnum[]
  }

  /**
   * TicketHandlers findMany
   */
  export type TicketHandlersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHandlers
     */
    select?: TicketHandlersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHandlers
     */
    omit?: TicketHandlersOmit<ExtArgs> | null
    /**
     * Filter, which TicketHandlers to fetch.
     */
    where?: TicketHandlersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketHandlers to fetch.
     */
    orderBy?: TicketHandlersOrderByWithRelationInput | TicketHandlersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketHandlers.
     */
    cursor?: TicketHandlersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketHandlers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketHandlers.
     */
    skip?: number
    distinct?: TicketHandlersScalarFieldEnum | TicketHandlersScalarFieldEnum[]
  }

  /**
   * TicketHandlers create
   */
  export type TicketHandlersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHandlers
     */
    select?: TicketHandlersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHandlers
     */
    omit?: TicketHandlersOmit<ExtArgs> | null
    /**
     * The data needed to create a TicketHandlers.
     */
    data: XOR<TicketHandlersCreateInput, TicketHandlersUncheckedCreateInput>
  }

  /**
   * TicketHandlers createMany
   */
  export type TicketHandlersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketHandlers.
     */
    data: TicketHandlersCreateManyInput | TicketHandlersCreateManyInput[]
  }

  /**
   * TicketHandlers update
   */
  export type TicketHandlersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHandlers
     */
    select?: TicketHandlersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHandlers
     */
    omit?: TicketHandlersOmit<ExtArgs> | null
    /**
     * The data needed to update a TicketHandlers.
     */
    data: XOR<TicketHandlersUpdateInput, TicketHandlersUncheckedUpdateInput>
    /**
     * Choose, which TicketHandlers to update.
     */
    where: TicketHandlersWhereUniqueInput
  }

  /**
   * TicketHandlers updateMany
   */
  export type TicketHandlersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketHandlers.
     */
    data: XOR<TicketHandlersUpdateManyMutationInput, TicketHandlersUncheckedUpdateManyInput>
    /**
     * Filter which TicketHandlers to update
     */
    where?: TicketHandlersWhereInput
    /**
     * Limit how many TicketHandlers to update.
     */
    limit?: number
  }

  /**
   * TicketHandlers upsert
   */
  export type TicketHandlersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHandlers
     */
    select?: TicketHandlersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHandlers
     */
    omit?: TicketHandlersOmit<ExtArgs> | null
    /**
     * The filter to search for the TicketHandlers to update in case it exists.
     */
    where: TicketHandlersWhereUniqueInput
    /**
     * In case the TicketHandlers found by the `where` argument doesn't exist, create a new TicketHandlers with this data.
     */
    create: XOR<TicketHandlersCreateInput, TicketHandlersUncheckedCreateInput>
    /**
     * In case the TicketHandlers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketHandlersUpdateInput, TicketHandlersUncheckedUpdateInput>
  }

  /**
   * TicketHandlers delete
   */
  export type TicketHandlersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHandlers
     */
    select?: TicketHandlersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHandlers
     */
    omit?: TicketHandlersOmit<ExtArgs> | null
    /**
     * Filter which TicketHandlers to delete.
     */
    where: TicketHandlersWhereUniqueInput
  }

  /**
   * TicketHandlers deleteMany
   */
  export type TicketHandlersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketHandlers to delete
     */
    where?: TicketHandlersWhereInput
    /**
     * Limit how many TicketHandlers to delete.
     */
    limit?: number
  }

  /**
   * TicketHandlers findRaw
   */
  export type TicketHandlersFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TicketHandlers aggregateRaw
   */
  export type TicketHandlersAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TicketHandlers without action
   */
  export type TicketHandlersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHandlers
     */
    select?: TicketHandlersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHandlers
     */
    omit?: TicketHandlersOmit<ExtArgs> | null
  }


  /**
   * Model Tickets
   */

  export type AggregateTickets = {
    _count: TicketsCountAggregateOutputType | null
    _min: TicketsMinAggregateOutputType | null
    _max: TicketsMaxAggregateOutputType | null
  }

  export type TicketsMinAggregateOutputType = {
    id: string | null
    TicketId: string | null
    GuildId: string | null
    ChannelId: string | null
    ThreadId: string | null
    IsClaimed: boolean | null
    IsArchived: boolean | null
    ArchiveMessageId: string | null
    UserWhoHasClaimedId: string | null
    IsLooked: boolean | null
    TicketOwnerId: string | null
    TranscriptChannelId: string | null
    TranscriptHTML: string | null
    TicketSetupId: string | null
  }

  export type TicketsMaxAggregateOutputType = {
    id: string | null
    TicketId: string | null
    GuildId: string | null
    ChannelId: string | null
    ThreadId: string | null
    IsClaimed: boolean | null
    IsArchived: boolean | null
    ArchiveMessageId: string | null
    UserWhoHasClaimedId: string | null
    IsLooked: boolean | null
    TicketOwnerId: string | null
    TranscriptChannelId: string | null
    TranscriptHTML: string | null
    TicketSetupId: string | null
  }

  export type TicketsCountAggregateOutputType = {
    id: number
    TicketId: number
    GuildId: number
    ChannelId: number
    ThreadId: number
    IsClaimed: number
    IsArchived: number
    ArchiveMessageId: number
    UserWhoHasClaimedId: number
    IsLooked: number
    TicketOwnerId: number
    AddedMemberIds: number
    Handlers: number
    TranscriptChannelId: number
    TranscriptHTML: number
    TicketNotes: number
    TicketSetupId: number
    _all: number
  }


  export type TicketsMinAggregateInputType = {
    id?: true
    TicketId?: true
    GuildId?: true
    ChannelId?: true
    ThreadId?: true
    IsClaimed?: true
    IsArchived?: true
    ArchiveMessageId?: true
    UserWhoHasClaimedId?: true
    IsLooked?: true
    TicketOwnerId?: true
    TranscriptChannelId?: true
    TranscriptHTML?: true
    TicketSetupId?: true
  }

  export type TicketsMaxAggregateInputType = {
    id?: true
    TicketId?: true
    GuildId?: true
    ChannelId?: true
    ThreadId?: true
    IsClaimed?: true
    IsArchived?: true
    ArchiveMessageId?: true
    UserWhoHasClaimedId?: true
    IsLooked?: true
    TicketOwnerId?: true
    TranscriptChannelId?: true
    TranscriptHTML?: true
    TicketSetupId?: true
  }

  export type TicketsCountAggregateInputType = {
    id?: true
    TicketId?: true
    GuildId?: true
    ChannelId?: true
    ThreadId?: true
    IsClaimed?: true
    IsArchived?: true
    ArchiveMessageId?: true
    UserWhoHasClaimedId?: true
    IsLooked?: true
    TicketOwnerId?: true
    AddedMemberIds?: true
    Handlers?: true
    TranscriptChannelId?: true
    TranscriptHTML?: true
    TicketNotes?: true
    TicketSetupId?: true
    _all?: true
  }

  export type TicketsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to aggregate.
     */
    where?: TicketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketsOrderByWithRelationInput | TicketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketsMaxAggregateInputType
  }

  export type GetTicketsAggregateType<T extends TicketsAggregateArgs> = {
        [P in keyof T & keyof AggregateTickets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTickets[P]>
      : GetScalarType<T[P], AggregateTickets[P]>
  }




  export type TicketsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketsWhereInput
    orderBy?: TicketsOrderByWithAggregationInput | TicketsOrderByWithAggregationInput[]
    by: TicketsScalarFieldEnum[] | TicketsScalarFieldEnum
    having?: TicketsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketsCountAggregateInputType | true
    _min?: TicketsMinAggregateInputType
    _max?: TicketsMaxAggregateInputType
  }

  export type TicketsGroupByOutputType = {
    id: string
    TicketId: string
    GuildId: string
    ChannelId: string | null
    ThreadId: string | null
    IsClaimed: boolean | null
    IsArchived: boolean | null
    ArchiveMessageId: string | null
    UserWhoHasClaimedId: string | null
    IsLooked: boolean | null
    TicketOwnerId: string
    AddedMemberIds: string[]
    Handlers: string[]
    TranscriptChannelId: string
    TranscriptHTML: string | null
    TicketNotes: string[]
    TicketSetupId: string
    _count: TicketsCountAggregateOutputType | null
    _min: TicketsMinAggregateOutputType | null
    _max: TicketsMaxAggregateOutputType | null
  }

  type GetTicketsGroupByPayload<T extends TicketsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketsGroupByOutputType[P]>
            : GetScalarType<T[P], TicketsGroupByOutputType[P]>
        }
      >
    >


  export type TicketsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    TicketId?: boolean
    GuildId?: boolean
    ChannelId?: boolean
    ThreadId?: boolean
    IsClaimed?: boolean
    IsArchived?: boolean
    ArchiveMessageId?: boolean
    UserWhoHasClaimedId?: boolean
    IsLooked?: boolean
    TicketOwnerId?: boolean
    AddedMemberIds?: boolean
    Handlers?: boolean
    TranscriptChannelId?: boolean
    TranscriptHTML?: boolean
    TicketNotes?: boolean
    TicketSetupId?: boolean
    TicketSetup?: boolean | TicketSetupsDefaultArgs<ExtArgs>
    TicketFeedback?: boolean | Tickets$TicketFeedbackArgs<ExtArgs>
  }, ExtArgs["result"]["tickets"]>



  export type TicketsSelectScalar = {
    id?: boolean
    TicketId?: boolean
    GuildId?: boolean
    ChannelId?: boolean
    ThreadId?: boolean
    IsClaimed?: boolean
    IsArchived?: boolean
    ArchiveMessageId?: boolean
    UserWhoHasClaimedId?: boolean
    IsLooked?: boolean
    TicketOwnerId?: boolean
    AddedMemberIds?: boolean
    Handlers?: boolean
    TranscriptChannelId?: boolean
    TranscriptHTML?: boolean
    TicketNotes?: boolean
    TicketSetupId?: boolean
  }

  export type TicketsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "TicketId" | "GuildId" | "ChannelId" | "ThreadId" | "IsClaimed" | "IsArchived" | "ArchiveMessageId" | "UserWhoHasClaimedId" | "IsLooked" | "TicketOwnerId" | "AddedMemberIds" | "Handlers" | "TranscriptChannelId" | "TranscriptHTML" | "TicketNotes" | "TicketSetupId", ExtArgs["result"]["tickets"]>
  export type TicketsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TicketSetup?: boolean | TicketSetupsDefaultArgs<ExtArgs>
    TicketFeedback?: boolean | Tickets$TicketFeedbackArgs<ExtArgs>
  }

  export type $TicketsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tickets"
    objects: {
      TicketSetup: Prisma.$TicketSetupsPayload<ExtArgs>
      TicketFeedback: Prisma.$TicketFeedbackPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      TicketId: string
      GuildId: string
      ChannelId: string | null
      ThreadId: string | null
      IsClaimed: boolean | null
      IsArchived: boolean | null
      ArchiveMessageId: string | null
      UserWhoHasClaimedId: string | null
      IsLooked: boolean | null
      TicketOwnerId: string
      AddedMemberIds: string[]
      Handlers: string[]
      TranscriptChannelId: string
      TranscriptHTML: string | null
      TicketNotes: string[]
      TicketSetupId: string
    }, ExtArgs["result"]["tickets"]>
    composites: {}
  }

  type TicketsGetPayload<S extends boolean | null | undefined | TicketsDefaultArgs> = $Result.GetResult<Prisma.$TicketsPayload, S>

  type TicketsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketsCountAggregateInputType | true
    }

  export interface TicketsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tickets'], meta: { name: 'Tickets' } }
    /**
     * Find zero or one Tickets that matches the filter.
     * @param {TicketsFindUniqueArgs} args - Arguments to find a Tickets
     * @example
     * // Get one Tickets
     * const tickets = await prisma.tickets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketsFindUniqueArgs>(args: SelectSubset<T, TicketsFindUniqueArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tickets that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketsFindUniqueOrThrowArgs} args - Arguments to find a Tickets
     * @example
     * // Get one Tickets
     * const tickets = await prisma.tickets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketsFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketsFindFirstArgs} args - Arguments to find a Tickets
     * @example
     * // Get one Tickets
     * const tickets = await prisma.tickets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketsFindFirstArgs>(args?: SelectSubset<T, TicketsFindFirstArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tickets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketsFindFirstOrThrowArgs} args - Arguments to find a Tickets
     * @example
     * // Get one Tickets
     * const tickets = await prisma.tickets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketsFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.tickets.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.tickets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketsWithIdOnly = await prisma.tickets.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketsFindManyArgs>(args?: SelectSubset<T, TicketsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tickets.
     * @param {TicketsCreateArgs} args - Arguments to create a Tickets.
     * @example
     * // Create one Tickets
     * const Tickets = await prisma.tickets.create({
     *   data: {
     *     // ... data to create a Tickets
     *   }
     * })
     * 
     */
    create<T extends TicketsCreateArgs>(args: SelectSubset<T, TicketsCreateArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tickets.
     * @param {TicketsCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const tickets = await prisma.tickets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketsCreateManyArgs>(args?: SelectSubset<T, TicketsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tickets.
     * @param {TicketsDeleteArgs} args - Arguments to delete one Tickets.
     * @example
     * // Delete one Tickets
     * const Tickets = await prisma.tickets.delete({
     *   where: {
     *     // ... filter to delete one Tickets
     *   }
     * })
     * 
     */
    delete<T extends TicketsDeleteArgs>(args: SelectSubset<T, TicketsDeleteArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tickets.
     * @param {TicketsUpdateArgs} args - Arguments to update one Tickets.
     * @example
     * // Update one Tickets
     * const tickets = await prisma.tickets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketsUpdateArgs>(args: SelectSubset<T, TicketsUpdateArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tickets.
     * @param {TicketsDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.tickets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketsDeleteManyArgs>(args?: SelectSubset<T, TicketsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const tickets = await prisma.tickets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketsUpdateManyArgs>(args: SelectSubset<T, TicketsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tickets.
     * @param {TicketsUpsertArgs} args - Arguments to update or create a Tickets.
     * @example
     * // Update or create a Tickets
     * const tickets = await prisma.tickets.upsert({
     *   create: {
     *     // ... data to create a Tickets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tickets we want to update
     *   }
     * })
     */
    upsert<T extends TicketsUpsertArgs>(args: SelectSubset<T, TicketsUpsertArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tickets that matches the filter.
     * @param {TicketsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tickets = await prisma.tickets.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TicketsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Tickets.
     * @param {TicketsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tickets = await prisma.tickets.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TicketsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketsCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.tickets.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketsCountArgs>(
      args?: Subset<T, TicketsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketsAggregateArgs>(args: Subset<T, TicketsAggregateArgs>): Prisma.PrismaPromise<GetTicketsAggregateType<T>>

    /**
     * Group by Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketsGroupByArgs['orderBy'] }
        : { orderBy?: TicketsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tickets model
   */
  readonly fields: TicketsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tickets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TicketSetup<T extends TicketSetupsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketSetupsDefaultArgs<ExtArgs>>): Prisma__TicketSetupsClient<$Result.GetResult<Prisma.$TicketSetupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    TicketFeedback<T extends Tickets$TicketFeedbackArgs<ExtArgs> = {}>(args?: Subset<T, Tickets$TicketFeedbackArgs<ExtArgs>>): Prisma__TicketFeedbackClient<$Result.GetResult<Prisma.$TicketFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tickets model
   */
  interface TicketsFieldRefs {
    readonly id: FieldRef<"Tickets", 'String'>
    readonly TicketId: FieldRef<"Tickets", 'String'>
    readonly GuildId: FieldRef<"Tickets", 'String'>
    readonly ChannelId: FieldRef<"Tickets", 'String'>
    readonly ThreadId: FieldRef<"Tickets", 'String'>
    readonly IsClaimed: FieldRef<"Tickets", 'Boolean'>
    readonly IsArchived: FieldRef<"Tickets", 'Boolean'>
    readonly ArchiveMessageId: FieldRef<"Tickets", 'String'>
    readonly UserWhoHasClaimedId: FieldRef<"Tickets", 'String'>
    readonly IsLooked: FieldRef<"Tickets", 'Boolean'>
    readonly TicketOwnerId: FieldRef<"Tickets", 'String'>
    readonly AddedMemberIds: FieldRef<"Tickets", 'String[]'>
    readonly Handlers: FieldRef<"Tickets", 'String[]'>
    readonly TranscriptChannelId: FieldRef<"Tickets", 'String'>
    readonly TranscriptHTML: FieldRef<"Tickets", 'String'>
    readonly TicketNotes: FieldRef<"Tickets", 'String[]'>
    readonly TicketSetupId: FieldRef<"Tickets", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tickets findUnique
   */
  export type TicketsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where: TicketsWhereUniqueInput
  }

  /**
   * Tickets findUniqueOrThrow
   */
  export type TicketsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where: TicketsWhereUniqueInput
  }

  /**
   * Tickets findFirst
   */
  export type TicketsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketsOrderByWithRelationInput | TicketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * Tickets findFirstOrThrow
   */
  export type TicketsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketsOrderByWithRelationInput | TicketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * Tickets findMany
   */
  export type TicketsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketsOrderByWithRelationInput | TicketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * Tickets create
   */
  export type TicketsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * The data needed to create a Tickets.
     */
    data: XOR<TicketsCreateInput, TicketsUncheckedCreateInput>
  }

  /**
   * Tickets createMany
   */
  export type TicketsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketsCreateManyInput | TicketsCreateManyInput[]
  }

  /**
   * Tickets update
   */
  export type TicketsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * The data needed to update a Tickets.
     */
    data: XOR<TicketsUpdateInput, TicketsUncheckedUpdateInput>
    /**
     * Choose, which Tickets to update.
     */
    where: TicketsWhereUniqueInput
  }

  /**
   * Tickets updateMany
   */
  export type TicketsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketsUpdateManyMutationInput, TicketsUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketsWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
  }

  /**
   * Tickets upsert
   */
  export type TicketsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * The filter to search for the Tickets to update in case it exists.
     */
    where: TicketsWhereUniqueInput
    /**
     * In case the Tickets found by the `where` argument doesn't exist, create a new Tickets with this data.
     */
    create: XOR<TicketsCreateInput, TicketsUncheckedCreateInput>
    /**
     * In case the Tickets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketsUpdateInput, TicketsUncheckedUpdateInput>
  }

  /**
   * Tickets delete
   */
  export type TicketsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * Filter which Tickets to delete.
     */
    where: TicketsWhereUniqueInput
  }

  /**
   * Tickets deleteMany
   */
  export type TicketsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketsWhereInput
    /**
     * Limit how many Tickets to delete.
     */
    limit?: number
  }

  /**
   * Tickets findRaw
   */
  export type TicketsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Tickets aggregateRaw
   */
  export type TicketsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Tickets.TicketFeedback
   */
  export type Tickets$TicketFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketFeedback
     */
    select?: TicketFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketFeedback
     */
    omit?: TicketFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketFeedbackInclude<ExtArgs> | null
    where?: TicketFeedbackWhereInput
  }

  /**
   * Tickets without action
   */
  export type TicketsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
  }


  /**
   * Model TicketFeedback
   */

  export type AggregateTicketFeedback = {
    _count: TicketFeedbackCountAggregateOutputType | null
    _avg: TicketFeedbackAvgAggregateOutputType | null
    _sum: TicketFeedbackSumAggregateOutputType | null
    _min: TicketFeedbackMinAggregateOutputType | null
    _max: TicketFeedbackMaxAggregateOutputType | null
  }

  export type TicketFeedbackAvgAggregateOutputType = {
    Rating: number | null
  }

  export type TicketFeedbackSumAggregateOutputType = {
    Rating: number | null
  }

  export type TicketFeedbackMinAggregateOutputType = {
    id: string | null
    TicketId: string | null
    Rating: number | null
    Comment: string | null
    SubmittedAt: Date | null
  }

  export type TicketFeedbackMaxAggregateOutputType = {
    id: string | null
    TicketId: string | null
    Rating: number | null
    Comment: string | null
    SubmittedAt: Date | null
  }

  export type TicketFeedbackCountAggregateOutputType = {
    id: number
    TicketId: number
    Rating: number
    Comment: number
    SubmittedAt: number
    _all: number
  }


  export type TicketFeedbackAvgAggregateInputType = {
    Rating?: true
  }

  export type TicketFeedbackSumAggregateInputType = {
    Rating?: true
  }

  export type TicketFeedbackMinAggregateInputType = {
    id?: true
    TicketId?: true
    Rating?: true
    Comment?: true
    SubmittedAt?: true
  }

  export type TicketFeedbackMaxAggregateInputType = {
    id?: true
    TicketId?: true
    Rating?: true
    Comment?: true
    SubmittedAt?: true
  }

  export type TicketFeedbackCountAggregateInputType = {
    id?: true
    TicketId?: true
    Rating?: true
    Comment?: true
    SubmittedAt?: true
    _all?: true
  }

  export type TicketFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketFeedback to aggregate.
     */
    where?: TicketFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketFeedbacks to fetch.
     */
    orderBy?: TicketFeedbackOrderByWithRelationInput | TicketFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketFeedbacks
    **/
    _count?: true | TicketFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketFeedbackMaxAggregateInputType
  }

  export type GetTicketFeedbackAggregateType<T extends TicketFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketFeedback[P]>
      : GetScalarType<T[P], AggregateTicketFeedback[P]>
  }




  export type TicketFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketFeedbackWhereInput
    orderBy?: TicketFeedbackOrderByWithAggregationInput | TicketFeedbackOrderByWithAggregationInput[]
    by: TicketFeedbackScalarFieldEnum[] | TicketFeedbackScalarFieldEnum
    having?: TicketFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketFeedbackCountAggregateInputType | true
    _avg?: TicketFeedbackAvgAggregateInputType
    _sum?: TicketFeedbackSumAggregateInputType
    _min?: TicketFeedbackMinAggregateInputType
    _max?: TicketFeedbackMaxAggregateInputType
  }

  export type TicketFeedbackGroupByOutputType = {
    id: string
    TicketId: string
    Rating: number
    Comment: string | null
    SubmittedAt: Date
    _count: TicketFeedbackCountAggregateOutputType | null
    _avg: TicketFeedbackAvgAggregateOutputType | null
    _sum: TicketFeedbackSumAggregateOutputType | null
    _min: TicketFeedbackMinAggregateOutputType | null
    _max: TicketFeedbackMaxAggregateOutputType | null
  }

  type GetTicketFeedbackGroupByPayload<T extends TicketFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], TicketFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type TicketFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    TicketId?: boolean
    Rating?: boolean
    Comment?: boolean
    SubmittedAt?: boolean
    Ticket?: boolean | TicketsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketFeedback"]>



  export type TicketFeedbackSelectScalar = {
    id?: boolean
    TicketId?: boolean
    Rating?: boolean
    Comment?: boolean
    SubmittedAt?: boolean
  }

  export type TicketFeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "TicketId" | "Rating" | "Comment" | "SubmittedAt", ExtArgs["result"]["ticketFeedback"]>
  export type TicketFeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Ticket?: boolean | TicketsDefaultArgs<ExtArgs>
  }

  export type $TicketFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketFeedback"
    objects: {
      Ticket: Prisma.$TicketsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      TicketId: string
      Rating: number
      Comment: string | null
      SubmittedAt: Date
    }, ExtArgs["result"]["ticketFeedback"]>
    composites: {}
  }

  type TicketFeedbackGetPayload<S extends boolean | null | undefined | TicketFeedbackDefaultArgs> = $Result.GetResult<Prisma.$TicketFeedbackPayload, S>

  type TicketFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketFeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketFeedbackCountAggregateInputType | true
    }

  export interface TicketFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketFeedback'], meta: { name: 'TicketFeedback' } }
    /**
     * Find zero or one TicketFeedback that matches the filter.
     * @param {TicketFeedbackFindUniqueArgs} args - Arguments to find a TicketFeedback
     * @example
     * // Get one TicketFeedback
     * const ticketFeedback = await prisma.ticketFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFeedbackFindUniqueArgs>(args: SelectSubset<T, TicketFeedbackFindUniqueArgs<ExtArgs>>): Prisma__TicketFeedbackClient<$Result.GetResult<Prisma.$TicketFeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketFeedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketFeedbackFindUniqueOrThrowArgs} args - Arguments to find a TicketFeedback
     * @example
     * // Get one TicketFeedback
     * const ticketFeedback = await prisma.ticketFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketFeedbackClient<$Result.GetResult<Prisma.$TicketFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFeedbackFindFirstArgs} args - Arguments to find a TicketFeedback
     * @example
     * // Get one TicketFeedback
     * const ticketFeedback = await prisma.ticketFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFeedbackFindFirstArgs>(args?: SelectSubset<T, TicketFeedbackFindFirstArgs<ExtArgs>>): Prisma__TicketFeedbackClient<$Result.GetResult<Prisma.$TicketFeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFeedbackFindFirstOrThrowArgs} args - Arguments to find a TicketFeedback
     * @example
     * // Get one TicketFeedback
     * const ticketFeedback = await prisma.ticketFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketFeedbackClient<$Result.GetResult<Prisma.$TicketFeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketFeedbacks
     * const ticketFeedbacks = await prisma.ticketFeedback.findMany()
     * 
     * // Get first 10 TicketFeedbacks
     * const ticketFeedbacks = await prisma.ticketFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketFeedbackWithIdOnly = await prisma.ticketFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFeedbackFindManyArgs>(args?: SelectSubset<T, TicketFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketFeedback.
     * @param {TicketFeedbackCreateArgs} args - Arguments to create a TicketFeedback.
     * @example
     * // Create one TicketFeedback
     * const TicketFeedback = await prisma.ticketFeedback.create({
     *   data: {
     *     // ... data to create a TicketFeedback
     *   }
     * })
     * 
     */
    create<T extends TicketFeedbackCreateArgs>(args: SelectSubset<T, TicketFeedbackCreateArgs<ExtArgs>>): Prisma__TicketFeedbackClient<$Result.GetResult<Prisma.$TicketFeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketFeedbacks.
     * @param {TicketFeedbackCreateManyArgs} args - Arguments to create many TicketFeedbacks.
     * @example
     * // Create many TicketFeedbacks
     * const ticketFeedback = await prisma.ticketFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketFeedbackCreateManyArgs>(args?: SelectSubset<T, TicketFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TicketFeedback.
     * @param {TicketFeedbackDeleteArgs} args - Arguments to delete one TicketFeedback.
     * @example
     * // Delete one TicketFeedback
     * const TicketFeedback = await prisma.ticketFeedback.delete({
     *   where: {
     *     // ... filter to delete one TicketFeedback
     *   }
     * })
     * 
     */
    delete<T extends TicketFeedbackDeleteArgs>(args: SelectSubset<T, TicketFeedbackDeleteArgs<ExtArgs>>): Prisma__TicketFeedbackClient<$Result.GetResult<Prisma.$TicketFeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketFeedback.
     * @param {TicketFeedbackUpdateArgs} args - Arguments to update one TicketFeedback.
     * @example
     * // Update one TicketFeedback
     * const ticketFeedback = await prisma.ticketFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketFeedbackUpdateArgs>(args: SelectSubset<T, TicketFeedbackUpdateArgs<ExtArgs>>): Prisma__TicketFeedbackClient<$Result.GetResult<Prisma.$TicketFeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketFeedbacks.
     * @param {TicketFeedbackDeleteManyArgs} args - Arguments to filter TicketFeedbacks to delete.
     * @example
     * // Delete a few TicketFeedbacks
     * const { count } = await prisma.ticketFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketFeedbackDeleteManyArgs>(args?: SelectSubset<T, TicketFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketFeedbacks
     * const ticketFeedback = await prisma.ticketFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketFeedbackUpdateManyArgs>(args: SelectSubset<T, TicketFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TicketFeedback.
     * @param {TicketFeedbackUpsertArgs} args - Arguments to update or create a TicketFeedback.
     * @example
     * // Update or create a TicketFeedback
     * const ticketFeedback = await prisma.ticketFeedback.upsert({
     *   create: {
     *     // ... data to create a TicketFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketFeedback we want to update
     *   }
     * })
     */
    upsert<T extends TicketFeedbackUpsertArgs>(args: SelectSubset<T, TicketFeedbackUpsertArgs<ExtArgs>>): Prisma__TicketFeedbackClient<$Result.GetResult<Prisma.$TicketFeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketFeedbacks that matches the filter.
     * @param {TicketFeedbackFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const ticketFeedback = await prisma.ticketFeedback.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TicketFeedbackFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TicketFeedback.
     * @param {TicketFeedbackAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const ticketFeedback = await prisma.ticketFeedback.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TicketFeedbackAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TicketFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFeedbackCountArgs} args - Arguments to filter TicketFeedbacks to count.
     * @example
     * // Count the number of TicketFeedbacks
     * const count = await prisma.ticketFeedback.count({
     *   where: {
     *     // ... the filter for the TicketFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends TicketFeedbackCountArgs>(
      args?: Subset<T, TicketFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketFeedbackAggregateArgs>(args: Subset<T, TicketFeedbackAggregateArgs>): Prisma.PrismaPromise<GetTicketFeedbackAggregateType<T>>

    /**
     * Group by TicketFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: TicketFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketFeedback model
   */
  readonly fields: TicketFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Ticket<T extends TicketsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketsDefaultArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketFeedback model
   */
  interface TicketFeedbackFieldRefs {
    readonly id: FieldRef<"TicketFeedback", 'String'>
    readonly TicketId: FieldRef<"TicketFeedback", 'String'>
    readonly Rating: FieldRef<"TicketFeedback", 'Int'>
    readonly Comment: FieldRef<"TicketFeedback", 'String'>
    readonly SubmittedAt: FieldRef<"TicketFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketFeedback findUnique
   */
  export type TicketFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketFeedback
     */
    select?: TicketFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketFeedback
     */
    omit?: TicketFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which TicketFeedback to fetch.
     */
    where: TicketFeedbackWhereUniqueInput
  }

  /**
   * TicketFeedback findUniqueOrThrow
   */
  export type TicketFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketFeedback
     */
    select?: TicketFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketFeedback
     */
    omit?: TicketFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which TicketFeedback to fetch.
     */
    where: TicketFeedbackWhereUniqueInput
  }

  /**
   * TicketFeedback findFirst
   */
  export type TicketFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketFeedback
     */
    select?: TicketFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketFeedback
     */
    omit?: TicketFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which TicketFeedback to fetch.
     */
    where?: TicketFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketFeedbacks to fetch.
     */
    orderBy?: TicketFeedbackOrderByWithRelationInput | TicketFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketFeedbacks.
     */
    cursor?: TicketFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketFeedbacks.
     */
    distinct?: TicketFeedbackScalarFieldEnum | TicketFeedbackScalarFieldEnum[]
  }

  /**
   * TicketFeedback findFirstOrThrow
   */
  export type TicketFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketFeedback
     */
    select?: TicketFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketFeedback
     */
    omit?: TicketFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which TicketFeedback to fetch.
     */
    where?: TicketFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketFeedbacks to fetch.
     */
    orderBy?: TicketFeedbackOrderByWithRelationInput | TicketFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketFeedbacks.
     */
    cursor?: TicketFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketFeedbacks.
     */
    distinct?: TicketFeedbackScalarFieldEnum | TicketFeedbackScalarFieldEnum[]
  }

  /**
   * TicketFeedback findMany
   */
  export type TicketFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketFeedback
     */
    select?: TicketFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketFeedback
     */
    omit?: TicketFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which TicketFeedbacks to fetch.
     */
    where?: TicketFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketFeedbacks to fetch.
     */
    orderBy?: TicketFeedbackOrderByWithRelationInput | TicketFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketFeedbacks.
     */
    cursor?: TicketFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketFeedbacks.
     */
    skip?: number
    distinct?: TicketFeedbackScalarFieldEnum | TicketFeedbackScalarFieldEnum[]
  }

  /**
   * TicketFeedback create
   */
  export type TicketFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketFeedback
     */
    select?: TicketFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketFeedback
     */
    omit?: TicketFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketFeedback.
     */
    data: XOR<TicketFeedbackCreateInput, TicketFeedbackUncheckedCreateInput>
  }

  /**
   * TicketFeedback createMany
   */
  export type TicketFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketFeedbacks.
     */
    data: TicketFeedbackCreateManyInput | TicketFeedbackCreateManyInput[]
  }

  /**
   * TicketFeedback update
   */
  export type TicketFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketFeedback
     */
    select?: TicketFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketFeedback
     */
    omit?: TicketFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketFeedback.
     */
    data: XOR<TicketFeedbackUpdateInput, TicketFeedbackUncheckedUpdateInput>
    /**
     * Choose, which TicketFeedback to update.
     */
    where: TicketFeedbackWhereUniqueInput
  }

  /**
   * TicketFeedback updateMany
   */
  export type TicketFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketFeedbacks.
     */
    data: XOR<TicketFeedbackUpdateManyMutationInput, TicketFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which TicketFeedbacks to update
     */
    where?: TicketFeedbackWhereInput
    /**
     * Limit how many TicketFeedbacks to update.
     */
    limit?: number
  }

  /**
   * TicketFeedback upsert
   */
  export type TicketFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketFeedback
     */
    select?: TicketFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketFeedback
     */
    omit?: TicketFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketFeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketFeedback to update in case it exists.
     */
    where: TicketFeedbackWhereUniqueInput
    /**
     * In case the TicketFeedback found by the `where` argument doesn't exist, create a new TicketFeedback with this data.
     */
    create: XOR<TicketFeedbackCreateInput, TicketFeedbackUncheckedCreateInput>
    /**
     * In case the TicketFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketFeedbackUpdateInput, TicketFeedbackUncheckedUpdateInput>
  }

  /**
   * TicketFeedback delete
   */
  export type TicketFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketFeedback
     */
    select?: TicketFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketFeedback
     */
    omit?: TicketFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketFeedbackInclude<ExtArgs> | null
    /**
     * Filter which TicketFeedback to delete.
     */
    where: TicketFeedbackWhereUniqueInput
  }

  /**
   * TicketFeedback deleteMany
   */
  export type TicketFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketFeedbacks to delete
     */
    where?: TicketFeedbackWhereInput
    /**
     * Limit how many TicketFeedbacks to delete.
     */
    limit?: number
  }

  /**
   * TicketFeedback findRaw
   */
  export type TicketFeedbackFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TicketFeedback aggregateRaw
   */
  export type TicketFeedbackAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TicketFeedback without action
   */
  export type TicketFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketFeedback
     */
    select?: TicketFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketFeedback
     */
    omit?: TicketFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketFeedbackInclude<ExtArgs> | null
  }


  /**
   * Model GuildFeatureToggles
   */

  export type AggregateGuildFeatureToggles = {
    _count: GuildFeatureTogglesCountAggregateOutputType | null
    _min: GuildFeatureTogglesMinAggregateOutputType | null
    _max: GuildFeatureTogglesMaxAggregateOutputType | null
  }

  export type GuildFeatureTogglesMinAggregateOutputType = {
    id: string | null
    LevelEnabled: boolean | null
    WecomeEnabled: boolean | null
    LeaveEnabled: boolean | null
    AutoreactEnabled: boolean | null
    AutopublishEnabled: boolean | null
    ConnectionsEnabled: boolean | null
    ChatfilterEnabled: boolean | null
    AutorolesEnabled: boolean | null
    LoggingEnabled: boolean | null
    TwitchEnabled: boolean | null
    YoutubeEnabled: boolean | null
    SpotifyEnabled: boolean | null
    GuildId: string | null
  }

  export type GuildFeatureTogglesMaxAggregateOutputType = {
    id: string | null
    LevelEnabled: boolean | null
    WecomeEnabled: boolean | null
    LeaveEnabled: boolean | null
    AutoreactEnabled: boolean | null
    AutopublishEnabled: boolean | null
    ConnectionsEnabled: boolean | null
    ChatfilterEnabled: boolean | null
    AutorolesEnabled: boolean | null
    LoggingEnabled: boolean | null
    TwitchEnabled: boolean | null
    YoutubeEnabled: boolean | null
    SpotifyEnabled: boolean | null
    GuildId: string | null
  }

  export type GuildFeatureTogglesCountAggregateOutputType = {
    id: number
    LevelEnabled: number
    WecomeEnabled: number
    LeaveEnabled: number
    AutoreactEnabled: number
    AutopublishEnabled: number
    ConnectionsEnabled: number
    ChatfilterEnabled: number
    AutorolesEnabled: number
    LoggingEnabled: number
    TwitchEnabled: number
    YoutubeEnabled: number
    SpotifyEnabled: number
    GuildId: number
    _all: number
  }


  export type GuildFeatureTogglesMinAggregateInputType = {
    id?: true
    LevelEnabled?: true
    WecomeEnabled?: true
    LeaveEnabled?: true
    AutoreactEnabled?: true
    AutopublishEnabled?: true
    ConnectionsEnabled?: true
    ChatfilterEnabled?: true
    AutorolesEnabled?: true
    LoggingEnabled?: true
    TwitchEnabled?: true
    YoutubeEnabled?: true
    SpotifyEnabled?: true
    GuildId?: true
  }

  export type GuildFeatureTogglesMaxAggregateInputType = {
    id?: true
    LevelEnabled?: true
    WecomeEnabled?: true
    LeaveEnabled?: true
    AutoreactEnabled?: true
    AutopublishEnabled?: true
    ConnectionsEnabled?: true
    ChatfilterEnabled?: true
    AutorolesEnabled?: true
    LoggingEnabled?: true
    TwitchEnabled?: true
    YoutubeEnabled?: true
    SpotifyEnabled?: true
    GuildId?: true
  }

  export type GuildFeatureTogglesCountAggregateInputType = {
    id?: true
    LevelEnabled?: true
    WecomeEnabled?: true
    LeaveEnabled?: true
    AutoreactEnabled?: true
    AutopublishEnabled?: true
    ConnectionsEnabled?: true
    ChatfilterEnabled?: true
    AutorolesEnabled?: true
    LoggingEnabled?: true
    TwitchEnabled?: true
    YoutubeEnabled?: true
    SpotifyEnabled?: true
    GuildId?: true
    _all?: true
  }

  export type GuildFeatureTogglesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildFeatureToggles to aggregate.
     */
    where?: GuildFeatureTogglesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildFeatureToggles to fetch.
     */
    orderBy?: GuildFeatureTogglesOrderByWithRelationInput | GuildFeatureTogglesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuildFeatureTogglesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildFeatureToggles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildFeatureToggles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuildFeatureToggles
    **/
    _count?: true | GuildFeatureTogglesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildFeatureTogglesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildFeatureTogglesMaxAggregateInputType
  }

  export type GetGuildFeatureTogglesAggregateType<T extends GuildFeatureTogglesAggregateArgs> = {
        [P in keyof T & keyof AggregateGuildFeatureToggles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuildFeatureToggles[P]>
      : GetScalarType<T[P], AggregateGuildFeatureToggles[P]>
  }




  export type GuildFeatureTogglesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildFeatureTogglesWhereInput
    orderBy?: GuildFeatureTogglesOrderByWithAggregationInput | GuildFeatureTogglesOrderByWithAggregationInput[]
    by: GuildFeatureTogglesScalarFieldEnum[] | GuildFeatureTogglesScalarFieldEnum
    having?: GuildFeatureTogglesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildFeatureTogglesCountAggregateInputType | true
    _min?: GuildFeatureTogglesMinAggregateInputType
    _max?: GuildFeatureTogglesMaxAggregateInputType
  }

  export type GuildFeatureTogglesGroupByOutputType = {
    id: string
    LevelEnabled: boolean
    WecomeEnabled: boolean
    LeaveEnabled: boolean
    AutoreactEnabled: boolean
    AutopublishEnabled: boolean
    ConnectionsEnabled: boolean
    ChatfilterEnabled: boolean
    AutorolesEnabled: boolean
    LoggingEnabled: boolean
    TwitchEnabled: boolean
    YoutubeEnabled: boolean
    SpotifyEnabled: boolean
    GuildId: string
    _count: GuildFeatureTogglesCountAggregateOutputType | null
    _min: GuildFeatureTogglesMinAggregateOutputType | null
    _max: GuildFeatureTogglesMaxAggregateOutputType | null
  }

  type GetGuildFeatureTogglesGroupByPayload<T extends GuildFeatureTogglesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildFeatureTogglesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildFeatureTogglesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildFeatureTogglesGroupByOutputType[P]>
            : GetScalarType<T[P], GuildFeatureTogglesGroupByOutputType[P]>
        }
      >
    >


  export type GuildFeatureTogglesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    LevelEnabled?: boolean
    WecomeEnabled?: boolean
    LeaveEnabled?: boolean
    AutoreactEnabled?: boolean
    AutopublishEnabled?: boolean
    ConnectionsEnabled?: boolean
    ChatfilterEnabled?: boolean
    AutorolesEnabled?: boolean
    LoggingEnabled?: boolean
    TwitchEnabled?: boolean
    YoutubeEnabled?: boolean
    SpotifyEnabled?: boolean
    GuildId?: boolean
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guildFeatureToggles"]>



  export type GuildFeatureTogglesSelectScalar = {
    id?: boolean
    LevelEnabled?: boolean
    WecomeEnabled?: boolean
    LeaveEnabled?: boolean
    AutoreactEnabled?: boolean
    AutopublishEnabled?: boolean
    ConnectionsEnabled?: boolean
    ChatfilterEnabled?: boolean
    AutorolesEnabled?: boolean
    LoggingEnabled?: boolean
    TwitchEnabled?: boolean
    YoutubeEnabled?: boolean
    SpotifyEnabled?: boolean
    GuildId?: boolean
  }

  export type GuildFeatureTogglesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "LevelEnabled" | "WecomeEnabled" | "LeaveEnabled" | "AutoreactEnabled" | "AutopublishEnabled" | "ConnectionsEnabled" | "ChatfilterEnabled" | "AutorolesEnabled" | "LoggingEnabled" | "TwitchEnabled" | "YoutubeEnabled" | "SpotifyEnabled" | "GuildId", ExtArgs["result"]["guildFeatureToggles"]>
  export type GuildFeatureTogglesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }

  export type $GuildFeatureTogglesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GuildFeatureToggles"
    objects: {
      Guilds: Prisma.$GuildsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      LevelEnabled: boolean
      WecomeEnabled: boolean
      LeaveEnabled: boolean
      AutoreactEnabled: boolean
      AutopublishEnabled: boolean
      ConnectionsEnabled: boolean
      ChatfilterEnabled: boolean
      AutorolesEnabled: boolean
      LoggingEnabled: boolean
      TwitchEnabled: boolean
      YoutubeEnabled: boolean
      SpotifyEnabled: boolean
      GuildId: string
    }, ExtArgs["result"]["guildFeatureToggles"]>
    composites: {}
  }

  type GuildFeatureTogglesGetPayload<S extends boolean | null | undefined | GuildFeatureTogglesDefaultArgs> = $Result.GetResult<Prisma.$GuildFeatureTogglesPayload, S>

  type GuildFeatureTogglesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuildFeatureTogglesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuildFeatureTogglesCountAggregateInputType | true
    }

  export interface GuildFeatureTogglesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GuildFeatureToggles'], meta: { name: 'GuildFeatureToggles' } }
    /**
     * Find zero or one GuildFeatureToggles that matches the filter.
     * @param {GuildFeatureTogglesFindUniqueArgs} args - Arguments to find a GuildFeatureToggles
     * @example
     * // Get one GuildFeatureToggles
     * const guildFeatureToggles = await prisma.guildFeatureToggles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuildFeatureTogglesFindUniqueArgs>(args: SelectSubset<T, GuildFeatureTogglesFindUniqueArgs<ExtArgs>>): Prisma__GuildFeatureTogglesClient<$Result.GetResult<Prisma.$GuildFeatureTogglesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GuildFeatureToggles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuildFeatureTogglesFindUniqueOrThrowArgs} args - Arguments to find a GuildFeatureToggles
     * @example
     * // Get one GuildFeatureToggles
     * const guildFeatureToggles = await prisma.guildFeatureToggles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuildFeatureTogglesFindUniqueOrThrowArgs>(args: SelectSubset<T, GuildFeatureTogglesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuildFeatureTogglesClient<$Result.GetResult<Prisma.$GuildFeatureTogglesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuildFeatureToggles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFeatureTogglesFindFirstArgs} args - Arguments to find a GuildFeatureToggles
     * @example
     * // Get one GuildFeatureToggles
     * const guildFeatureToggles = await prisma.guildFeatureToggles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuildFeatureTogglesFindFirstArgs>(args?: SelectSubset<T, GuildFeatureTogglesFindFirstArgs<ExtArgs>>): Prisma__GuildFeatureTogglesClient<$Result.GetResult<Prisma.$GuildFeatureTogglesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuildFeatureToggles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFeatureTogglesFindFirstOrThrowArgs} args - Arguments to find a GuildFeatureToggles
     * @example
     * // Get one GuildFeatureToggles
     * const guildFeatureToggles = await prisma.guildFeatureToggles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuildFeatureTogglesFindFirstOrThrowArgs>(args?: SelectSubset<T, GuildFeatureTogglesFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuildFeatureTogglesClient<$Result.GetResult<Prisma.$GuildFeatureTogglesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuildFeatureToggles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFeatureTogglesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuildFeatureToggles
     * const guildFeatureToggles = await prisma.guildFeatureToggles.findMany()
     * 
     * // Get first 10 GuildFeatureToggles
     * const guildFeatureToggles = await prisma.guildFeatureToggles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildFeatureTogglesWithIdOnly = await prisma.guildFeatureToggles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuildFeatureTogglesFindManyArgs>(args?: SelectSubset<T, GuildFeatureTogglesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildFeatureTogglesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GuildFeatureToggles.
     * @param {GuildFeatureTogglesCreateArgs} args - Arguments to create a GuildFeatureToggles.
     * @example
     * // Create one GuildFeatureToggles
     * const GuildFeatureToggles = await prisma.guildFeatureToggles.create({
     *   data: {
     *     // ... data to create a GuildFeatureToggles
     *   }
     * })
     * 
     */
    create<T extends GuildFeatureTogglesCreateArgs>(args: SelectSubset<T, GuildFeatureTogglesCreateArgs<ExtArgs>>): Prisma__GuildFeatureTogglesClient<$Result.GetResult<Prisma.$GuildFeatureTogglesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GuildFeatureToggles.
     * @param {GuildFeatureTogglesCreateManyArgs} args - Arguments to create many GuildFeatureToggles.
     * @example
     * // Create many GuildFeatureToggles
     * const guildFeatureToggles = await prisma.guildFeatureToggles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuildFeatureTogglesCreateManyArgs>(args?: SelectSubset<T, GuildFeatureTogglesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GuildFeatureToggles.
     * @param {GuildFeatureTogglesDeleteArgs} args - Arguments to delete one GuildFeatureToggles.
     * @example
     * // Delete one GuildFeatureToggles
     * const GuildFeatureToggles = await prisma.guildFeatureToggles.delete({
     *   where: {
     *     // ... filter to delete one GuildFeatureToggles
     *   }
     * })
     * 
     */
    delete<T extends GuildFeatureTogglesDeleteArgs>(args: SelectSubset<T, GuildFeatureTogglesDeleteArgs<ExtArgs>>): Prisma__GuildFeatureTogglesClient<$Result.GetResult<Prisma.$GuildFeatureTogglesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GuildFeatureToggles.
     * @param {GuildFeatureTogglesUpdateArgs} args - Arguments to update one GuildFeatureToggles.
     * @example
     * // Update one GuildFeatureToggles
     * const guildFeatureToggles = await prisma.guildFeatureToggles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuildFeatureTogglesUpdateArgs>(args: SelectSubset<T, GuildFeatureTogglesUpdateArgs<ExtArgs>>): Prisma__GuildFeatureTogglesClient<$Result.GetResult<Prisma.$GuildFeatureTogglesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GuildFeatureToggles.
     * @param {GuildFeatureTogglesDeleteManyArgs} args - Arguments to filter GuildFeatureToggles to delete.
     * @example
     * // Delete a few GuildFeatureToggles
     * const { count } = await prisma.guildFeatureToggles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuildFeatureTogglesDeleteManyArgs>(args?: SelectSubset<T, GuildFeatureTogglesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuildFeatureToggles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFeatureTogglesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuildFeatureToggles
     * const guildFeatureToggles = await prisma.guildFeatureToggles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuildFeatureTogglesUpdateManyArgs>(args: SelectSubset<T, GuildFeatureTogglesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GuildFeatureToggles.
     * @param {GuildFeatureTogglesUpsertArgs} args - Arguments to update or create a GuildFeatureToggles.
     * @example
     * // Update or create a GuildFeatureToggles
     * const guildFeatureToggles = await prisma.guildFeatureToggles.upsert({
     *   create: {
     *     // ... data to create a GuildFeatureToggles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuildFeatureToggles we want to update
     *   }
     * })
     */
    upsert<T extends GuildFeatureTogglesUpsertArgs>(args: SelectSubset<T, GuildFeatureTogglesUpsertArgs<ExtArgs>>): Prisma__GuildFeatureTogglesClient<$Result.GetResult<Prisma.$GuildFeatureTogglesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuildFeatureToggles that matches the filter.
     * @param {GuildFeatureTogglesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const guildFeatureToggles = await prisma.guildFeatureToggles.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: GuildFeatureTogglesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a GuildFeatureToggles.
     * @param {GuildFeatureTogglesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const guildFeatureToggles = await prisma.guildFeatureToggles.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: GuildFeatureTogglesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of GuildFeatureToggles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFeatureTogglesCountArgs} args - Arguments to filter GuildFeatureToggles to count.
     * @example
     * // Count the number of GuildFeatureToggles
     * const count = await prisma.guildFeatureToggles.count({
     *   where: {
     *     // ... the filter for the GuildFeatureToggles we want to count
     *   }
     * })
    **/
    count<T extends GuildFeatureTogglesCountArgs>(
      args?: Subset<T, GuildFeatureTogglesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildFeatureTogglesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuildFeatureToggles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFeatureTogglesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildFeatureTogglesAggregateArgs>(args: Subset<T, GuildFeatureTogglesAggregateArgs>): Prisma.PrismaPromise<GetGuildFeatureTogglesAggregateType<T>>

    /**
     * Group by GuildFeatureToggles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFeatureTogglesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildFeatureTogglesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildFeatureTogglesGroupByArgs['orderBy'] }
        : { orderBy?: GuildFeatureTogglesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildFeatureTogglesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildFeatureTogglesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GuildFeatureToggles model
   */
  readonly fields: GuildFeatureTogglesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuildFeatureToggles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuildFeatureTogglesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GuildFeatureToggles model
   */
  interface GuildFeatureTogglesFieldRefs {
    readonly id: FieldRef<"GuildFeatureToggles", 'String'>
    readonly LevelEnabled: FieldRef<"GuildFeatureToggles", 'Boolean'>
    readonly WecomeEnabled: FieldRef<"GuildFeatureToggles", 'Boolean'>
    readonly LeaveEnabled: FieldRef<"GuildFeatureToggles", 'Boolean'>
    readonly AutoreactEnabled: FieldRef<"GuildFeatureToggles", 'Boolean'>
    readonly AutopublishEnabled: FieldRef<"GuildFeatureToggles", 'Boolean'>
    readonly ConnectionsEnabled: FieldRef<"GuildFeatureToggles", 'Boolean'>
    readonly ChatfilterEnabled: FieldRef<"GuildFeatureToggles", 'Boolean'>
    readonly AutorolesEnabled: FieldRef<"GuildFeatureToggles", 'Boolean'>
    readonly LoggingEnabled: FieldRef<"GuildFeatureToggles", 'Boolean'>
    readonly TwitchEnabled: FieldRef<"GuildFeatureToggles", 'Boolean'>
    readonly YoutubeEnabled: FieldRef<"GuildFeatureToggles", 'Boolean'>
    readonly SpotifyEnabled: FieldRef<"GuildFeatureToggles", 'Boolean'>
    readonly GuildId: FieldRef<"GuildFeatureToggles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GuildFeatureToggles findUnique
   */
  export type GuildFeatureTogglesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildFeatureToggles
     */
    select?: GuildFeatureTogglesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildFeatureToggles
     */
    omit?: GuildFeatureTogglesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildFeatureTogglesInclude<ExtArgs> | null
    /**
     * Filter, which GuildFeatureToggles to fetch.
     */
    where: GuildFeatureTogglesWhereUniqueInput
  }

  /**
   * GuildFeatureToggles findUniqueOrThrow
   */
  export type GuildFeatureTogglesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildFeatureToggles
     */
    select?: GuildFeatureTogglesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildFeatureToggles
     */
    omit?: GuildFeatureTogglesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildFeatureTogglesInclude<ExtArgs> | null
    /**
     * Filter, which GuildFeatureToggles to fetch.
     */
    where: GuildFeatureTogglesWhereUniqueInput
  }

  /**
   * GuildFeatureToggles findFirst
   */
  export type GuildFeatureTogglesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildFeatureToggles
     */
    select?: GuildFeatureTogglesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildFeatureToggles
     */
    omit?: GuildFeatureTogglesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildFeatureTogglesInclude<ExtArgs> | null
    /**
     * Filter, which GuildFeatureToggles to fetch.
     */
    where?: GuildFeatureTogglesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildFeatureToggles to fetch.
     */
    orderBy?: GuildFeatureTogglesOrderByWithRelationInput | GuildFeatureTogglesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildFeatureToggles.
     */
    cursor?: GuildFeatureTogglesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildFeatureToggles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildFeatureToggles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildFeatureToggles.
     */
    distinct?: GuildFeatureTogglesScalarFieldEnum | GuildFeatureTogglesScalarFieldEnum[]
  }

  /**
   * GuildFeatureToggles findFirstOrThrow
   */
  export type GuildFeatureTogglesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildFeatureToggles
     */
    select?: GuildFeatureTogglesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildFeatureToggles
     */
    omit?: GuildFeatureTogglesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildFeatureTogglesInclude<ExtArgs> | null
    /**
     * Filter, which GuildFeatureToggles to fetch.
     */
    where?: GuildFeatureTogglesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildFeatureToggles to fetch.
     */
    orderBy?: GuildFeatureTogglesOrderByWithRelationInput | GuildFeatureTogglesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildFeatureToggles.
     */
    cursor?: GuildFeatureTogglesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildFeatureToggles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildFeatureToggles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildFeatureToggles.
     */
    distinct?: GuildFeatureTogglesScalarFieldEnum | GuildFeatureTogglesScalarFieldEnum[]
  }

  /**
   * GuildFeatureToggles findMany
   */
  export type GuildFeatureTogglesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildFeatureToggles
     */
    select?: GuildFeatureTogglesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildFeatureToggles
     */
    omit?: GuildFeatureTogglesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildFeatureTogglesInclude<ExtArgs> | null
    /**
     * Filter, which GuildFeatureToggles to fetch.
     */
    where?: GuildFeatureTogglesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildFeatureToggles to fetch.
     */
    orderBy?: GuildFeatureTogglesOrderByWithRelationInput | GuildFeatureTogglesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuildFeatureToggles.
     */
    cursor?: GuildFeatureTogglesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildFeatureToggles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildFeatureToggles.
     */
    skip?: number
    distinct?: GuildFeatureTogglesScalarFieldEnum | GuildFeatureTogglesScalarFieldEnum[]
  }

  /**
   * GuildFeatureToggles create
   */
  export type GuildFeatureTogglesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildFeatureToggles
     */
    select?: GuildFeatureTogglesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildFeatureToggles
     */
    omit?: GuildFeatureTogglesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildFeatureTogglesInclude<ExtArgs> | null
    /**
     * The data needed to create a GuildFeatureToggles.
     */
    data: XOR<GuildFeatureTogglesCreateInput, GuildFeatureTogglesUncheckedCreateInput>
  }

  /**
   * GuildFeatureToggles createMany
   */
  export type GuildFeatureTogglesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GuildFeatureToggles.
     */
    data: GuildFeatureTogglesCreateManyInput | GuildFeatureTogglesCreateManyInput[]
  }

  /**
   * GuildFeatureToggles update
   */
  export type GuildFeatureTogglesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildFeatureToggles
     */
    select?: GuildFeatureTogglesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildFeatureToggles
     */
    omit?: GuildFeatureTogglesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildFeatureTogglesInclude<ExtArgs> | null
    /**
     * The data needed to update a GuildFeatureToggles.
     */
    data: XOR<GuildFeatureTogglesUpdateInput, GuildFeatureTogglesUncheckedUpdateInput>
    /**
     * Choose, which GuildFeatureToggles to update.
     */
    where: GuildFeatureTogglesWhereUniqueInput
  }

  /**
   * GuildFeatureToggles updateMany
   */
  export type GuildFeatureTogglesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GuildFeatureToggles.
     */
    data: XOR<GuildFeatureTogglesUpdateManyMutationInput, GuildFeatureTogglesUncheckedUpdateManyInput>
    /**
     * Filter which GuildFeatureToggles to update
     */
    where?: GuildFeatureTogglesWhereInput
    /**
     * Limit how many GuildFeatureToggles to update.
     */
    limit?: number
  }

  /**
   * GuildFeatureToggles upsert
   */
  export type GuildFeatureTogglesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildFeatureToggles
     */
    select?: GuildFeatureTogglesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildFeatureToggles
     */
    omit?: GuildFeatureTogglesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildFeatureTogglesInclude<ExtArgs> | null
    /**
     * The filter to search for the GuildFeatureToggles to update in case it exists.
     */
    where: GuildFeatureTogglesWhereUniqueInput
    /**
     * In case the GuildFeatureToggles found by the `where` argument doesn't exist, create a new GuildFeatureToggles with this data.
     */
    create: XOR<GuildFeatureTogglesCreateInput, GuildFeatureTogglesUncheckedCreateInput>
    /**
     * In case the GuildFeatureToggles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuildFeatureTogglesUpdateInput, GuildFeatureTogglesUncheckedUpdateInput>
  }

  /**
   * GuildFeatureToggles delete
   */
  export type GuildFeatureTogglesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildFeatureToggles
     */
    select?: GuildFeatureTogglesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildFeatureToggles
     */
    omit?: GuildFeatureTogglesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildFeatureTogglesInclude<ExtArgs> | null
    /**
     * Filter which GuildFeatureToggles to delete.
     */
    where: GuildFeatureTogglesWhereUniqueInput
  }

  /**
   * GuildFeatureToggles deleteMany
   */
  export type GuildFeatureTogglesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildFeatureToggles to delete
     */
    where?: GuildFeatureTogglesWhereInput
    /**
     * Limit how many GuildFeatureToggles to delete.
     */
    limit?: number
  }

  /**
   * GuildFeatureToggles findRaw
   */
  export type GuildFeatureTogglesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GuildFeatureToggles aggregateRaw
   */
  export type GuildFeatureTogglesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GuildFeatureToggles without action
   */
  export type GuildFeatureTogglesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildFeatureToggles
     */
    select?: GuildFeatureTogglesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildFeatureToggles
     */
    omit?: GuildFeatureTogglesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildFeatureTogglesInclude<ExtArgs> | null
  }


  /**
   * Model TwitchNotifications
   */

  export type AggregateTwitchNotifications = {
    _count: TwitchNotificationsCountAggregateOutputType | null
    _min: TwitchNotificationsMinAggregateOutputType | null
    _max: TwitchNotificationsMaxAggregateOutputType | null
  }

  export type TwitchNotificationsMinAggregateOutputType = {
    id: string | null
    UUID: string | null
    TwitchChannelName: string | null
    ChannelId: string | null
    Live: boolean | null
    MessageTemplateId: string | null
    GuildId: string | null
  }

  export type TwitchNotificationsMaxAggregateOutputType = {
    id: string | null
    UUID: string | null
    TwitchChannelName: string | null
    ChannelId: string | null
    Live: boolean | null
    MessageTemplateId: string | null
    GuildId: string | null
  }

  export type TwitchNotificationsCountAggregateOutputType = {
    id: number
    UUID: number
    TwitchChannelName: number
    ChannelId: number
    Live: number
    MessageTemplateId: number
    PingRoles: number
    GuildId: number
    _all: number
  }


  export type TwitchNotificationsMinAggregateInputType = {
    id?: true
    UUID?: true
    TwitchChannelName?: true
    ChannelId?: true
    Live?: true
    MessageTemplateId?: true
    GuildId?: true
  }

  export type TwitchNotificationsMaxAggregateInputType = {
    id?: true
    UUID?: true
    TwitchChannelName?: true
    ChannelId?: true
    Live?: true
    MessageTemplateId?: true
    GuildId?: true
  }

  export type TwitchNotificationsCountAggregateInputType = {
    id?: true
    UUID?: true
    TwitchChannelName?: true
    ChannelId?: true
    Live?: true
    MessageTemplateId?: true
    PingRoles?: true
    GuildId?: true
    _all?: true
  }

  export type TwitchNotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwitchNotifications to aggregate.
     */
    where?: TwitchNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitchNotifications to fetch.
     */
    orderBy?: TwitchNotificationsOrderByWithRelationInput | TwitchNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitchNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitchNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitchNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitchNotifications
    **/
    _count?: true | TwitchNotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitchNotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitchNotificationsMaxAggregateInputType
  }

  export type GetTwitchNotificationsAggregateType<T extends TwitchNotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitchNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitchNotifications[P]>
      : GetScalarType<T[P], AggregateTwitchNotifications[P]>
  }




  export type TwitchNotificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwitchNotificationsWhereInput
    orderBy?: TwitchNotificationsOrderByWithAggregationInput | TwitchNotificationsOrderByWithAggregationInput[]
    by: TwitchNotificationsScalarFieldEnum[] | TwitchNotificationsScalarFieldEnum
    having?: TwitchNotificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitchNotificationsCountAggregateInputType | true
    _min?: TwitchNotificationsMinAggregateInputType
    _max?: TwitchNotificationsMaxAggregateInputType
  }

  export type TwitchNotificationsGroupByOutputType = {
    id: string
    UUID: string
    TwitchChannelName: string
    ChannelId: string
    Live: boolean
    MessageTemplateId: string
    PingRoles: string[]
    GuildId: string
    _count: TwitchNotificationsCountAggregateOutputType | null
    _min: TwitchNotificationsMinAggregateOutputType | null
    _max: TwitchNotificationsMaxAggregateOutputType | null
  }

  type GetTwitchNotificationsGroupByPayload<T extends TwitchNotificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TwitchNotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitchNotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitchNotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], TwitchNotificationsGroupByOutputType[P]>
        }
      >
    >


  export type TwitchNotificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    UUID?: boolean
    TwitchChannelName?: boolean
    ChannelId?: boolean
    Live?: boolean
    MessageTemplateId?: boolean
    PingRoles?: boolean
    GuildId?: boolean
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["twitchNotifications"]>



  export type TwitchNotificationsSelectScalar = {
    id?: boolean
    UUID?: boolean
    TwitchChannelName?: boolean
    ChannelId?: boolean
    Live?: boolean
    MessageTemplateId?: boolean
    PingRoles?: boolean
    GuildId?: boolean
  }

  export type TwitchNotificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "UUID" | "TwitchChannelName" | "ChannelId" | "Live" | "MessageTemplateId" | "PingRoles" | "GuildId", ExtArgs["result"]["twitchNotifications"]>
  export type TwitchNotificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }

  export type $TwitchNotificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TwitchNotifications"
    objects: {
      Guilds: Prisma.$GuildsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      UUID: string
      TwitchChannelName: string
      ChannelId: string
      Live: boolean
      MessageTemplateId: string
      PingRoles: string[]
      GuildId: string
    }, ExtArgs["result"]["twitchNotifications"]>
    composites: {}
  }

  type TwitchNotificationsGetPayload<S extends boolean | null | undefined | TwitchNotificationsDefaultArgs> = $Result.GetResult<Prisma.$TwitchNotificationsPayload, S>

  type TwitchNotificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TwitchNotificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TwitchNotificationsCountAggregateInputType | true
    }

  export interface TwitchNotificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TwitchNotifications'], meta: { name: 'TwitchNotifications' } }
    /**
     * Find zero or one TwitchNotifications that matches the filter.
     * @param {TwitchNotificationsFindUniqueArgs} args - Arguments to find a TwitchNotifications
     * @example
     * // Get one TwitchNotifications
     * const twitchNotifications = await prisma.twitchNotifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TwitchNotificationsFindUniqueArgs>(args: SelectSubset<T, TwitchNotificationsFindUniqueArgs<ExtArgs>>): Prisma__TwitchNotificationsClient<$Result.GetResult<Prisma.$TwitchNotificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TwitchNotifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TwitchNotificationsFindUniqueOrThrowArgs} args - Arguments to find a TwitchNotifications
     * @example
     * // Get one TwitchNotifications
     * const twitchNotifications = await prisma.twitchNotifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TwitchNotificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, TwitchNotificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TwitchNotificationsClient<$Result.GetResult<Prisma.$TwitchNotificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TwitchNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitchNotificationsFindFirstArgs} args - Arguments to find a TwitchNotifications
     * @example
     * // Get one TwitchNotifications
     * const twitchNotifications = await prisma.twitchNotifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TwitchNotificationsFindFirstArgs>(args?: SelectSubset<T, TwitchNotificationsFindFirstArgs<ExtArgs>>): Prisma__TwitchNotificationsClient<$Result.GetResult<Prisma.$TwitchNotificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TwitchNotifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitchNotificationsFindFirstOrThrowArgs} args - Arguments to find a TwitchNotifications
     * @example
     * // Get one TwitchNotifications
     * const twitchNotifications = await prisma.twitchNotifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TwitchNotificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, TwitchNotificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TwitchNotificationsClient<$Result.GetResult<Prisma.$TwitchNotificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TwitchNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitchNotificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitchNotifications
     * const twitchNotifications = await prisma.twitchNotifications.findMany()
     * 
     * // Get first 10 TwitchNotifications
     * const twitchNotifications = await prisma.twitchNotifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitchNotificationsWithIdOnly = await prisma.twitchNotifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TwitchNotificationsFindManyArgs>(args?: SelectSubset<T, TwitchNotificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwitchNotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TwitchNotifications.
     * @param {TwitchNotificationsCreateArgs} args - Arguments to create a TwitchNotifications.
     * @example
     * // Create one TwitchNotifications
     * const TwitchNotifications = await prisma.twitchNotifications.create({
     *   data: {
     *     // ... data to create a TwitchNotifications
     *   }
     * })
     * 
     */
    create<T extends TwitchNotificationsCreateArgs>(args: SelectSubset<T, TwitchNotificationsCreateArgs<ExtArgs>>): Prisma__TwitchNotificationsClient<$Result.GetResult<Prisma.$TwitchNotificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TwitchNotifications.
     * @param {TwitchNotificationsCreateManyArgs} args - Arguments to create many TwitchNotifications.
     * @example
     * // Create many TwitchNotifications
     * const twitchNotifications = await prisma.twitchNotifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TwitchNotificationsCreateManyArgs>(args?: SelectSubset<T, TwitchNotificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwitchNotifications.
     * @param {TwitchNotificationsDeleteArgs} args - Arguments to delete one TwitchNotifications.
     * @example
     * // Delete one TwitchNotifications
     * const TwitchNotifications = await prisma.twitchNotifications.delete({
     *   where: {
     *     // ... filter to delete one TwitchNotifications
     *   }
     * })
     * 
     */
    delete<T extends TwitchNotificationsDeleteArgs>(args: SelectSubset<T, TwitchNotificationsDeleteArgs<ExtArgs>>): Prisma__TwitchNotificationsClient<$Result.GetResult<Prisma.$TwitchNotificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TwitchNotifications.
     * @param {TwitchNotificationsUpdateArgs} args - Arguments to update one TwitchNotifications.
     * @example
     * // Update one TwitchNotifications
     * const twitchNotifications = await prisma.twitchNotifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TwitchNotificationsUpdateArgs>(args: SelectSubset<T, TwitchNotificationsUpdateArgs<ExtArgs>>): Prisma__TwitchNotificationsClient<$Result.GetResult<Prisma.$TwitchNotificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TwitchNotifications.
     * @param {TwitchNotificationsDeleteManyArgs} args - Arguments to filter TwitchNotifications to delete.
     * @example
     * // Delete a few TwitchNotifications
     * const { count } = await prisma.twitchNotifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TwitchNotificationsDeleteManyArgs>(args?: SelectSubset<T, TwitchNotificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitchNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitchNotificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitchNotifications
     * const twitchNotifications = await prisma.twitchNotifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TwitchNotificationsUpdateManyArgs>(args: SelectSubset<T, TwitchNotificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwitchNotifications.
     * @param {TwitchNotificationsUpsertArgs} args - Arguments to update or create a TwitchNotifications.
     * @example
     * // Update or create a TwitchNotifications
     * const twitchNotifications = await prisma.twitchNotifications.upsert({
     *   create: {
     *     // ... data to create a TwitchNotifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitchNotifications we want to update
     *   }
     * })
     */
    upsert<T extends TwitchNotificationsUpsertArgs>(args: SelectSubset<T, TwitchNotificationsUpsertArgs<ExtArgs>>): Prisma__TwitchNotificationsClient<$Result.GetResult<Prisma.$TwitchNotificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TwitchNotifications that matches the filter.
     * @param {TwitchNotificationsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const twitchNotifications = await prisma.twitchNotifications.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TwitchNotificationsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TwitchNotifications.
     * @param {TwitchNotificationsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const twitchNotifications = await prisma.twitchNotifications.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TwitchNotificationsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TwitchNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitchNotificationsCountArgs} args - Arguments to filter TwitchNotifications to count.
     * @example
     * // Count the number of TwitchNotifications
     * const count = await prisma.twitchNotifications.count({
     *   where: {
     *     // ... the filter for the TwitchNotifications we want to count
     *   }
     * })
    **/
    count<T extends TwitchNotificationsCountArgs>(
      args?: Subset<T, TwitchNotificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitchNotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitchNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitchNotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitchNotificationsAggregateArgs>(args: Subset<T, TwitchNotificationsAggregateArgs>): Prisma.PrismaPromise<GetTwitchNotificationsAggregateType<T>>

    /**
     * Group by TwitchNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitchNotificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitchNotificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitchNotificationsGroupByArgs['orderBy'] }
        : { orderBy?: TwitchNotificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitchNotificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitchNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TwitchNotifications model
   */
  readonly fields: TwitchNotificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitchNotifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TwitchNotificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TwitchNotifications model
   */
  interface TwitchNotificationsFieldRefs {
    readonly id: FieldRef<"TwitchNotifications", 'String'>
    readonly UUID: FieldRef<"TwitchNotifications", 'String'>
    readonly TwitchChannelName: FieldRef<"TwitchNotifications", 'String'>
    readonly ChannelId: FieldRef<"TwitchNotifications", 'String'>
    readonly Live: FieldRef<"TwitchNotifications", 'Boolean'>
    readonly MessageTemplateId: FieldRef<"TwitchNotifications", 'String'>
    readonly PingRoles: FieldRef<"TwitchNotifications", 'String[]'>
    readonly GuildId: FieldRef<"TwitchNotifications", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TwitchNotifications findUnique
   */
  export type TwitchNotificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitchNotifications
     */
    select?: TwitchNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitchNotifications
     */
    omit?: TwitchNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitchNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which TwitchNotifications to fetch.
     */
    where: TwitchNotificationsWhereUniqueInput
  }

  /**
   * TwitchNotifications findUniqueOrThrow
   */
  export type TwitchNotificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitchNotifications
     */
    select?: TwitchNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitchNotifications
     */
    omit?: TwitchNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitchNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which TwitchNotifications to fetch.
     */
    where: TwitchNotificationsWhereUniqueInput
  }

  /**
   * TwitchNotifications findFirst
   */
  export type TwitchNotificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitchNotifications
     */
    select?: TwitchNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitchNotifications
     */
    omit?: TwitchNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitchNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which TwitchNotifications to fetch.
     */
    where?: TwitchNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitchNotifications to fetch.
     */
    orderBy?: TwitchNotificationsOrderByWithRelationInput | TwitchNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitchNotifications.
     */
    cursor?: TwitchNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitchNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitchNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitchNotifications.
     */
    distinct?: TwitchNotificationsScalarFieldEnum | TwitchNotificationsScalarFieldEnum[]
  }

  /**
   * TwitchNotifications findFirstOrThrow
   */
  export type TwitchNotificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitchNotifications
     */
    select?: TwitchNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitchNotifications
     */
    omit?: TwitchNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitchNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which TwitchNotifications to fetch.
     */
    where?: TwitchNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitchNotifications to fetch.
     */
    orderBy?: TwitchNotificationsOrderByWithRelationInput | TwitchNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitchNotifications.
     */
    cursor?: TwitchNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitchNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitchNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitchNotifications.
     */
    distinct?: TwitchNotificationsScalarFieldEnum | TwitchNotificationsScalarFieldEnum[]
  }

  /**
   * TwitchNotifications findMany
   */
  export type TwitchNotificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitchNotifications
     */
    select?: TwitchNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitchNotifications
     */
    omit?: TwitchNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitchNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which TwitchNotifications to fetch.
     */
    where?: TwitchNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitchNotifications to fetch.
     */
    orderBy?: TwitchNotificationsOrderByWithRelationInput | TwitchNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitchNotifications.
     */
    cursor?: TwitchNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitchNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitchNotifications.
     */
    skip?: number
    distinct?: TwitchNotificationsScalarFieldEnum | TwitchNotificationsScalarFieldEnum[]
  }

  /**
   * TwitchNotifications create
   */
  export type TwitchNotificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitchNotifications
     */
    select?: TwitchNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitchNotifications
     */
    omit?: TwitchNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitchNotificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a TwitchNotifications.
     */
    data: XOR<TwitchNotificationsCreateInput, TwitchNotificationsUncheckedCreateInput>
  }

  /**
   * TwitchNotifications createMany
   */
  export type TwitchNotificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TwitchNotifications.
     */
    data: TwitchNotificationsCreateManyInput | TwitchNotificationsCreateManyInput[]
  }

  /**
   * TwitchNotifications update
   */
  export type TwitchNotificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitchNotifications
     */
    select?: TwitchNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitchNotifications
     */
    omit?: TwitchNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitchNotificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a TwitchNotifications.
     */
    data: XOR<TwitchNotificationsUpdateInput, TwitchNotificationsUncheckedUpdateInput>
    /**
     * Choose, which TwitchNotifications to update.
     */
    where: TwitchNotificationsWhereUniqueInput
  }

  /**
   * TwitchNotifications updateMany
   */
  export type TwitchNotificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TwitchNotifications.
     */
    data: XOR<TwitchNotificationsUpdateManyMutationInput, TwitchNotificationsUncheckedUpdateManyInput>
    /**
     * Filter which TwitchNotifications to update
     */
    where?: TwitchNotificationsWhereInput
    /**
     * Limit how many TwitchNotifications to update.
     */
    limit?: number
  }

  /**
   * TwitchNotifications upsert
   */
  export type TwitchNotificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitchNotifications
     */
    select?: TwitchNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitchNotifications
     */
    omit?: TwitchNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitchNotificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the TwitchNotifications to update in case it exists.
     */
    where: TwitchNotificationsWhereUniqueInput
    /**
     * In case the TwitchNotifications found by the `where` argument doesn't exist, create a new TwitchNotifications with this data.
     */
    create: XOR<TwitchNotificationsCreateInput, TwitchNotificationsUncheckedCreateInput>
    /**
     * In case the TwitchNotifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitchNotificationsUpdateInput, TwitchNotificationsUncheckedUpdateInput>
  }

  /**
   * TwitchNotifications delete
   */
  export type TwitchNotificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitchNotifications
     */
    select?: TwitchNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitchNotifications
     */
    omit?: TwitchNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitchNotificationsInclude<ExtArgs> | null
    /**
     * Filter which TwitchNotifications to delete.
     */
    where: TwitchNotificationsWhereUniqueInput
  }

  /**
   * TwitchNotifications deleteMany
   */
  export type TwitchNotificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwitchNotifications to delete
     */
    where?: TwitchNotificationsWhereInput
    /**
     * Limit how many TwitchNotifications to delete.
     */
    limit?: number
  }

  /**
   * TwitchNotifications findRaw
   */
  export type TwitchNotificationsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TwitchNotifications aggregateRaw
   */
  export type TwitchNotificationsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TwitchNotifications without action
   */
  export type TwitchNotificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitchNotifications
     */
    select?: TwitchNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitchNotifications
     */
    omit?: TwitchNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitchNotificationsInclude<ExtArgs> | null
  }


  /**
   * Model YoutubeNotifications
   */

  export type AggregateYoutubeNotifications = {
    _count: YoutubeNotificationsCountAggregateOutputType | null
    _min: YoutubeNotificationsMinAggregateOutputType | null
    _max: YoutubeNotificationsMaxAggregateOutputType | null
  }

  export type YoutubeNotificationsMinAggregateOutputType = {
    id: string | null
    YoutubeChannelId: string | null
    ChannelId: string | null
    MessageTemplateId: string | null
    UUID: string | null
    GuildId: string | null
  }

  export type YoutubeNotificationsMaxAggregateOutputType = {
    id: string | null
    YoutubeChannelId: string | null
    ChannelId: string | null
    MessageTemplateId: string | null
    UUID: string | null
    GuildId: string | null
  }

  export type YoutubeNotificationsCountAggregateOutputType = {
    id: number
    YoutubeChannelId: number
    ChannelId: number
    Latest: number
    MessageTemplateId: number
    PingRoles: number
    UUID: number
    GuildId: number
    _all: number
  }


  export type YoutubeNotificationsMinAggregateInputType = {
    id?: true
    YoutubeChannelId?: true
    ChannelId?: true
    MessageTemplateId?: true
    UUID?: true
    GuildId?: true
  }

  export type YoutubeNotificationsMaxAggregateInputType = {
    id?: true
    YoutubeChannelId?: true
    ChannelId?: true
    MessageTemplateId?: true
    UUID?: true
    GuildId?: true
  }

  export type YoutubeNotificationsCountAggregateInputType = {
    id?: true
    YoutubeChannelId?: true
    ChannelId?: true
    Latest?: true
    MessageTemplateId?: true
    PingRoles?: true
    UUID?: true
    GuildId?: true
    _all?: true
  }

  export type YoutubeNotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YoutubeNotifications to aggregate.
     */
    where?: YoutubeNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeNotifications to fetch.
     */
    orderBy?: YoutubeNotificationsOrderByWithRelationInput | YoutubeNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeNotifications
    **/
    _count?: true | YoutubeNotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeNotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeNotificationsMaxAggregateInputType
  }

  export type GetYoutubeNotificationsAggregateType<T extends YoutubeNotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeNotifications[P]>
      : GetScalarType<T[P], AggregateYoutubeNotifications[P]>
  }




  export type YoutubeNotificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YoutubeNotificationsWhereInput
    orderBy?: YoutubeNotificationsOrderByWithAggregationInput | YoutubeNotificationsOrderByWithAggregationInput[]
    by: YoutubeNotificationsScalarFieldEnum[] | YoutubeNotificationsScalarFieldEnum
    having?: YoutubeNotificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeNotificationsCountAggregateInputType | true
    _min?: YoutubeNotificationsMinAggregateInputType
    _max?: YoutubeNotificationsMaxAggregateInputType
  }

  export type YoutubeNotificationsGroupByOutputType = {
    id: string
    YoutubeChannelId: string
    ChannelId: string
    Latest: string[]
    MessageTemplateId: string
    PingRoles: string[]
    UUID: string
    GuildId: string
    _count: YoutubeNotificationsCountAggregateOutputType | null
    _min: YoutubeNotificationsMinAggregateOutputType | null
    _max: YoutubeNotificationsMaxAggregateOutputType | null
  }

  type GetYoutubeNotificationsGroupByPayload<T extends YoutubeNotificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<YoutubeNotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeNotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeNotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeNotificationsGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeNotificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    YoutubeChannelId?: boolean
    ChannelId?: boolean
    Latest?: boolean
    MessageTemplateId?: boolean
    PingRoles?: boolean
    UUID?: boolean
    GuildId?: boolean
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["youtubeNotifications"]>



  export type YoutubeNotificationsSelectScalar = {
    id?: boolean
    YoutubeChannelId?: boolean
    ChannelId?: boolean
    Latest?: boolean
    MessageTemplateId?: boolean
    PingRoles?: boolean
    UUID?: boolean
    GuildId?: boolean
  }

  export type YoutubeNotificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "YoutubeChannelId" | "ChannelId" | "Latest" | "MessageTemplateId" | "PingRoles" | "UUID" | "GuildId", ExtArgs["result"]["youtubeNotifications"]>
  export type YoutubeNotificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Guilds?: boolean | GuildsDefaultArgs<ExtArgs>
  }

  export type $YoutubeNotificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "YoutubeNotifications"
    objects: {
      Guilds: Prisma.$GuildsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      YoutubeChannelId: string
      ChannelId: string
      Latest: string[]
      MessageTemplateId: string
      PingRoles: string[]
      UUID: string
      GuildId: string
    }, ExtArgs["result"]["youtubeNotifications"]>
    composites: {}
  }

  type YoutubeNotificationsGetPayload<S extends boolean | null | undefined | YoutubeNotificationsDefaultArgs> = $Result.GetResult<Prisma.$YoutubeNotificationsPayload, S>

  type YoutubeNotificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<YoutubeNotificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: YoutubeNotificationsCountAggregateInputType | true
    }

  export interface YoutubeNotificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['YoutubeNotifications'], meta: { name: 'YoutubeNotifications' } }
    /**
     * Find zero or one YoutubeNotifications that matches the filter.
     * @param {YoutubeNotificationsFindUniqueArgs} args - Arguments to find a YoutubeNotifications
     * @example
     * // Get one YoutubeNotifications
     * const youtubeNotifications = await prisma.youtubeNotifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends YoutubeNotificationsFindUniqueArgs>(args: SelectSubset<T, YoutubeNotificationsFindUniqueArgs<ExtArgs>>): Prisma__YoutubeNotificationsClient<$Result.GetResult<Prisma.$YoutubeNotificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one YoutubeNotifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {YoutubeNotificationsFindUniqueOrThrowArgs} args - Arguments to find a YoutubeNotifications
     * @example
     * // Get one YoutubeNotifications
     * const youtubeNotifications = await prisma.youtubeNotifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends YoutubeNotificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, YoutubeNotificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__YoutubeNotificationsClient<$Result.GetResult<Prisma.$YoutubeNotificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first YoutubeNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeNotificationsFindFirstArgs} args - Arguments to find a YoutubeNotifications
     * @example
     * // Get one YoutubeNotifications
     * const youtubeNotifications = await prisma.youtubeNotifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends YoutubeNotificationsFindFirstArgs>(args?: SelectSubset<T, YoutubeNotificationsFindFirstArgs<ExtArgs>>): Prisma__YoutubeNotificationsClient<$Result.GetResult<Prisma.$YoutubeNotificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first YoutubeNotifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeNotificationsFindFirstOrThrowArgs} args - Arguments to find a YoutubeNotifications
     * @example
     * // Get one YoutubeNotifications
     * const youtubeNotifications = await prisma.youtubeNotifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends YoutubeNotificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, YoutubeNotificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__YoutubeNotificationsClient<$Result.GetResult<Prisma.$YoutubeNotificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more YoutubeNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeNotificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeNotifications
     * const youtubeNotifications = await prisma.youtubeNotifications.findMany()
     * 
     * // Get first 10 YoutubeNotifications
     * const youtubeNotifications = await prisma.youtubeNotifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youtubeNotificationsWithIdOnly = await prisma.youtubeNotifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends YoutubeNotificationsFindManyArgs>(args?: SelectSubset<T, YoutubeNotificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YoutubeNotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a YoutubeNotifications.
     * @param {YoutubeNotificationsCreateArgs} args - Arguments to create a YoutubeNotifications.
     * @example
     * // Create one YoutubeNotifications
     * const YoutubeNotifications = await prisma.youtubeNotifications.create({
     *   data: {
     *     // ... data to create a YoutubeNotifications
     *   }
     * })
     * 
     */
    create<T extends YoutubeNotificationsCreateArgs>(args: SelectSubset<T, YoutubeNotificationsCreateArgs<ExtArgs>>): Prisma__YoutubeNotificationsClient<$Result.GetResult<Prisma.$YoutubeNotificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many YoutubeNotifications.
     * @param {YoutubeNotificationsCreateManyArgs} args - Arguments to create many YoutubeNotifications.
     * @example
     * // Create many YoutubeNotifications
     * const youtubeNotifications = await prisma.youtubeNotifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends YoutubeNotificationsCreateManyArgs>(args?: SelectSubset<T, YoutubeNotificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeNotifications.
     * @param {YoutubeNotificationsDeleteArgs} args - Arguments to delete one YoutubeNotifications.
     * @example
     * // Delete one YoutubeNotifications
     * const YoutubeNotifications = await prisma.youtubeNotifications.delete({
     *   where: {
     *     // ... filter to delete one YoutubeNotifications
     *   }
     * })
     * 
     */
    delete<T extends YoutubeNotificationsDeleteArgs>(args: SelectSubset<T, YoutubeNotificationsDeleteArgs<ExtArgs>>): Prisma__YoutubeNotificationsClient<$Result.GetResult<Prisma.$YoutubeNotificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one YoutubeNotifications.
     * @param {YoutubeNotificationsUpdateArgs} args - Arguments to update one YoutubeNotifications.
     * @example
     * // Update one YoutubeNotifications
     * const youtubeNotifications = await prisma.youtubeNotifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends YoutubeNotificationsUpdateArgs>(args: SelectSubset<T, YoutubeNotificationsUpdateArgs<ExtArgs>>): Prisma__YoutubeNotificationsClient<$Result.GetResult<Prisma.$YoutubeNotificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more YoutubeNotifications.
     * @param {YoutubeNotificationsDeleteManyArgs} args - Arguments to filter YoutubeNotifications to delete.
     * @example
     * // Delete a few YoutubeNotifications
     * const { count } = await prisma.youtubeNotifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends YoutubeNotificationsDeleteManyArgs>(args?: SelectSubset<T, YoutubeNotificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeNotificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeNotifications
     * const youtubeNotifications = await prisma.youtubeNotifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends YoutubeNotificationsUpdateManyArgs>(args: SelectSubset<T, YoutubeNotificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeNotifications.
     * @param {YoutubeNotificationsUpsertArgs} args - Arguments to update or create a YoutubeNotifications.
     * @example
     * // Update or create a YoutubeNotifications
     * const youtubeNotifications = await prisma.youtubeNotifications.upsert({
     *   create: {
     *     // ... data to create a YoutubeNotifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeNotifications we want to update
     *   }
     * })
     */
    upsert<T extends YoutubeNotificationsUpsertArgs>(args: SelectSubset<T, YoutubeNotificationsUpsertArgs<ExtArgs>>): Prisma__YoutubeNotificationsClient<$Result.GetResult<Prisma.$YoutubeNotificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more YoutubeNotifications that matches the filter.
     * @param {YoutubeNotificationsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const youtubeNotifications = await prisma.youtubeNotifications.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: YoutubeNotificationsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a YoutubeNotifications.
     * @param {YoutubeNotificationsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const youtubeNotifications = await prisma.youtubeNotifications.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: YoutubeNotificationsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of YoutubeNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeNotificationsCountArgs} args - Arguments to filter YoutubeNotifications to count.
     * @example
     * // Count the number of YoutubeNotifications
     * const count = await prisma.youtubeNotifications.count({
     *   where: {
     *     // ... the filter for the YoutubeNotifications we want to count
     *   }
     * })
    **/
    count<T extends YoutubeNotificationsCountArgs>(
      args?: Subset<T, YoutubeNotificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeNotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeNotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeNotificationsAggregateArgs>(args: Subset<T, YoutubeNotificationsAggregateArgs>): Prisma.PrismaPromise<GetYoutubeNotificationsAggregateType<T>>

    /**
     * Group by YoutubeNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeNotificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeNotificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeNotificationsGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeNotificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeNotificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the YoutubeNotifications model
   */
  readonly fields: YoutubeNotificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeNotifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__YoutubeNotificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Guilds<T extends GuildsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildsDefaultArgs<ExtArgs>>): Prisma__GuildsClient<$Result.GetResult<Prisma.$GuildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the YoutubeNotifications model
   */
  interface YoutubeNotificationsFieldRefs {
    readonly id: FieldRef<"YoutubeNotifications", 'String'>
    readonly YoutubeChannelId: FieldRef<"YoutubeNotifications", 'String'>
    readonly ChannelId: FieldRef<"YoutubeNotifications", 'String'>
    readonly Latest: FieldRef<"YoutubeNotifications", 'String[]'>
    readonly MessageTemplateId: FieldRef<"YoutubeNotifications", 'String'>
    readonly PingRoles: FieldRef<"YoutubeNotifications", 'String[]'>
    readonly UUID: FieldRef<"YoutubeNotifications", 'String'>
    readonly GuildId: FieldRef<"YoutubeNotifications", 'String'>
  }
    

  // Custom InputTypes
  /**
   * YoutubeNotifications findUnique
   */
  export type YoutubeNotificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YoutubeNotifications
     */
    select?: YoutubeNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YoutubeNotifications
     */
    omit?: YoutubeNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YoutubeNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which YoutubeNotifications to fetch.
     */
    where: YoutubeNotificationsWhereUniqueInput
  }

  /**
   * YoutubeNotifications findUniqueOrThrow
   */
  export type YoutubeNotificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YoutubeNotifications
     */
    select?: YoutubeNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YoutubeNotifications
     */
    omit?: YoutubeNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YoutubeNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which YoutubeNotifications to fetch.
     */
    where: YoutubeNotificationsWhereUniqueInput
  }

  /**
   * YoutubeNotifications findFirst
   */
  export type YoutubeNotificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YoutubeNotifications
     */
    select?: YoutubeNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YoutubeNotifications
     */
    omit?: YoutubeNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YoutubeNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which YoutubeNotifications to fetch.
     */
    where?: YoutubeNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeNotifications to fetch.
     */
    orderBy?: YoutubeNotificationsOrderByWithRelationInput | YoutubeNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeNotifications.
     */
    cursor?: YoutubeNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeNotifications.
     */
    distinct?: YoutubeNotificationsScalarFieldEnum | YoutubeNotificationsScalarFieldEnum[]
  }

  /**
   * YoutubeNotifications findFirstOrThrow
   */
  export type YoutubeNotificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YoutubeNotifications
     */
    select?: YoutubeNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YoutubeNotifications
     */
    omit?: YoutubeNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YoutubeNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which YoutubeNotifications to fetch.
     */
    where?: YoutubeNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeNotifications to fetch.
     */
    orderBy?: YoutubeNotificationsOrderByWithRelationInput | YoutubeNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeNotifications.
     */
    cursor?: YoutubeNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeNotifications.
     */
    distinct?: YoutubeNotificationsScalarFieldEnum | YoutubeNotificationsScalarFieldEnum[]
  }

  /**
   * YoutubeNotifications findMany
   */
  export type YoutubeNotificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YoutubeNotifications
     */
    select?: YoutubeNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YoutubeNotifications
     */
    omit?: YoutubeNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YoutubeNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which YoutubeNotifications to fetch.
     */
    where?: YoutubeNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeNotifications to fetch.
     */
    orderBy?: YoutubeNotificationsOrderByWithRelationInput | YoutubeNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeNotifications.
     */
    cursor?: YoutubeNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeNotifications.
     */
    skip?: number
    distinct?: YoutubeNotificationsScalarFieldEnum | YoutubeNotificationsScalarFieldEnum[]
  }

  /**
   * YoutubeNotifications create
   */
  export type YoutubeNotificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YoutubeNotifications
     */
    select?: YoutubeNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YoutubeNotifications
     */
    omit?: YoutubeNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YoutubeNotificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a YoutubeNotifications.
     */
    data: XOR<YoutubeNotificationsCreateInput, YoutubeNotificationsUncheckedCreateInput>
  }

  /**
   * YoutubeNotifications createMany
   */
  export type YoutubeNotificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many YoutubeNotifications.
     */
    data: YoutubeNotificationsCreateManyInput | YoutubeNotificationsCreateManyInput[]
  }

  /**
   * YoutubeNotifications update
   */
  export type YoutubeNotificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YoutubeNotifications
     */
    select?: YoutubeNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YoutubeNotifications
     */
    omit?: YoutubeNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YoutubeNotificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a YoutubeNotifications.
     */
    data: XOR<YoutubeNotificationsUpdateInput, YoutubeNotificationsUncheckedUpdateInput>
    /**
     * Choose, which YoutubeNotifications to update.
     */
    where: YoutubeNotificationsWhereUniqueInput
  }

  /**
   * YoutubeNotifications updateMany
   */
  export type YoutubeNotificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update YoutubeNotifications.
     */
    data: XOR<YoutubeNotificationsUpdateManyMutationInput, YoutubeNotificationsUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeNotifications to update
     */
    where?: YoutubeNotificationsWhereInput
    /**
     * Limit how many YoutubeNotifications to update.
     */
    limit?: number
  }

  /**
   * YoutubeNotifications upsert
   */
  export type YoutubeNotificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YoutubeNotifications
     */
    select?: YoutubeNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YoutubeNotifications
     */
    omit?: YoutubeNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YoutubeNotificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the YoutubeNotifications to update in case it exists.
     */
    where: YoutubeNotificationsWhereUniqueInput
    /**
     * In case the YoutubeNotifications found by the `where` argument doesn't exist, create a new YoutubeNotifications with this data.
     */
    create: XOR<YoutubeNotificationsCreateInput, YoutubeNotificationsUncheckedCreateInput>
    /**
     * In case the YoutubeNotifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeNotificationsUpdateInput, YoutubeNotificationsUncheckedUpdateInput>
  }

  /**
   * YoutubeNotifications delete
   */
  export type YoutubeNotificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YoutubeNotifications
     */
    select?: YoutubeNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YoutubeNotifications
     */
    omit?: YoutubeNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YoutubeNotificationsInclude<ExtArgs> | null
    /**
     * Filter which YoutubeNotifications to delete.
     */
    where: YoutubeNotificationsWhereUniqueInput
  }

  /**
   * YoutubeNotifications deleteMany
   */
  export type YoutubeNotificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YoutubeNotifications to delete
     */
    where?: YoutubeNotificationsWhereInput
    /**
     * Limit how many YoutubeNotifications to delete.
     */
    limit?: number
  }

  /**
   * YoutubeNotifications findRaw
   */
  export type YoutubeNotificationsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * YoutubeNotifications aggregateRaw
   */
  export type YoutubeNotificationsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * YoutubeNotifications without action
   */
  export type YoutubeNotificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YoutubeNotifications
     */
    select?: YoutubeNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YoutubeNotifications
     */
    omit?: YoutubeNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YoutubeNotificationsInclude<ExtArgs> | null
  }


  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    Votes: number | null
    GloablVotes: number | null
    CustomerBots: number | null
    BackupCount: number | null
  }

  export type UsersSumAggregateOutputType = {
    Votes: number | null
    GloablVotes: number | null
    CustomerBots: number | null
    BackupCount: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    Username: string | null
    UserId: string | null
    Votes: number | null
    GloablVotes: number | null
    CustomerBots: number | null
    BackupCount: number | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    Username: string | null
    UserId: string | null
    Votes: number | null
    GloablVotes: number | null
    CustomerBots: number | null
    BackupCount: number | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    Username: number
    UserId: number
    Votes: number
    GloablVotes: number
    CustomerBots: number
    BackupCount: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    Votes?: true
    GloablVotes?: true
    CustomerBots?: true
    BackupCount?: true
  }

  export type UsersSumAggregateInputType = {
    Votes?: true
    GloablVotes?: true
    CustomerBots?: true
    BackupCount?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    Username?: true
    UserId?: true
    Votes?: true
    GloablVotes?: true
    CustomerBots?: true
    BackupCount?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    Username?: true
    UserId?: true
    Votes?: true
    GloablVotes?: true
    CustomerBots?: true
    BackupCount?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    Username?: true
    UserId?: true
    Votes?: true
    GloablVotes?: true
    CustomerBots?: true
    BackupCount?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    Username: string
    UserId: string
    Votes: number
    GloablVotes: number
    CustomerBots: number
    BackupCount: number
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Username?: boolean
    UserId?: boolean
    Votes?: boolean
    GloablVotes?: boolean
    CustomerBots?: boolean
    BackupCount?: boolean
    Apiss?: boolean | Users$ApissArgs<ExtArgs>
    GuildBackups?: boolean | Users$GuildBackupsArgs<ExtArgs>
    Customers?: boolean | Users$CustomersArgs<ExtArgs>
    DisBotUserNotifications?: boolean | Users$DisBotUserNotificationsArgs<ExtArgs>
    Vanitys?: boolean | Users$VanitysArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>



  export type UsersSelectScalar = {
    id?: boolean
    Username?: boolean
    UserId?: boolean
    Votes?: boolean
    GloablVotes?: boolean
    CustomerBots?: boolean
    BackupCount?: boolean
  }

  export type UsersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Username" | "UserId" | "Votes" | "GloablVotes" | "CustomerBots" | "BackupCount", ExtArgs["result"]["users"]>
  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Apiss?: boolean | Users$ApissArgs<ExtArgs>
    GuildBackups?: boolean | Users$GuildBackupsArgs<ExtArgs>
    Customers?: boolean | Users$CustomersArgs<ExtArgs>
    DisBotUserNotifications?: boolean | Users$DisBotUserNotificationsArgs<ExtArgs>
    Vanitys?: boolean | Users$VanitysArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      Apiss: Prisma.$ApisPayload<ExtArgs>[]
      GuildBackups: Prisma.$GuildBackupsPayload<ExtArgs>[]
      Customers: Prisma.$CustomersPayload<ExtArgs>[]
      DisBotUserNotifications: Prisma.$DisBotUserNotificationsPayload<ExtArgs> | null
      Vanitys: Prisma.$VanitysPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Username: string
      UserId: string
      Votes: number
      GloablVotes: number
      CustomerBots: number
      BackupCount: number
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UsersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const users = await prisma.users.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UsersFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Users.
     * @param {UsersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const users = await prisma.users.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UsersAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Apiss<T extends Users$ApissArgs<ExtArgs> = {}>(args?: Subset<T, Users$ApissArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    GuildBackups<T extends Users$GuildBackupsArgs<ExtArgs> = {}>(args?: Subset<T, Users$GuildBackupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildBackupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Customers<T extends Users$CustomersArgs<ExtArgs> = {}>(args?: Subset<T, Users$CustomersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DisBotUserNotifications<T extends Users$DisBotUserNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, Users$DisBotUserNotificationsArgs<ExtArgs>>): Prisma__DisBotUserNotificationsClient<$Result.GetResult<Prisma.$DisBotUserNotificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Vanitys<T extends Users$VanitysArgs<ExtArgs> = {}>(args?: Subset<T, Users$VanitysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VanitysPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */
  interface UsersFieldRefs {
    readonly id: FieldRef<"Users", 'String'>
    readonly Username: FieldRef<"Users", 'String'>
    readonly UserId: FieldRef<"Users", 'String'>
    readonly Votes: FieldRef<"Users", 'Int'>
    readonly GloablVotes: FieldRef<"Users", 'Int'>
    readonly CustomerBots: FieldRef<"Users", 'Int'>
    readonly BackupCount: FieldRef<"Users", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * Users findRaw
   */
  export type UsersFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Users aggregateRaw
   */
  export type UsersAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Users.Apiss
   */
  export type Users$ApissArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apis
     */
    select?: ApisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Apis
     */
    omit?: ApisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApisInclude<ExtArgs> | null
    where?: ApisWhereInput
    orderBy?: ApisOrderByWithRelationInput | ApisOrderByWithRelationInput[]
    cursor?: ApisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApisScalarFieldEnum | ApisScalarFieldEnum[]
  }

  /**
   * Users.GuildBackups
   */
  export type Users$GuildBackupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBackups
     */
    select?: GuildBackupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBackups
     */
    omit?: GuildBackupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBackupsInclude<ExtArgs> | null
    where?: GuildBackupsWhereInput
    orderBy?: GuildBackupsOrderByWithRelationInput | GuildBackupsOrderByWithRelationInput[]
    cursor?: GuildBackupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GuildBackupsScalarFieldEnum | GuildBackupsScalarFieldEnum[]
  }

  /**
   * Users.Customers
   */
  export type Users$CustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    where?: CustomersWhereInput
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    cursor?: CustomersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * Users.DisBotUserNotifications
   */
  export type Users$DisBotUserNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisBotUserNotifications
     */
    select?: DisBotUserNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisBotUserNotifications
     */
    omit?: DisBotUserNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisBotUserNotificationsInclude<ExtArgs> | null
    where?: DisBotUserNotificationsWhereInput
  }

  /**
   * Users.Vanitys
   */
  export type Users$VanitysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vanitys
     */
    select?: VanitysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vanitys
     */
    omit?: VanitysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanitysInclude<ExtArgs> | null
    where?: VanitysWhereInput
    orderBy?: VanitysOrderByWithRelationInput | VanitysOrderByWithRelationInput[]
    cursor?: VanitysWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VanitysScalarFieldEnum | VanitysScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model Apis
   */

  export type AggregateApis = {
    _count: ApisCountAggregateOutputType | null
    _min: ApisMinAggregateOutputType | null
    _max: ApisMaxAggregateOutputType | null
  }

  export type ApisMinAggregateOutputType = {
    id: string | null
    Key: string | null
    UserId: string | null
  }

  export type ApisMaxAggregateOutputType = {
    id: string | null
    Key: string | null
    UserId: string | null
  }

  export type ApisCountAggregateOutputType = {
    id: number
    Flags: number
    Guilds: number
    Key: number
    UserId: number
    _all: number
  }


  export type ApisMinAggregateInputType = {
    id?: true
    Key?: true
    UserId?: true
  }

  export type ApisMaxAggregateInputType = {
    id?: true
    Key?: true
    UserId?: true
  }

  export type ApisCountAggregateInputType = {
    id?: true
    Flags?: true
    Guilds?: true
    Key?: true
    UserId?: true
    _all?: true
  }

  export type ApisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Apis to aggregate.
     */
    where?: ApisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apis to fetch.
     */
    orderBy?: ApisOrderByWithRelationInput | ApisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Apis
    **/
    _count?: true | ApisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApisMaxAggregateInputType
  }

  export type GetApisAggregateType<T extends ApisAggregateArgs> = {
        [P in keyof T & keyof AggregateApis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApis[P]>
      : GetScalarType<T[P], AggregateApis[P]>
  }




  export type ApisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApisWhereInput
    orderBy?: ApisOrderByWithAggregationInput | ApisOrderByWithAggregationInput[]
    by: ApisScalarFieldEnum[] | ApisScalarFieldEnum
    having?: ApisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApisCountAggregateInputType | true
    _min?: ApisMinAggregateInputType
    _max?: ApisMaxAggregateInputType
  }

  export type ApisGroupByOutputType = {
    id: string
    Flags: string[]
    Guilds: string[]
    Key: string
    UserId: string
    _count: ApisCountAggregateOutputType | null
    _min: ApisMinAggregateOutputType | null
    _max: ApisMaxAggregateOutputType | null
  }

  type GetApisGroupByPayload<T extends ApisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApisGroupByOutputType[P]>
            : GetScalarType<T[P], ApisGroupByOutputType[P]>
        }
      >
    >


  export type ApisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Flags?: boolean
    Guilds?: boolean
    Key?: boolean
    UserId?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apis"]>



  export type ApisSelectScalar = {
    id?: boolean
    Flags?: boolean
    Guilds?: boolean
    Key?: boolean
    UserId?: boolean
  }

  export type ApisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Flags" | "Guilds" | "Key" | "UserId", ExtArgs["result"]["apis"]>
  export type ApisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $ApisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Apis"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Flags: string[]
      Guilds: string[]
      Key: string
      UserId: string
    }, ExtArgs["result"]["apis"]>
    composites: {}
  }

  type ApisGetPayload<S extends boolean | null | undefined | ApisDefaultArgs> = $Result.GetResult<Prisma.$ApisPayload, S>

  type ApisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApisCountAggregateInputType | true
    }

  export interface ApisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Apis'], meta: { name: 'Apis' } }
    /**
     * Find zero or one Apis that matches the filter.
     * @param {ApisFindUniqueArgs} args - Arguments to find a Apis
     * @example
     * // Get one Apis
     * const apis = await prisma.apis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApisFindUniqueArgs>(args: SelectSubset<T, ApisFindUniqueArgs<ExtArgs>>): Prisma__ApisClient<$Result.GetResult<Prisma.$ApisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Apis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApisFindUniqueOrThrowArgs} args - Arguments to find a Apis
     * @example
     * // Get one Apis
     * const apis = await prisma.apis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApisFindUniqueOrThrowArgs>(args: SelectSubset<T, ApisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApisClient<$Result.GetResult<Prisma.$ApisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Apis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApisFindFirstArgs} args - Arguments to find a Apis
     * @example
     * // Get one Apis
     * const apis = await prisma.apis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApisFindFirstArgs>(args?: SelectSubset<T, ApisFindFirstArgs<ExtArgs>>): Prisma__ApisClient<$Result.GetResult<Prisma.$ApisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Apis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApisFindFirstOrThrowArgs} args - Arguments to find a Apis
     * @example
     * // Get one Apis
     * const apis = await prisma.apis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApisFindFirstOrThrowArgs>(args?: SelectSubset<T, ApisFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApisClient<$Result.GetResult<Prisma.$ApisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Apis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Apis
     * const apis = await prisma.apis.findMany()
     * 
     * // Get first 10 Apis
     * const apis = await prisma.apis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apisWithIdOnly = await prisma.apis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApisFindManyArgs>(args?: SelectSubset<T, ApisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Apis.
     * @param {ApisCreateArgs} args - Arguments to create a Apis.
     * @example
     * // Create one Apis
     * const Apis = await prisma.apis.create({
     *   data: {
     *     // ... data to create a Apis
     *   }
     * })
     * 
     */
    create<T extends ApisCreateArgs>(args: SelectSubset<T, ApisCreateArgs<ExtArgs>>): Prisma__ApisClient<$Result.GetResult<Prisma.$ApisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Apis.
     * @param {ApisCreateManyArgs} args - Arguments to create many Apis.
     * @example
     * // Create many Apis
     * const apis = await prisma.apis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApisCreateManyArgs>(args?: SelectSubset<T, ApisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Apis.
     * @param {ApisDeleteArgs} args - Arguments to delete one Apis.
     * @example
     * // Delete one Apis
     * const Apis = await prisma.apis.delete({
     *   where: {
     *     // ... filter to delete one Apis
     *   }
     * })
     * 
     */
    delete<T extends ApisDeleteArgs>(args: SelectSubset<T, ApisDeleteArgs<ExtArgs>>): Prisma__ApisClient<$Result.GetResult<Prisma.$ApisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Apis.
     * @param {ApisUpdateArgs} args - Arguments to update one Apis.
     * @example
     * // Update one Apis
     * const apis = await prisma.apis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApisUpdateArgs>(args: SelectSubset<T, ApisUpdateArgs<ExtArgs>>): Prisma__ApisClient<$Result.GetResult<Prisma.$ApisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Apis.
     * @param {ApisDeleteManyArgs} args - Arguments to filter Apis to delete.
     * @example
     * // Delete a few Apis
     * const { count } = await prisma.apis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApisDeleteManyArgs>(args?: SelectSubset<T, ApisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Apis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Apis
     * const apis = await prisma.apis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApisUpdateManyArgs>(args: SelectSubset<T, ApisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Apis.
     * @param {ApisUpsertArgs} args - Arguments to update or create a Apis.
     * @example
     * // Update or create a Apis
     * const apis = await prisma.apis.upsert({
     *   create: {
     *     // ... data to create a Apis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Apis we want to update
     *   }
     * })
     */
    upsert<T extends ApisUpsertArgs>(args: SelectSubset<T, ApisUpsertArgs<ExtArgs>>): Prisma__ApisClient<$Result.GetResult<Prisma.$ApisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Apis that matches the filter.
     * @param {ApisFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const apis = await prisma.apis.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ApisFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Apis.
     * @param {ApisAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const apis = await prisma.apis.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ApisAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Apis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApisCountArgs} args - Arguments to filter Apis to count.
     * @example
     * // Count the number of Apis
     * const count = await prisma.apis.count({
     *   where: {
     *     // ... the filter for the Apis we want to count
     *   }
     * })
    **/
    count<T extends ApisCountArgs>(
      args?: Subset<T, ApisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Apis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApisAggregateArgs>(args: Subset<T, ApisAggregateArgs>): Prisma.PrismaPromise<GetApisAggregateType<T>>

    /**
     * Group by Apis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApisGroupByArgs['orderBy'] }
        : { orderBy?: ApisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Apis model
   */
  readonly fields: ApisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Apis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Apis model
   */
  interface ApisFieldRefs {
    readonly id: FieldRef<"Apis", 'String'>
    readonly Flags: FieldRef<"Apis", 'String[]'>
    readonly Guilds: FieldRef<"Apis", 'String[]'>
    readonly Key: FieldRef<"Apis", 'String'>
    readonly UserId: FieldRef<"Apis", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Apis findUnique
   */
  export type ApisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apis
     */
    select?: ApisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Apis
     */
    omit?: ApisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApisInclude<ExtArgs> | null
    /**
     * Filter, which Apis to fetch.
     */
    where: ApisWhereUniqueInput
  }

  /**
   * Apis findUniqueOrThrow
   */
  export type ApisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apis
     */
    select?: ApisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Apis
     */
    omit?: ApisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApisInclude<ExtArgs> | null
    /**
     * Filter, which Apis to fetch.
     */
    where: ApisWhereUniqueInput
  }

  /**
   * Apis findFirst
   */
  export type ApisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apis
     */
    select?: ApisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Apis
     */
    omit?: ApisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApisInclude<ExtArgs> | null
    /**
     * Filter, which Apis to fetch.
     */
    where?: ApisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apis to fetch.
     */
    orderBy?: ApisOrderByWithRelationInput | ApisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Apis.
     */
    cursor?: ApisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Apis.
     */
    distinct?: ApisScalarFieldEnum | ApisScalarFieldEnum[]
  }

  /**
   * Apis findFirstOrThrow
   */
  export type ApisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apis
     */
    select?: ApisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Apis
     */
    omit?: ApisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApisInclude<ExtArgs> | null
    /**
     * Filter, which Apis to fetch.
     */
    where?: ApisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apis to fetch.
     */
    orderBy?: ApisOrderByWithRelationInput | ApisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Apis.
     */
    cursor?: ApisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Apis.
     */
    distinct?: ApisScalarFieldEnum | ApisScalarFieldEnum[]
  }

  /**
   * Apis findMany
   */
  export type ApisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apis
     */
    select?: ApisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Apis
     */
    omit?: ApisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApisInclude<ExtArgs> | null
    /**
     * Filter, which Apis to fetch.
     */
    where?: ApisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apis to fetch.
     */
    orderBy?: ApisOrderByWithRelationInput | ApisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Apis.
     */
    cursor?: ApisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apis.
     */
    skip?: number
    distinct?: ApisScalarFieldEnum | ApisScalarFieldEnum[]
  }

  /**
   * Apis create
   */
  export type ApisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apis
     */
    select?: ApisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Apis
     */
    omit?: ApisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApisInclude<ExtArgs> | null
    /**
     * The data needed to create a Apis.
     */
    data: XOR<ApisCreateInput, ApisUncheckedCreateInput>
  }

  /**
   * Apis createMany
   */
  export type ApisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Apis.
     */
    data: ApisCreateManyInput | ApisCreateManyInput[]
  }

  /**
   * Apis update
   */
  export type ApisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apis
     */
    select?: ApisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Apis
     */
    omit?: ApisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApisInclude<ExtArgs> | null
    /**
     * The data needed to update a Apis.
     */
    data: XOR<ApisUpdateInput, ApisUncheckedUpdateInput>
    /**
     * Choose, which Apis to update.
     */
    where: ApisWhereUniqueInput
  }

  /**
   * Apis updateMany
   */
  export type ApisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Apis.
     */
    data: XOR<ApisUpdateManyMutationInput, ApisUncheckedUpdateManyInput>
    /**
     * Filter which Apis to update
     */
    where?: ApisWhereInput
    /**
     * Limit how many Apis to update.
     */
    limit?: number
  }

  /**
   * Apis upsert
   */
  export type ApisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apis
     */
    select?: ApisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Apis
     */
    omit?: ApisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApisInclude<ExtArgs> | null
    /**
     * The filter to search for the Apis to update in case it exists.
     */
    where: ApisWhereUniqueInput
    /**
     * In case the Apis found by the `where` argument doesn't exist, create a new Apis with this data.
     */
    create: XOR<ApisCreateInput, ApisUncheckedCreateInput>
    /**
     * In case the Apis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApisUpdateInput, ApisUncheckedUpdateInput>
  }

  /**
   * Apis delete
   */
  export type ApisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apis
     */
    select?: ApisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Apis
     */
    omit?: ApisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApisInclude<ExtArgs> | null
    /**
     * Filter which Apis to delete.
     */
    where: ApisWhereUniqueInput
  }

  /**
   * Apis deleteMany
   */
  export type ApisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Apis to delete
     */
    where?: ApisWhereInput
    /**
     * Limit how many Apis to delete.
     */
    limit?: number
  }

  /**
   * Apis findRaw
   */
  export type ApisFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Apis aggregateRaw
   */
  export type ApisAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Apis without action
   */
  export type ApisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apis
     */
    select?: ApisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Apis
     */
    omit?: ApisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApisInclude<ExtArgs> | null
  }


  /**
   * Model GuildBackups
   */

  export type AggregateGuildBackups = {
    _count: GuildBackupsCountAggregateOutputType | null
    _min: GuildBackupsMinAggregateOutputType | null
    _max: GuildBackupsMaxAggregateOutputType | null
  }

  export type GuildBackupsMinAggregateOutputType = {
    id: string | null
    CreatedAt: Date | null
    UUID: string | null
    Name: string | null
    GuildId: string | null
    UserId: string | null
  }

  export type GuildBackupsMaxAggregateOutputType = {
    id: string | null
    CreatedAt: Date | null
    UUID: string | null
    Name: string | null
    GuildId: string | null
    UserId: string | null
  }

  export type GuildBackupsCountAggregateOutputType = {
    id: number
    BackupJSON: number
    CreatedAt: number
    UUID: number
    Name: number
    GuildId: number
    UserId: number
    _all: number
  }


  export type GuildBackupsMinAggregateInputType = {
    id?: true
    CreatedAt?: true
    UUID?: true
    Name?: true
    GuildId?: true
    UserId?: true
  }

  export type GuildBackupsMaxAggregateInputType = {
    id?: true
    CreatedAt?: true
    UUID?: true
    Name?: true
    GuildId?: true
    UserId?: true
  }

  export type GuildBackupsCountAggregateInputType = {
    id?: true
    BackupJSON?: true
    CreatedAt?: true
    UUID?: true
    Name?: true
    GuildId?: true
    UserId?: true
    _all?: true
  }

  export type GuildBackupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildBackups to aggregate.
     */
    where?: GuildBackupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildBackups to fetch.
     */
    orderBy?: GuildBackupsOrderByWithRelationInput | GuildBackupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuildBackupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildBackups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildBackups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuildBackups
    **/
    _count?: true | GuildBackupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildBackupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildBackupsMaxAggregateInputType
  }

  export type GetGuildBackupsAggregateType<T extends GuildBackupsAggregateArgs> = {
        [P in keyof T & keyof AggregateGuildBackups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuildBackups[P]>
      : GetScalarType<T[P], AggregateGuildBackups[P]>
  }




  export type GuildBackupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildBackupsWhereInput
    orderBy?: GuildBackupsOrderByWithAggregationInput | GuildBackupsOrderByWithAggregationInput[]
    by: GuildBackupsScalarFieldEnum[] | GuildBackupsScalarFieldEnum
    having?: GuildBackupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildBackupsCountAggregateInputType | true
    _min?: GuildBackupsMinAggregateInputType
    _max?: GuildBackupsMaxAggregateInputType
  }

  export type GuildBackupsGroupByOutputType = {
    id: string
    BackupJSON: JsonValue
    CreatedAt: Date
    UUID: string
    Name: string
    GuildId: string
    UserId: string
    _count: GuildBackupsCountAggregateOutputType | null
    _min: GuildBackupsMinAggregateOutputType | null
    _max: GuildBackupsMaxAggregateOutputType | null
  }

  type GetGuildBackupsGroupByPayload<T extends GuildBackupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildBackupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildBackupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildBackupsGroupByOutputType[P]>
            : GetScalarType<T[P], GuildBackupsGroupByOutputType[P]>
        }
      >
    >


  export type GuildBackupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    BackupJSON?: boolean
    CreatedAt?: boolean
    UUID?: boolean
    Name?: boolean
    GuildId?: boolean
    UserId?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guildBackups"]>



  export type GuildBackupsSelectScalar = {
    id?: boolean
    BackupJSON?: boolean
    CreatedAt?: boolean
    UUID?: boolean
    Name?: boolean
    GuildId?: boolean
    UserId?: boolean
  }

  export type GuildBackupsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "BackupJSON" | "CreatedAt" | "UUID" | "Name" | "GuildId" | "UserId", ExtArgs["result"]["guildBackups"]>
  export type GuildBackupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $GuildBackupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GuildBackups"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      BackupJSON: Prisma.JsonValue
      CreatedAt: Date
      UUID: string
      Name: string
      GuildId: string
      UserId: string
    }, ExtArgs["result"]["guildBackups"]>
    composites: {}
  }

  type GuildBackupsGetPayload<S extends boolean | null | undefined | GuildBackupsDefaultArgs> = $Result.GetResult<Prisma.$GuildBackupsPayload, S>

  type GuildBackupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuildBackupsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuildBackupsCountAggregateInputType | true
    }

  export interface GuildBackupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GuildBackups'], meta: { name: 'GuildBackups' } }
    /**
     * Find zero or one GuildBackups that matches the filter.
     * @param {GuildBackupsFindUniqueArgs} args - Arguments to find a GuildBackups
     * @example
     * // Get one GuildBackups
     * const guildBackups = await prisma.guildBackups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuildBackupsFindUniqueArgs>(args: SelectSubset<T, GuildBackupsFindUniqueArgs<ExtArgs>>): Prisma__GuildBackupsClient<$Result.GetResult<Prisma.$GuildBackupsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GuildBackups that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuildBackupsFindUniqueOrThrowArgs} args - Arguments to find a GuildBackups
     * @example
     * // Get one GuildBackups
     * const guildBackups = await prisma.guildBackups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuildBackupsFindUniqueOrThrowArgs>(args: SelectSubset<T, GuildBackupsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuildBackupsClient<$Result.GetResult<Prisma.$GuildBackupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuildBackups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildBackupsFindFirstArgs} args - Arguments to find a GuildBackups
     * @example
     * // Get one GuildBackups
     * const guildBackups = await prisma.guildBackups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuildBackupsFindFirstArgs>(args?: SelectSubset<T, GuildBackupsFindFirstArgs<ExtArgs>>): Prisma__GuildBackupsClient<$Result.GetResult<Prisma.$GuildBackupsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuildBackups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildBackupsFindFirstOrThrowArgs} args - Arguments to find a GuildBackups
     * @example
     * // Get one GuildBackups
     * const guildBackups = await prisma.guildBackups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuildBackupsFindFirstOrThrowArgs>(args?: SelectSubset<T, GuildBackupsFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuildBackupsClient<$Result.GetResult<Prisma.$GuildBackupsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuildBackups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildBackupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuildBackups
     * const guildBackups = await prisma.guildBackups.findMany()
     * 
     * // Get first 10 GuildBackups
     * const guildBackups = await prisma.guildBackups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildBackupsWithIdOnly = await prisma.guildBackups.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuildBackupsFindManyArgs>(args?: SelectSubset<T, GuildBackupsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildBackupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GuildBackups.
     * @param {GuildBackupsCreateArgs} args - Arguments to create a GuildBackups.
     * @example
     * // Create one GuildBackups
     * const GuildBackups = await prisma.guildBackups.create({
     *   data: {
     *     // ... data to create a GuildBackups
     *   }
     * })
     * 
     */
    create<T extends GuildBackupsCreateArgs>(args: SelectSubset<T, GuildBackupsCreateArgs<ExtArgs>>): Prisma__GuildBackupsClient<$Result.GetResult<Prisma.$GuildBackupsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GuildBackups.
     * @param {GuildBackupsCreateManyArgs} args - Arguments to create many GuildBackups.
     * @example
     * // Create many GuildBackups
     * const guildBackups = await prisma.guildBackups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuildBackupsCreateManyArgs>(args?: SelectSubset<T, GuildBackupsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GuildBackups.
     * @param {GuildBackupsDeleteArgs} args - Arguments to delete one GuildBackups.
     * @example
     * // Delete one GuildBackups
     * const GuildBackups = await prisma.guildBackups.delete({
     *   where: {
     *     // ... filter to delete one GuildBackups
     *   }
     * })
     * 
     */
    delete<T extends GuildBackupsDeleteArgs>(args: SelectSubset<T, GuildBackupsDeleteArgs<ExtArgs>>): Prisma__GuildBackupsClient<$Result.GetResult<Prisma.$GuildBackupsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GuildBackups.
     * @param {GuildBackupsUpdateArgs} args - Arguments to update one GuildBackups.
     * @example
     * // Update one GuildBackups
     * const guildBackups = await prisma.guildBackups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuildBackupsUpdateArgs>(args: SelectSubset<T, GuildBackupsUpdateArgs<ExtArgs>>): Prisma__GuildBackupsClient<$Result.GetResult<Prisma.$GuildBackupsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GuildBackups.
     * @param {GuildBackupsDeleteManyArgs} args - Arguments to filter GuildBackups to delete.
     * @example
     * // Delete a few GuildBackups
     * const { count } = await prisma.guildBackups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuildBackupsDeleteManyArgs>(args?: SelectSubset<T, GuildBackupsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuildBackups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildBackupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuildBackups
     * const guildBackups = await prisma.guildBackups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuildBackupsUpdateManyArgs>(args: SelectSubset<T, GuildBackupsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GuildBackups.
     * @param {GuildBackupsUpsertArgs} args - Arguments to update or create a GuildBackups.
     * @example
     * // Update or create a GuildBackups
     * const guildBackups = await prisma.guildBackups.upsert({
     *   create: {
     *     // ... data to create a GuildBackups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuildBackups we want to update
     *   }
     * })
     */
    upsert<T extends GuildBackupsUpsertArgs>(args: SelectSubset<T, GuildBackupsUpsertArgs<ExtArgs>>): Prisma__GuildBackupsClient<$Result.GetResult<Prisma.$GuildBackupsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuildBackups that matches the filter.
     * @param {GuildBackupsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const guildBackups = await prisma.guildBackups.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: GuildBackupsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a GuildBackups.
     * @param {GuildBackupsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const guildBackups = await prisma.guildBackups.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: GuildBackupsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of GuildBackups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildBackupsCountArgs} args - Arguments to filter GuildBackups to count.
     * @example
     * // Count the number of GuildBackups
     * const count = await prisma.guildBackups.count({
     *   where: {
     *     // ... the filter for the GuildBackups we want to count
     *   }
     * })
    **/
    count<T extends GuildBackupsCountArgs>(
      args?: Subset<T, GuildBackupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildBackupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuildBackups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildBackupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildBackupsAggregateArgs>(args: Subset<T, GuildBackupsAggregateArgs>): Prisma.PrismaPromise<GetGuildBackupsAggregateType<T>>

    /**
     * Group by GuildBackups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildBackupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildBackupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildBackupsGroupByArgs['orderBy'] }
        : { orderBy?: GuildBackupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildBackupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildBackupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GuildBackups model
   */
  readonly fields: GuildBackupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuildBackups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuildBackupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GuildBackups model
   */
  interface GuildBackupsFieldRefs {
    readonly id: FieldRef<"GuildBackups", 'String'>
    readonly BackupJSON: FieldRef<"GuildBackups", 'Json'>
    readonly CreatedAt: FieldRef<"GuildBackups", 'DateTime'>
    readonly UUID: FieldRef<"GuildBackups", 'String'>
    readonly Name: FieldRef<"GuildBackups", 'String'>
    readonly GuildId: FieldRef<"GuildBackups", 'String'>
    readonly UserId: FieldRef<"GuildBackups", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GuildBackups findUnique
   */
  export type GuildBackupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBackups
     */
    select?: GuildBackupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBackups
     */
    omit?: GuildBackupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBackupsInclude<ExtArgs> | null
    /**
     * Filter, which GuildBackups to fetch.
     */
    where: GuildBackupsWhereUniqueInput
  }

  /**
   * GuildBackups findUniqueOrThrow
   */
  export type GuildBackupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBackups
     */
    select?: GuildBackupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBackups
     */
    omit?: GuildBackupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBackupsInclude<ExtArgs> | null
    /**
     * Filter, which GuildBackups to fetch.
     */
    where: GuildBackupsWhereUniqueInput
  }

  /**
   * GuildBackups findFirst
   */
  export type GuildBackupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBackups
     */
    select?: GuildBackupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBackups
     */
    omit?: GuildBackupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBackupsInclude<ExtArgs> | null
    /**
     * Filter, which GuildBackups to fetch.
     */
    where?: GuildBackupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildBackups to fetch.
     */
    orderBy?: GuildBackupsOrderByWithRelationInput | GuildBackupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildBackups.
     */
    cursor?: GuildBackupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildBackups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildBackups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildBackups.
     */
    distinct?: GuildBackupsScalarFieldEnum | GuildBackupsScalarFieldEnum[]
  }

  /**
   * GuildBackups findFirstOrThrow
   */
  export type GuildBackupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBackups
     */
    select?: GuildBackupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBackups
     */
    omit?: GuildBackupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBackupsInclude<ExtArgs> | null
    /**
     * Filter, which GuildBackups to fetch.
     */
    where?: GuildBackupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildBackups to fetch.
     */
    orderBy?: GuildBackupsOrderByWithRelationInput | GuildBackupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildBackups.
     */
    cursor?: GuildBackupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildBackups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildBackups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildBackups.
     */
    distinct?: GuildBackupsScalarFieldEnum | GuildBackupsScalarFieldEnum[]
  }

  /**
   * GuildBackups findMany
   */
  export type GuildBackupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBackups
     */
    select?: GuildBackupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBackups
     */
    omit?: GuildBackupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBackupsInclude<ExtArgs> | null
    /**
     * Filter, which GuildBackups to fetch.
     */
    where?: GuildBackupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildBackups to fetch.
     */
    orderBy?: GuildBackupsOrderByWithRelationInput | GuildBackupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuildBackups.
     */
    cursor?: GuildBackupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildBackups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildBackups.
     */
    skip?: number
    distinct?: GuildBackupsScalarFieldEnum | GuildBackupsScalarFieldEnum[]
  }

  /**
   * GuildBackups create
   */
  export type GuildBackupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBackups
     */
    select?: GuildBackupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBackups
     */
    omit?: GuildBackupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBackupsInclude<ExtArgs> | null
    /**
     * The data needed to create a GuildBackups.
     */
    data: XOR<GuildBackupsCreateInput, GuildBackupsUncheckedCreateInput>
  }

  /**
   * GuildBackups createMany
   */
  export type GuildBackupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GuildBackups.
     */
    data: GuildBackupsCreateManyInput | GuildBackupsCreateManyInput[]
  }

  /**
   * GuildBackups update
   */
  export type GuildBackupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBackups
     */
    select?: GuildBackupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBackups
     */
    omit?: GuildBackupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBackupsInclude<ExtArgs> | null
    /**
     * The data needed to update a GuildBackups.
     */
    data: XOR<GuildBackupsUpdateInput, GuildBackupsUncheckedUpdateInput>
    /**
     * Choose, which GuildBackups to update.
     */
    where: GuildBackupsWhereUniqueInput
  }

  /**
   * GuildBackups updateMany
   */
  export type GuildBackupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GuildBackups.
     */
    data: XOR<GuildBackupsUpdateManyMutationInput, GuildBackupsUncheckedUpdateManyInput>
    /**
     * Filter which GuildBackups to update
     */
    where?: GuildBackupsWhereInput
    /**
     * Limit how many GuildBackups to update.
     */
    limit?: number
  }

  /**
   * GuildBackups upsert
   */
  export type GuildBackupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBackups
     */
    select?: GuildBackupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBackups
     */
    omit?: GuildBackupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBackupsInclude<ExtArgs> | null
    /**
     * The filter to search for the GuildBackups to update in case it exists.
     */
    where: GuildBackupsWhereUniqueInput
    /**
     * In case the GuildBackups found by the `where` argument doesn't exist, create a new GuildBackups with this data.
     */
    create: XOR<GuildBackupsCreateInput, GuildBackupsUncheckedCreateInput>
    /**
     * In case the GuildBackups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuildBackupsUpdateInput, GuildBackupsUncheckedUpdateInput>
  }

  /**
   * GuildBackups delete
   */
  export type GuildBackupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBackups
     */
    select?: GuildBackupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBackups
     */
    omit?: GuildBackupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBackupsInclude<ExtArgs> | null
    /**
     * Filter which GuildBackups to delete.
     */
    where: GuildBackupsWhereUniqueInput
  }

  /**
   * GuildBackups deleteMany
   */
  export type GuildBackupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildBackups to delete
     */
    where?: GuildBackupsWhereInput
    /**
     * Limit how many GuildBackups to delete.
     */
    limit?: number
  }

  /**
   * GuildBackups findRaw
   */
  export type GuildBackupsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GuildBackups aggregateRaw
   */
  export type GuildBackupsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GuildBackups without action
   */
  export type GuildBackupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBackups
     */
    select?: GuildBackupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBackups
     */
    omit?: GuildBackupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBackupsInclude<ExtArgs> | null
  }


  /**
   * Model Customers
   */

  export type AggregateCustomers = {
    _count: CustomersCountAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  export type CustomersMinAggregateOutputType = {
    id: string | null
    ExternalUUID: string | null
    RealUUID: string | null
    Application: string | null
    DisplayName: string | null
    ServerPort: string | null
    WSAPI: string | null
    UserId: string | null
  }

  export type CustomersMaxAggregateOutputType = {
    id: string | null
    ExternalUUID: string | null
    RealUUID: string | null
    Application: string | null
    DisplayName: string | null
    ServerPort: string | null
    WSAPI: string | null
    UserId: string | null
  }

  export type CustomersCountAggregateOutputType = {
    id: number
    ExternalUUID: number
    RealUUID: number
    Application: number
    DisplayName: number
    GuildIds: number
    ServerPort: number
    WSAPI: number
    UserId: number
    _all: number
  }


  export type CustomersMinAggregateInputType = {
    id?: true
    ExternalUUID?: true
    RealUUID?: true
    Application?: true
    DisplayName?: true
    ServerPort?: true
    WSAPI?: true
    UserId?: true
  }

  export type CustomersMaxAggregateInputType = {
    id?: true
    ExternalUUID?: true
    RealUUID?: true
    Application?: true
    DisplayName?: true
    ServerPort?: true
    WSAPI?: true
    UserId?: true
  }

  export type CustomersCountAggregateInputType = {
    id?: true
    ExternalUUID?: true
    RealUUID?: true
    Application?: true
    DisplayName?: true
    GuildIds?: true
    ServerPort?: true
    WSAPI?: true
    UserId?: true
    _all?: true
  }

  export type CustomersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to aggregate.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomersMaxAggregateInputType
  }

  export type GetCustomersAggregateType<T extends CustomersAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomers[P]>
      : GetScalarType<T[P], AggregateCustomers[P]>
  }




  export type CustomersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomersWhereInput
    orderBy?: CustomersOrderByWithAggregationInput | CustomersOrderByWithAggregationInput[]
    by: CustomersScalarFieldEnum[] | CustomersScalarFieldEnum
    having?: CustomersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomersCountAggregateInputType | true
    _min?: CustomersMinAggregateInputType
    _max?: CustomersMaxAggregateInputType
  }

  export type CustomersGroupByOutputType = {
    id: string
    ExternalUUID: string
    RealUUID: string
    Application: string
    DisplayName: string
    GuildIds: string[]
    ServerPort: string
    WSAPI: string
    UserId: string
    _count: CustomersCountAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  type GetCustomersGroupByPayload<T extends CustomersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomersGroupByOutputType[P]>
            : GetScalarType<T[P], CustomersGroupByOutputType[P]>
        }
      >
    >


  export type CustomersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ExternalUUID?: boolean
    RealUUID?: boolean
    Application?: boolean
    BotStatus?: boolean | BotStatusDefaultArgs<ExtArgs>
    DisplayName?: boolean
    GuildIds?: boolean
    ServerPort?: boolean
    WSAPI?: boolean
    UserId?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customers"]>



  export type CustomersSelectScalar = {
    id?: boolean
    ExternalUUID?: boolean
    RealUUID?: boolean
    Application?: boolean
    DisplayName?: boolean
    GuildIds?: boolean
    ServerPort?: boolean
    WSAPI?: boolean
    UserId?: boolean
  }

  export type CustomersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ExternalUUID" | "RealUUID" | "Application" | "BotStatus" | "DisplayName" | "GuildIds" | "ServerPort" | "WSAPI" | "UserId", ExtArgs["result"]["customers"]>
  export type CustomersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $CustomersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customers"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ExternalUUID: string
      RealUUID: string
      Application: string
      DisplayName: string
      GuildIds: string[]
      ServerPort: string
      WSAPI: string
      UserId: string
    }, ExtArgs["result"]["customers"]>
    composites: {
      BotStatus: Prisma.$BotStatusPayload
    }
  }

  type CustomersGetPayload<S extends boolean | null | undefined | CustomersDefaultArgs> = $Result.GetResult<Prisma.$CustomersPayload, S>

  type CustomersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomersCountAggregateInputType | true
    }

  export interface CustomersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customers'], meta: { name: 'Customers' } }
    /**
     * Find zero or one Customers that matches the filter.
     * @param {CustomersFindUniqueArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomersFindUniqueArgs>(args: SelectSubset<T, CustomersFindUniqueArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomersFindUniqueOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomersFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindFirstArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomersFindFirstArgs>(args?: SelectSubset<T, CustomersFindFirstArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindFirstOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomersFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomersFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customers.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customersWithIdOnly = await prisma.customers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomersFindManyArgs>(args?: SelectSubset<T, CustomersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customers.
     * @param {CustomersCreateArgs} args - Arguments to create a Customers.
     * @example
     * // Create one Customers
     * const Customers = await prisma.customers.create({
     *   data: {
     *     // ... data to create a Customers
     *   }
     * })
     * 
     */
    create<T extends CustomersCreateArgs>(args: SelectSubset<T, CustomersCreateArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomersCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customers = await prisma.customers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomersCreateManyArgs>(args?: SelectSubset<T, CustomersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customers.
     * @param {CustomersDeleteArgs} args - Arguments to delete one Customers.
     * @example
     * // Delete one Customers
     * const Customers = await prisma.customers.delete({
     *   where: {
     *     // ... filter to delete one Customers
     *   }
     * })
     * 
     */
    delete<T extends CustomersDeleteArgs>(args: SelectSubset<T, CustomersDeleteArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customers.
     * @param {CustomersUpdateArgs} args - Arguments to update one Customers.
     * @example
     * // Update one Customers
     * const customers = await prisma.customers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomersUpdateArgs>(args: SelectSubset<T, CustomersUpdateArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomersDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomersDeleteManyArgs>(args?: SelectSubset<T, CustomersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomersUpdateManyArgs>(args: SelectSubset<T, CustomersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customers.
     * @param {CustomersUpsertArgs} args - Arguments to update or create a Customers.
     * @example
     * // Update or create a Customers
     * const customers = await prisma.customers.upsert({
     *   create: {
     *     // ... data to create a Customers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customers we want to update
     *   }
     * })
     */
    upsert<T extends CustomersUpsertArgs>(args: SelectSubset<T, CustomersUpsertArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * @param {CustomersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const customers = await prisma.customers.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CustomersFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Customers.
     * @param {CustomersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const customers = await prisma.customers.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CustomersAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customers.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomersCountArgs>(
      args?: Subset<T, CustomersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomersAggregateArgs>(args: Subset<T, CustomersAggregateArgs>): Prisma.PrismaPromise<GetCustomersAggregateType<T>>

    /**
     * Group by Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomersGroupByArgs['orderBy'] }
        : { orderBy?: CustomersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customers model
   */
  readonly fields: CustomersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customers model
   */
  interface CustomersFieldRefs {
    readonly id: FieldRef<"Customers", 'String'>
    readonly ExternalUUID: FieldRef<"Customers", 'String'>
    readonly RealUUID: FieldRef<"Customers", 'String'>
    readonly Application: FieldRef<"Customers", 'String'>
    readonly DisplayName: FieldRef<"Customers", 'String'>
    readonly GuildIds: FieldRef<"Customers", 'String[]'>
    readonly ServerPort: FieldRef<"Customers", 'String'>
    readonly WSAPI: FieldRef<"Customers", 'String'>
    readonly UserId: FieldRef<"Customers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Customers findUnique
   */
  export type CustomersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers findUniqueOrThrow
   */
  export type CustomersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers findFirst
   */
  export type CustomersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * Customers findFirstOrThrow
   */
  export type CustomersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * Customers findMany
   */
  export type CustomersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * Customers create
   */
  export type CustomersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * The data needed to create a Customers.
     */
    data: XOR<CustomersCreateInput, CustomersUncheckedCreateInput>
  }

  /**
   * Customers createMany
   */
  export type CustomersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomersCreateManyInput | CustomersCreateManyInput[]
  }

  /**
   * Customers update
   */
  export type CustomersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * The data needed to update a Customers.
     */
    data: XOR<CustomersUpdateInput, CustomersUncheckedUpdateInput>
    /**
     * Choose, which Customers to update.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers updateMany
   */
  export type CustomersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomersUpdateManyMutationInput, CustomersUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomersWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customers upsert
   */
  export type CustomersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * The filter to search for the Customers to update in case it exists.
     */
    where: CustomersWhereUniqueInput
    /**
     * In case the Customers found by the `where` argument doesn't exist, create a new Customers with this data.
     */
    create: XOR<CustomersCreateInput, CustomersUncheckedCreateInput>
    /**
     * In case the Customers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomersUpdateInput, CustomersUncheckedUpdateInput>
  }

  /**
   * Customers delete
   */
  export type CustomersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter which Customers to delete.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers deleteMany
   */
  export type CustomersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomersWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customers findRaw
   */
  export type CustomersFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Customers aggregateRaw
   */
  export type CustomersAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Customers without action
   */
  export type CustomersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
  }


  /**
   * Model Vanitys
   */

  export type AggregateVanitys = {
    _count: VanitysCountAggregateOutputType | null
    _min: VanitysMinAggregateOutputType | null
    _max: VanitysMaxAggregateOutputType | null
  }

  export type VanitysMinAggregateOutputType = {
    id: string | null
    UUID: string | null
    Slug: string | null
    Host: string | null
    GuildId: string | null
    Invite: string | null
    CreatedAt: Date | null
    UserId: string | null
  }

  export type VanitysMaxAggregateOutputType = {
    id: string | null
    UUID: string | null
    Slug: string | null
    Host: string | null
    GuildId: string | null
    Invite: string | null
    CreatedAt: Date | null
    UserId: string | null
  }

  export type VanitysCountAggregateOutputType = {
    id: number
    UUID: number
    Slug: number
    Host: number
    GuildId: number
    Invite: number
    CreatedAt: number
    UserId: number
    _all: number
  }


  export type VanitysMinAggregateInputType = {
    id?: true
    UUID?: true
    Slug?: true
    Host?: true
    GuildId?: true
    Invite?: true
    CreatedAt?: true
    UserId?: true
  }

  export type VanitysMaxAggregateInputType = {
    id?: true
    UUID?: true
    Slug?: true
    Host?: true
    GuildId?: true
    Invite?: true
    CreatedAt?: true
    UserId?: true
  }

  export type VanitysCountAggregateInputType = {
    id?: true
    UUID?: true
    Slug?: true
    Host?: true
    GuildId?: true
    Invite?: true
    CreatedAt?: true
    UserId?: true
    _all?: true
  }

  export type VanitysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vanitys to aggregate.
     */
    where?: VanitysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vanitys to fetch.
     */
    orderBy?: VanitysOrderByWithRelationInput | VanitysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VanitysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vanitys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vanitys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vanitys
    **/
    _count?: true | VanitysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VanitysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VanitysMaxAggregateInputType
  }

  export type GetVanitysAggregateType<T extends VanitysAggregateArgs> = {
        [P in keyof T & keyof AggregateVanitys]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVanitys[P]>
      : GetScalarType<T[P], AggregateVanitys[P]>
  }




  export type VanitysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VanitysWhereInput
    orderBy?: VanitysOrderByWithAggregationInput | VanitysOrderByWithAggregationInput[]
    by: VanitysScalarFieldEnum[] | VanitysScalarFieldEnum
    having?: VanitysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VanitysCountAggregateInputType | true
    _min?: VanitysMinAggregateInputType
    _max?: VanitysMaxAggregateInputType
  }

  export type VanitysGroupByOutputType = {
    id: string
    UUID: string
    Slug: string
    Host: string
    GuildId: string
    Invite: string
    CreatedAt: Date
    UserId: string
    _count: VanitysCountAggregateOutputType | null
    _min: VanitysMinAggregateOutputType | null
    _max: VanitysMaxAggregateOutputType | null
  }

  type GetVanitysGroupByPayload<T extends VanitysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VanitysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VanitysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VanitysGroupByOutputType[P]>
            : GetScalarType<T[P], VanitysGroupByOutputType[P]>
        }
      >
    >


  export type VanitysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    UUID?: boolean
    Slug?: boolean
    Host?: boolean
    GuildId?: boolean
    Invite?: boolean
    CreatedAt?: boolean
    UserId?: boolean
    Analytics?: boolean | Vanitys$AnalyticsArgs<ExtArgs>
    Embed?: boolean | Vanitys$EmbedArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vanitys"]>



  export type VanitysSelectScalar = {
    id?: boolean
    UUID?: boolean
    Slug?: boolean
    Host?: boolean
    GuildId?: boolean
    Invite?: boolean
    CreatedAt?: boolean
    UserId?: boolean
  }

  export type VanitysOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "UUID" | "Slug" | "Host" | "GuildId" | "Invite" | "CreatedAt" | "UserId", ExtArgs["result"]["vanitys"]>
  export type VanitysInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Analytics?: boolean | Vanitys$AnalyticsArgs<ExtArgs>
    Embed?: boolean | Vanitys$EmbedArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $VanitysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vanitys"
    objects: {
      Analytics: Prisma.$VanityAnalyticsPayload<ExtArgs> | null
      Embed: Prisma.$VanityEmbedsPayload<ExtArgs> | null
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      UUID: string
      Slug: string
      Host: string
      GuildId: string
      Invite: string
      CreatedAt: Date
      UserId: string
    }, ExtArgs["result"]["vanitys"]>
    composites: {}
  }

  type VanitysGetPayload<S extends boolean | null | undefined | VanitysDefaultArgs> = $Result.GetResult<Prisma.$VanitysPayload, S>

  type VanitysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VanitysFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VanitysCountAggregateInputType | true
    }

  export interface VanitysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vanitys'], meta: { name: 'Vanitys' } }
    /**
     * Find zero or one Vanitys that matches the filter.
     * @param {VanitysFindUniqueArgs} args - Arguments to find a Vanitys
     * @example
     * // Get one Vanitys
     * const vanitys = await prisma.vanitys.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VanitysFindUniqueArgs>(args: SelectSubset<T, VanitysFindUniqueArgs<ExtArgs>>): Prisma__VanitysClient<$Result.GetResult<Prisma.$VanitysPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vanitys that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VanitysFindUniqueOrThrowArgs} args - Arguments to find a Vanitys
     * @example
     * // Get one Vanitys
     * const vanitys = await prisma.vanitys.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VanitysFindUniqueOrThrowArgs>(args: SelectSubset<T, VanitysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VanitysClient<$Result.GetResult<Prisma.$VanitysPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vanitys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanitysFindFirstArgs} args - Arguments to find a Vanitys
     * @example
     * // Get one Vanitys
     * const vanitys = await prisma.vanitys.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VanitysFindFirstArgs>(args?: SelectSubset<T, VanitysFindFirstArgs<ExtArgs>>): Prisma__VanitysClient<$Result.GetResult<Prisma.$VanitysPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vanitys that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanitysFindFirstOrThrowArgs} args - Arguments to find a Vanitys
     * @example
     * // Get one Vanitys
     * const vanitys = await prisma.vanitys.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VanitysFindFirstOrThrowArgs>(args?: SelectSubset<T, VanitysFindFirstOrThrowArgs<ExtArgs>>): Prisma__VanitysClient<$Result.GetResult<Prisma.$VanitysPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vanitys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanitysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vanitys
     * const vanitys = await prisma.vanitys.findMany()
     * 
     * // Get first 10 Vanitys
     * const vanitys = await prisma.vanitys.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vanitysWithIdOnly = await prisma.vanitys.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VanitysFindManyArgs>(args?: SelectSubset<T, VanitysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VanitysPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vanitys.
     * @param {VanitysCreateArgs} args - Arguments to create a Vanitys.
     * @example
     * // Create one Vanitys
     * const Vanitys = await prisma.vanitys.create({
     *   data: {
     *     // ... data to create a Vanitys
     *   }
     * })
     * 
     */
    create<T extends VanitysCreateArgs>(args: SelectSubset<T, VanitysCreateArgs<ExtArgs>>): Prisma__VanitysClient<$Result.GetResult<Prisma.$VanitysPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vanitys.
     * @param {VanitysCreateManyArgs} args - Arguments to create many Vanitys.
     * @example
     * // Create many Vanitys
     * const vanitys = await prisma.vanitys.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VanitysCreateManyArgs>(args?: SelectSubset<T, VanitysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vanitys.
     * @param {VanitysDeleteArgs} args - Arguments to delete one Vanitys.
     * @example
     * // Delete one Vanitys
     * const Vanitys = await prisma.vanitys.delete({
     *   where: {
     *     // ... filter to delete one Vanitys
     *   }
     * })
     * 
     */
    delete<T extends VanitysDeleteArgs>(args: SelectSubset<T, VanitysDeleteArgs<ExtArgs>>): Prisma__VanitysClient<$Result.GetResult<Prisma.$VanitysPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vanitys.
     * @param {VanitysUpdateArgs} args - Arguments to update one Vanitys.
     * @example
     * // Update one Vanitys
     * const vanitys = await prisma.vanitys.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VanitysUpdateArgs>(args: SelectSubset<T, VanitysUpdateArgs<ExtArgs>>): Prisma__VanitysClient<$Result.GetResult<Prisma.$VanitysPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vanitys.
     * @param {VanitysDeleteManyArgs} args - Arguments to filter Vanitys to delete.
     * @example
     * // Delete a few Vanitys
     * const { count } = await prisma.vanitys.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VanitysDeleteManyArgs>(args?: SelectSubset<T, VanitysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vanitys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanitysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vanitys
     * const vanitys = await prisma.vanitys.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VanitysUpdateManyArgs>(args: SelectSubset<T, VanitysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vanitys.
     * @param {VanitysUpsertArgs} args - Arguments to update or create a Vanitys.
     * @example
     * // Update or create a Vanitys
     * const vanitys = await prisma.vanitys.upsert({
     *   create: {
     *     // ... data to create a Vanitys
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vanitys we want to update
     *   }
     * })
     */
    upsert<T extends VanitysUpsertArgs>(args: SelectSubset<T, VanitysUpsertArgs<ExtArgs>>): Prisma__VanitysClient<$Result.GetResult<Prisma.$VanitysPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vanitys that matches the filter.
     * @param {VanitysFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const vanitys = await prisma.vanitys.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: VanitysFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Vanitys.
     * @param {VanitysAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const vanitys = await prisma.vanitys.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: VanitysAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Vanitys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanitysCountArgs} args - Arguments to filter Vanitys to count.
     * @example
     * // Count the number of Vanitys
     * const count = await prisma.vanitys.count({
     *   where: {
     *     // ... the filter for the Vanitys we want to count
     *   }
     * })
    **/
    count<T extends VanitysCountArgs>(
      args?: Subset<T, VanitysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VanitysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vanitys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanitysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VanitysAggregateArgs>(args: Subset<T, VanitysAggregateArgs>): Prisma.PrismaPromise<GetVanitysAggregateType<T>>

    /**
     * Group by Vanitys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanitysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VanitysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VanitysGroupByArgs['orderBy'] }
        : { orderBy?: VanitysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VanitysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVanitysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vanitys model
   */
  readonly fields: VanitysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vanitys.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VanitysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Analytics<T extends Vanitys$AnalyticsArgs<ExtArgs> = {}>(args?: Subset<T, Vanitys$AnalyticsArgs<ExtArgs>>): Prisma__VanityAnalyticsClient<$Result.GetResult<Prisma.$VanityAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Embed<T extends Vanitys$EmbedArgs<ExtArgs> = {}>(args?: Subset<T, Vanitys$EmbedArgs<ExtArgs>>): Prisma__VanityEmbedsClient<$Result.GetResult<Prisma.$VanityEmbedsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vanitys model
   */
  interface VanitysFieldRefs {
    readonly id: FieldRef<"Vanitys", 'String'>
    readonly UUID: FieldRef<"Vanitys", 'String'>
    readonly Slug: FieldRef<"Vanitys", 'String'>
    readonly Host: FieldRef<"Vanitys", 'String'>
    readonly GuildId: FieldRef<"Vanitys", 'String'>
    readonly Invite: FieldRef<"Vanitys", 'String'>
    readonly CreatedAt: FieldRef<"Vanitys", 'DateTime'>
    readonly UserId: FieldRef<"Vanitys", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Vanitys findUnique
   */
  export type VanitysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vanitys
     */
    select?: VanitysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vanitys
     */
    omit?: VanitysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanitysInclude<ExtArgs> | null
    /**
     * Filter, which Vanitys to fetch.
     */
    where: VanitysWhereUniqueInput
  }

  /**
   * Vanitys findUniqueOrThrow
   */
  export type VanitysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vanitys
     */
    select?: VanitysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vanitys
     */
    omit?: VanitysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanitysInclude<ExtArgs> | null
    /**
     * Filter, which Vanitys to fetch.
     */
    where: VanitysWhereUniqueInput
  }

  /**
   * Vanitys findFirst
   */
  export type VanitysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vanitys
     */
    select?: VanitysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vanitys
     */
    omit?: VanitysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanitysInclude<ExtArgs> | null
    /**
     * Filter, which Vanitys to fetch.
     */
    where?: VanitysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vanitys to fetch.
     */
    orderBy?: VanitysOrderByWithRelationInput | VanitysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vanitys.
     */
    cursor?: VanitysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vanitys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vanitys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vanitys.
     */
    distinct?: VanitysScalarFieldEnum | VanitysScalarFieldEnum[]
  }

  /**
   * Vanitys findFirstOrThrow
   */
  export type VanitysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vanitys
     */
    select?: VanitysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vanitys
     */
    omit?: VanitysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanitysInclude<ExtArgs> | null
    /**
     * Filter, which Vanitys to fetch.
     */
    where?: VanitysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vanitys to fetch.
     */
    orderBy?: VanitysOrderByWithRelationInput | VanitysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vanitys.
     */
    cursor?: VanitysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vanitys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vanitys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vanitys.
     */
    distinct?: VanitysScalarFieldEnum | VanitysScalarFieldEnum[]
  }

  /**
   * Vanitys findMany
   */
  export type VanitysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vanitys
     */
    select?: VanitysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vanitys
     */
    omit?: VanitysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanitysInclude<ExtArgs> | null
    /**
     * Filter, which Vanitys to fetch.
     */
    where?: VanitysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vanitys to fetch.
     */
    orderBy?: VanitysOrderByWithRelationInput | VanitysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vanitys.
     */
    cursor?: VanitysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vanitys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vanitys.
     */
    skip?: number
    distinct?: VanitysScalarFieldEnum | VanitysScalarFieldEnum[]
  }

  /**
   * Vanitys create
   */
  export type VanitysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vanitys
     */
    select?: VanitysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vanitys
     */
    omit?: VanitysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanitysInclude<ExtArgs> | null
    /**
     * The data needed to create a Vanitys.
     */
    data: XOR<VanitysCreateInput, VanitysUncheckedCreateInput>
  }

  /**
   * Vanitys createMany
   */
  export type VanitysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vanitys.
     */
    data: VanitysCreateManyInput | VanitysCreateManyInput[]
  }

  /**
   * Vanitys update
   */
  export type VanitysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vanitys
     */
    select?: VanitysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vanitys
     */
    omit?: VanitysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanitysInclude<ExtArgs> | null
    /**
     * The data needed to update a Vanitys.
     */
    data: XOR<VanitysUpdateInput, VanitysUncheckedUpdateInput>
    /**
     * Choose, which Vanitys to update.
     */
    where: VanitysWhereUniqueInput
  }

  /**
   * Vanitys updateMany
   */
  export type VanitysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vanitys.
     */
    data: XOR<VanitysUpdateManyMutationInput, VanitysUncheckedUpdateManyInput>
    /**
     * Filter which Vanitys to update
     */
    where?: VanitysWhereInput
    /**
     * Limit how many Vanitys to update.
     */
    limit?: number
  }

  /**
   * Vanitys upsert
   */
  export type VanitysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vanitys
     */
    select?: VanitysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vanitys
     */
    omit?: VanitysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanitysInclude<ExtArgs> | null
    /**
     * The filter to search for the Vanitys to update in case it exists.
     */
    where: VanitysWhereUniqueInput
    /**
     * In case the Vanitys found by the `where` argument doesn't exist, create a new Vanitys with this data.
     */
    create: XOR<VanitysCreateInput, VanitysUncheckedCreateInput>
    /**
     * In case the Vanitys was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VanitysUpdateInput, VanitysUncheckedUpdateInput>
  }

  /**
   * Vanitys delete
   */
  export type VanitysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vanitys
     */
    select?: VanitysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vanitys
     */
    omit?: VanitysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanitysInclude<ExtArgs> | null
    /**
     * Filter which Vanitys to delete.
     */
    where: VanitysWhereUniqueInput
  }

  /**
   * Vanitys deleteMany
   */
  export type VanitysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vanitys to delete
     */
    where?: VanitysWhereInput
    /**
     * Limit how many Vanitys to delete.
     */
    limit?: number
  }

  /**
   * Vanitys findRaw
   */
  export type VanitysFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Vanitys aggregateRaw
   */
  export type VanitysAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Vanitys.Analytics
   */
  export type Vanitys$AnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityAnalytics
     */
    select?: VanityAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityAnalytics
     */
    omit?: VanityAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityAnalyticsInclude<ExtArgs> | null
    where?: VanityAnalyticsWhereInput
  }

  /**
   * Vanitys.Embed
   */
  export type Vanitys$EmbedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityEmbeds
     */
    select?: VanityEmbedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityEmbeds
     */
    omit?: VanityEmbedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityEmbedsInclude<ExtArgs> | null
    where?: VanityEmbedsWhereInput
  }

  /**
   * Vanitys without action
   */
  export type VanitysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vanitys
     */
    select?: VanitysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vanitys
     */
    omit?: VanitysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanitysInclude<ExtArgs> | null
  }


  /**
   * Model VanityEmbeds
   */

  export type AggregateVanityEmbeds = {
    _count: VanityEmbedsCountAggregateOutputType | null
    _min: VanityEmbedsMinAggregateOutputType | null
    _max: VanityEmbedsMaxAggregateOutputType | null
  }

  export type VanityEmbedsMinAggregateOutputType = {
    id: string | null
    Title: string | null
    Description: string | null
    Color: string | null
    ImageUrl: string | null
    ThumbnailUrl: string | null
    VanityId: string | null
  }

  export type VanityEmbedsMaxAggregateOutputType = {
    id: string | null
    Title: string | null
    Description: string | null
    Color: string | null
    ImageUrl: string | null
    ThumbnailUrl: string | null
    VanityId: string | null
  }

  export type VanityEmbedsCountAggregateOutputType = {
    id: number
    Title: number
    Description: number
    Color: number
    ImageUrl: number
    ThumbnailUrl: number
    VanityId: number
    _all: number
  }


  export type VanityEmbedsMinAggregateInputType = {
    id?: true
    Title?: true
    Description?: true
    Color?: true
    ImageUrl?: true
    ThumbnailUrl?: true
    VanityId?: true
  }

  export type VanityEmbedsMaxAggregateInputType = {
    id?: true
    Title?: true
    Description?: true
    Color?: true
    ImageUrl?: true
    ThumbnailUrl?: true
    VanityId?: true
  }

  export type VanityEmbedsCountAggregateInputType = {
    id?: true
    Title?: true
    Description?: true
    Color?: true
    ImageUrl?: true
    ThumbnailUrl?: true
    VanityId?: true
    _all?: true
  }

  export type VanityEmbedsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VanityEmbeds to aggregate.
     */
    where?: VanityEmbedsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VanityEmbeds to fetch.
     */
    orderBy?: VanityEmbedsOrderByWithRelationInput | VanityEmbedsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VanityEmbedsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VanityEmbeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VanityEmbeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VanityEmbeds
    **/
    _count?: true | VanityEmbedsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VanityEmbedsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VanityEmbedsMaxAggregateInputType
  }

  export type GetVanityEmbedsAggregateType<T extends VanityEmbedsAggregateArgs> = {
        [P in keyof T & keyof AggregateVanityEmbeds]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVanityEmbeds[P]>
      : GetScalarType<T[P], AggregateVanityEmbeds[P]>
  }




  export type VanityEmbedsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VanityEmbedsWhereInput
    orderBy?: VanityEmbedsOrderByWithAggregationInput | VanityEmbedsOrderByWithAggregationInput[]
    by: VanityEmbedsScalarFieldEnum[] | VanityEmbedsScalarFieldEnum
    having?: VanityEmbedsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VanityEmbedsCountAggregateInputType | true
    _min?: VanityEmbedsMinAggregateInputType
    _max?: VanityEmbedsMaxAggregateInputType
  }

  export type VanityEmbedsGroupByOutputType = {
    id: string
    Title: string
    Description: string
    Color: string
    ImageUrl: string
    ThumbnailUrl: string
    VanityId: string
    _count: VanityEmbedsCountAggregateOutputType | null
    _min: VanityEmbedsMinAggregateOutputType | null
    _max: VanityEmbedsMaxAggregateOutputType | null
  }

  type GetVanityEmbedsGroupByPayload<T extends VanityEmbedsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VanityEmbedsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VanityEmbedsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VanityEmbedsGroupByOutputType[P]>
            : GetScalarType<T[P], VanityEmbedsGroupByOutputType[P]>
        }
      >
    >


  export type VanityEmbedsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Title?: boolean
    Description?: boolean
    Color?: boolean
    ImageUrl?: boolean
    ThumbnailUrl?: boolean
    VanityId?: boolean
    Author?: boolean | VanityEmbeds$AuthorArgs<ExtArgs>
    Vanitys?: boolean | VanitysDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vanityEmbeds"]>



  export type VanityEmbedsSelectScalar = {
    id?: boolean
    Title?: boolean
    Description?: boolean
    Color?: boolean
    ImageUrl?: boolean
    ThumbnailUrl?: boolean
    VanityId?: boolean
  }

  export type VanityEmbedsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Title" | "Description" | "Color" | "ImageUrl" | "ThumbnailUrl" | "VanityId", ExtArgs["result"]["vanityEmbeds"]>
  export type VanityEmbedsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Author?: boolean | VanityEmbeds$AuthorArgs<ExtArgs>
    Vanitys?: boolean | VanitysDefaultArgs<ExtArgs>
  }

  export type $VanityEmbedsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VanityEmbeds"
    objects: {
      Author: Prisma.$VanityEmbedAuthorsPayload<ExtArgs> | null
      Vanitys: Prisma.$VanitysPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Title: string
      Description: string
      Color: string
      ImageUrl: string
      ThumbnailUrl: string
      VanityId: string
    }, ExtArgs["result"]["vanityEmbeds"]>
    composites: {}
  }

  type VanityEmbedsGetPayload<S extends boolean | null | undefined | VanityEmbedsDefaultArgs> = $Result.GetResult<Prisma.$VanityEmbedsPayload, S>

  type VanityEmbedsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VanityEmbedsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VanityEmbedsCountAggregateInputType | true
    }

  export interface VanityEmbedsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VanityEmbeds'], meta: { name: 'VanityEmbeds' } }
    /**
     * Find zero or one VanityEmbeds that matches the filter.
     * @param {VanityEmbedsFindUniqueArgs} args - Arguments to find a VanityEmbeds
     * @example
     * // Get one VanityEmbeds
     * const vanityEmbeds = await prisma.vanityEmbeds.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VanityEmbedsFindUniqueArgs>(args: SelectSubset<T, VanityEmbedsFindUniqueArgs<ExtArgs>>): Prisma__VanityEmbedsClient<$Result.GetResult<Prisma.$VanityEmbedsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VanityEmbeds that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VanityEmbedsFindUniqueOrThrowArgs} args - Arguments to find a VanityEmbeds
     * @example
     * // Get one VanityEmbeds
     * const vanityEmbeds = await prisma.vanityEmbeds.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VanityEmbedsFindUniqueOrThrowArgs>(args: SelectSubset<T, VanityEmbedsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VanityEmbedsClient<$Result.GetResult<Prisma.$VanityEmbedsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VanityEmbeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanityEmbedsFindFirstArgs} args - Arguments to find a VanityEmbeds
     * @example
     * // Get one VanityEmbeds
     * const vanityEmbeds = await prisma.vanityEmbeds.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VanityEmbedsFindFirstArgs>(args?: SelectSubset<T, VanityEmbedsFindFirstArgs<ExtArgs>>): Prisma__VanityEmbedsClient<$Result.GetResult<Prisma.$VanityEmbedsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VanityEmbeds that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanityEmbedsFindFirstOrThrowArgs} args - Arguments to find a VanityEmbeds
     * @example
     * // Get one VanityEmbeds
     * const vanityEmbeds = await prisma.vanityEmbeds.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VanityEmbedsFindFirstOrThrowArgs>(args?: SelectSubset<T, VanityEmbedsFindFirstOrThrowArgs<ExtArgs>>): Prisma__VanityEmbedsClient<$Result.GetResult<Prisma.$VanityEmbedsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VanityEmbeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanityEmbedsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VanityEmbeds
     * const vanityEmbeds = await prisma.vanityEmbeds.findMany()
     * 
     * // Get first 10 VanityEmbeds
     * const vanityEmbeds = await prisma.vanityEmbeds.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vanityEmbedsWithIdOnly = await prisma.vanityEmbeds.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VanityEmbedsFindManyArgs>(args?: SelectSubset<T, VanityEmbedsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VanityEmbedsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VanityEmbeds.
     * @param {VanityEmbedsCreateArgs} args - Arguments to create a VanityEmbeds.
     * @example
     * // Create one VanityEmbeds
     * const VanityEmbeds = await prisma.vanityEmbeds.create({
     *   data: {
     *     // ... data to create a VanityEmbeds
     *   }
     * })
     * 
     */
    create<T extends VanityEmbedsCreateArgs>(args: SelectSubset<T, VanityEmbedsCreateArgs<ExtArgs>>): Prisma__VanityEmbedsClient<$Result.GetResult<Prisma.$VanityEmbedsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VanityEmbeds.
     * @param {VanityEmbedsCreateManyArgs} args - Arguments to create many VanityEmbeds.
     * @example
     * // Create many VanityEmbeds
     * const vanityEmbeds = await prisma.vanityEmbeds.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VanityEmbedsCreateManyArgs>(args?: SelectSubset<T, VanityEmbedsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VanityEmbeds.
     * @param {VanityEmbedsDeleteArgs} args - Arguments to delete one VanityEmbeds.
     * @example
     * // Delete one VanityEmbeds
     * const VanityEmbeds = await prisma.vanityEmbeds.delete({
     *   where: {
     *     // ... filter to delete one VanityEmbeds
     *   }
     * })
     * 
     */
    delete<T extends VanityEmbedsDeleteArgs>(args: SelectSubset<T, VanityEmbedsDeleteArgs<ExtArgs>>): Prisma__VanityEmbedsClient<$Result.GetResult<Prisma.$VanityEmbedsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VanityEmbeds.
     * @param {VanityEmbedsUpdateArgs} args - Arguments to update one VanityEmbeds.
     * @example
     * // Update one VanityEmbeds
     * const vanityEmbeds = await prisma.vanityEmbeds.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VanityEmbedsUpdateArgs>(args: SelectSubset<T, VanityEmbedsUpdateArgs<ExtArgs>>): Prisma__VanityEmbedsClient<$Result.GetResult<Prisma.$VanityEmbedsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VanityEmbeds.
     * @param {VanityEmbedsDeleteManyArgs} args - Arguments to filter VanityEmbeds to delete.
     * @example
     * // Delete a few VanityEmbeds
     * const { count } = await prisma.vanityEmbeds.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VanityEmbedsDeleteManyArgs>(args?: SelectSubset<T, VanityEmbedsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VanityEmbeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanityEmbedsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VanityEmbeds
     * const vanityEmbeds = await prisma.vanityEmbeds.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VanityEmbedsUpdateManyArgs>(args: SelectSubset<T, VanityEmbedsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VanityEmbeds.
     * @param {VanityEmbedsUpsertArgs} args - Arguments to update or create a VanityEmbeds.
     * @example
     * // Update or create a VanityEmbeds
     * const vanityEmbeds = await prisma.vanityEmbeds.upsert({
     *   create: {
     *     // ... data to create a VanityEmbeds
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VanityEmbeds we want to update
     *   }
     * })
     */
    upsert<T extends VanityEmbedsUpsertArgs>(args: SelectSubset<T, VanityEmbedsUpsertArgs<ExtArgs>>): Prisma__VanityEmbedsClient<$Result.GetResult<Prisma.$VanityEmbedsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VanityEmbeds that matches the filter.
     * @param {VanityEmbedsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const vanityEmbeds = await prisma.vanityEmbeds.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: VanityEmbedsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a VanityEmbeds.
     * @param {VanityEmbedsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const vanityEmbeds = await prisma.vanityEmbeds.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: VanityEmbedsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of VanityEmbeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanityEmbedsCountArgs} args - Arguments to filter VanityEmbeds to count.
     * @example
     * // Count the number of VanityEmbeds
     * const count = await prisma.vanityEmbeds.count({
     *   where: {
     *     // ... the filter for the VanityEmbeds we want to count
     *   }
     * })
    **/
    count<T extends VanityEmbedsCountArgs>(
      args?: Subset<T, VanityEmbedsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VanityEmbedsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VanityEmbeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanityEmbedsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VanityEmbedsAggregateArgs>(args: Subset<T, VanityEmbedsAggregateArgs>): Prisma.PrismaPromise<GetVanityEmbedsAggregateType<T>>

    /**
     * Group by VanityEmbeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanityEmbedsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VanityEmbedsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VanityEmbedsGroupByArgs['orderBy'] }
        : { orderBy?: VanityEmbedsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VanityEmbedsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVanityEmbedsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VanityEmbeds model
   */
  readonly fields: VanityEmbedsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VanityEmbeds.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VanityEmbedsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Author<T extends VanityEmbeds$AuthorArgs<ExtArgs> = {}>(args?: Subset<T, VanityEmbeds$AuthorArgs<ExtArgs>>): Prisma__VanityEmbedAuthorsClient<$Result.GetResult<Prisma.$VanityEmbedAuthorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Vanitys<T extends VanitysDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VanitysDefaultArgs<ExtArgs>>): Prisma__VanitysClient<$Result.GetResult<Prisma.$VanitysPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VanityEmbeds model
   */
  interface VanityEmbedsFieldRefs {
    readonly id: FieldRef<"VanityEmbeds", 'String'>
    readonly Title: FieldRef<"VanityEmbeds", 'String'>
    readonly Description: FieldRef<"VanityEmbeds", 'String'>
    readonly Color: FieldRef<"VanityEmbeds", 'String'>
    readonly ImageUrl: FieldRef<"VanityEmbeds", 'String'>
    readonly ThumbnailUrl: FieldRef<"VanityEmbeds", 'String'>
    readonly VanityId: FieldRef<"VanityEmbeds", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VanityEmbeds findUnique
   */
  export type VanityEmbedsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityEmbeds
     */
    select?: VanityEmbedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityEmbeds
     */
    omit?: VanityEmbedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityEmbedsInclude<ExtArgs> | null
    /**
     * Filter, which VanityEmbeds to fetch.
     */
    where: VanityEmbedsWhereUniqueInput
  }

  /**
   * VanityEmbeds findUniqueOrThrow
   */
  export type VanityEmbedsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityEmbeds
     */
    select?: VanityEmbedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityEmbeds
     */
    omit?: VanityEmbedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityEmbedsInclude<ExtArgs> | null
    /**
     * Filter, which VanityEmbeds to fetch.
     */
    where: VanityEmbedsWhereUniqueInput
  }

  /**
   * VanityEmbeds findFirst
   */
  export type VanityEmbedsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityEmbeds
     */
    select?: VanityEmbedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityEmbeds
     */
    omit?: VanityEmbedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityEmbedsInclude<ExtArgs> | null
    /**
     * Filter, which VanityEmbeds to fetch.
     */
    where?: VanityEmbedsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VanityEmbeds to fetch.
     */
    orderBy?: VanityEmbedsOrderByWithRelationInput | VanityEmbedsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VanityEmbeds.
     */
    cursor?: VanityEmbedsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VanityEmbeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VanityEmbeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VanityEmbeds.
     */
    distinct?: VanityEmbedsScalarFieldEnum | VanityEmbedsScalarFieldEnum[]
  }

  /**
   * VanityEmbeds findFirstOrThrow
   */
  export type VanityEmbedsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityEmbeds
     */
    select?: VanityEmbedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityEmbeds
     */
    omit?: VanityEmbedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityEmbedsInclude<ExtArgs> | null
    /**
     * Filter, which VanityEmbeds to fetch.
     */
    where?: VanityEmbedsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VanityEmbeds to fetch.
     */
    orderBy?: VanityEmbedsOrderByWithRelationInput | VanityEmbedsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VanityEmbeds.
     */
    cursor?: VanityEmbedsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VanityEmbeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VanityEmbeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VanityEmbeds.
     */
    distinct?: VanityEmbedsScalarFieldEnum | VanityEmbedsScalarFieldEnum[]
  }

  /**
   * VanityEmbeds findMany
   */
  export type VanityEmbedsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityEmbeds
     */
    select?: VanityEmbedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityEmbeds
     */
    omit?: VanityEmbedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityEmbedsInclude<ExtArgs> | null
    /**
     * Filter, which VanityEmbeds to fetch.
     */
    where?: VanityEmbedsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VanityEmbeds to fetch.
     */
    orderBy?: VanityEmbedsOrderByWithRelationInput | VanityEmbedsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VanityEmbeds.
     */
    cursor?: VanityEmbedsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VanityEmbeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VanityEmbeds.
     */
    skip?: number
    distinct?: VanityEmbedsScalarFieldEnum | VanityEmbedsScalarFieldEnum[]
  }

  /**
   * VanityEmbeds create
   */
  export type VanityEmbedsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityEmbeds
     */
    select?: VanityEmbedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityEmbeds
     */
    omit?: VanityEmbedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityEmbedsInclude<ExtArgs> | null
    /**
     * The data needed to create a VanityEmbeds.
     */
    data: XOR<VanityEmbedsCreateInput, VanityEmbedsUncheckedCreateInput>
  }

  /**
   * VanityEmbeds createMany
   */
  export type VanityEmbedsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VanityEmbeds.
     */
    data: VanityEmbedsCreateManyInput | VanityEmbedsCreateManyInput[]
  }

  /**
   * VanityEmbeds update
   */
  export type VanityEmbedsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityEmbeds
     */
    select?: VanityEmbedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityEmbeds
     */
    omit?: VanityEmbedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityEmbedsInclude<ExtArgs> | null
    /**
     * The data needed to update a VanityEmbeds.
     */
    data: XOR<VanityEmbedsUpdateInput, VanityEmbedsUncheckedUpdateInput>
    /**
     * Choose, which VanityEmbeds to update.
     */
    where: VanityEmbedsWhereUniqueInput
  }

  /**
   * VanityEmbeds updateMany
   */
  export type VanityEmbedsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VanityEmbeds.
     */
    data: XOR<VanityEmbedsUpdateManyMutationInput, VanityEmbedsUncheckedUpdateManyInput>
    /**
     * Filter which VanityEmbeds to update
     */
    where?: VanityEmbedsWhereInput
    /**
     * Limit how many VanityEmbeds to update.
     */
    limit?: number
  }

  /**
   * VanityEmbeds upsert
   */
  export type VanityEmbedsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityEmbeds
     */
    select?: VanityEmbedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityEmbeds
     */
    omit?: VanityEmbedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityEmbedsInclude<ExtArgs> | null
    /**
     * The filter to search for the VanityEmbeds to update in case it exists.
     */
    where: VanityEmbedsWhereUniqueInput
    /**
     * In case the VanityEmbeds found by the `where` argument doesn't exist, create a new VanityEmbeds with this data.
     */
    create: XOR<VanityEmbedsCreateInput, VanityEmbedsUncheckedCreateInput>
    /**
     * In case the VanityEmbeds was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VanityEmbedsUpdateInput, VanityEmbedsUncheckedUpdateInput>
  }

  /**
   * VanityEmbeds delete
   */
  export type VanityEmbedsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityEmbeds
     */
    select?: VanityEmbedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityEmbeds
     */
    omit?: VanityEmbedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityEmbedsInclude<ExtArgs> | null
    /**
     * Filter which VanityEmbeds to delete.
     */
    where: VanityEmbedsWhereUniqueInput
  }

  /**
   * VanityEmbeds deleteMany
   */
  export type VanityEmbedsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VanityEmbeds to delete
     */
    where?: VanityEmbedsWhereInput
    /**
     * Limit how many VanityEmbeds to delete.
     */
    limit?: number
  }

  /**
   * VanityEmbeds findRaw
   */
  export type VanityEmbedsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * VanityEmbeds aggregateRaw
   */
  export type VanityEmbedsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * VanityEmbeds.Author
   */
  export type VanityEmbeds$AuthorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityEmbedAuthors
     */
    select?: VanityEmbedAuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityEmbedAuthors
     */
    omit?: VanityEmbedAuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityEmbedAuthorsInclude<ExtArgs> | null
    where?: VanityEmbedAuthorsWhereInput
  }

  /**
   * VanityEmbeds without action
   */
  export type VanityEmbedsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityEmbeds
     */
    select?: VanityEmbedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityEmbeds
     */
    omit?: VanityEmbedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityEmbedsInclude<ExtArgs> | null
  }


  /**
   * Model VanityEmbedAuthors
   */

  export type AggregateVanityEmbedAuthors = {
    _count: VanityEmbedAuthorsCountAggregateOutputType | null
    _min: VanityEmbedAuthorsMinAggregateOutputType | null
    _max: VanityEmbedAuthorsMaxAggregateOutputType | null
  }

  export type VanityEmbedAuthorsMinAggregateOutputType = {
    id: string | null
    Name: string | null
    URL: string | null
    IconURL: string | null
    VanityEmbedsId: string | null
  }

  export type VanityEmbedAuthorsMaxAggregateOutputType = {
    id: string | null
    Name: string | null
    URL: string | null
    IconURL: string | null
    VanityEmbedsId: string | null
  }

  export type VanityEmbedAuthorsCountAggregateOutputType = {
    id: number
    Name: number
    URL: number
    IconURL: number
    VanityEmbedsId: number
    _all: number
  }


  export type VanityEmbedAuthorsMinAggregateInputType = {
    id?: true
    Name?: true
    URL?: true
    IconURL?: true
    VanityEmbedsId?: true
  }

  export type VanityEmbedAuthorsMaxAggregateInputType = {
    id?: true
    Name?: true
    URL?: true
    IconURL?: true
    VanityEmbedsId?: true
  }

  export type VanityEmbedAuthorsCountAggregateInputType = {
    id?: true
    Name?: true
    URL?: true
    IconURL?: true
    VanityEmbedsId?: true
    _all?: true
  }

  export type VanityEmbedAuthorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VanityEmbedAuthors to aggregate.
     */
    where?: VanityEmbedAuthorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VanityEmbedAuthors to fetch.
     */
    orderBy?: VanityEmbedAuthorsOrderByWithRelationInput | VanityEmbedAuthorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VanityEmbedAuthorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VanityEmbedAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VanityEmbedAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VanityEmbedAuthors
    **/
    _count?: true | VanityEmbedAuthorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VanityEmbedAuthorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VanityEmbedAuthorsMaxAggregateInputType
  }

  export type GetVanityEmbedAuthorsAggregateType<T extends VanityEmbedAuthorsAggregateArgs> = {
        [P in keyof T & keyof AggregateVanityEmbedAuthors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVanityEmbedAuthors[P]>
      : GetScalarType<T[P], AggregateVanityEmbedAuthors[P]>
  }




  export type VanityEmbedAuthorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VanityEmbedAuthorsWhereInput
    orderBy?: VanityEmbedAuthorsOrderByWithAggregationInput | VanityEmbedAuthorsOrderByWithAggregationInput[]
    by: VanityEmbedAuthorsScalarFieldEnum[] | VanityEmbedAuthorsScalarFieldEnum
    having?: VanityEmbedAuthorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VanityEmbedAuthorsCountAggregateInputType | true
    _min?: VanityEmbedAuthorsMinAggregateInputType
    _max?: VanityEmbedAuthorsMaxAggregateInputType
  }

  export type VanityEmbedAuthorsGroupByOutputType = {
    id: string
    Name: string
    URL: string
    IconURL: string
    VanityEmbedsId: string
    _count: VanityEmbedAuthorsCountAggregateOutputType | null
    _min: VanityEmbedAuthorsMinAggregateOutputType | null
    _max: VanityEmbedAuthorsMaxAggregateOutputType | null
  }

  type GetVanityEmbedAuthorsGroupByPayload<T extends VanityEmbedAuthorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VanityEmbedAuthorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VanityEmbedAuthorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VanityEmbedAuthorsGroupByOutputType[P]>
            : GetScalarType<T[P], VanityEmbedAuthorsGroupByOutputType[P]>
        }
      >
    >


  export type VanityEmbedAuthorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Name?: boolean
    URL?: boolean
    IconURL?: boolean
    VanityEmbedsId?: boolean
    VanityEmbeds?: boolean | VanityEmbedsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vanityEmbedAuthors"]>



  export type VanityEmbedAuthorsSelectScalar = {
    id?: boolean
    Name?: boolean
    URL?: boolean
    IconURL?: boolean
    VanityEmbedsId?: boolean
  }

  export type VanityEmbedAuthorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Name" | "URL" | "IconURL" | "VanityEmbedsId", ExtArgs["result"]["vanityEmbedAuthors"]>
  export type VanityEmbedAuthorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VanityEmbeds?: boolean | VanityEmbedsDefaultArgs<ExtArgs>
  }

  export type $VanityEmbedAuthorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VanityEmbedAuthors"
    objects: {
      VanityEmbeds: Prisma.$VanityEmbedsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Name: string
      URL: string
      IconURL: string
      VanityEmbedsId: string
    }, ExtArgs["result"]["vanityEmbedAuthors"]>
    composites: {}
  }

  type VanityEmbedAuthorsGetPayload<S extends boolean | null | undefined | VanityEmbedAuthorsDefaultArgs> = $Result.GetResult<Prisma.$VanityEmbedAuthorsPayload, S>

  type VanityEmbedAuthorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VanityEmbedAuthorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VanityEmbedAuthorsCountAggregateInputType | true
    }

  export interface VanityEmbedAuthorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VanityEmbedAuthors'], meta: { name: 'VanityEmbedAuthors' } }
    /**
     * Find zero or one VanityEmbedAuthors that matches the filter.
     * @param {VanityEmbedAuthorsFindUniqueArgs} args - Arguments to find a VanityEmbedAuthors
     * @example
     * // Get one VanityEmbedAuthors
     * const vanityEmbedAuthors = await prisma.vanityEmbedAuthors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VanityEmbedAuthorsFindUniqueArgs>(args: SelectSubset<T, VanityEmbedAuthorsFindUniqueArgs<ExtArgs>>): Prisma__VanityEmbedAuthorsClient<$Result.GetResult<Prisma.$VanityEmbedAuthorsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VanityEmbedAuthors that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VanityEmbedAuthorsFindUniqueOrThrowArgs} args - Arguments to find a VanityEmbedAuthors
     * @example
     * // Get one VanityEmbedAuthors
     * const vanityEmbedAuthors = await prisma.vanityEmbedAuthors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VanityEmbedAuthorsFindUniqueOrThrowArgs>(args: SelectSubset<T, VanityEmbedAuthorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VanityEmbedAuthorsClient<$Result.GetResult<Prisma.$VanityEmbedAuthorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VanityEmbedAuthors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanityEmbedAuthorsFindFirstArgs} args - Arguments to find a VanityEmbedAuthors
     * @example
     * // Get one VanityEmbedAuthors
     * const vanityEmbedAuthors = await prisma.vanityEmbedAuthors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VanityEmbedAuthorsFindFirstArgs>(args?: SelectSubset<T, VanityEmbedAuthorsFindFirstArgs<ExtArgs>>): Prisma__VanityEmbedAuthorsClient<$Result.GetResult<Prisma.$VanityEmbedAuthorsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VanityEmbedAuthors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanityEmbedAuthorsFindFirstOrThrowArgs} args - Arguments to find a VanityEmbedAuthors
     * @example
     * // Get one VanityEmbedAuthors
     * const vanityEmbedAuthors = await prisma.vanityEmbedAuthors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VanityEmbedAuthorsFindFirstOrThrowArgs>(args?: SelectSubset<T, VanityEmbedAuthorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__VanityEmbedAuthorsClient<$Result.GetResult<Prisma.$VanityEmbedAuthorsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VanityEmbedAuthors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanityEmbedAuthorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VanityEmbedAuthors
     * const vanityEmbedAuthors = await prisma.vanityEmbedAuthors.findMany()
     * 
     * // Get first 10 VanityEmbedAuthors
     * const vanityEmbedAuthors = await prisma.vanityEmbedAuthors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vanityEmbedAuthorsWithIdOnly = await prisma.vanityEmbedAuthors.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VanityEmbedAuthorsFindManyArgs>(args?: SelectSubset<T, VanityEmbedAuthorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VanityEmbedAuthorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VanityEmbedAuthors.
     * @param {VanityEmbedAuthorsCreateArgs} args - Arguments to create a VanityEmbedAuthors.
     * @example
     * // Create one VanityEmbedAuthors
     * const VanityEmbedAuthors = await prisma.vanityEmbedAuthors.create({
     *   data: {
     *     // ... data to create a VanityEmbedAuthors
     *   }
     * })
     * 
     */
    create<T extends VanityEmbedAuthorsCreateArgs>(args: SelectSubset<T, VanityEmbedAuthorsCreateArgs<ExtArgs>>): Prisma__VanityEmbedAuthorsClient<$Result.GetResult<Prisma.$VanityEmbedAuthorsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VanityEmbedAuthors.
     * @param {VanityEmbedAuthorsCreateManyArgs} args - Arguments to create many VanityEmbedAuthors.
     * @example
     * // Create many VanityEmbedAuthors
     * const vanityEmbedAuthors = await prisma.vanityEmbedAuthors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VanityEmbedAuthorsCreateManyArgs>(args?: SelectSubset<T, VanityEmbedAuthorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VanityEmbedAuthors.
     * @param {VanityEmbedAuthorsDeleteArgs} args - Arguments to delete one VanityEmbedAuthors.
     * @example
     * // Delete one VanityEmbedAuthors
     * const VanityEmbedAuthors = await prisma.vanityEmbedAuthors.delete({
     *   where: {
     *     // ... filter to delete one VanityEmbedAuthors
     *   }
     * })
     * 
     */
    delete<T extends VanityEmbedAuthorsDeleteArgs>(args: SelectSubset<T, VanityEmbedAuthorsDeleteArgs<ExtArgs>>): Prisma__VanityEmbedAuthorsClient<$Result.GetResult<Prisma.$VanityEmbedAuthorsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VanityEmbedAuthors.
     * @param {VanityEmbedAuthorsUpdateArgs} args - Arguments to update one VanityEmbedAuthors.
     * @example
     * // Update one VanityEmbedAuthors
     * const vanityEmbedAuthors = await prisma.vanityEmbedAuthors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VanityEmbedAuthorsUpdateArgs>(args: SelectSubset<T, VanityEmbedAuthorsUpdateArgs<ExtArgs>>): Prisma__VanityEmbedAuthorsClient<$Result.GetResult<Prisma.$VanityEmbedAuthorsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VanityEmbedAuthors.
     * @param {VanityEmbedAuthorsDeleteManyArgs} args - Arguments to filter VanityEmbedAuthors to delete.
     * @example
     * // Delete a few VanityEmbedAuthors
     * const { count } = await prisma.vanityEmbedAuthors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VanityEmbedAuthorsDeleteManyArgs>(args?: SelectSubset<T, VanityEmbedAuthorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VanityEmbedAuthors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanityEmbedAuthorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VanityEmbedAuthors
     * const vanityEmbedAuthors = await prisma.vanityEmbedAuthors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VanityEmbedAuthorsUpdateManyArgs>(args: SelectSubset<T, VanityEmbedAuthorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VanityEmbedAuthors.
     * @param {VanityEmbedAuthorsUpsertArgs} args - Arguments to update or create a VanityEmbedAuthors.
     * @example
     * // Update or create a VanityEmbedAuthors
     * const vanityEmbedAuthors = await prisma.vanityEmbedAuthors.upsert({
     *   create: {
     *     // ... data to create a VanityEmbedAuthors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VanityEmbedAuthors we want to update
     *   }
     * })
     */
    upsert<T extends VanityEmbedAuthorsUpsertArgs>(args: SelectSubset<T, VanityEmbedAuthorsUpsertArgs<ExtArgs>>): Prisma__VanityEmbedAuthorsClient<$Result.GetResult<Prisma.$VanityEmbedAuthorsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VanityEmbedAuthors that matches the filter.
     * @param {VanityEmbedAuthorsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const vanityEmbedAuthors = await prisma.vanityEmbedAuthors.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: VanityEmbedAuthorsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a VanityEmbedAuthors.
     * @param {VanityEmbedAuthorsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const vanityEmbedAuthors = await prisma.vanityEmbedAuthors.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: VanityEmbedAuthorsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of VanityEmbedAuthors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanityEmbedAuthorsCountArgs} args - Arguments to filter VanityEmbedAuthors to count.
     * @example
     * // Count the number of VanityEmbedAuthors
     * const count = await prisma.vanityEmbedAuthors.count({
     *   where: {
     *     // ... the filter for the VanityEmbedAuthors we want to count
     *   }
     * })
    **/
    count<T extends VanityEmbedAuthorsCountArgs>(
      args?: Subset<T, VanityEmbedAuthorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VanityEmbedAuthorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VanityEmbedAuthors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanityEmbedAuthorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VanityEmbedAuthorsAggregateArgs>(args: Subset<T, VanityEmbedAuthorsAggregateArgs>): Prisma.PrismaPromise<GetVanityEmbedAuthorsAggregateType<T>>

    /**
     * Group by VanityEmbedAuthors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanityEmbedAuthorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VanityEmbedAuthorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VanityEmbedAuthorsGroupByArgs['orderBy'] }
        : { orderBy?: VanityEmbedAuthorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VanityEmbedAuthorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVanityEmbedAuthorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VanityEmbedAuthors model
   */
  readonly fields: VanityEmbedAuthorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VanityEmbedAuthors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VanityEmbedAuthorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    VanityEmbeds<T extends VanityEmbedsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VanityEmbedsDefaultArgs<ExtArgs>>): Prisma__VanityEmbedsClient<$Result.GetResult<Prisma.$VanityEmbedsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VanityEmbedAuthors model
   */
  interface VanityEmbedAuthorsFieldRefs {
    readonly id: FieldRef<"VanityEmbedAuthors", 'String'>
    readonly Name: FieldRef<"VanityEmbedAuthors", 'String'>
    readonly URL: FieldRef<"VanityEmbedAuthors", 'String'>
    readonly IconURL: FieldRef<"VanityEmbedAuthors", 'String'>
    readonly VanityEmbedsId: FieldRef<"VanityEmbedAuthors", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VanityEmbedAuthors findUnique
   */
  export type VanityEmbedAuthorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityEmbedAuthors
     */
    select?: VanityEmbedAuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityEmbedAuthors
     */
    omit?: VanityEmbedAuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityEmbedAuthorsInclude<ExtArgs> | null
    /**
     * Filter, which VanityEmbedAuthors to fetch.
     */
    where: VanityEmbedAuthorsWhereUniqueInput
  }

  /**
   * VanityEmbedAuthors findUniqueOrThrow
   */
  export type VanityEmbedAuthorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityEmbedAuthors
     */
    select?: VanityEmbedAuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityEmbedAuthors
     */
    omit?: VanityEmbedAuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityEmbedAuthorsInclude<ExtArgs> | null
    /**
     * Filter, which VanityEmbedAuthors to fetch.
     */
    where: VanityEmbedAuthorsWhereUniqueInput
  }

  /**
   * VanityEmbedAuthors findFirst
   */
  export type VanityEmbedAuthorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityEmbedAuthors
     */
    select?: VanityEmbedAuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityEmbedAuthors
     */
    omit?: VanityEmbedAuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityEmbedAuthorsInclude<ExtArgs> | null
    /**
     * Filter, which VanityEmbedAuthors to fetch.
     */
    where?: VanityEmbedAuthorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VanityEmbedAuthors to fetch.
     */
    orderBy?: VanityEmbedAuthorsOrderByWithRelationInput | VanityEmbedAuthorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VanityEmbedAuthors.
     */
    cursor?: VanityEmbedAuthorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VanityEmbedAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VanityEmbedAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VanityEmbedAuthors.
     */
    distinct?: VanityEmbedAuthorsScalarFieldEnum | VanityEmbedAuthorsScalarFieldEnum[]
  }

  /**
   * VanityEmbedAuthors findFirstOrThrow
   */
  export type VanityEmbedAuthorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityEmbedAuthors
     */
    select?: VanityEmbedAuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityEmbedAuthors
     */
    omit?: VanityEmbedAuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityEmbedAuthorsInclude<ExtArgs> | null
    /**
     * Filter, which VanityEmbedAuthors to fetch.
     */
    where?: VanityEmbedAuthorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VanityEmbedAuthors to fetch.
     */
    orderBy?: VanityEmbedAuthorsOrderByWithRelationInput | VanityEmbedAuthorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VanityEmbedAuthors.
     */
    cursor?: VanityEmbedAuthorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VanityEmbedAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VanityEmbedAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VanityEmbedAuthors.
     */
    distinct?: VanityEmbedAuthorsScalarFieldEnum | VanityEmbedAuthorsScalarFieldEnum[]
  }

  /**
   * VanityEmbedAuthors findMany
   */
  export type VanityEmbedAuthorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityEmbedAuthors
     */
    select?: VanityEmbedAuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityEmbedAuthors
     */
    omit?: VanityEmbedAuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityEmbedAuthorsInclude<ExtArgs> | null
    /**
     * Filter, which VanityEmbedAuthors to fetch.
     */
    where?: VanityEmbedAuthorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VanityEmbedAuthors to fetch.
     */
    orderBy?: VanityEmbedAuthorsOrderByWithRelationInput | VanityEmbedAuthorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VanityEmbedAuthors.
     */
    cursor?: VanityEmbedAuthorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VanityEmbedAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VanityEmbedAuthors.
     */
    skip?: number
    distinct?: VanityEmbedAuthorsScalarFieldEnum | VanityEmbedAuthorsScalarFieldEnum[]
  }

  /**
   * VanityEmbedAuthors create
   */
  export type VanityEmbedAuthorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityEmbedAuthors
     */
    select?: VanityEmbedAuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityEmbedAuthors
     */
    omit?: VanityEmbedAuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityEmbedAuthorsInclude<ExtArgs> | null
    /**
     * The data needed to create a VanityEmbedAuthors.
     */
    data: XOR<VanityEmbedAuthorsCreateInput, VanityEmbedAuthorsUncheckedCreateInput>
  }

  /**
   * VanityEmbedAuthors createMany
   */
  export type VanityEmbedAuthorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VanityEmbedAuthors.
     */
    data: VanityEmbedAuthorsCreateManyInput | VanityEmbedAuthorsCreateManyInput[]
  }

  /**
   * VanityEmbedAuthors update
   */
  export type VanityEmbedAuthorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityEmbedAuthors
     */
    select?: VanityEmbedAuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityEmbedAuthors
     */
    omit?: VanityEmbedAuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityEmbedAuthorsInclude<ExtArgs> | null
    /**
     * The data needed to update a VanityEmbedAuthors.
     */
    data: XOR<VanityEmbedAuthorsUpdateInput, VanityEmbedAuthorsUncheckedUpdateInput>
    /**
     * Choose, which VanityEmbedAuthors to update.
     */
    where: VanityEmbedAuthorsWhereUniqueInput
  }

  /**
   * VanityEmbedAuthors updateMany
   */
  export type VanityEmbedAuthorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VanityEmbedAuthors.
     */
    data: XOR<VanityEmbedAuthorsUpdateManyMutationInput, VanityEmbedAuthorsUncheckedUpdateManyInput>
    /**
     * Filter which VanityEmbedAuthors to update
     */
    where?: VanityEmbedAuthorsWhereInput
    /**
     * Limit how many VanityEmbedAuthors to update.
     */
    limit?: number
  }

  /**
   * VanityEmbedAuthors upsert
   */
  export type VanityEmbedAuthorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityEmbedAuthors
     */
    select?: VanityEmbedAuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityEmbedAuthors
     */
    omit?: VanityEmbedAuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityEmbedAuthorsInclude<ExtArgs> | null
    /**
     * The filter to search for the VanityEmbedAuthors to update in case it exists.
     */
    where: VanityEmbedAuthorsWhereUniqueInput
    /**
     * In case the VanityEmbedAuthors found by the `where` argument doesn't exist, create a new VanityEmbedAuthors with this data.
     */
    create: XOR<VanityEmbedAuthorsCreateInput, VanityEmbedAuthorsUncheckedCreateInput>
    /**
     * In case the VanityEmbedAuthors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VanityEmbedAuthorsUpdateInput, VanityEmbedAuthorsUncheckedUpdateInput>
  }

  /**
   * VanityEmbedAuthors delete
   */
  export type VanityEmbedAuthorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityEmbedAuthors
     */
    select?: VanityEmbedAuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityEmbedAuthors
     */
    omit?: VanityEmbedAuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityEmbedAuthorsInclude<ExtArgs> | null
    /**
     * Filter which VanityEmbedAuthors to delete.
     */
    where: VanityEmbedAuthorsWhereUniqueInput
  }

  /**
   * VanityEmbedAuthors deleteMany
   */
  export type VanityEmbedAuthorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VanityEmbedAuthors to delete
     */
    where?: VanityEmbedAuthorsWhereInput
    /**
     * Limit how many VanityEmbedAuthors to delete.
     */
    limit?: number
  }

  /**
   * VanityEmbedAuthors findRaw
   */
  export type VanityEmbedAuthorsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * VanityEmbedAuthors aggregateRaw
   */
  export type VanityEmbedAuthorsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * VanityEmbedAuthors without action
   */
  export type VanityEmbedAuthorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityEmbedAuthors
     */
    select?: VanityEmbedAuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityEmbedAuthors
     */
    omit?: VanityEmbedAuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityEmbedAuthorsInclude<ExtArgs> | null
  }


  /**
   * Model VanityAnalytics
   */

  export type AggregateVanityAnalytics = {
    _count: VanityAnalyticsCountAggregateOutputType | null
    _avg: VanityAnalyticsAvgAggregateOutputType | null
    _sum: VanityAnalyticsSumAggregateOutputType | null
    _min: VanityAnalyticsMinAggregateOutputType | null
    _max: VanityAnalyticsMaxAggregateOutputType | null
  }

  export type VanityAnalyticsAvgAggregateOutputType = {
    Click: number | null
    UniqueClick: number | null
    JoinedWithCode: number | null
  }

  export type VanityAnalyticsSumAggregateOutputType = {
    Click: number | null
    UniqueClick: number | null
    JoinedWithCode: number | null
  }

  export type VanityAnalyticsMinAggregateOutputType = {
    id: string | null
    Click: number | null
    TrackInviteWithLog: string | null
    TrackMessageId: string | null
    Update: Date | null
    UniqueClick: number | null
    JoinedWithCode: number | null
    VanityId: string | null
  }

  export type VanityAnalyticsMaxAggregateOutputType = {
    id: string | null
    Click: number | null
    TrackInviteWithLog: string | null
    TrackMessageId: string | null
    Update: Date | null
    UniqueClick: number | null
    JoinedWithCode: number | null
    VanityId: string | null
  }

  export type VanityAnalyticsCountAggregateOutputType = {
    id: number
    Click: number
    TrackInviteWithLog: number
    TrackMessageId: number
    Update: number
    UniqueClick: number
    JoinedWithCode: number
    LoggedIPs: number
    VanityId: number
    _all: number
  }


  export type VanityAnalyticsAvgAggregateInputType = {
    Click?: true
    UniqueClick?: true
    JoinedWithCode?: true
  }

  export type VanityAnalyticsSumAggregateInputType = {
    Click?: true
    UniqueClick?: true
    JoinedWithCode?: true
  }

  export type VanityAnalyticsMinAggregateInputType = {
    id?: true
    Click?: true
    TrackInviteWithLog?: true
    TrackMessageId?: true
    Update?: true
    UniqueClick?: true
    JoinedWithCode?: true
    VanityId?: true
  }

  export type VanityAnalyticsMaxAggregateInputType = {
    id?: true
    Click?: true
    TrackInviteWithLog?: true
    TrackMessageId?: true
    Update?: true
    UniqueClick?: true
    JoinedWithCode?: true
    VanityId?: true
  }

  export type VanityAnalyticsCountAggregateInputType = {
    id?: true
    Click?: true
    TrackInviteWithLog?: true
    TrackMessageId?: true
    Update?: true
    UniqueClick?: true
    JoinedWithCode?: true
    LoggedIPs?: true
    VanityId?: true
    _all?: true
  }

  export type VanityAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VanityAnalytics to aggregate.
     */
    where?: VanityAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VanityAnalytics to fetch.
     */
    orderBy?: VanityAnalyticsOrderByWithRelationInput | VanityAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VanityAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VanityAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VanityAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VanityAnalytics
    **/
    _count?: true | VanityAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VanityAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VanityAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VanityAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VanityAnalyticsMaxAggregateInputType
  }

  export type GetVanityAnalyticsAggregateType<T extends VanityAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateVanityAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVanityAnalytics[P]>
      : GetScalarType<T[P], AggregateVanityAnalytics[P]>
  }




  export type VanityAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VanityAnalyticsWhereInput
    orderBy?: VanityAnalyticsOrderByWithAggregationInput | VanityAnalyticsOrderByWithAggregationInput[]
    by: VanityAnalyticsScalarFieldEnum[] | VanityAnalyticsScalarFieldEnum
    having?: VanityAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VanityAnalyticsCountAggregateInputType | true
    _avg?: VanityAnalyticsAvgAggregateInputType
    _sum?: VanityAnalyticsSumAggregateInputType
    _min?: VanityAnalyticsMinAggregateInputType
    _max?: VanityAnalyticsMaxAggregateInputType
  }

  export type VanityAnalyticsGroupByOutputType = {
    id: string
    Click: number
    TrackInviteWithLog: string | null
    TrackMessageId: string | null
    Update: Date | null
    UniqueClick: number | null
    JoinedWithCode: number | null
    LoggedIPs: string[]
    VanityId: string
    _count: VanityAnalyticsCountAggregateOutputType | null
    _avg: VanityAnalyticsAvgAggregateOutputType | null
    _sum: VanityAnalyticsSumAggregateOutputType | null
    _min: VanityAnalyticsMinAggregateOutputType | null
    _max: VanityAnalyticsMaxAggregateOutputType | null
  }

  type GetVanityAnalyticsGroupByPayload<T extends VanityAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VanityAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VanityAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VanityAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], VanityAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type VanityAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Click?: boolean
    TrackInviteWithLog?: boolean
    TrackMessageId?: boolean
    Update?: boolean
    UniqueClick?: boolean
    JoinedWithCode?: boolean
    LoggedIPs?: boolean
    VanityId?: boolean
    Latest30Days?: boolean | VanityAnalytics$Latest30DaysArgs<ExtArgs>
    Vanitys?: boolean | VanitysDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vanityAnalytics"]>



  export type VanityAnalyticsSelectScalar = {
    id?: boolean
    Click?: boolean
    TrackInviteWithLog?: boolean
    TrackMessageId?: boolean
    Update?: boolean
    UniqueClick?: boolean
    JoinedWithCode?: boolean
    LoggedIPs?: boolean
    VanityId?: boolean
  }

  export type VanityAnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Click" | "TrackInviteWithLog" | "TrackMessageId" | "Update" | "UniqueClick" | "JoinedWithCode" | "LoggedIPs" | "VanityId", ExtArgs["result"]["vanityAnalytics"]>
  export type VanityAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Latest30Days?: boolean | VanityAnalytics$Latest30DaysArgs<ExtArgs>
    Vanitys?: boolean | VanitysDefaultArgs<ExtArgs>
  }

  export type $VanityAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VanityAnalytics"
    objects: {
      Latest30Days: Prisma.$AnalyticsLatest30DaysPayload<ExtArgs> | null
      Vanitys: Prisma.$VanitysPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Click: number
      TrackInviteWithLog: string | null
      TrackMessageId: string | null
      Update: Date | null
      UniqueClick: number | null
      JoinedWithCode: number | null
      LoggedIPs: string[]
      VanityId: string
    }, ExtArgs["result"]["vanityAnalytics"]>
    composites: {}
  }

  type VanityAnalyticsGetPayload<S extends boolean | null | undefined | VanityAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$VanityAnalyticsPayload, S>

  type VanityAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VanityAnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VanityAnalyticsCountAggregateInputType | true
    }

  export interface VanityAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VanityAnalytics'], meta: { name: 'VanityAnalytics' } }
    /**
     * Find zero or one VanityAnalytics that matches the filter.
     * @param {VanityAnalyticsFindUniqueArgs} args - Arguments to find a VanityAnalytics
     * @example
     * // Get one VanityAnalytics
     * const vanityAnalytics = await prisma.vanityAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VanityAnalyticsFindUniqueArgs>(args: SelectSubset<T, VanityAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__VanityAnalyticsClient<$Result.GetResult<Prisma.$VanityAnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VanityAnalytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VanityAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a VanityAnalytics
     * @example
     * // Get one VanityAnalytics
     * const vanityAnalytics = await prisma.vanityAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VanityAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, VanityAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VanityAnalyticsClient<$Result.GetResult<Prisma.$VanityAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VanityAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanityAnalyticsFindFirstArgs} args - Arguments to find a VanityAnalytics
     * @example
     * // Get one VanityAnalytics
     * const vanityAnalytics = await prisma.vanityAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VanityAnalyticsFindFirstArgs>(args?: SelectSubset<T, VanityAnalyticsFindFirstArgs<ExtArgs>>): Prisma__VanityAnalyticsClient<$Result.GetResult<Prisma.$VanityAnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VanityAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanityAnalyticsFindFirstOrThrowArgs} args - Arguments to find a VanityAnalytics
     * @example
     * // Get one VanityAnalytics
     * const vanityAnalytics = await prisma.vanityAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VanityAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, VanityAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__VanityAnalyticsClient<$Result.GetResult<Prisma.$VanityAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VanityAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanityAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VanityAnalytics
     * const vanityAnalytics = await prisma.vanityAnalytics.findMany()
     * 
     * // Get first 10 VanityAnalytics
     * const vanityAnalytics = await prisma.vanityAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vanityAnalyticsWithIdOnly = await prisma.vanityAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VanityAnalyticsFindManyArgs>(args?: SelectSubset<T, VanityAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VanityAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VanityAnalytics.
     * @param {VanityAnalyticsCreateArgs} args - Arguments to create a VanityAnalytics.
     * @example
     * // Create one VanityAnalytics
     * const VanityAnalytics = await prisma.vanityAnalytics.create({
     *   data: {
     *     // ... data to create a VanityAnalytics
     *   }
     * })
     * 
     */
    create<T extends VanityAnalyticsCreateArgs>(args: SelectSubset<T, VanityAnalyticsCreateArgs<ExtArgs>>): Prisma__VanityAnalyticsClient<$Result.GetResult<Prisma.$VanityAnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VanityAnalytics.
     * @param {VanityAnalyticsCreateManyArgs} args - Arguments to create many VanityAnalytics.
     * @example
     * // Create many VanityAnalytics
     * const vanityAnalytics = await prisma.vanityAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VanityAnalyticsCreateManyArgs>(args?: SelectSubset<T, VanityAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VanityAnalytics.
     * @param {VanityAnalyticsDeleteArgs} args - Arguments to delete one VanityAnalytics.
     * @example
     * // Delete one VanityAnalytics
     * const VanityAnalytics = await prisma.vanityAnalytics.delete({
     *   where: {
     *     // ... filter to delete one VanityAnalytics
     *   }
     * })
     * 
     */
    delete<T extends VanityAnalyticsDeleteArgs>(args: SelectSubset<T, VanityAnalyticsDeleteArgs<ExtArgs>>): Prisma__VanityAnalyticsClient<$Result.GetResult<Prisma.$VanityAnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VanityAnalytics.
     * @param {VanityAnalyticsUpdateArgs} args - Arguments to update one VanityAnalytics.
     * @example
     * // Update one VanityAnalytics
     * const vanityAnalytics = await prisma.vanityAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VanityAnalyticsUpdateArgs>(args: SelectSubset<T, VanityAnalyticsUpdateArgs<ExtArgs>>): Prisma__VanityAnalyticsClient<$Result.GetResult<Prisma.$VanityAnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VanityAnalytics.
     * @param {VanityAnalyticsDeleteManyArgs} args - Arguments to filter VanityAnalytics to delete.
     * @example
     * // Delete a few VanityAnalytics
     * const { count } = await prisma.vanityAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VanityAnalyticsDeleteManyArgs>(args?: SelectSubset<T, VanityAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VanityAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanityAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VanityAnalytics
     * const vanityAnalytics = await prisma.vanityAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VanityAnalyticsUpdateManyArgs>(args: SelectSubset<T, VanityAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VanityAnalytics.
     * @param {VanityAnalyticsUpsertArgs} args - Arguments to update or create a VanityAnalytics.
     * @example
     * // Update or create a VanityAnalytics
     * const vanityAnalytics = await prisma.vanityAnalytics.upsert({
     *   create: {
     *     // ... data to create a VanityAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VanityAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends VanityAnalyticsUpsertArgs>(args: SelectSubset<T, VanityAnalyticsUpsertArgs<ExtArgs>>): Prisma__VanityAnalyticsClient<$Result.GetResult<Prisma.$VanityAnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VanityAnalytics that matches the filter.
     * @param {VanityAnalyticsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const vanityAnalytics = await prisma.vanityAnalytics.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: VanityAnalyticsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a VanityAnalytics.
     * @param {VanityAnalyticsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const vanityAnalytics = await prisma.vanityAnalytics.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: VanityAnalyticsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of VanityAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanityAnalyticsCountArgs} args - Arguments to filter VanityAnalytics to count.
     * @example
     * // Count the number of VanityAnalytics
     * const count = await prisma.vanityAnalytics.count({
     *   where: {
     *     // ... the filter for the VanityAnalytics we want to count
     *   }
     * })
    **/
    count<T extends VanityAnalyticsCountArgs>(
      args?: Subset<T, VanityAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VanityAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VanityAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanityAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VanityAnalyticsAggregateArgs>(args: Subset<T, VanityAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetVanityAnalyticsAggregateType<T>>

    /**
     * Group by VanityAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanityAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VanityAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VanityAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: VanityAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VanityAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVanityAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VanityAnalytics model
   */
  readonly fields: VanityAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VanityAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VanityAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Latest30Days<T extends VanityAnalytics$Latest30DaysArgs<ExtArgs> = {}>(args?: Subset<T, VanityAnalytics$Latest30DaysArgs<ExtArgs>>): Prisma__AnalyticsLatest30DaysClient<$Result.GetResult<Prisma.$AnalyticsLatest30DaysPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Vanitys<T extends VanitysDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VanitysDefaultArgs<ExtArgs>>): Prisma__VanitysClient<$Result.GetResult<Prisma.$VanitysPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VanityAnalytics model
   */
  interface VanityAnalyticsFieldRefs {
    readonly id: FieldRef<"VanityAnalytics", 'String'>
    readonly Click: FieldRef<"VanityAnalytics", 'Int'>
    readonly TrackInviteWithLog: FieldRef<"VanityAnalytics", 'String'>
    readonly TrackMessageId: FieldRef<"VanityAnalytics", 'String'>
    readonly Update: FieldRef<"VanityAnalytics", 'DateTime'>
    readonly UniqueClick: FieldRef<"VanityAnalytics", 'Int'>
    readonly JoinedWithCode: FieldRef<"VanityAnalytics", 'Int'>
    readonly LoggedIPs: FieldRef<"VanityAnalytics", 'String[]'>
    readonly VanityId: FieldRef<"VanityAnalytics", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VanityAnalytics findUnique
   */
  export type VanityAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityAnalytics
     */
    select?: VanityAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityAnalytics
     */
    omit?: VanityAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which VanityAnalytics to fetch.
     */
    where: VanityAnalyticsWhereUniqueInput
  }

  /**
   * VanityAnalytics findUniqueOrThrow
   */
  export type VanityAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityAnalytics
     */
    select?: VanityAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityAnalytics
     */
    omit?: VanityAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which VanityAnalytics to fetch.
     */
    where: VanityAnalyticsWhereUniqueInput
  }

  /**
   * VanityAnalytics findFirst
   */
  export type VanityAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityAnalytics
     */
    select?: VanityAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityAnalytics
     */
    omit?: VanityAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which VanityAnalytics to fetch.
     */
    where?: VanityAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VanityAnalytics to fetch.
     */
    orderBy?: VanityAnalyticsOrderByWithRelationInput | VanityAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VanityAnalytics.
     */
    cursor?: VanityAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VanityAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VanityAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VanityAnalytics.
     */
    distinct?: VanityAnalyticsScalarFieldEnum | VanityAnalyticsScalarFieldEnum[]
  }

  /**
   * VanityAnalytics findFirstOrThrow
   */
  export type VanityAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityAnalytics
     */
    select?: VanityAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityAnalytics
     */
    omit?: VanityAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which VanityAnalytics to fetch.
     */
    where?: VanityAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VanityAnalytics to fetch.
     */
    orderBy?: VanityAnalyticsOrderByWithRelationInput | VanityAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VanityAnalytics.
     */
    cursor?: VanityAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VanityAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VanityAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VanityAnalytics.
     */
    distinct?: VanityAnalyticsScalarFieldEnum | VanityAnalyticsScalarFieldEnum[]
  }

  /**
   * VanityAnalytics findMany
   */
  export type VanityAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityAnalytics
     */
    select?: VanityAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityAnalytics
     */
    omit?: VanityAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which VanityAnalytics to fetch.
     */
    where?: VanityAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VanityAnalytics to fetch.
     */
    orderBy?: VanityAnalyticsOrderByWithRelationInput | VanityAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VanityAnalytics.
     */
    cursor?: VanityAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VanityAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VanityAnalytics.
     */
    skip?: number
    distinct?: VanityAnalyticsScalarFieldEnum | VanityAnalyticsScalarFieldEnum[]
  }

  /**
   * VanityAnalytics create
   */
  export type VanityAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityAnalytics
     */
    select?: VanityAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityAnalytics
     */
    omit?: VanityAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a VanityAnalytics.
     */
    data: XOR<VanityAnalyticsCreateInput, VanityAnalyticsUncheckedCreateInput>
  }

  /**
   * VanityAnalytics createMany
   */
  export type VanityAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VanityAnalytics.
     */
    data: VanityAnalyticsCreateManyInput | VanityAnalyticsCreateManyInput[]
  }

  /**
   * VanityAnalytics update
   */
  export type VanityAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityAnalytics
     */
    select?: VanityAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityAnalytics
     */
    omit?: VanityAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a VanityAnalytics.
     */
    data: XOR<VanityAnalyticsUpdateInput, VanityAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which VanityAnalytics to update.
     */
    where: VanityAnalyticsWhereUniqueInput
  }

  /**
   * VanityAnalytics updateMany
   */
  export type VanityAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VanityAnalytics.
     */
    data: XOR<VanityAnalyticsUpdateManyMutationInput, VanityAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which VanityAnalytics to update
     */
    where?: VanityAnalyticsWhereInput
    /**
     * Limit how many VanityAnalytics to update.
     */
    limit?: number
  }

  /**
   * VanityAnalytics upsert
   */
  export type VanityAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityAnalytics
     */
    select?: VanityAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityAnalytics
     */
    omit?: VanityAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the VanityAnalytics to update in case it exists.
     */
    where: VanityAnalyticsWhereUniqueInput
    /**
     * In case the VanityAnalytics found by the `where` argument doesn't exist, create a new VanityAnalytics with this data.
     */
    create: XOR<VanityAnalyticsCreateInput, VanityAnalyticsUncheckedCreateInput>
    /**
     * In case the VanityAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VanityAnalyticsUpdateInput, VanityAnalyticsUncheckedUpdateInput>
  }

  /**
   * VanityAnalytics delete
   */
  export type VanityAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityAnalytics
     */
    select?: VanityAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityAnalytics
     */
    omit?: VanityAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which VanityAnalytics to delete.
     */
    where: VanityAnalyticsWhereUniqueInput
  }

  /**
   * VanityAnalytics deleteMany
   */
  export type VanityAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VanityAnalytics to delete
     */
    where?: VanityAnalyticsWhereInput
    /**
     * Limit how many VanityAnalytics to delete.
     */
    limit?: number
  }

  /**
   * VanityAnalytics findRaw
   */
  export type VanityAnalyticsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * VanityAnalytics aggregateRaw
   */
  export type VanityAnalyticsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * VanityAnalytics.Latest30Days
   */
  export type VanityAnalytics$Latest30DaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsLatest30Days
     */
    select?: AnalyticsLatest30DaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsLatest30Days
     */
    omit?: AnalyticsLatest30DaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsLatest30DaysInclude<ExtArgs> | null
    where?: AnalyticsLatest30DaysWhereInput
  }

  /**
   * VanityAnalytics without action
   */
  export type VanityAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VanityAnalytics
     */
    select?: VanityAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VanityAnalytics
     */
    omit?: VanityAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VanityAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model AnalyticsLatest30Days
   */

  export type AggregateAnalyticsLatest30Days = {
    _count: AnalyticsLatest30DaysCountAggregateOutputType | null
    _avg: AnalyticsLatest30DaysAvgAggregateOutputType | null
    _sum: AnalyticsLatest30DaysSumAggregateOutputType | null
    _min: AnalyticsLatest30DaysMinAggregateOutputType | null
    _max: AnalyticsLatest30DaysMaxAggregateOutputType | null
  }

  export type AnalyticsLatest30DaysAvgAggregateOutputType = {
    Click: number | null
    UniqueClick: number | null
    JoinedWithCode: number | null
  }

  export type AnalyticsLatest30DaysSumAggregateOutputType = {
    Click: number | null
    UniqueClick: number | null
    JoinedWithCode: number | null
  }

  export type AnalyticsLatest30DaysMinAggregateOutputType = {
    id: string | null
    Click: number | null
    UniqueClick: number | null
    Date: Date | null
    JoinedWithCode: number | null
    VanityAnalyticsId: string | null
  }

  export type AnalyticsLatest30DaysMaxAggregateOutputType = {
    id: string | null
    Click: number | null
    UniqueClick: number | null
    Date: Date | null
    JoinedWithCode: number | null
    VanityAnalyticsId: string | null
  }

  export type AnalyticsLatest30DaysCountAggregateOutputType = {
    id: number
    Click: number
    UniqueClick: number
    Date: number
    JoinedWithCode: number
    VanityAnalyticsId: number
    _all: number
  }


  export type AnalyticsLatest30DaysAvgAggregateInputType = {
    Click?: true
    UniqueClick?: true
    JoinedWithCode?: true
  }

  export type AnalyticsLatest30DaysSumAggregateInputType = {
    Click?: true
    UniqueClick?: true
    JoinedWithCode?: true
  }

  export type AnalyticsLatest30DaysMinAggregateInputType = {
    id?: true
    Click?: true
    UniqueClick?: true
    Date?: true
    JoinedWithCode?: true
    VanityAnalyticsId?: true
  }

  export type AnalyticsLatest30DaysMaxAggregateInputType = {
    id?: true
    Click?: true
    UniqueClick?: true
    Date?: true
    JoinedWithCode?: true
    VanityAnalyticsId?: true
  }

  export type AnalyticsLatest30DaysCountAggregateInputType = {
    id?: true
    Click?: true
    UniqueClick?: true
    Date?: true
    JoinedWithCode?: true
    VanityAnalyticsId?: true
    _all?: true
  }

  export type AnalyticsLatest30DaysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsLatest30Days to aggregate.
     */
    where?: AnalyticsLatest30DaysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsLatest30Days to fetch.
     */
    orderBy?: AnalyticsLatest30DaysOrderByWithRelationInput | AnalyticsLatest30DaysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsLatest30DaysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsLatest30Days from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsLatest30Days.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsLatest30Days
    **/
    _count?: true | AnalyticsLatest30DaysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalyticsLatest30DaysAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalyticsLatest30DaysSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsLatest30DaysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsLatest30DaysMaxAggregateInputType
  }

  export type GetAnalyticsLatest30DaysAggregateType<T extends AnalyticsLatest30DaysAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsLatest30Days]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsLatest30Days[P]>
      : GetScalarType<T[P], AggregateAnalyticsLatest30Days[P]>
  }




  export type AnalyticsLatest30DaysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsLatest30DaysWhereInput
    orderBy?: AnalyticsLatest30DaysOrderByWithAggregationInput | AnalyticsLatest30DaysOrderByWithAggregationInput[]
    by: AnalyticsLatest30DaysScalarFieldEnum[] | AnalyticsLatest30DaysScalarFieldEnum
    having?: AnalyticsLatest30DaysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsLatest30DaysCountAggregateInputType | true
    _avg?: AnalyticsLatest30DaysAvgAggregateInputType
    _sum?: AnalyticsLatest30DaysSumAggregateInputType
    _min?: AnalyticsLatest30DaysMinAggregateInputType
    _max?: AnalyticsLatest30DaysMaxAggregateInputType
  }

  export type AnalyticsLatest30DaysGroupByOutputType = {
    id: string
    Click: number | null
    UniqueClick: number | null
    Date: Date | null
    JoinedWithCode: number | null
    VanityAnalyticsId: string
    _count: AnalyticsLatest30DaysCountAggregateOutputType | null
    _avg: AnalyticsLatest30DaysAvgAggregateOutputType | null
    _sum: AnalyticsLatest30DaysSumAggregateOutputType | null
    _min: AnalyticsLatest30DaysMinAggregateOutputType | null
    _max: AnalyticsLatest30DaysMaxAggregateOutputType | null
  }

  type GetAnalyticsLatest30DaysGroupByPayload<T extends AnalyticsLatest30DaysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsLatest30DaysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsLatest30DaysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsLatest30DaysGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsLatest30DaysGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsLatest30DaysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Click?: boolean
    UniqueClick?: boolean
    Date?: boolean
    JoinedWithCode?: boolean
    VanityAnalyticsId?: boolean
    VanityAnalytics?: boolean | VanityAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyticsLatest30Days"]>



  export type AnalyticsLatest30DaysSelectScalar = {
    id?: boolean
    Click?: boolean
    UniqueClick?: boolean
    Date?: boolean
    JoinedWithCode?: boolean
    VanityAnalyticsId?: boolean
  }

  export type AnalyticsLatest30DaysOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Click" | "UniqueClick" | "Date" | "JoinedWithCode" | "VanityAnalyticsId", ExtArgs["result"]["analyticsLatest30Days"]>
  export type AnalyticsLatest30DaysInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VanityAnalytics?: boolean | VanityAnalyticsDefaultArgs<ExtArgs>
  }

  export type $AnalyticsLatest30DaysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsLatest30Days"
    objects: {
      VanityAnalytics: Prisma.$VanityAnalyticsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Click: number | null
      UniqueClick: number | null
      Date: Date | null
      JoinedWithCode: number | null
      VanityAnalyticsId: string
    }, ExtArgs["result"]["analyticsLatest30Days"]>
    composites: {}
  }

  type AnalyticsLatest30DaysGetPayload<S extends boolean | null | undefined | AnalyticsLatest30DaysDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsLatest30DaysPayload, S>

  type AnalyticsLatest30DaysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticsLatest30DaysFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalyticsLatest30DaysCountAggregateInputType | true
    }

  export interface AnalyticsLatest30DaysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsLatest30Days'], meta: { name: 'AnalyticsLatest30Days' } }
    /**
     * Find zero or one AnalyticsLatest30Days that matches the filter.
     * @param {AnalyticsLatest30DaysFindUniqueArgs} args - Arguments to find a AnalyticsLatest30Days
     * @example
     * // Get one AnalyticsLatest30Days
     * const analyticsLatest30Days = await prisma.analyticsLatest30Days.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsLatest30DaysFindUniqueArgs>(args: SelectSubset<T, AnalyticsLatest30DaysFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsLatest30DaysClient<$Result.GetResult<Prisma.$AnalyticsLatest30DaysPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalyticsLatest30Days that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsLatest30DaysFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsLatest30Days
     * @example
     * // Get one AnalyticsLatest30Days
     * const analyticsLatest30Days = await prisma.analyticsLatest30Days.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsLatest30DaysFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsLatest30DaysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsLatest30DaysClient<$Result.GetResult<Prisma.$AnalyticsLatest30DaysPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsLatest30Days that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsLatest30DaysFindFirstArgs} args - Arguments to find a AnalyticsLatest30Days
     * @example
     * // Get one AnalyticsLatest30Days
     * const analyticsLatest30Days = await prisma.analyticsLatest30Days.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsLatest30DaysFindFirstArgs>(args?: SelectSubset<T, AnalyticsLatest30DaysFindFirstArgs<ExtArgs>>): Prisma__AnalyticsLatest30DaysClient<$Result.GetResult<Prisma.$AnalyticsLatest30DaysPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsLatest30Days that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsLatest30DaysFindFirstOrThrowArgs} args - Arguments to find a AnalyticsLatest30Days
     * @example
     * // Get one AnalyticsLatest30Days
     * const analyticsLatest30Days = await prisma.analyticsLatest30Days.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsLatest30DaysFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsLatest30DaysFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsLatest30DaysClient<$Result.GetResult<Prisma.$AnalyticsLatest30DaysPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalyticsLatest30Days that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsLatest30DaysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsLatest30Days
     * const analyticsLatest30Days = await prisma.analyticsLatest30Days.findMany()
     * 
     * // Get first 10 AnalyticsLatest30Days
     * const analyticsLatest30Days = await prisma.analyticsLatest30Days.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsLatest30DaysWithIdOnly = await prisma.analyticsLatest30Days.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsLatest30DaysFindManyArgs>(args?: SelectSubset<T, AnalyticsLatest30DaysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsLatest30DaysPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalyticsLatest30Days.
     * @param {AnalyticsLatest30DaysCreateArgs} args - Arguments to create a AnalyticsLatest30Days.
     * @example
     * // Create one AnalyticsLatest30Days
     * const AnalyticsLatest30Days = await prisma.analyticsLatest30Days.create({
     *   data: {
     *     // ... data to create a AnalyticsLatest30Days
     *   }
     * })
     * 
     */
    create<T extends AnalyticsLatest30DaysCreateArgs>(args: SelectSubset<T, AnalyticsLatest30DaysCreateArgs<ExtArgs>>): Prisma__AnalyticsLatest30DaysClient<$Result.GetResult<Prisma.$AnalyticsLatest30DaysPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalyticsLatest30Days.
     * @param {AnalyticsLatest30DaysCreateManyArgs} args - Arguments to create many AnalyticsLatest30Days.
     * @example
     * // Create many AnalyticsLatest30Days
     * const analyticsLatest30Days = await prisma.analyticsLatest30Days.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsLatest30DaysCreateManyArgs>(args?: SelectSubset<T, AnalyticsLatest30DaysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AnalyticsLatest30Days.
     * @param {AnalyticsLatest30DaysDeleteArgs} args - Arguments to delete one AnalyticsLatest30Days.
     * @example
     * // Delete one AnalyticsLatest30Days
     * const AnalyticsLatest30Days = await prisma.analyticsLatest30Days.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsLatest30Days
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsLatest30DaysDeleteArgs>(args: SelectSubset<T, AnalyticsLatest30DaysDeleteArgs<ExtArgs>>): Prisma__AnalyticsLatest30DaysClient<$Result.GetResult<Prisma.$AnalyticsLatest30DaysPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalyticsLatest30Days.
     * @param {AnalyticsLatest30DaysUpdateArgs} args - Arguments to update one AnalyticsLatest30Days.
     * @example
     * // Update one AnalyticsLatest30Days
     * const analyticsLatest30Days = await prisma.analyticsLatest30Days.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsLatest30DaysUpdateArgs>(args: SelectSubset<T, AnalyticsLatest30DaysUpdateArgs<ExtArgs>>): Prisma__AnalyticsLatest30DaysClient<$Result.GetResult<Prisma.$AnalyticsLatest30DaysPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalyticsLatest30Days.
     * @param {AnalyticsLatest30DaysDeleteManyArgs} args - Arguments to filter AnalyticsLatest30Days to delete.
     * @example
     * // Delete a few AnalyticsLatest30Days
     * const { count } = await prisma.analyticsLatest30Days.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsLatest30DaysDeleteManyArgs>(args?: SelectSubset<T, AnalyticsLatest30DaysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsLatest30Days.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsLatest30DaysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsLatest30Days
     * const analyticsLatest30Days = await prisma.analyticsLatest30Days.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsLatest30DaysUpdateManyArgs>(args: SelectSubset<T, AnalyticsLatest30DaysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnalyticsLatest30Days.
     * @param {AnalyticsLatest30DaysUpsertArgs} args - Arguments to update or create a AnalyticsLatest30Days.
     * @example
     * // Update or create a AnalyticsLatest30Days
     * const analyticsLatest30Days = await prisma.analyticsLatest30Days.upsert({
     *   create: {
     *     // ... data to create a AnalyticsLatest30Days
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsLatest30Days we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsLatest30DaysUpsertArgs>(args: SelectSubset<T, AnalyticsLatest30DaysUpsertArgs<ExtArgs>>): Prisma__AnalyticsLatest30DaysClient<$Result.GetResult<Prisma.$AnalyticsLatest30DaysPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalyticsLatest30Days that matches the filter.
     * @param {AnalyticsLatest30DaysFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const analyticsLatest30Days = await prisma.analyticsLatest30Days.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AnalyticsLatest30DaysFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AnalyticsLatest30Days.
     * @param {AnalyticsLatest30DaysAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const analyticsLatest30Days = await prisma.analyticsLatest30Days.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AnalyticsLatest30DaysAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AnalyticsLatest30Days.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsLatest30DaysCountArgs} args - Arguments to filter AnalyticsLatest30Days to count.
     * @example
     * // Count the number of AnalyticsLatest30Days
     * const count = await prisma.analyticsLatest30Days.count({
     *   where: {
     *     // ... the filter for the AnalyticsLatest30Days we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsLatest30DaysCountArgs>(
      args?: Subset<T, AnalyticsLatest30DaysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsLatest30DaysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsLatest30Days.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsLatest30DaysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsLatest30DaysAggregateArgs>(args: Subset<T, AnalyticsLatest30DaysAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsLatest30DaysAggregateType<T>>

    /**
     * Group by AnalyticsLatest30Days.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsLatest30DaysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsLatest30DaysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsLatest30DaysGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsLatest30DaysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsLatest30DaysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsLatest30DaysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsLatest30Days model
   */
  readonly fields: AnalyticsLatest30DaysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsLatest30Days.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsLatest30DaysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    VanityAnalytics<T extends VanityAnalyticsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VanityAnalyticsDefaultArgs<ExtArgs>>): Prisma__VanityAnalyticsClient<$Result.GetResult<Prisma.$VanityAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsLatest30Days model
   */
  interface AnalyticsLatest30DaysFieldRefs {
    readonly id: FieldRef<"AnalyticsLatest30Days", 'String'>
    readonly Click: FieldRef<"AnalyticsLatest30Days", 'Int'>
    readonly UniqueClick: FieldRef<"AnalyticsLatest30Days", 'Int'>
    readonly Date: FieldRef<"AnalyticsLatest30Days", 'DateTime'>
    readonly JoinedWithCode: FieldRef<"AnalyticsLatest30Days", 'Int'>
    readonly VanityAnalyticsId: FieldRef<"AnalyticsLatest30Days", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsLatest30Days findUnique
   */
  export type AnalyticsLatest30DaysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsLatest30Days
     */
    select?: AnalyticsLatest30DaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsLatest30Days
     */
    omit?: AnalyticsLatest30DaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsLatest30DaysInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsLatest30Days to fetch.
     */
    where: AnalyticsLatest30DaysWhereUniqueInput
  }

  /**
   * AnalyticsLatest30Days findUniqueOrThrow
   */
  export type AnalyticsLatest30DaysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsLatest30Days
     */
    select?: AnalyticsLatest30DaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsLatest30Days
     */
    omit?: AnalyticsLatest30DaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsLatest30DaysInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsLatest30Days to fetch.
     */
    where: AnalyticsLatest30DaysWhereUniqueInput
  }

  /**
   * AnalyticsLatest30Days findFirst
   */
  export type AnalyticsLatest30DaysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsLatest30Days
     */
    select?: AnalyticsLatest30DaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsLatest30Days
     */
    omit?: AnalyticsLatest30DaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsLatest30DaysInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsLatest30Days to fetch.
     */
    where?: AnalyticsLatest30DaysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsLatest30Days to fetch.
     */
    orderBy?: AnalyticsLatest30DaysOrderByWithRelationInput | AnalyticsLatest30DaysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsLatest30Days.
     */
    cursor?: AnalyticsLatest30DaysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsLatest30Days from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsLatest30Days.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsLatest30Days.
     */
    distinct?: AnalyticsLatest30DaysScalarFieldEnum | AnalyticsLatest30DaysScalarFieldEnum[]
  }

  /**
   * AnalyticsLatest30Days findFirstOrThrow
   */
  export type AnalyticsLatest30DaysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsLatest30Days
     */
    select?: AnalyticsLatest30DaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsLatest30Days
     */
    omit?: AnalyticsLatest30DaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsLatest30DaysInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsLatest30Days to fetch.
     */
    where?: AnalyticsLatest30DaysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsLatest30Days to fetch.
     */
    orderBy?: AnalyticsLatest30DaysOrderByWithRelationInput | AnalyticsLatest30DaysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsLatest30Days.
     */
    cursor?: AnalyticsLatest30DaysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsLatest30Days from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsLatest30Days.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsLatest30Days.
     */
    distinct?: AnalyticsLatest30DaysScalarFieldEnum | AnalyticsLatest30DaysScalarFieldEnum[]
  }

  /**
   * AnalyticsLatest30Days findMany
   */
  export type AnalyticsLatest30DaysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsLatest30Days
     */
    select?: AnalyticsLatest30DaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsLatest30Days
     */
    omit?: AnalyticsLatest30DaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsLatest30DaysInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsLatest30Days to fetch.
     */
    where?: AnalyticsLatest30DaysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsLatest30Days to fetch.
     */
    orderBy?: AnalyticsLatest30DaysOrderByWithRelationInput | AnalyticsLatest30DaysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsLatest30Days.
     */
    cursor?: AnalyticsLatest30DaysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsLatest30Days from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsLatest30Days.
     */
    skip?: number
    distinct?: AnalyticsLatest30DaysScalarFieldEnum | AnalyticsLatest30DaysScalarFieldEnum[]
  }

  /**
   * AnalyticsLatest30Days create
   */
  export type AnalyticsLatest30DaysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsLatest30Days
     */
    select?: AnalyticsLatest30DaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsLatest30Days
     */
    omit?: AnalyticsLatest30DaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsLatest30DaysInclude<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsLatest30Days.
     */
    data: XOR<AnalyticsLatest30DaysCreateInput, AnalyticsLatest30DaysUncheckedCreateInput>
  }

  /**
   * AnalyticsLatest30Days createMany
   */
  export type AnalyticsLatest30DaysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsLatest30Days.
     */
    data: AnalyticsLatest30DaysCreateManyInput | AnalyticsLatest30DaysCreateManyInput[]
  }

  /**
   * AnalyticsLatest30Days update
   */
  export type AnalyticsLatest30DaysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsLatest30Days
     */
    select?: AnalyticsLatest30DaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsLatest30Days
     */
    omit?: AnalyticsLatest30DaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsLatest30DaysInclude<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsLatest30Days.
     */
    data: XOR<AnalyticsLatest30DaysUpdateInput, AnalyticsLatest30DaysUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsLatest30Days to update.
     */
    where: AnalyticsLatest30DaysWhereUniqueInput
  }

  /**
   * AnalyticsLatest30Days updateMany
   */
  export type AnalyticsLatest30DaysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsLatest30Days.
     */
    data: XOR<AnalyticsLatest30DaysUpdateManyMutationInput, AnalyticsLatest30DaysUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsLatest30Days to update
     */
    where?: AnalyticsLatest30DaysWhereInput
    /**
     * Limit how many AnalyticsLatest30Days to update.
     */
    limit?: number
  }

  /**
   * AnalyticsLatest30Days upsert
   */
  export type AnalyticsLatest30DaysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsLatest30Days
     */
    select?: AnalyticsLatest30DaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsLatest30Days
     */
    omit?: AnalyticsLatest30DaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsLatest30DaysInclude<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsLatest30Days to update in case it exists.
     */
    where: AnalyticsLatest30DaysWhereUniqueInput
    /**
     * In case the AnalyticsLatest30Days found by the `where` argument doesn't exist, create a new AnalyticsLatest30Days with this data.
     */
    create: XOR<AnalyticsLatest30DaysCreateInput, AnalyticsLatest30DaysUncheckedCreateInput>
    /**
     * In case the AnalyticsLatest30Days was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsLatest30DaysUpdateInput, AnalyticsLatest30DaysUncheckedUpdateInput>
  }

  /**
   * AnalyticsLatest30Days delete
   */
  export type AnalyticsLatest30DaysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsLatest30Days
     */
    select?: AnalyticsLatest30DaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsLatest30Days
     */
    omit?: AnalyticsLatest30DaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsLatest30DaysInclude<ExtArgs> | null
    /**
     * Filter which AnalyticsLatest30Days to delete.
     */
    where: AnalyticsLatest30DaysWhereUniqueInput
  }

  /**
   * AnalyticsLatest30Days deleteMany
   */
  export type AnalyticsLatest30DaysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsLatest30Days to delete
     */
    where?: AnalyticsLatest30DaysWhereInput
    /**
     * Limit how many AnalyticsLatest30Days to delete.
     */
    limit?: number
  }

  /**
   * AnalyticsLatest30Days findRaw
   */
  export type AnalyticsLatest30DaysFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AnalyticsLatest30Days aggregateRaw
   */
  export type AnalyticsLatest30DaysAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AnalyticsLatest30Days without action
   */
  export type AnalyticsLatest30DaysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsLatest30Days
     */
    select?: AnalyticsLatest30DaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsLatest30Days
     */
    omit?: AnalyticsLatest30DaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsLatest30DaysInclude<ExtArgs> | null
  }


  /**
   * Model DisBotUserNotifications
   */

  export type AggregateDisBotUserNotifications = {
    _count: DisBotUserNotificationsCountAggregateOutputType | null
    _min: DisBotUserNotificationsMinAggregateOutputType | null
    _max: DisBotUserNotificationsMaxAggregateOutputType | null
  }

  export type DisBotUserNotificationsMinAggregateOutputType = {
    id: string | null
    Updates: boolean | null
    Status: boolean | null
    Announcements: boolean | null
    Customer: boolean | null
    UserId: string | null
  }

  export type DisBotUserNotificationsMaxAggregateOutputType = {
    id: string | null
    Updates: boolean | null
    Status: boolean | null
    Announcements: boolean | null
    Customer: boolean | null
    UserId: string | null
  }

  export type DisBotUserNotificationsCountAggregateOutputType = {
    id: number
    Updates: number
    Status: number
    Announcements: number
    Customer: number
    UserId: number
    _all: number
  }


  export type DisBotUserNotificationsMinAggregateInputType = {
    id?: true
    Updates?: true
    Status?: true
    Announcements?: true
    Customer?: true
    UserId?: true
  }

  export type DisBotUserNotificationsMaxAggregateInputType = {
    id?: true
    Updates?: true
    Status?: true
    Announcements?: true
    Customer?: true
    UserId?: true
  }

  export type DisBotUserNotificationsCountAggregateInputType = {
    id?: true
    Updates?: true
    Status?: true
    Announcements?: true
    Customer?: true
    UserId?: true
    _all?: true
  }

  export type DisBotUserNotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisBotUserNotifications to aggregate.
     */
    where?: DisBotUserNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisBotUserNotifications to fetch.
     */
    orderBy?: DisBotUserNotificationsOrderByWithRelationInput | DisBotUserNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisBotUserNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisBotUserNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisBotUserNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DisBotUserNotifications
    **/
    _count?: true | DisBotUserNotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisBotUserNotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisBotUserNotificationsMaxAggregateInputType
  }

  export type GetDisBotUserNotificationsAggregateType<T extends DisBotUserNotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateDisBotUserNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisBotUserNotifications[P]>
      : GetScalarType<T[P], AggregateDisBotUserNotifications[P]>
  }




  export type DisBotUserNotificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisBotUserNotificationsWhereInput
    orderBy?: DisBotUserNotificationsOrderByWithAggregationInput | DisBotUserNotificationsOrderByWithAggregationInput[]
    by: DisBotUserNotificationsScalarFieldEnum[] | DisBotUserNotificationsScalarFieldEnum
    having?: DisBotUserNotificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisBotUserNotificationsCountAggregateInputType | true
    _min?: DisBotUserNotificationsMinAggregateInputType
    _max?: DisBotUserNotificationsMaxAggregateInputType
  }

  export type DisBotUserNotificationsGroupByOutputType = {
    id: string
    Updates: boolean
    Status: boolean
    Announcements: boolean
    Customer: boolean
    UserId: string
    _count: DisBotUserNotificationsCountAggregateOutputType | null
    _min: DisBotUserNotificationsMinAggregateOutputType | null
    _max: DisBotUserNotificationsMaxAggregateOutputType | null
  }

  type GetDisBotUserNotificationsGroupByPayload<T extends DisBotUserNotificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisBotUserNotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisBotUserNotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisBotUserNotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], DisBotUserNotificationsGroupByOutputType[P]>
        }
      >
    >


  export type DisBotUserNotificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Updates?: boolean
    Status?: boolean
    Announcements?: boolean
    Customer?: boolean
    UserId?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disBotUserNotifications"]>



  export type DisBotUserNotificationsSelectScalar = {
    id?: boolean
    Updates?: boolean
    Status?: boolean
    Announcements?: boolean
    Customer?: boolean
    UserId?: boolean
  }

  export type DisBotUserNotificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Updates" | "Status" | "Announcements" | "Customer" | "UserId", ExtArgs["result"]["disBotUserNotifications"]>
  export type DisBotUserNotificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $DisBotUserNotificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DisBotUserNotifications"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Updates: boolean
      Status: boolean
      Announcements: boolean
      Customer: boolean
      UserId: string
    }, ExtArgs["result"]["disBotUserNotifications"]>
    composites: {}
  }

  type DisBotUserNotificationsGetPayload<S extends boolean | null | undefined | DisBotUserNotificationsDefaultArgs> = $Result.GetResult<Prisma.$DisBotUserNotificationsPayload, S>

  type DisBotUserNotificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DisBotUserNotificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DisBotUserNotificationsCountAggregateInputType | true
    }

  export interface DisBotUserNotificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DisBotUserNotifications'], meta: { name: 'DisBotUserNotifications' } }
    /**
     * Find zero or one DisBotUserNotifications that matches the filter.
     * @param {DisBotUserNotificationsFindUniqueArgs} args - Arguments to find a DisBotUserNotifications
     * @example
     * // Get one DisBotUserNotifications
     * const disBotUserNotifications = await prisma.disBotUserNotifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisBotUserNotificationsFindUniqueArgs>(args: SelectSubset<T, DisBotUserNotificationsFindUniqueArgs<ExtArgs>>): Prisma__DisBotUserNotificationsClient<$Result.GetResult<Prisma.$DisBotUserNotificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DisBotUserNotifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DisBotUserNotificationsFindUniqueOrThrowArgs} args - Arguments to find a DisBotUserNotifications
     * @example
     * // Get one DisBotUserNotifications
     * const disBotUserNotifications = await prisma.disBotUserNotifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisBotUserNotificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, DisBotUserNotificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisBotUserNotificationsClient<$Result.GetResult<Prisma.$DisBotUserNotificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisBotUserNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisBotUserNotificationsFindFirstArgs} args - Arguments to find a DisBotUserNotifications
     * @example
     * // Get one DisBotUserNotifications
     * const disBotUserNotifications = await prisma.disBotUserNotifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisBotUserNotificationsFindFirstArgs>(args?: SelectSubset<T, DisBotUserNotificationsFindFirstArgs<ExtArgs>>): Prisma__DisBotUserNotificationsClient<$Result.GetResult<Prisma.$DisBotUserNotificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisBotUserNotifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisBotUserNotificationsFindFirstOrThrowArgs} args - Arguments to find a DisBotUserNotifications
     * @example
     * // Get one DisBotUserNotifications
     * const disBotUserNotifications = await prisma.disBotUserNotifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisBotUserNotificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, DisBotUserNotificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisBotUserNotificationsClient<$Result.GetResult<Prisma.$DisBotUserNotificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DisBotUserNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisBotUserNotificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DisBotUserNotifications
     * const disBotUserNotifications = await prisma.disBotUserNotifications.findMany()
     * 
     * // Get first 10 DisBotUserNotifications
     * const disBotUserNotifications = await prisma.disBotUserNotifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disBotUserNotificationsWithIdOnly = await prisma.disBotUserNotifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DisBotUserNotificationsFindManyArgs>(args?: SelectSubset<T, DisBotUserNotificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisBotUserNotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DisBotUserNotifications.
     * @param {DisBotUserNotificationsCreateArgs} args - Arguments to create a DisBotUserNotifications.
     * @example
     * // Create one DisBotUserNotifications
     * const DisBotUserNotifications = await prisma.disBotUserNotifications.create({
     *   data: {
     *     // ... data to create a DisBotUserNotifications
     *   }
     * })
     * 
     */
    create<T extends DisBotUserNotificationsCreateArgs>(args: SelectSubset<T, DisBotUserNotificationsCreateArgs<ExtArgs>>): Prisma__DisBotUserNotificationsClient<$Result.GetResult<Prisma.$DisBotUserNotificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DisBotUserNotifications.
     * @param {DisBotUserNotificationsCreateManyArgs} args - Arguments to create many DisBotUserNotifications.
     * @example
     * // Create many DisBotUserNotifications
     * const disBotUserNotifications = await prisma.disBotUserNotifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisBotUserNotificationsCreateManyArgs>(args?: SelectSubset<T, DisBotUserNotificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DisBotUserNotifications.
     * @param {DisBotUserNotificationsDeleteArgs} args - Arguments to delete one DisBotUserNotifications.
     * @example
     * // Delete one DisBotUserNotifications
     * const DisBotUserNotifications = await prisma.disBotUserNotifications.delete({
     *   where: {
     *     // ... filter to delete one DisBotUserNotifications
     *   }
     * })
     * 
     */
    delete<T extends DisBotUserNotificationsDeleteArgs>(args: SelectSubset<T, DisBotUserNotificationsDeleteArgs<ExtArgs>>): Prisma__DisBotUserNotificationsClient<$Result.GetResult<Prisma.$DisBotUserNotificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DisBotUserNotifications.
     * @param {DisBotUserNotificationsUpdateArgs} args - Arguments to update one DisBotUserNotifications.
     * @example
     * // Update one DisBotUserNotifications
     * const disBotUserNotifications = await prisma.disBotUserNotifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisBotUserNotificationsUpdateArgs>(args: SelectSubset<T, DisBotUserNotificationsUpdateArgs<ExtArgs>>): Prisma__DisBotUserNotificationsClient<$Result.GetResult<Prisma.$DisBotUserNotificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DisBotUserNotifications.
     * @param {DisBotUserNotificationsDeleteManyArgs} args - Arguments to filter DisBotUserNotifications to delete.
     * @example
     * // Delete a few DisBotUserNotifications
     * const { count } = await prisma.disBotUserNotifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisBotUserNotificationsDeleteManyArgs>(args?: SelectSubset<T, DisBotUserNotificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisBotUserNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisBotUserNotificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DisBotUserNotifications
     * const disBotUserNotifications = await prisma.disBotUserNotifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisBotUserNotificationsUpdateManyArgs>(args: SelectSubset<T, DisBotUserNotificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DisBotUserNotifications.
     * @param {DisBotUserNotificationsUpsertArgs} args - Arguments to update or create a DisBotUserNotifications.
     * @example
     * // Update or create a DisBotUserNotifications
     * const disBotUserNotifications = await prisma.disBotUserNotifications.upsert({
     *   create: {
     *     // ... data to create a DisBotUserNotifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DisBotUserNotifications we want to update
     *   }
     * })
     */
    upsert<T extends DisBotUserNotificationsUpsertArgs>(args: SelectSubset<T, DisBotUserNotificationsUpsertArgs<ExtArgs>>): Prisma__DisBotUserNotificationsClient<$Result.GetResult<Prisma.$DisBotUserNotificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DisBotUserNotifications that matches the filter.
     * @param {DisBotUserNotificationsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const disBotUserNotifications = await prisma.disBotUserNotifications.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DisBotUserNotificationsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DisBotUserNotifications.
     * @param {DisBotUserNotificationsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const disBotUserNotifications = await prisma.disBotUserNotifications.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DisBotUserNotificationsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DisBotUserNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisBotUserNotificationsCountArgs} args - Arguments to filter DisBotUserNotifications to count.
     * @example
     * // Count the number of DisBotUserNotifications
     * const count = await prisma.disBotUserNotifications.count({
     *   where: {
     *     // ... the filter for the DisBotUserNotifications we want to count
     *   }
     * })
    **/
    count<T extends DisBotUserNotificationsCountArgs>(
      args?: Subset<T, DisBotUserNotificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisBotUserNotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DisBotUserNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisBotUserNotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisBotUserNotificationsAggregateArgs>(args: Subset<T, DisBotUserNotificationsAggregateArgs>): Prisma.PrismaPromise<GetDisBotUserNotificationsAggregateType<T>>

    /**
     * Group by DisBotUserNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisBotUserNotificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisBotUserNotificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisBotUserNotificationsGroupByArgs['orderBy'] }
        : { orderBy?: DisBotUserNotificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisBotUserNotificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisBotUserNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DisBotUserNotifications model
   */
  readonly fields: DisBotUserNotificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DisBotUserNotifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisBotUserNotificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DisBotUserNotifications model
   */
  interface DisBotUserNotificationsFieldRefs {
    readonly id: FieldRef<"DisBotUserNotifications", 'String'>
    readonly Updates: FieldRef<"DisBotUserNotifications", 'Boolean'>
    readonly Status: FieldRef<"DisBotUserNotifications", 'Boolean'>
    readonly Announcements: FieldRef<"DisBotUserNotifications", 'Boolean'>
    readonly Customer: FieldRef<"DisBotUserNotifications", 'Boolean'>
    readonly UserId: FieldRef<"DisBotUserNotifications", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DisBotUserNotifications findUnique
   */
  export type DisBotUserNotificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisBotUserNotifications
     */
    select?: DisBotUserNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisBotUserNotifications
     */
    omit?: DisBotUserNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisBotUserNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which DisBotUserNotifications to fetch.
     */
    where: DisBotUserNotificationsWhereUniqueInput
  }

  /**
   * DisBotUserNotifications findUniqueOrThrow
   */
  export type DisBotUserNotificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisBotUserNotifications
     */
    select?: DisBotUserNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisBotUserNotifications
     */
    omit?: DisBotUserNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisBotUserNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which DisBotUserNotifications to fetch.
     */
    where: DisBotUserNotificationsWhereUniqueInput
  }

  /**
   * DisBotUserNotifications findFirst
   */
  export type DisBotUserNotificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisBotUserNotifications
     */
    select?: DisBotUserNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisBotUserNotifications
     */
    omit?: DisBotUserNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisBotUserNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which DisBotUserNotifications to fetch.
     */
    where?: DisBotUserNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisBotUserNotifications to fetch.
     */
    orderBy?: DisBotUserNotificationsOrderByWithRelationInput | DisBotUserNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisBotUserNotifications.
     */
    cursor?: DisBotUserNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisBotUserNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisBotUserNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisBotUserNotifications.
     */
    distinct?: DisBotUserNotificationsScalarFieldEnum | DisBotUserNotificationsScalarFieldEnum[]
  }

  /**
   * DisBotUserNotifications findFirstOrThrow
   */
  export type DisBotUserNotificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisBotUserNotifications
     */
    select?: DisBotUserNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisBotUserNotifications
     */
    omit?: DisBotUserNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisBotUserNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which DisBotUserNotifications to fetch.
     */
    where?: DisBotUserNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisBotUserNotifications to fetch.
     */
    orderBy?: DisBotUserNotificationsOrderByWithRelationInput | DisBotUserNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisBotUserNotifications.
     */
    cursor?: DisBotUserNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisBotUserNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisBotUserNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisBotUserNotifications.
     */
    distinct?: DisBotUserNotificationsScalarFieldEnum | DisBotUserNotificationsScalarFieldEnum[]
  }

  /**
   * DisBotUserNotifications findMany
   */
  export type DisBotUserNotificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisBotUserNotifications
     */
    select?: DisBotUserNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisBotUserNotifications
     */
    omit?: DisBotUserNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisBotUserNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which DisBotUserNotifications to fetch.
     */
    where?: DisBotUserNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisBotUserNotifications to fetch.
     */
    orderBy?: DisBotUserNotificationsOrderByWithRelationInput | DisBotUserNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DisBotUserNotifications.
     */
    cursor?: DisBotUserNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisBotUserNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisBotUserNotifications.
     */
    skip?: number
    distinct?: DisBotUserNotificationsScalarFieldEnum | DisBotUserNotificationsScalarFieldEnum[]
  }

  /**
   * DisBotUserNotifications create
   */
  export type DisBotUserNotificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisBotUserNotifications
     */
    select?: DisBotUserNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisBotUserNotifications
     */
    omit?: DisBotUserNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisBotUserNotificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a DisBotUserNotifications.
     */
    data: XOR<DisBotUserNotificationsCreateInput, DisBotUserNotificationsUncheckedCreateInput>
  }

  /**
   * DisBotUserNotifications createMany
   */
  export type DisBotUserNotificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DisBotUserNotifications.
     */
    data: DisBotUserNotificationsCreateManyInput | DisBotUserNotificationsCreateManyInput[]
  }

  /**
   * DisBotUserNotifications update
   */
  export type DisBotUserNotificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisBotUserNotifications
     */
    select?: DisBotUserNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisBotUserNotifications
     */
    omit?: DisBotUserNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisBotUserNotificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a DisBotUserNotifications.
     */
    data: XOR<DisBotUserNotificationsUpdateInput, DisBotUserNotificationsUncheckedUpdateInput>
    /**
     * Choose, which DisBotUserNotifications to update.
     */
    where: DisBotUserNotificationsWhereUniqueInput
  }

  /**
   * DisBotUserNotifications updateMany
   */
  export type DisBotUserNotificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DisBotUserNotifications.
     */
    data: XOR<DisBotUserNotificationsUpdateManyMutationInput, DisBotUserNotificationsUncheckedUpdateManyInput>
    /**
     * Filter which DisBotUserNotifications to update
     */
    where?: DisBotUserNotificationsWhereInput
    /**
     * Limit how many DisBotUserNotifications to update.
     */
    limit?: number
  }

  /**
   * DisBotUserNotifications upsert
   */
  export type DisBotUserNotificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisBotUserNotifications
     */
    select?: DisBotUserNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisBotUserNotifications
     */
    omit?: DisBotUserNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisBotUserNotificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the DisBotUserNotifications to update in case it exists.
     */
    where: DisBotUserNotificationsWhereUniqueInput
    /**
     * In case the DisBotUserNotifications found by the `where` argument doesn't exist, create a new DisBotUserNotifications with this data.
     */
    create: XOR<DisBotUserNotificationsCreateInput, DisBotUserNotificationsUncheckedCreateInput>
    /**
     * In case the DisBotUserNotifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisBotUserNotificationsUpdateInput, DisBotUserNotificationsUncheckedUpdateInput>
  }

  /**
   * DisBotUserNotifications delete
   */
  export type DisBotUserNotificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisBotUserNotifications
     */
    select?: DisBotUserNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisBotUserNotifications
     */
    omit?: DisBotUserNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisBotUserNotificationsInclude<ExtArgs> | null
    /**
     * Filter which DisBotUserNotifications to delete.
     */
    where: DisBotUserNotificationsWhereUniqueInput
  }

  /**
   * DisBotUserNotifications deleteMany
   */
  export type DisBotUserNotificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisBotUserNotifications to delete
     */
    where?: DisBotUserNotificationsWhereInput
    /**
     * Limit how many DisBotUserNotifications to delete.
     */
    limit?: number
  }

  /**
   * DisBotUserNotifications findRaw
   */
  export type DisBotUserNotificationsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DisBotUserNotifications aggregateRaw
   */
  export type DisBotUserNotificationsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DisBotUserNotifications without action
   */
  export type DisBotUserNotificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisBotUserNotifications
     */
    select?: DisBotUserNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisBotUserNotifications
     */
    omit?: DisBotUserNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisBotUserNotificationsInclude<ExtArgs> | null
  }


  /**
   * Model DisBot
   */

  export type AggregateDisBot = {
    _count: DisBotCountAggregateOutputType | null
    _min: DisBotMinAggregateOutputType | null
    _max: DisBotMaxAggregateOutputType | null
  }

  export type DisBotMinAggregateOutputType = {
    id: string | null
    SpotifyToken: string | null
    TwitchToken: string | null
    Version: string | null
    GetConf: string | null
  }

  export type DisBotMaxAggregateOutputType = {
    id: string | null
    SpotifyToken: string | null
    TwitchToken: string | null
    Version: string | null
    GetConf: string | null
  }

  export type DisBotCountAggregateOutputType = {
    id: number
    SpotifyToken: number
    TwitchToken: number
    Version: number
    GetConf: number
    _all: number
  }


  export type DisBotMinAggregateInputType = {
    id?: true
    SpotifyToken?: true
    TwitchToken?: true
    Version?: true
    GetConf?: true
  }

  export type DisBotMaxAggregateInputType = {
    id?: true
    SpotifyToken?: true
    TwitchToken?: true
    Version?: true
    GetConf?: true
  }

  export type DisBotCountAggregateInputType = {
    id?: true
    SpotifyToken?: true
    TwitchToken?: true
    Version?: true
    GetConf?: true
    _all?: true
  }

  export type DisBotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisBot to aggregate.
     */
    where?: DisBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisBots to fetch.
     */
    orderBy?: DisBotOrderByWithRelationInput | DisBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DisBots
    **/
    _count?: true | DisBotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisBotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisBotMaxAggregateInputType
  }

  export type GetDisBotAggregateType<T extends DisBotAggregateArgs> = {
        [P in keyof T & keyof AggregateDisBot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisBot[P]>
      : GetScalarType<T[P], AggregateDisBot[P]>
  }




  export type DisBotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisBotWhereInput
    orderBy?: DisBotOrderByWithAggregationInput | DisBotOrderByWithAggregationInput[]
    by: DisBotScalarFieldEnum[] | DisBotScalarFieldEnum
    having?: DisBotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisBotCountAggregateInputType | true
    _min?: DisBotMinAggregateInputType
    _max?: DisBotMaxAggregateInputType
  }

  export type DisBotGroupByOutputType = {
    id: string
    SpotifyToken: string
    TwitchToken: string
    Version: string
    GetConf: string
    _count: DisBotCountAggregateOutputType | null
    _min: DisBotMinAggregateOutputType | null
    _max: DisBotMaxAggregateOutputType | null
  }

  type GetDisBotGroupByPayload<T extends DisBotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisBotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisBotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisBotGroupByOutputType[P]>
            : GetScalarType<T[P], DisBotGroupByOutputType[P]>
        }
      >
    >


  export type DisBotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Logs?: boolean | DisbotsLogsDefaultArgs<ExtArgs>
    SpotifyToken?: boolean
    TwitchToken?: boolean
    Version?: boolean
    GetConf?: boolean
  }, ExtArgs["result"]["disBot"]>



  export type DisBotSelectScalar = {
    id?: boolean
    SpotifyToken?: boolean
    TwitchToken?: boolean
    Version?: boolean
    GetConf?: boolean
  }

  export type DisBotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Logs" | "SpotifyToken" | "TwitchToken" | "Version" | "GetConf", ExtArgs["result"]["disBot"]>
  export type DisBotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DisBotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DisBot"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      SpotifyToken: string
      TwitchToken: string
      Version: string
      GetConf: string
    }, ExtArgs["result"]["disBot"]>
    composites: {
      Logs: Prisma.$DisbotsLogsPayload[]
    }
  }

  type DisBotGetPayload<S extends boolean | null | undefined | DisBotDefaultArgs> = $Result.GetResult<Prisma.$DisBotPayload, S>

  type DisBotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DisBotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DisBotCountAggregateInputType | true
    }

  export interface DisBotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DisBot'], meta: { name: 'DisBot' } }
    /**
     * Find zero or one DisBot that matches the filter.
     * @param {DisBotFindUniqueArgs} args - Arguments to find a DisBot
     * @example
     * // Get one DisBot
     * const disBot = await prisma.disBot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisBotFindUniqueArgs>(args: SelectSubset<T, DisBotFindUniqueArgs<ExtArgs>>): Prisma__DisBotClient<$Result.GetResult<Prisma.$DisBotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DisBot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DisBotFindUniqueOrThrowArgs} args - Arguments to find a DisBot
     * @example
     * // Get one DisBot
     * const disBot = await prisma.disBot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisBotFindUniqueOrThrowArgs>(args: SelectSubset<T, DisBotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisBotClient<$Result.GetResult<Prisma.$DisBotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisBot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisBotFindFirstArgs} args - Arguments to find a DisBot
     * @example
     * // Get one DisBot
     * const disBot = await prisma.disBot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisBotFindFirstArgs>(args?: SelectSubset<T, DisBotFindFirstArgs<ExtArgs>>): Prisma__DisBotClient<$Result.GetResult<Prisma.$DisBotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisBot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisBotFindFirstOrThrowArgs} args - Arguments to find a DisBot
     * @example
     * // Get one DisBot
     * const disBot = await prisma.disBot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisBotFindFirstOrThrowArgs>(args?: SelectSubset<T, DisBotFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisBotClient<$Result.GetResult<Prisma.$DisBotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DisBots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisBotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DisBots
     * const disBots = await prisma.disBot.findMany()
     * 
     * // Get first 10 DisBots
     * const disBots = await prisma.disBot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disBotWithIdOnly = await prisma.disBot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DisBotFindManyArgs>(args?: SelectSubset<T, DisBotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisBotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DisBot.
     * @param {DisBotCreateArgs} args - Arguments to create a DisBot.
     * @example
     * // Create one DisBot
     * const DisBot = await prisma.disBot.create({
     *   data: {
     *     // ... data to create a DisBot
     *   }
     * })
     * 
     */
    create<T extends DisBotCreateArgs>(args: SelectSubset<T, DisBotCreateArgs<ExtArgs>>): Prisma__DisBotClient<$Result.GetResult<Prisma.$DisBotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DisBots.
     * @param {DisBotCreateManyArgs} args - Arguments to create many DisBots.
     * @example
     * // Create many DisBots
     * const disBot = await prisma.disBot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisBotCreateManyArgs>(args?: SelectSubset<T, DisBotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DisBot.
     * @param {DisBotDeleteArgs} args - Arguments to delete one DisBot.
     * @example
     * // Delete one DisBot
     * const DisBot = await prisma.disBot.delete({
     *   where: {
     *     // ... filter to delete one DisBot
     *   }
     * })
     * 
     */
    delete<T extends DisBotDeleteArgs>(args: SelectSubset<T, DisBotDeleteArgs<ExtArgs>>): Prisma__DisBotClient<$Result.GetResult<Prisma.$DisBotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DisBot.
     * @param {DisBotUpdateArgs} args - Arguments to update one DisBot.
     * @example
     * // Update one DisBot
     * const disBot = await prisma.disBot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisBotUpdateArgs>(args: SelectSubset<T, DisBotUpdateArgs<ExtArgs>>): Prisma__DisBotClient<$Result.GetResult<Prisma.$DisBotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DisBots.
     * @param {DisBotDeleteManyArgs} args - Arguments to filter DisBots to delete.
     * @example
     * // Delete a few DisBots
     * const { count } = await prisma.disBot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisBotDeleteManyArgs>(args?: SelectSubset<T, DisBotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisBots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisBotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DisBots
     * const disBot = await prisma.disBot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisBotUpdateManyArgs>(args: SelectSubset<T, DisBotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DisBot.
     * @param {DisBotUpsertArgs} args - Arguments to update or create a DisBot.
     * @example
     * // Update or create a DisBot
     * const disBot = await prisma.disBot.upsert({
     *   create: {
     *     // ... data to create a DisBot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DisBot we want to update
     *   }
     * })
     */
    upsert<T extends DisBotUpsertArgs>(args: SelectSubset<T, DisBotUpsertArgs<ExtArgs>>): Prisma__DisBotClient<$Result.GetResult<Prisma.$DisBotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DisBots that matches the filter.
     * @param {DisBotFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const disBot = await prisma.disBot.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DisBotFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DisBot.
     * @param {DisBotAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const disBot = await prisma.disBot.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DisBotAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DisBots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisBotCountArgs} args - Arguments to filter DisBots to count.
     * @example
     * // Count the number of DisBots
     * const count = await prisma.disBot.count({
     *   where: {
     *     // ... the filter for the DisBots we want to count
     *   }
     * })
    **/
    count<T extends DisBotCountArgs>(
      args?: Subset<T, DisBotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisBotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DisBot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisBotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisBotAggregateArgs>(args: Subset<T, DisBotAggregateArgs>): Prisma.PrismaPromise<GetDisBotAggregateType<T>>

    /**
     * Group by DisBot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisBotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisBotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisBotGroupByArgs['orderBy'] }
        : { orderBy?: DisBotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisBotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisBotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DisBot model
   */
  readonly fields: DisBotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DisBot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisBotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DisBot model
   */
  interface DisBotFieldRefs {
    readonly id: FieldRef<"DisBot", 'String'>
    readonly SpotifyToken: FieldRef<"DisBot", 'String'>
    readonly TwitchToken: FieldRef<"DisBot", 'String'>
    readonly Version: FieldRef<"DisBot", 'String'>
    readonly GetConf: FieldRef<"DisBot", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DisBot findUnique
   */
  export type DisBotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisBot
     */
    select?: DisBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisBot
     */
    omit?: DisBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisBotInclude<ExtArgs> | null
    /**
     * Filter, which DisBot to fetch.
     */
    where: DisBotWhereUniqueInput
  }

  /**
   * DisBot findUniqueOrThrow
   */
  export type DisBotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisBot
     */
    select?: DisBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisBot
     */
    omit?: DisBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisBotInclude<ExtArgs> | null
    /**
     * Filter, which DisBot to fetch.
     */
    where: DisBotWhereUniqueInput
  }

  /**
   * DisBot findFirst
   */
  export type DisBotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisBot
     */
    select?: DisBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisBot
     */
    omit?: DisBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisBotInclude<ExtArgs> | null
    /**
     * Filter, which DisBot to fetch.
     */
    where?: DisBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisBots to fetch.
     */
    orderBy?: DisBotOrderByWithRelationInput | DisBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisBots.
     */
    cursor?: DisBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisBots.
     */
    distinct?: DisBotScalarFieldEnum | DisBotScalarFieldEnum[]
  }

  /**
   * DisBot findFirstOrThrow
   */
  export type DisBotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisBot
     */
    select?: DisBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisBot
     */
    omit?: DisBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisBotInclude<ExtArgs> | null
    /**
     * Filter, which DisBot to fetch.
     */
    where?: DisBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisBots to fetch.
     */
    orderBy?: DisBotOrderByWithRelationInput | DisBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisBots.
     */
    cursor?: DisBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisBots.
     */
    distinct?: DisBotScalarFieldEnum | DisBotScalarFieldEnum[]
  }

  /**
   * DisBot findMany
   */
  export type DisBotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisBot
     */
    select?: DisBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisBot
     */
    omit?: DisBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisBotInclude<ExtArgs> | null
    /**
     * Filter, which DisBots to fetch.
     */
    where?: DisBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisBots to fetch.
     */
    orderBy?: DisBotOrderByWithRelationInput | DisBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DisBots.
     */
    cursor?: DisBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisBots.
     */
    skip?: number
    distinct?: DisBotScalarFieldEnum | DisBotScalarFieldEnum[]
  }

  /**
   * DisBot create
   */
  export type DisBotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisBot
     */
    select?: DisBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisBot
     */
    omit?: DisBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisBotInclude<ExtArgs> | null
    /**
     * The data needed to create a DisBot.
     */
    data: XOR<DisBotCreateInput, DisBotUncheckedCreateInput>
  }

  /**
   * DisBot createMany
   */
  export type DisBotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DisBots.
     */
    data: DisBotCreateManyInput | DisBotCreateManyInput[]
  }

  /**
   * DisBot update
   */
  export type DisBotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisBot
     */
    select?: DisBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisBot
     */
    omit?: DisBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisBotInclude<ExtArgs> | null
    /**
     * The data needed to update a DisBot.
     */
    data: XOR<DisBotUpdateInput, DisBotUncheckedUpdateInput>
    /**
     * Choose, which DisBot to update.
     */
    where: DisBotWhereUniqueInput
  }

  /**
   * DisBot updateMany
   */
  export type DisBotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DisBots.
     */
    data: XOR<DisBotUpdateManyMutationInput, DisBotUncheckedUpdateManyInput>
    /**
     * Filter which DisBots to update
     */
    where?: DisBotWhereInput
    /**
     * Limit how many DisBots to update.
     */
    limit?: number
  }

  /**
   * DisBot upsert
   */
  export type DisBotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisBot
     */
    select?: DisBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisBot
     */
    omit?: DisBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisBotInclude<ExtArgs> | null
    /**
     * The filter to search for the DisBot to update in case it exists.
     */
    where: DisBotWhereUniqueInput
    /**
     * In case the DisBot found by the `where` argument doesn't exist, create a new DisBot with this data.
     */
    create: XOR<DisBotCreateInput, DisBotUncheckedCreateInput>
    /**
     * In case the DisBot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisBotUpdateInput, DisBotUncheckedUpdateInput>
  }

  /**
   * DisBot delete
   */
  export type DisBotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisBot
     */
    select?: DisBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisBot
     */
    omit?: DisBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisBotInclude<ExtArgs> | null
    /**
     * Filter which DisBot to delete.
     */
    where: DisBotWhereUniqueInput
  }

  /**
   * DisBot deleteMany
   */
  export type DisBotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisBots to delete
     */
    where?: DisBotWhereInput
    /**
     * Limit how many DisBots to delete.
     */
    limit?: number
  }

  /**
   * DisBot findRaw
   */
  export type DisBotFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DisBot aggregateRaw
   */
  export type DisBotAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DisBot without action
   */
  export type DisBotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisBot
     */
    select?: DisBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisBot
     */
    omit?: DisBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisBotInclude<ExtArgs> | null
  }


  /**
   * Model ImageApis
   */

  export type AggregateImageApis = {
    _count: ImageApisCountAggregateOutputType | null
    _min: ImageApisMinAggregateOutputType | null
    _max: ImageApisMaxAggregateOutputType | null
  }

  export type ImageApisMinAggregateOutputType = {
    id: string | null
    UUID: string | null
    ImageBase64: string | null
    URL: string | null
  }

  export type ImageApisMaxAggregateOutputType = {
    id: string | null
    UUID: string | null
    ImageBase64: string | null
    URL: string | null
  }

  export type ImageApisCountAggregateOutputType = {
    id: number
    UUID: number
    ImageBase64: number
    URL: number
    _all: number
  }


  export type ImageApisMinAggregateInputType = {
    id?: true
    UUID?: true
    ImageBase64?: true
    URL?: true
  }

  export type ImageApisMaxAggregateInputType = {
    id?: true
    UUID?: true
    ImageBase64?: true
    URL?: true
  }

  export type ImageApisCountAggregateInputType = {
    id?: true
    UUID?: true
    ImageBase64?: true
    URL?: true
    _all?: true
  }

  export type ImageApisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImageApis to aggregate.
     */
    where?: ImageApisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageApis to fetch.
     */
    orderBy?: ImageApisOrderByWithRelationInput | ImageApisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageApisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageApis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageApis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImageApis
    **/
    _count?: true | ImageApisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageApisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageApisMaxAggregateInputType
  }

  export type GetImageApisAggregateType<T extends ImageApisAggregateArgs> = {
        [P in keyof T & keyof AggregateImageApis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImageApis[P]>
      : GetScalarType<T[P], AggregateImageApis[P]>
  }




  export type ImageApisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageApisWhereInput
    orderBy?: ImageApisOrderByWithAggregationInput | ImageApisOrderByWithAggregationInput[]
    by: ImageApisScalarFieldEnum[] | ImageApisScalarFieldEnum
    having?: ImageApisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageApisCountAggregateInputType | true
    _min?: ImageApisMinAggregateInputType
    _max?: ImageApisMaxAggregateInputType
  }

  export type ImageApisGroupByOutputType = {
    id: string
    UUID: string
    ImageBase64: string
    URL: string
    _count: ImageApisCountAggregateOutputType | null
    _min: ImageApisMinAggregateOutputType | null
    _max: ImageApisMaxAggregateOutputType | null
  }

  type GetImageApisGroupByPayload<T extends ImageApisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImageApisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageApisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageApisGroupByOutputType[P]>
            : GetScalarType<T[P], ImageApisGroupByOutputType[P]>
        }
      >
    >


  export type ImageApisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    UUID?: boolean
    ImageBase64?: boolean
    URL?: boolean
  }, ExtArgs["result"]["imageApis"]>



  export type ImageApisSelectScalar = {
    id?: boolean
    UUID?: boolean
    ImageBase64?: boolean
    URL?: boolean
  }

  export type ImageApisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "UUID" | "ImageBase64" | "URL", ExtArgs["result"]["imageApis"]>

  export type $ImageApisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImageApis"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      UUID: string
      ImageBase64: string
      URL: string
    }, ExtArgs["result"]["imageApis"]>
    composites: {}
  }

  type ImageApisGetPayload<S extends boolean | null | undefined | ImageApisDefaultArgs> = $Result.GetResult<Prisma.$ImageApisPayload, S>

  type ImageApisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImageApisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImageApisCountAggregateInputType | true
    }

  export interface ImageApisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImageApis'], meta: { name: 'ImageApis' } }
    /**
     * Find zero or one ImageApis that matches the filter.
     * @param {ImageApisFindUniqueArgs} args - Arguments to find a ImageApis
     * @example
     * // Get one ImageApis
     * const imageApis = await prisma.imageApis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImageApisFindUniqueArgs>(args: SelectSubset<T, ImageApisFindUniqueArgs<ExtArgs>>): Prisma__ImageApisClient<$Result.GetResult<Prisma.$ImageApisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ImageApis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImageApisFindUniqueOrThrowArgs} args - Arguments to find a ImageApis
     * @example
     * // Get one ImageApis
     * const imageApis = await prisma.imageApis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImageApisFindUniqueOrThrowArgs>(args: SelectSubset<T, ImageApisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImageApisClient<$Result.GetResult<Prisma.$ImageApisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImageApis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageApisFindFirstArgs} args - Arguments to find a ImageApis
     * @example
     * // Get one ImageApis
     * const imageApis = await prisma.imageApis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImageApisFindFirstArgs>(args?: SelectSubset<T, ImageApisFindFirstArgs<ExtArgs>>): Prisma__ImageApisClient<$Result.GetResult<Prisma.$ImageApisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImageApis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageApisFindFirstOrThrowArgs} args - Arguments to find a ImageApis
     * @example
     * // Get one ImageApis
     * const imageApis = await prisma.imageApis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImageApisFindFirstOrThrowArgs>(args?: SelectSubset<T, ImageApisFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImageApisClient<$Result.GetResult<Prisma.$ImageApisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ImageApis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageApisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImageApis
     * const imageApis = await prisma.imageApis.findMany()
     * 
     * // Get first 10 ImageApis
     * const imageApis = await prisma.imageApis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageApisWithIdOnly = await prisma.imageApis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImageApisFindManyArgs>(args?: SelectSubset<T, ImageApisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImageApisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ImageApis.
     * @param {ImageApisCreateArgs} args - Arguments to create a ImageApis.
     * @example
     * // Create one ImageApis
     * const ImageApis = await prisma.imageApis.create({
     *   data: {
     *     // ... data to create a ImageApis
     *   }
     * })
     * 
     */
    create<T extends ImageApisCreateArgs>(args: SelectSubset<T, ImageApisCreateArgs<ExtArgs>>): Prisma__ImageApisClient<$Result.GetResult<Prisma.$ImageApisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ImageApis.
     * @param {ImageApisCreateManyArgs} args - Arguments to create many ImageApis.
     * @example
     * // Create many ImageApis
     * const imageApis = await prisma.imageApis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImageApisCreateManyArgs>(args?: SelectSubset<T, ImageApisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ImageApis.
     * @param {ImageApisDeleteArgs} args - Arguments to delete one ImageApis.
     * @example
     * // Delete one ImageApis
     * const ImageApis = await prisma.imageApis.delete({
     *   where: {
     *     // ... filter to delete one ImageApis
     *   }
     * })
     * 
     */
    delete<T extends ImageApisDeleteArgs>(args: SelectSubset<T, ImageApisDeleteArgs<ExtArgs>>): Prisma__ImageApisClient<$Result.GetResult<Prisma.$ImageApisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ImageApis.
     * @param {ImageApisUpdateArgs} args - Arguments to update one ImageApis.
     * @example
     * // Update one ImageApis
     * const imageApis = await prisma.imageApis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImageApisUpdateArgs>(args: SelectSubset<T, ImageApisUpdateArgs<ExtArgs>>): Prisma__ImageApisClient<$Result.GetResult<Prisma.$ImageApisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ImageApis.
     * @param {ImageApisDeleteManyArgs} args - Arguments to filter ImageApis to delete.
     * @example
     * // Delete a few ImageApis
     * const { count } = await prisma.imageApis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImageApisDeleteManyArgs>(args?: SelectSubset<T, ImageApisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImageApis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageApisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImageApis
     * const imageApis = await prisma.imageApis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImageApisUpdateManyArgs>(args: SelectSubset<T, ImageApisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ImageApis.
     * @param {ImageApisUpsertArgs} args - Arguments to update or create a ImageApis.
     * @example
     * // Update or create a ImageApis
     * const imageApis = await prisma.imageApis.upsert({
     *   create: {
     *     // ... data to create a ImageApis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImageApis we want to update
     *   }
     * })
     */
    upsert<T extends ImageApisUpsertArgs>(args: SelectSubset<T, ImageApisUpsertArgs<ExtArgs>>): Prisma__ImageApisClient<$Result.GetResult<Prisma.$ImageApisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ImageApis that matches the filter.
     * @param {ImageApisFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const imageApis = await prisma.imageApis.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ImageApisFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ImageApis.
     * @param {ImageApisAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const imageApis = await prisma.imageApis.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ImageApisAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ImageApis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageApisCountArgs} args - Arguments to filter ImageApis to count.
     * @example
     * // Count the number of ImageApis
     * const count = await prisma.imageApis.count({
     *   where: {
     *     // ... the filter for the ImageApis we want to count
     *   }
     * })
    **/
    count<T extends ImageApisCountArgs>(
      args?: Subset<T, ImageApisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageApisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImageApis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageApisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageApisAggregateArgs>(args: Subset<T, ImageApisAggregateArgs>): Prisma.PrismaPromise<GetImageApisAggregateType<T>>

    /**
     * Group by ImageApis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageApisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageApisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageApisGroupByArgs['orderBy'] }
        : { orderBy?: ImageApisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageApisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageApisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImageApis model
   */
  readonly fields: ImageApisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImageApis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImageApisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImageApis model
   */
  interface ImageApisFieldRefs {
    readonly id: FieldRef<"ImageApis", 'String'>
    readonly UUID: FieldRef<"ImageApis", 'String'>
    readonly ImageBase64: FieldRef<"ImageApis", 'String'>
    readonly URL: FieldRef<"ImageApis", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ImageApis findUnique
   */
  export type ImageApisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageApis
     */
    select?: ImageApisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageApis
     */
    omit?: ImageApisOmit<ExtArgs> | null
    /**
     * Filter, which ImageApis to fetch.
     */
    where: ImageApisWhereUniqueInput
  }

  /**
   * ImageApis findUniqueOrThrow
   */
  export type ImageApisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageApis
     */
    select?: ImageApisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageApis
     */
    omit?: ImageApisOmit<ExtArgs> | null
    /**
     * Filter, which ImageApis to fetch.
     */
    where: ImageApisWhereUniqueInput
  }

  /**
   * ImageApis findFirst
   */
  export type ImageApisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageApis
     */
    select?: ImageApisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageApis
     */
    omit?: ImageApisOmit<ExtArgs> | null
    /**
     * Filter, which ImageApis to fetch.
     */
    where?: ImageApisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageApis to fetch.
     */
    orderBy?: ImageApisOrderByWithRelationInput | ImageApisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImageApis.
     */
    cursor?: ImageApisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageApis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageApis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImageApis.
     */
    distinct?: ImageApisScalarFieldEnum | ImageApisScalarFieldEnum[]
  }

  /**
   * ImageApis findFirstOrThrow
   */
  export type ImageApisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageApis
     */
    select?: ImageApisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageApis
     */
    omit?: ImageApisOmit<ExtArgs> | null
    /**
     * Filter, which ImageApis to fetch.
     */
    where?: ImageApisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageApis to fetch.
     */
    orderBy?: ImageApisOrderByWithRelationInput | ImageApisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImageApis.
     */
    cursor?: ImageApisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageApis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageApis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImageApis.
     */
    distinct?: ImageApisScalarFieldEnum | ImageApisScalarFieldEnum[]
  }

  /**
   * ImageApis findMany
   */
  export type ImageApisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageApis
     */
    select?: ImageApisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageApis
     */
    omit?: ImageApisOmit<ExtArgs> | null
    /**
     * Filter, which ImageApis to fetch.
     */
    where?: ImageApisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageApis to fetch.
     */
    orderBy?: ImageApisOrderByWithRelationInput | ImageApisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImageApis.
     */
    cursor?: ImageApisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageApis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageApis.
     */
    skip?: number
    distinct?: ImageApisScalarFieldEnum | ImageApisScalarFieldEnum[]
  }

  /**
   * ImageApis create
   */
  export type ImageApisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageApis
     */
    select?: ImageApisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageApis
     */
    omit?: ImageApisOmit<ExtArgs> | null
    /**
     * The data needed to create a ImageApis.
     */
    data: XOR<ImageApisCreateInput, ImageApisUncheckedCreateInput>
  }

  /**
   * ImageApis createMany
   */
  export type ImageApisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImageApis.
     */
    data: ImageApisCreateManyInput | ImageApisCreateManyInput[]
  }

  /**
   * ImageApis update
   */
  export type ImageApisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageApis
     */
    select?: ImageApisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageApis
     */
    omit?: ImageApisOmit<ExtArgs> | null
    /**
     * The data needed to update a ImageApis.
     */
    data: XOR<ImageApisUpdateInput, ImageApisUncheckedUpdateInput>
    /**
     * Choose, which ImageApis to update.
     */
    where: ImageApisWhereUniqueInput
  }

  /**
   * ImageApis updateMany
   */
  export type ImageApisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImageApis.
     */
    data: XOR<ImageApisUpdateManyMutationInput, ImageApisUncheckedUpdateManyInput>
    /**
     * Filter which ImageApis to update
     */
    where?: ImageApisWhereInput
    /**
     * Limit how many ImageApis to update.
     */
    limit?: number
  }

  /**
   * ImageApis upsert
   */
  export type ImageApisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageApis
     */
    select?: ImageApisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageApis
     */
    omit?: ImageApisOmit<ExtArgs> | null
    /**
     * The filter to search for the ImageApis to update in case it exists.
     */
    where: ImageApisWhereUniqueInput
    /**
     * In case the ImageApis found by the `where` argument doesn't exist, create a new ImageApis with this data.
     */
    create: XOR<ImageApisCreateInput, ImageApisUncheckedCreateInput>
    /**
     * In case the ImageApis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageApisUpdateInput, ImageApisUncheckedUpdateInput>
  }

  /**
   * ImageApis delete
   */
  export type ImageApisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageApis
     */
    select?: ImageApisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageApis
     */
    omit?: ImageApisOmit<ExtArgs> | null
    /**
     * Filter which ImageApis to delete.
     */
    where: ImageApisWhereUniqueInput
  }

  /**
   * ImageApis deleteMany
   */
  export type ImageApisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImageApis to delete
     */
    where?: ImageApisWhereInput
    /**
     * Limit how many ImageApis to delete.
     */
    limit?: number
  }

  /**
   * ImageApis findRaw
   */
  export type ImageApisFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ImageApis aggregateRaw
   */
  export type ImageApisAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ImageApis without action
   */
  export type ImageApisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageApis
     */
    select?: ImageApisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageApis
     */
    omit?: ImageApisOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const GuildsScalarFieldEnum: {
    id: 'id',
    GuildId: 'GuildId',
    GuildName: 'GuildName',
    GuildOwner: 'GuildOwner'
  };

  export type GuildsScalarFieldEnum = (typeof GuildsScalarFieldEnum)[keyof typeof GuildsScalarFieldEnum]


  export const AutoDeletesScalarFieldEnum: {
    id: 'id',
    ChannelId: 'ChannelId',
    IsActive: 'IsActive',
    Time: 'Time',
    UUID: 'UUID',
    WhitelistedMessages: 'WhitelistedMessages',
    WhitelistedRoles: 'WhitelistedRoles',
    WhitelistedUsers: 'WhitelistedUsers',
    GuildId: 'GuildId'
  };

  export type AutoDeletesScalarFieldEnum = (typeof AutoDeletesScalarFieldEnum)[keyof typeof AutoDeletesScalarFieldEnum]


  export const AutoPublishScalarFieldEnum: {
    id: 'id',
    Channels: 'Channels',
    GuildId: 'GuildId'
  };

  export type AutoPublishScalarFieldEnum = (typeof AutoPublishScalarFieldEnum)[keyof typeof AutoPublishScalarFieldEnum]


  export const AutoReactsScalarFieldEnum: {
    id: 'id',
    ChannelId: 'ChannelId',
    Emoji: 'Emoji',
    GuildId: 'GuildId'
  };

  export type AutoReactsScalarFieldEnum = (typeof AutoReactsScalarFieldEnum)[keyof typeof AutoReactsScalarFieldEnum]


  export const AutoRolesScalarFieldEnum: {
    id: 'id',
    RoleId: 'RoleId',
    GuildId: 'GuildId'
  };

  export type AutoRolesScalarFieldEnum = (typeof AutoRolesScalarFieldEnum)[keyof typeof AutoRolesScalarFieldEnum]


  export const GuildBansScalarFieldEnum: {
    id: 'id',
    UUID: 'UUID',
    Time: 'Time',
    UserId: 'UserId',
    Reason: 'Reason',
    ModeratorId: 'ModeratorId',
    DmMessage: 'DmMessage',
    Banned: 'Banned',
    CreatedAt: 'CreatedAt',
    GuildId: 'GuildId'
  };

  export type GuildBansScalarFieldEnum = (typeof GuildBansScalarFieldEnum)[keyof typeof GuildBansScalarFieldEnum]


  export const ChatModerationsScalarFieldEnum: {
    id: 'id',
    LogChannelId: 'LogChannelId',
    Words: 'Words',
    WhiteListRole: 'WhiteListRole',
    WhiteListChannel: 'WhiteListChannel',
    GuildId: 'GuildId'
  };

  export type ChatModerationsScalarFieldEnum = (typeof ChatModerationsScalarFieldEnum)[keyof typeof ChatModerationsScalarFieldEnum]


  export const ChannelLinksScalarFieldEnum: {
    id: 'id',
    UUID: 'UUID',
    ChannelId: 'ChannelId',
    WebhookUrls: 'WebhookUrls',
    GuildId: 'GuildId'
  };

  export type ChannelLinksScalarFieldEnum = (typeof ChannelLinksScalarFieldEnum)[keyof typeof ChannelLinksScalarFieldEnum]


  export const SyncedChannelLinkMessagesScalarFieldEnum: {
    id: 'id',
    GuildId: 'GuildId',
    UserMessageId: 'UserMessageId',
    WebhookMessageId: 'WebhookMessageId',
    WebhookURL: 'WebhookURL',
    ChannelId: 'ChannelId',
    ChannelLinkId: 'ChannelLinkId'
  };

  export type SyncedChannelLinkMessagesScalarFieldEnum = (typeof SyncedChannelLinkMessagesScalarFieldEnum)[keyof typeof SyncedChannelLinkMessagesScalarFieldEnum]


  export const DiscordAddonsScalarFieldEnum: {
    id: 'id',
    OnlyMedia: 'OnlyMedia',
    NoLinkEmbeds: 'NoLinkEmbeds',
    InvitesPaused: 'InvitesPaused',
    GuildId: 'GuildId'
  };

  export type DiscordAddonsScalarFieldEnum = (typeof DiscordAddonsScalarFieldEnum)[keyof typeof DiscordAddonsScalarFieldEnum]


  export const GiveawaysScalarFieldEnum: {
    id: 'id',
    UUID: 'UUID',
    MessageId: 'MessageId',
    ChannelId: 'ChannelId',
    Prize: 'Prize',
    Winners: 'Winners',
    Time: 'Time',
    CreatedAt: 'CreatedAt',
    Ended: 'Ended',
    EndedAt: 'EndedAt',
    EndedBy: 'EndedBy',
    Paused: 'Paused',
    EndedMessage: 'EndedMessage',
    Rerolled: 'Rerolled',
    WinnerIds: 'WinnerIds',
    WinnerMessageTemplate: 'WinnerMessageTemplate',
    HostedBy: 'HostedBy',
    MessageTemplate: 'MessageTemplate',
    Content: 'Content',
    Entrys: 'Entrys',
    Requirements: 'Requirements',
    GuildId: 'GuildId'
  };

  export type GiveawaysScalarFieldEnum = (typeof GiveawaysScalarFieldEnum)[keyof typeof GiveawaysScalarFieldEnum]


  export const TempVoicesScalarFieldEnum: {
    id: 'id',
    UUID: 'UUID',
    Name: 'Name',
    JointoCreateChannel: 'JointoCreateChannel',
    JointoCreateCategory: 'JointoCreateCategory',
    Manage: 'Manage',
    PresetLimit: 'PresetLimit',
    GuildId: 'GuildId'
  };

  export type TempVoicesScalarFieldEnum = (typeof TempVoicesScalarFieldEnum)[keyof typeof TempVoicesScalarFieldEnum]


  export const TempVoiceChannelsScalarFieldEnum: {
    id: 'id',
    GuildId: 'GuildId',
    ChannelId: 'ChannelId',
    OwnerId: 'OwnerId',
    TempVoiceId: 'TempVoiceId'
  };

  export type TempVoiceChannelsScalarFieldEnum = (typeof TempVoiceChannelsScalarFieldEnum)[keyof typeof TempVoiceChannelsScalarFieldEnum]


  export const GuildLeaveSetupsScalarFieldEnum: {
    id: 'id',
    MessageTemplateId: 'MessageTemplateId',
    ChannelId: 'ChannelId',
    Image: 'Image',
    GuildId: 'GuildId'
  };

  export type GuildLeaveSetupsScalarFieldEnum = (typeof GuildLeaveSetupsScalarFieldEnum)[keyof typeof GuildLeaveSetupsScalarFieldEnum]


  export const GuildWelcomeSetupsScalarFieldEnum: {
    id: 'id',
    MessageTemplateId: 'MessageTemplateId',
    ChannelId: 'ChannelId',
    Image: 'Image',
    GuildId: 'GuildId'
  };

  export type GuildWelcomeSetupsScalarFieldEnum = (typeof GuildWelcomeSetupsScalarFieldEnum)[keyof typeof GuildWelcomeSetupsScalarFieldEnum]


  export const GuildLoggingsScalarFieldEnum: {
    id: 'id',
    AutoMod: 'AutoMod',
    Channel: 'Channel',
    Emoji: 'Emoji',
    Guild: 'Guild',
    Integration: 'Integration',
    Invite: 'Invite',
    Member: 'Member',
    Message: 'Message',
    Moderation: 'Moderation',
    Reaction: 'Reaction',
    Role: 'Role',
    SoundBoard: 'SoundBoard',
    Sticker: 'Sticker',
    Thread: 'Thread',
    Voice: 'Voice',
    Webhook: 'Webhook',
    Ban: 'Ban',
    Kick: 'Kick',
    Poll: 'Poll',
    Stage: 'Stage',
    Event: 'Event',
    GuildId: 'GuildId'
  };

  export type GuildLoggingsScalarFieldEnum = (typeof GuildLoggingsScalarFieldEnum)[keyof typeof GuildLoggingsScalarFieldEnum]


  export const GuildLoggersScalarFieldEnum: {
    id: 'id',
    UUID: 'UUID',
    Notes: 'Notes',
    LogMessage: 'LogMessage',
    LogJSON: 'LogJSON',
    GuildId: 'GuildId'
  };

  export type GuildLoggersScalarFieldEnum = (typeof GuildLoggersScalarFieldEnum)[keyof typeof GuildLoggersScalarFieldEnum]


  export const MessageTemplatesScalarFieldEnum: {
    id: 'id',
    Content: 'Content',
    EmbedJSON: 'EmbedJSON',
    OtherEmbeds: 'OtherEmbeds',
    Name: 'Name',
    GuildId: 'GuildId'
  };

  export type MessageTemplatesScalarFieldEnum = (typeof MessageTemplatesScalarFieldEnum)[keyof typeof MessageTemplatesScalarFieldEnum]


  export const PermissionsScalarFieldEnum: {
    id: 'id',
    GuildId: 'GuildId'
  };

  export type PermissionsScalarFieldEnum = (typeof PermissionsScalarFieldEnum)[keyof typeof PermissionsScalarFieldEnum]


  export const ReactionRolesScalarFieldEnum: {
    id: 'id',
    UUID: 'UUID',
    Roles: 'Roles',
    MessageId: 'MessageId',
    ChannelId: 'ChannelId',
    AddMessage: 'AddMessage',
    RemoveMessage: 'RemoveMessage',
    Emoji: 'Emoji',
    GuildId: 'GuildId'
  };

  export type ReactionRolesScalarFieldEnum = (typeof ReactionRolesScalarFieldEnum)[keyof typeof ReactionRolesScalarFieldEnum]


  export const SecuritysScalarFieldEnum: {
    id: 'id',
    InviteLoggingActive: 'InviteLoggingActive',
    MaxAccountAge: 'MaxAccountAge',
    GuildId: 'GuildId'
  };

  export type SecuritysScalarFieldEnum = (typeof SecuritysScalarFieldEnum)[keyof typeof SecuritysScalarFieldEnum]


  export const VerificationGatesScalarFieldEnum: {
    id: 'id',
    UUID: 'UUID',
    ChannelId: 'ChannelId',
    MessageId: 'MessageId',
    Action: 'Action',
    ActionType: 'ActionType',
    Roles: 'Roles',
    VerifiedUsers: 'VerifiedUsers',
    CreatedAt: 'CreatedAt',
    Active: 'Active',
    SecurityId: 'SecurityId'
  };

  export type VerificationGatesScalarFieldEnum = (typeof VerificationGatesScalarFieldEnum)[keyof typeof VerificationGatesScalarFieldEnum]


  export const VerificationGatesPermissionScalarFieldEnum: {
    id: 'id',
    Permission: 'Permission',
    ChannelId: 'ChannelId',
    VerificationGateId: 'VerificationGateId'
  };

  export type VerificationGatesPermissionScalarFieldEnum = (typeof VerificationGatesPermissionScalarFieldEnum)[keyof typeof VerificationGatesPermissionScalarFieldEnum]


  export const SpotifyNotificationsScalarFieldEnum: {
    id: 'id',
    ShowId: 'ShowId',
    ChannelId: 'ChannelId',
    Latests: 'Latests',
    MessageTemplateId: 'MessageTemplateId',
    PingRoles: 'PingRoles',
    UUID: 'UUID',
    GuildId: 'GuildId'
  };

  export type SpotifyNotificationsScalarFieldEnum = (typeof SpotifyNotificationsScalarFieldEnum)[keyof typeof SpotifyNotificationsScalarFieldEnum]


  export const TagsScalarFieldEnum: {
    id: 'id',
    UUID: 'UUID',
    TagId: 'TagId',
    MessageId: 'MessageId',
    IsShlashCommand: 'IsShlashCommand',
    ShlashCommandId: 'ShlashCommandId',
    IsTextInputCommand: 'IsTextInputCommand',
    IsEnabled: 'IsEnabled',
    PermissionRoleId: 'PermissionRoleId',
    CommandDescription: 'CommandDescription',
    FilterTextFromMessages: 'FilterTextFromMessages',
    GuildId: 'GuildId'
  };

  export type TagsScalarFieldEnum = (typeof TagsScalarFieldEnum)[keyof typeof TagsScalarFieldEnum]


  export const TicketSetupsScalarFieldEnum: {
    id: 'id',
    CategoryId: 'CategoryId',
    Handlers: 'Handlers',
    HandlerWithShadowPing: 'HandlerWithShadowPing',
    CustomId: 'CustomId',
    TicketChannelName: 'TicketChannelName',
    ChannelType: 'ChannelType',
    MessageTempleateId: 'MessageTempleateId',
    TicketBlacklistRoles: 'TicketBlacklistRoles',
    TranscriptChannelId: 'TranscriptChannelId',
    HasModal: 'HasModal',
    UserDMWhenCloseMessageTemplateId: 'UserDMWhenCloseMessageTemplateId',
    TicketLimit: 'TicketLimit',
    WithTicketFeedback: 'WithTicketFeedback',
    TicketFeedbackChannelId: 'TicketFeedbackChannelId',
    ModalTitle: 'ModalTitle',
    TicketCreationCooldownPerUser: 'TicketCreationCooldownPerUser',
    AutoCloseAfterInactivity: 'AutoCloseAfterInactivity',
    AutoAssignHandler: 'AutoAssignHandler',
    AutoReplyMessageTemplateId: 'AutoReplyMessageTemplateId',
    RequiredRoles: 'RequiredRoles',
    OpenTicketWithCommand: 'OpenTicketWithCommand',
    SlashCommandId: 'SlashCommandId',
    TextCommandName: 'TextCommandName',
    SendTranscriptToUser: 'SendTranscriptToUser',
    GuildId: 'GuildId'
  };

  export type TicketSetupsScalarFieldEnum = (typeof TicketSetupsScalarFieldEnum)[keyof typeof TicketSetupsScalarFieldEnum]


  export const TicketModalDataScalarFieldEnum: {
    id: 'id',
    Name: 'Name',
    Placeholder: 'Placeholder',
    Type: 'Type',
    TicketSetupId: 'TicketSetupId'
  };

  export type TicketModalDataScalarFieldEnum = (typeof TicketModalDataScalarFieldEnum)[keyof typeof TicketModalDataScalarFieldEnum]


  export const TicketHandlersScalarFieldEnum: {
    id: 'id',
    DiscordRoleId: 'DiscordRoleId',
    TicketPermission: 'TicketPermission',
    AddedDiscordPermission: 'AddedDiscordPermission',
    RemovedDiscordPermission: 'RemovedDiscordPermission'
  };

  export type TicketHandlersScalarFieldEnum = (typeof TicketHandlersScalarFieldEnum)[keyof typeof TicketHandlersScalarFieldEnum]


  export const TicketsScalarFieldEnum: {
    id: 'id',
    TicketId: 'TicketId',
    GuildId: 'GuildId',
    ChannelId: 'ChannelId',
    ThreadId: 'ThreadId',
    IsClaimed: 'IsClaimed',
    IsArchived: 'IsArchived',
    ArchiveMessageId: 'ArchiveMessageId',
    UserWhoHasClaimedId: 'UserWhoHasClaimedId',
    IsLooked: 'IsLooked',
    TicketOwnerId: 'TicketOwnerId',
    AddedMemberIds: 'AddedMemberIds',
    Handlers: 'Handlers',
    TranscriptChannelId: 'TranscriptChannelId',
    TranscriptHTML: 'TranscriptHTML',
    TicketNotes: 'TicketNotes',
    TicketSetupId: 'TicketSetupId'
  };

  export type TicketsScalarFieldEnum = (typeof TicketsScalarFieldEnum)[keyof typeof TicketsScalarFieldEnum]


  export const TicketFeedbackScalarFieldEnum: {
    id: 'id',
    TicketId: 'TicketId',
    Rating: 'Rating',
    Comment: 'Comment',
    SubmittedAt: 'SubmittedAt'
  };

  export type TicketFeedbackScalarFieldEnum = (typeof TicketFeedbackScalarFieldEnum)[keyof typeof TicketFeedbackScalarFieldEnum]


  export const GuildFeatureTogglesScalarFieldEnum: {
    id: 'id',
    LevelEnabled: 'LevelEnabled',
    WecomeEnabled: 'WecomeEnabled',
    LeaveEnabled: 'LeaveEnabled',
    AutoreactEnabled: 'AutoreactEnabled',
    AutopublishEnabled: 'AutopublishEnabled',
    ConnectionsEnabled: 'ConnectionsEnabled',
    ChatfilterEnabled: 'ChatfilterEnabled',
    AutorolesEnabled: 'AutorolesEnabled',
    LoggingEnabled: 'LoggingEnabled',
    TwitchEnabled: 'TwitchEnabled',
    YoutubeEnabled: 'YoutubeEnabled',
    SpotifyEnabled: 'SpotifyEnabled',
    GuildId: 'GuildId'
  };

  export type GuildFeatureTogglesScalarFieldEnum = (typeof GuildFeatureTogglesScalarFieldEnum)[keyof typeof GuildFeatureTogglesScalarFieldEnum]


  export const TwitchNotificationsScalarFieldEnum: {
    id: 'id',
    UUID: 'UUID',
    TwitchChannelName: 'TwitchChannelName',
    ChannelId: 'ChannelId',
    Live: 'Live',
    MessageTemplateId: 'MessageTemplateId',
    PingRoles: 'PingRoles',
    GuildId: 'GuildId'
  };

  export type TwitchNotificationsScalarFieldEnum = (typeof TwitchNotificationsScalarFieldEnum)[keyof typeof TwitchNotificationsScalarFieldEnum]


  export const YoutubeNotificationsScalarFieldEnum: {
    id: 'id',
    YoutubeChannelId: 'YoutubeChannelId',
    ChannelId: 'ChannelId',
    Latest: 'Latest',
    MessageTemplateId: 'MessageTemplateId',
    PingRoles: 'PingRoles',
    UUID: 'UUID',
    GuildId: 'GuildId'
  };

  export type YoutubeNotificationsScalarFieldEnum = (typeof YoutubeNotificationsScalarFieldEnum)[keyof typeof YoutubeNotificationsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    Username: 'Username',
    UserId: 'UserId',
    Votes: 'Votes',
    GloablVotes: 'GloablVotes',
    CustomerBots: 'CustomerBots',
    BackupCount: 'BackupCount'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const ApisScalarFieldEnum: {
    id: 'id',
    Flags: 'Flags',
    Guilds: 'Guilds',
    Key: 'Key',
    UserId: 'UserId'
  };

  export type ApisScalarFieldEnum = (typeof ApisScalarFieldEnum)[keyof typeof ApisScalarFieldEnum]


  export const GuildBackupsScalarFieldEnum: {
    id: 'id',
    BackupJSON: 'BackupJSON',
    CreatedAt: 'CreatedAt',
    UUID: 'UUID',
    Name: 'Name',
    GuildId: 'GuildId',
    UserId: 'UserId'
  };

  export type GuildBackupsScalarFieldEnum = (typeof GuildBackupsScalarFieldEnum)[keyof typeof GuildBackupsScalarFieldEnum]


  export const CustomersScalarFieldEnum: {
    id: 'id',
    ExternalUUID: 'ExternalUUID',
    RealUUID: 'RealUUID',
    Application: 'Application',
    DisplayName: 'DisplayName',
    GuildIds: 'GuildIds',
    ServerPort: 'ServerPort',
    WSAPI: 'WSAPI',
    UserId: 'UserId'
  };

  export type CustomersScalarFieldEnum = (typeof CustomersScalarFieldEnum)[keyof typeof CustomersScalarFieldEnum]


  export const VanitysScalarFieldEnum: {
    id: 'id',
    UUID: 'UUID',
    Slug: 'Slug',
    Host: 'Host',
    GuildId: 'GuildId',
    Invite: 'Invite',
    CreatedAt: 'CreatedAt',
    UserId: 'UserId'
  };

  export type VanitysScalarFieldEnum = (typeof VanitysScalarFieldEnum)[keyof typeof VanitysScalarFieldEnum]


  export const VanityEmbedsScalarFieldEnum: {
    id: 'id',
    Title: 'Title',
    Description: 'Description',
    Color: 'Color',
    ImageUrl: 'ImageUrl',
    ThumbnailUrl: 'ThumbnailUrl',
    VanityId: 'VanityId'
  };

  export type VanityEmbedsScalarFieldEnum = (typeof VanityEmbedsScalarFieldEnum)[keyof typeof VanityEmbedsScalarFieldEnum]


  export const VanityEmbedAuthorsScalarFieldEnum: {
    id: 'id',
    Name: 'Name',
    URL: 'URL',
    IconURL: 'IconURL',
    VanityEmbedsId: 'VanityEmbedsId'
  };

  export type VanityEmbedAuthorsScalarFieldEnum = (typeof VanityEmbedAuthorsScalarFieldEnum)[keyof typeof VanityEmbedAuthorsScalarFieldEnum]


  export const VanityAnalyticsScalarFieldEnum: {
    id: 'id',
    Click: 'Click',
    TrackInviteWithLog: 'TrackInviteWithLog',
    TrackMessageId: 'TrackMessageId',
    Update: 'Update',
    UniqueClick: 'UniqueClick',
    JoinedWithCode: 'JoinedWithCode',
    LoggedIPs: 'LoggedIPs',
    VanityId: 'VanityId'
  };

  export type VanityAnalyticsScalarFieldEnum = (typeof VanityAnalyticsScalarFieldEnum)[keyof typeof VanityAnalyticsScalarFieldEnum]


  export const AnalyticsLatest30DaysScalarFieldEnum: {
    id: 'id',
    Click: 'Click',
    UniqueClick: 'UniqueClick',
    Date: 'Date',
    JoinedWithCode: 'JoinedWithCode',
    VanityAnalyticsId: 'VanityAnalyticsId'
  };

  export type AnalyticsLatest30DaysScalarFieldEnum = (typeof AnalyticsLatest30DaysScalarFieldEnum)[keyof typeof AnalyticsLatest30DaysScalarFieldEnum]


  export const DisBotUserNotificationsScalarFieldEnum: {
    id: 'id',
    Updates: 'Updates',
    Status: 'Status',
    Announcements: 'Announcements',
    Customer: 'Customer',
    UserId: 'UserId'
  };

  export type DisBotUserNotificationsScalarFieldEnum = (typeof DisBotUserNotificationsScalarFieldEnum)[keyof typeof DisBotUserNotificationsScalarFieldEnum]


  export const DisBotScalarFieldEnum: {
    id: 'id',
    SpotifyToken: 'SpotifyToken',
    TwitchToken: 'TwitchToken',
    Version: 'Version',
    GetConf: 'GetConf'
  };

  export type DisBotScalarFieldEnum = (typeof DisBotScalarFieldEnum)[keyof typeof DisBotScalarFieldEnum]


  export const ImageApisScalarFieldEnum: {
    id: 'id',
    UUID: 'UUID',
    ImageBase64: 'ImageBase64',
    URL: 'URL'
  };

  export type ImageApisScalarFieldEnum = (typeof ImageApisScalarFieldEnum)[keyof typeof ImageApisScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type GuildsWhereInput = {
    AND?: GuildsWhereInput | GuildsWhereInput[]
    OR?: GuildsWhereInput[]
    NOT?: GuildsWhereInput | GuildsWhereInput[]
    id?: StringFilter<"Guilds"> | string
    GuildId?: StringFilter<"Guilds"> | string
    GuildName?: StringFilter<"Guilds"> | string
    GuildOwner?: StringFilter<"Guilds"> | string
    AutoAutoDeletes?: AutoDeletesListRelationFilter
    AutoPublish?: XOR<AutoPublishNullableScalarRelationFilter, AutoPublishWhereInput> | null
    AutoReacts?: AutoReactsListRelationFilter
    AutoRoles?: AutoRolesListRelationFilter
    GuildBans?: GuildBansListRelationFilter
    ChatModerations?: XOR<ChatModerationsNullableScalarRelationFilter, ChatModerationsWhereInput> | null
    ChannelLinks?: ChannelLinksListRelationFilter
    DiscordAddons?: XOR<DiscordAddonsNullableScalarRelationFilter, DiscordAddonsWhereInput> | null
    Giveaways?: GiveawaysListRelationFilter
    TempVoices?: TempVoicesListRelationFilter
    GuildLeaveSetup?: XOR<GuildLeaveSetupsNullableScalarRelationFilter, GuildLeaveSetupsWhereInput> | null
    GuildLogging?: XOR<GuildLoggingsNullableScalarRelationFilter, GuildLoggingsWhereInput> | null
    MessageTemplates?: MessageTemplatesListRelationFilter
    Permissions?: XOR<PermissionsNullableScalarRelationFilter, PermissionsWhereInput> | null
    ReactionRole?: ReactionRolesListRelationFilter
    Security?: XOR<SecuritysNullableScalarRelationFilter, SecuritysWhereInput> | null
    SpotifyNotifications?: SpotifyNotificationsListRelationFilter
    Tags?: TagsListRelationFilter
    TicketSetups?: TicketSetupsListRelationFilter
    GuildFeatureToggle?: XOR<GuildFeatureTogglesNullableScalarRelationFilter, GuildFeatureTogglesWhereInput> | null
    TwitchNotifications?: TwitchNotificationsListRelationFilter
    GuildWelcomeSetup?: XOR<GuildWelcomeSetupsNullableScalarRelationFilter, GuildWelcomeSetupsWhereInput> | null
    YoutubeNotifications?: YoutubeNotificationsListRelationFilter
    GuildLoggers?: GuildLoggersListRelationFilter
  }

  export type GuildsOrderByWithRelationInput = {
    id?: SortOrder
    GuildId?: SortOrder
    GuildName?: SortOrder
    GuildOwner?: SortOrder
    AutoAutoDeletes?: AutoDeletesOrderByRelationAggregateInput
    AutoPublish?: AutoPublishOrderByWithRelationInput
    AutoReacts?: AutoReactsOrderByRelationAggregateInput
    AutoRoles?: AutoRolesOrderByRelationAggregateInput
    GuildBans?: GuildBansOrderByRelationAggregateInput
    ChatModerations?: ChatModerationsOrderByWithRelationInput
    ChannelLinks?: ChannelLinksOrderByRelationAggregateInput
    DiscordAddons?: DiscordAddonsOrderByWithRelationInput
    Giveaways?: GiveawaysOrderByRelationAggregateInput
    TempVoices?: TempVoicesOrderByRelationAggregateInput
    GuildLeaveSetup?: GuildLeaveSetupsOrderByWithRelationInput
    GuildLogging?: GuildLoggingsOrderByWithRelationInput
    MessageTemplates?: MessageTemplatesOrderByRelationAggregateInput
    Permissions?: PermissionsOrderByWithRelationInput
    ReactionRole?: ReactionRolesOrderByRelationAggregateInput
    Security?: SecuritysOrderByWithRelationInput
    SpotifyNotifications?: SpotifyNotificationsOrderByRelationAggregateInput
    Tags?: TagsOrderByRelationAggregateInput
    TicketSetups?: TicketSetupsOrderByRelationAggregateInput
    GuildFeatureToggle?: GuildFeatureTogglesOrderByWithRelationInput
    TwitchNotifications?: TwitchNotificationsOrderByRelationAggregateInput
    GuildWelcomeSetup?: GuildWelcomeSetupsOrderByWithRelationInput
    YoutubeNotifications?: YoutubeNotificationsOrderByRelationAggregateInput
    GuildLoggers?: GuildLoggersOrderByRelationAggregateInput
  }

  export type GuildsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    GuildId?: string
    AND?: GuildsWhereInput | GuildsWhereInput[]
    OR?: GuildsWhereInput[]
    NOT?: GuildsWhereInput | GuildsWhereInput[]
    GuildName?: StringFilter<"Guilds"> | string
    GuildOwner?: StringFilter<"Guilds"> | string
    AutoAutoDeletes?: AutoDeletesListRelationFilter
    AutoPublish?: XOR<AutoPublishNullableScalarRelationFilter, AutoPublishWhereInput> | null
    AutoReacts?: AutoReactsListRelationFilter
    AutoRoles?: AutoRolesListRelationFilter
    GuildBans?: GuildBansListRelationFilter
    ChatModerations?: XOR<ChatModerationsNullableScalarRelationFilter, ChatModerationsWhereInput> | null
    ChannelLinks?: ChannelLinksListRelationFilter
    DiscordAddons?: XOR<DiscordAddonsNullableScalarRelationFilter, DiscordAddonsWhereInput> | null
    Giveaways?: GiveawaysListRelationFilter
    TempVoices?: TempVoicesListRelationFilter
    GuildLeaveSetup?: XOR<GuildLeaveSetupsNullableScalarRelationFilter, GuildLeaveSetupsWhereInput> | null
    GuildLogging?: XOR<GuildLoggingsNullableScalarRelationFilter, GuildLoggingsWhereInput> | null
    MessageTemplates?: MessageTemplatesListRelationFilter
    Permissions?: XOR<PermissionsNullableScalarRelationFilter, PermissionsWhereInput> | null
    ReactionRole?: ReactionRolesListRelationFilter
    Security?: XOR<SecuritysNullableScalarRelationFilter, SecuritysWhereInput> | null
    SpotifyNotifications?: SpotifyNotificationsListRelationFilter
    Tags?: TagsListRelationFilter
    TicketSetups?: TicketSetupsListRelationFilter
    GuildFeatureToggle?: XOR<GuildFeatureTogglesNullableScalarRelationFilter, GuildFeatureTogglesWhereInput> | null
    TwitchNotifications?: TwitchNotificationsListRelationFilter
    GuildWelcomeSetup?: XOR<GuildWelcomeSetupsNullableScalarRelationFilter, GuildWelcomeSetupsWhereInput> | null
    YoutubeNotifications?: YoutubeNotificationsListRelationFilter
    GuildLoggers?: GuildLoggersListRelationFilter
  }, "id" | "GuildId">

  export type GuildsOrderByWithAggregationInput = {
    id?: SortOrder
    GuildId?: SortOrder
    GuildName?: SortOrder
    GuildOwner?: SortOrder
    _count?: GuildsCountOrderByAggregateInput
    _max?: GuildsMaxOrderByAggregateInput
    _min?: GuildsMinOrderByAggregateInput
  }

  export type GuildsScalarWhereWithAggregatesInput = {
    AND?: GuildsScalarWhereWithAggregatesInput | GuildsScalarWhereWithAggregatesInput[]
    OR?: GuildsScalarWhereWithAggregatesInput[]
    NOT?: GuildsScalarWhereWithAggregatesInput | GuildsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Guilds"> | string
    GuildId?: StringWithAggregatesFilter<"Guilds"> | string
    GuildName?: StringWithAggregatesFilter<"Guilds"> | string
    GuildOwner?: StringWithAggregatesFilter<"Guilds"> | string
  }

  export type AutoDeletesWhereInput = {
    AND?: AutoDeletesWhereInput | AutoDeletesWhereInput[]
    OR?: AutoDeletesWhereInput[]
    NOT?: AutoDeletesWhereInput | AutoDeletesWhereInput[]
    id?: StringFilter<"AutoDeletes"> | string
    ChannelId?: StringNullableFilter<"AutoDeletes"> | string | null
    IsActive?: BoolNullableFilter<"AutoDeletes"> | boolean | null
    Time?: StringNullableFilter<"AutoDeletes"> | string | null
    UUID?: StringNullableFilter<"AutoDeletes"> | string | null
    WhitelistedMessages?: StringNullableListFilter<"AutoDeletes">
    WhitelistedRoles?: StringNullableListFilter<"AutoDeletes">
    WhitelistedUsers?: StringNullableListFilter<"AutoDeletes">
    GuildId?: StringFilter<"AutoDeletes"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }

  export type AutoDeletesOrderByWithRelationInput = {
    id?: SortOrder
    ChannelId?: SortOrder
    IsActive?: SortOrder
    Time?: SortOrder
    UUID?: SortOrder
    WhitelistedMessages?: SortOrder
    WhitelistedRoles?: SortOrder
    WhitelistedUsers?: SortOrder
    GuildId?: SortOrder
    Guilds?: GuildsOrderByWithRelationInput
  }

  export type AutoDeletesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    UUID?: string
    AND?: AutoDeletesWhereInput | AutoDeletesWhereInput[]
    OR?: AutoDeletesWhereInput[]
    NOT?: AutoDeletesWhereInput | AutoDeletesWhereInput[]
    ChannelId?: StringNullableFilter<"AutoDeletes"> | string | null
    IsActive?: BoolNullableFilter<"AutoDeletes"> | boolean | null
    Time?: StringNullableFilter<"AutoDeletes"> | string | null
    WhitelistedMessages?: StringNullableListFilter<"AutoDeletes">
    WhitelistedRoles?: StringNullableListFilter<"AutoDeletes">
    WhitelistedUsers?: StringNullableListFilter<"AutoDeletes">
    GuildId?: StringFilter<"AutoDeletes"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }, "id" | "UUID">

  export type AutoDeletesOrderByWithAggregationInput = {
    id?: SortOrder
    ChannelId?: SortOrder
    IsActive?: SortOrder
    Time?: SortOrder
    UUID?: SortOrder
    WhitelistedMessages?: SortOrder
    WhitelistedRoles?: SortOrder
    WhitelistedUsers?: SortOrder
    GuildId?: SortOrder
    _count?: AutoDeletesCountOrderByAggregateInput
    _max?: AutoDeletesMaxOrderByAggregateInput
    _min?: AutoDeletesMinOrderByAggregateInput
  }

  export type AutoDeletesScalarWhereWithAggregatesInput = {
    AND?: AutoDeletesScalarWhereWithAggregatesInput | AutoDeletesScalarWhereWithAggregatesInput[]
    OR?: AutoDeletesScalarWhereWithAggregatesInput[]
    NOT?: AutoDeletesScalarWhereWithAggregatesInput | AutoDeletesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutoDeletes"> | string
    ChannelId?: StringNullableWithAggregatesFilter<"AutoDeletes"> | string | null
    IsActive?: BoolNullableWithAggregatesFilter<"AutoDeletes"> | boolean | null
    Time?: StringNullableWithAggregatesFilter<"AutoDeletes"> | string | null
    UUID?: StringNullableWithAggregatesFilter<"AutoDeletes"> | string | null
    WhitelistedMessages?: StringNullableListFilter<"AutoDeletes">
    WhitelistedRoles?: StringNullableListFilter<"AutoDeletes">
    WhitelistedUsers?: StringNullableListFilter<"AutoDeletes">
    GuildId?: StringWithAggregatesFilter<"AutoDeletes"> | string
  }

  export type AutoPublishWhereInput = {
    AND?: AutoPublishWhereInput | AutoPublishWhereInput[]
    OR?: AutoPublishWhereInput[]
    NOT?: AutoPublishWhereInput | AutoPublishWhereInput[]
    id?: StringFilter<"AutoPublish"> | string
    Channels?: StringNullableListFilter<"AutoPublish">
    GuildId?: StringFilter<"AutoPublish"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }

  export type AutoPublishOrderByWithRelationInput = {
    id?: SortOrder
    Channels?: SortOrder
    GuildId?: SortOrder
    Guilds?: GuildsOrderByWithRelationInput
  }

  export type AutoPublishWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    GuildId?: string
    AND?: AutoPublishWhereInput | AutoPublishWhereInput[]
    OR?: AutoPublishWhereInput[]
    NOT?: AutoPublishWhereInput | AutoPublishWhereInput[]
    Channels?: StringNullableListFilter<"AutoPublish">
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }, "id" | "GuildId">

  export type AutoPublishOrderByWithAggregationInput = {
    id?: SortOrder
    Channels?: SortOrder
    GuildId?: SortOrder
    _count?: AutoPublishCountOrderByAggregateInput
    _max?: AutoPublishMaxOrderByAggregateInput
    _min?: AutoPublishMinOrderByAggregateInput
  }

  export type AutoPublishScalarWhereWithAggregatesInput = {
    AND?: AutoPublishScalarWhereWithAggregatesInput | AutoPublishScalarWhereWithAggregatesInput[]
    OR?: AutoPublishScalarWhereWithAggregatesInput[]
    NOT?: AutoPublishScalarWhereWithAggregatesInput | AutoPublishScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutoPublish"> | string
    Channels?: StringNullableListFilter<"AutoPublish">
    GuildId?: StringWithAggregatesFilter<"AutoPublish"> | string
  }

  export type AutoReactsWhereInput = {
    AND?: AutoReactsWhereInput | AutoReactsWhereInput[]
    OR?: AutoReactsWhereInput[]
    NOT?: AutoReactsWhereInput | AutoReactsWhereInput[]
    id?: StringFilter<"AutoReacts"> | string
    ChannelId?: StringFilter<"AutoReacts"> | string
    Emoji?: StringFilter<"AutoReacts"> | string
    GuildId?: StringFilter<"AutoReacts"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }

  export type AutoReactsOrderByWithRelationInput = {
    id?: SortOrder
    ChannelId?: SortOrder
    Emoji?: SortOrder
    GuildId?: SortOrder
    Guilds?: GuildsOrderByWithRelationInput
  }

  export type AutoReactsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutoReactsWhereInput | AutoReactsWhereInput[]
    OR?: AutoReactsWhereInput[]
    NOT?: AutoReactsWhereInput | AutoReactsWhereInput[]
    ChannelId?: StringFilter<"AutoReacts"> | string
    Emoji?: StringFilter<"AutoReacts"> | string
    GuildId?: StringFilter<"AutoReacts"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }, "id">

  export type AutoReactsOrderByWithAggregationInput = {
    id?: SortOrder
    ChannelId?: SortOrder
    Emoji?: SortOrder
    GuildId?: SortOrder
    _count?: AutoReactsCountOrderByAggregateInput
    _max?: AutoReactsMaxOrderByAggregateInput
    _min?: AutoReactsMinOrderByAggregateInput
  }

  export type AutoReactsScalarWhereWithAggregatesInput = {
    AND?: AutoReactsScalarWhereWithAggregatesInput | AutoReactsScalarWhereWithAggregatesInput[]
    OR?: AutoReactsScalarWhereWithAggregatesInput[]
    NOT?: AutoReactsScalarWhereWithAggregatesInput | AutoReactsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutoReacts"> | string
    ChannelId?: StringWithAggregatesFilter<"AutoReacts"> | string
    Emoji?: StringWithAggregatesFilter<"AutoReacts"> | string
    GuildId?: StringWithAggregatesFilter<"AutoReacts"> | string
  }

  export type AutoRolesWhereInput = {
    AND?: AutoRolesWhereInput | AutoRolesWhereInput[]
    OR?: AutoRolesWhereInput[]
    NOT?: AutoRolesWhereInput | AutoRolesWhereInput[]
    id?: StringFilter<"AutoRoles"> | string
    RoleId?: StringFilter<"AutoRoles"> | string
    GuildId?: StringFilter<"AutoRoles"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }

  export type AutoRolesOrderByWithRelationInput = {
    id?: SortOrder
    RoleId?: SortOrder
    GuildId?: SortOrder
    Guilds?: GuildsOrderByWithRelationInput
  }

  export type AutoRolesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutoRolesWhereInput | AutoRolesWhereInput[]
    OR?: AutoRolesWhereInput[]
    NOT?: AutoRolesWhereInput | AutoRolesWhereInput[]
    RoleId?: StringFilter<"AutoRoles"> | string
    GuildId?: StringFilter<"AutoRoles"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }, "id">

  export type AutoRolesOrderByWithAggregationInput = {
    id?: SortOrder
    RoleId?: SortOrder
    GuildId?: SortOrder
    _count?: AutoRolesCountOrderByAggregateInput
    _max?: AutoRolesMaxOrderByAggregateInput
    _min?: AutoRolesMinOrderByAggregateInput
  }

  export type AutoRolesScalarWhereWithAggregatesInput = {
    AND?: AutoRolesScalarWhereWithAggregatesInput | AutoRolesScalarWhereWithAggregatesInput[]
    OR?: AutoRolesScalarWhereWithAggregatesInput[]
    NOT?: AutoRolesScalarWhereWithAggregatesInput | AutoRolesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutoRoles"> | string
    RoleId?: StringWithAggregatesFilter<"AutoRoles"> | string
    GuildId?: StringWithAggregatesFilter<"AutoRoles"> | string
  }

  export type GuildBansWhereInput = {
    AND?: GuildBansWhereInput | GuildBansWhereInput[]
    OR?: GuildBansWhereInput[]
    NOT?: GuildBansWhereInput | GuildBansWhereInput[]
    id?: StringFilter<"GuildBans"> | string
    UUID?: StringFilter<"GuildBans"> | string
    Time?: StringNullableFilter<"GuildBans"> | string | null
    UserId?: StringNullableListFilter<"GuildBans">
    Reason?: StringNullableFilter<"GuildBans"> | string | null
    ModeratorId?: StringNullableFilter<"GuildBans"> | string | null
    DmMessage?: StringNullableFilter<"GuildBans"> | string | null
    Banned?: BoolNullableFilter<"GuildBans"> | boolean | null
    CreatedAt?: DateTimeNullableFilter<"GuildBans"> | Date | string | null
    GuildId?: StringFilter<"GuildBans"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }

  export type GuildBansOrderByWithRelationInput = {
    id?: SortOrder
    UUID?: SortOrder
    Time?: SortOrder
    UserId?: SortOrder
    Reason?: SortOrder
    ModeratorId?: SortOrder
    DmMessage?: SortOrder
    Banned?: SortOrder
    CreatedAt?: SortOrder
    GuildId?: SortOrder
    Guilds?: GuildsOrderByWithRelationInput
  }

  export type GuildBansWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    UUID?: string
    AND?: GuildBansWhereInput | GuildBansWhereInput[]
    OR?: GuildBansWhereInput[]
    NOT?: GuildBansWhereInput | GuildBansWhereInput[]
    Time?: StringNullableFilter<"GuildBans"> | string | null
    UserId?: StringNullableListFilter<"GuildBans">
    Reason?: StringNullableFilter<"GuildBans"> | string | null
    ModeratorId?: StringNullableFilter<"GuildBans"> | string | null
    DmMessage?: StringNullableFilter<"GuildBans"> | string | null
    Banned?: BoolNullableFilter<"GuildBans"> | boolean | null
    CreatedAt?: DateTimeNullableFilter<"GuildBans"> | Date | string | null
    GuildId?: StringFilter<"GuildBans"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }, "id" | "UUID">

  export type GuildBansOrderByWithAggregationInput = {
    id?: SortOrder
    UUID?: SortOrder
    Time?: SortOrder
    UserId?: SortOrder
    Reason?: SortOrder
    ModeratorId?: SortOrder
    DmMessage?: SortOrder
    Banned?: SortOrder
    CreatedAt?: SortOrder
    GuildId?: SortOrder
    _count?: GuildBansCountOrderByAggregateInput
    _max?: GuildBansMaxOrderByAggregateInput
    _min?: GuildBansMinOrderByAggregateInput
  }

  export type GuildBansScalarWhereWithAggregatesInput = {
    AND?: GuildBansScalarWhereWithAggregatesInput | GuildBansScalarWhereWithAggregatesInput[]
    OR?: GuildBansScalarWhereWithAggregatesInput[]
    NOT?: GuildBansScalarWhereWithAggregatesInput | GuildBansScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GuildBans"> | string
    UUID?: StringWithAggregatesFilter<"GuildBans"> | string
    Time?: StringNullableWithAggregatesFilter<"GuildBans"> | string | null
    UserId?: StringNullableListFilter<"GuildBans">
    Reason?: StringNullableWithAggregatesFilter<"GuildBans"> | string | null
    ModeratorId?: StringNullableWithAggregatesFilter<"GuildBans"> | string | null
    DmMessage?: StringNullableWithAggregatesFilter<"GuildBans"> | string | null
    Banned?: BoolNullableWithAggregatesFilter<"GuildBans"> | boolean | null
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"GuildBans"> | Date | string | null
    GuildId?: StringWithAggregatesFilter<"GuildBans"> | string
  }

  export type ChatModerationsWhereInput = {
    AND?: ChatModerationsWhereInput | ChatModerationsWhereInput[]
    OR?: ChatModerationsWhereInput[]
    NOT?: ChatModerationsWhereInput | ChatModerationsWhereInput[]
    id?: StringFilter<"ChatModerations"> | string
    LogChannelId?: StringFilter<"ChatModerations"> | string
    Words?: StringNullableListFilter<"ChatModerations">
    WhiteListRole?: StringNullableListFilter<"ChatModerations">
    WhiteListChannel?: StringNullableListFilter<"ChatModerations">
    GuildId?: StringFilter<"ChatModerations"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }

  export type ChatModerationsOrderByWithRelationInput = {
    id?: SortOrder
    LogChannelId?: SortOrder
    Words?: SortOrder
    WhiteListRole?: SortOrder
    WhiteListChannel?: SortOrder
    GuildId?: SortOrder
    Guilds?: GuildsOrderByWithRelationInput
  }

  export type ChatModerationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    GuildId?: string
    AND?: ChatModerationsWhereInput | ChatModerationsWhereInput[]
    OR?: ChatModerationsWhereInput[]
    NOT?: ChatModerationsWhereInput | ChatModerationsWhereInput[]
    LogChannelId?: StringFilter<"ChatModerations"> | string
    Words?: StringNullableListFilter<"ChatModerations">
    WhiteListRole?: StringNullableListFilter<"ChatModerations">
    WhiteListChannel?: StringNullableListFilter<"ChatModerations">
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }, "id" | "GuildId">

  export type ChatModerationsOrderByWithAggregationInput = {
    id?: SortOrder
    LogChannelId?: SortOrder
    Words?: SortOrder
    WhiteListRole?: SortOrder
    WhiteListChannel?: SortOrder
    GuildId?: SortOrder
    _count?: ChatModerationsCountOrderByAggregateInput
    _max?: ChatModerationsMaxOrderByAggregateInput
    _min?: ChatModerationsMinOrderByAggregateInput
  }

  export type ChatModerationsScalarWhereWithAggregatesInput = {
    AND?: ChatModerationsScalarWhereWithAggregatesInput | ChatModerationsScalarWhereWithAggregatesInput[]
    OR?: ChatModerationsScalarWhereWithAggregatesInput[]
    NOT?: ChatModerationsScalarWhereWithAggregatesInput | ChatModerationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatModerations"> | string
    LogChannelId?: StringWithAggregatesFilter<"ChatModerations"> | string
    Words?: StringNullableListFilter<"ChatModerations">
    WhiteListRole?: StringNullableListFilter<"ChatModerations">
    WhiteListChannel?: StringNullableListFilter<"ChatModerations">
    GuildId?: StringWithAggregatesFilter<"ChatModerations"> | string
  }

  export type ChannelLinksWhereInput = {
    AND?: ChannelLinksWhereInput | ChannelLinksWhereInput[]
    OR?: ChannelLinksWhereInput[]
    NOT?: ChannelLinksWhereInput | ChannelLinksWhereInput[]
    id?: StringFilter<"ChannelLinks"> | string
    UUID?: StringFilter<"ChannelLinks"> | string
    ChannelId?: StringFilter<"ChannelLinks"> | string
    WebhookUrls?: StringNullableListFilter<"ChannelLinks">
    GuildId?: StringFilter<"ChannelLinks"> | string
    SyncedChannelLinkMessage?: SyncedChannelLinkMessagesListRelationFilter
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }

  export type ChannelLinksOrderByWithRelationInput = {
    id?: SortOrder
    UUID?: SortOrder
    ChannelId?: SortOrder
    WebhookUrls?: SortOrder
    GuildId?: SortOrder
    SyncedChannelLinkMessage?: SyncedChannelLinkMessagesOrderByRelationAggregateInput
    Guilds?: GuildsOrderByWithRelationInput
  }

  export type ChannelLinksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    UUID?: string
    AND?: ChannelLinksWhereInput | ChannelLinksWhereInput[]
    OR?: ChannelLinksWhereInput[]
    NOT?: ChannelLinksWhereInput | ChannelLinksWhereInput[]
    ChannelId?: StringFilter<"ChannelLinks"> | string
    WebhookUrls?: StringNullableListFilter<"ChannelLinks">
    GuildId?: StringFilter<"ChannelLinks"> | string
    SyncedChannelLinkMessage?: SyncedChannelLinkMessagesListRelationFilter
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }, "id" | "UUID">

  export type ChannelLinksOrderByWithAggregationInput = {
    id?: SortOrder
    UUID?: SortOrder
    ChannelId?: SortOrder
    WebhookUrls?: SortOrder
    GuildId?: SortOrder
    _count?: ChannelLinksCountOrderByAggregateInput
    _max?: ChannelLinksMaxOrderByAggregateInput
    _min?: ChannelLinksMinOrderByAggregateInput
  }

  export type ChannelLinksScalarWhereWithAggregatesInput = {
    AND?: ChannelLinksScalarWhereWithAggregatesInput | ChannelLinksScalarWhereWithAggregatesInput[]
    OR?: ChannelLinksScalarWhereWithAggregatesInput[]
    NOT?: ChannelLinksScalarWhereWithAggregatesInput | ChannelLinksScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChannelLinks"> | string
    UUID?: StringWithAggregatesFilter<"ChannelLinks"> | string
    ChannelId?: StringWithAggregatesFilter<"ChannelLinks"> | string
    WebhookUrls?: StringNullableListFilter<"ChannelLinks">
    GuildId?: StringWithAggregatesFilter<"ChannelLinks"> | string
  }

  export type SyncedChannelLinkMessagesWhereInput = {
    AND?: SyncedChannelLinkMessagesWhereInput | SyncedChannelLinkMessagesWhereInput[]
    OR?: SyncedChannelLinkMessagesWhereInput[]
    NOT?: SyncedChannelLinkMessagesWhereInput | SyncedChannelLinkMessagesWhereInput[]
    id?: StringFilter<"SyncedChannelLinkMessages"> | string
    GuildId?: StringFilter<"SyncedChannelLinkMessages"> | string
    UserMessageId?: StringFilter<"SyncedChannelLinkMessages"> | string
    WebhookMessageId?: StringFilter<"SyncedChannelLinkMessages"> | string
    WebhookURL?: StringFilter<"SyncedChannelLinkMessages"> | string
    ChannelId?: StringFilter<"SyncedChannelLinkMessages"> | string
    ChannelLinkId?: StringFilter<"SyncedChannelLinkMessages"> | string
    ChannelLinks?: XOR<ChannelLinksScalarRelationFilter, ChannelLinksWhereInput>
  }

  export type SyncedChannelLinkMessagesOrderByWithRelationInput = {
    id?: SortOrder
    GuildId?: SortOrder
    UserMessageId?: SortOrder
    WebhookMessageId?: SortOrder
    WebhookURL?: SortOrder
    ChannelId?: SortOrder
    ChannelLinkId?: SortOrder
    ChannelLinks?: ChannelLinksOrderByWithRelationInput
  }

  export type SyncedChannelLinkMessagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SyncedChannelLinkMessagesWhereInput | SyncedChannelLinkMessagesWhereInput[]
    OR?: SyncedChannelLinkMessagesWhereInput[]
    NOT?: SyncedChannelLinkMessagesWhereInput | SyncedChannelLinkMessagesWhereInput[]
    GuildId?: StringFilter<"SyncedChannelLinkMessages"> | string
    UserMessageId?: StringFilter<"SyncedChannelLinkMessages"> | string
    WebhookMessageId?: StringFilter<"SyncedChannelLinkMessages"> | string
    WebhookURL?: StringFilter<"SyncedChannelLinkMessages"> | string
    ChannelId?: StringFilter<"SyncedChannelLinkMessages"> | string
    ChannelLinkId?: StringFilter<"SyncedChannelLinkMessages"> | string
    ChannelLinks?: XOR<ChannelLinksScalarRelationFilter, ChannelLinksWhereInput>
  }, "id">

  export type SyncedChannelLinkMessagesOrderByWithAggregationInput = {
    id?: SortOrder
    GuildId?: SortOrder
    UserMessageId?: SortOrder
    WebhookMessageId?: SortOrder
    WebhookURL?: SortOrder
    ChannelId?: SortOrder
    ChannelLinkId?: SortOrder
    _count?: SyncedChannelLinkMessagesCountOrderByAggregateInput
    _max?: SyncedChannelLinkMessagesMaxOrderByAggregateInput
    _min?: SyncedChannelLinkMessagesMinOrderByAggregateInput
  }

  export type SyncedChannelLinkMessagesScalarWhereWithAggregatesInput = {
    AND?: SyncedChannelLinkMessagesScalarWhereWithAggregatesInput | SyncedChannelLinkMessagesScalarWhereWithAggregatesInput[]
    OR?: SyncedChannelLinkMessagesScalarWhereWithAggregatesInput[]
    NOT?: SyncedChannelLinkMessagesScalarWhereWithAggregatesInput | SyncedChannelLinkMessagesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SyncedChannelLinkMessages"> | string
    GuildId?: StringWithAggregatesFilter<"SyncedChannelLinkMessages"> | string
    UserMessageId?: StringWithAggregatesFilter<"SyncedChannelLinkMessages"> | string
    WebhookMessageId?: StringWithAggregatesFilter<"SyncedChannelLinkMessages"> | string
    WebhookURL?: StringWithAggregatesFilter<"SyncedChannelLinkMessages"> | string
    ChannelId?: StringWithAggregatesFilter<"SyncedChannelLinkMessages"> | string
    ChannelLinkId?: StringWithAggregatesFilter<"SyncedChannelLinkMessages"> | string
  }

  export type DiscordAddonsWhereInput = {
    AND?: DiscordAddonsWhereInput | DiscordAddonsWhereInput[]
    OR?: DiscordAddonsWhereInput[]
    NOT?: DiscordAddonsWhereInput | DiscordAddonsWhereInput[]
    id?: StringFilter<"DiscordAddons"> | string
    OnlyMedia?: StringNullableListFilter<"DiscordAddons">
    NoLinkEmbeds?: StringNullableListFilter<"DiscordAddons">
    InvitesPaused?: BoolFilter<"DiscordAddons"> | boolean
    GuildId?: StringFilter<"DiscordAddons"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }

  export type DiscordAddonsOrderByWithRelationInput = {
    id?: SortOrder
    OnlyMedia?: SortOrder
    NoLinkEmbeds?: SortOrder
    InvitesPaused?: SortOrder
    GuildId?: SortOrder
    Guilds?: GuildsOrderByWithRelationInput
  }

  export type DiscordAddonsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    GuildId?: string
    AND?: DiscordAddonsWhereInput | DiscordAddonsWhereInput[]
    OR?: DiscordAddonsWhereInput[]
    NOT?: DiscordAddonsWhereInput | DiscordAddonsWhereInput[]
    OnlyMedia?: StringNullableListFilter<"DiscordAddons">
    NoLinkEmbeds?: StringNullableListFilter<"DiscordAddons">
    InvitesPaused?: BoolFilter<"DiscordAddons"> | boolean
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }, "id" | "GuildId">

  export type DiscordAddonsOrderByWithAggregationInput = {
    id?: SortOrder
    OnlyMedia?: SortOrder
    NoLinkEmbeds?: SortOrder
    InvitesPaused?: SortOrder
    GuildId?: SortOrder
    _count?: DiscordAddonsCountOrderByAggregateInput
    _max?: DiscordAddonsMaxOrderByAggregateInput
    _min?: DiscordAddonsMinOrderByAggregateInput
  }

  export type DiscordAddonsScalarWhereWithAggregatesInput = {
    AND?: DiscordAddonsScalarWhereWithAggregatesInput | DiscordAddonsScalarWhereWithAggregatesInput[]
    OR?: DiscordAddonsScalarWhereWithAggregatesInput[]
    NOT?: DiscordAddonsScalarWhereWithAggregatesInput | DiscordAddonsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DiscordAddons"> | string
    OnlyMedia?: StringNullableListFilter<"DiscordAddons">
    NoLinkEmbeds?: StringNullableListFilter<"DiscordAddons">
    InvitesPaused?: BoolWithAggregatesFilter<"DiscordAddons"> | boolean
    GuildId?: StringWithAggregatesFilter<"DiscordAddons"> | string
  }

  export type GiveawaysWhereInput = {
    AND?: GiveawaysWhereInput | GiveawaysWhereInput[]
    OR?: GiveawaysWhereInput[]
    NOT?: GiveawaysWhereInput | GiveawaysWhereInput[]
    id?: StringFilter<"Giveaways"> | string
    UUID?: StringFilter<"Giveaways"> | string
    MessageId?: StringFilter<"Giveaways"> | string
    ChannelId?: StringNullableFilter<"Giveaways"> | string | null
    Prize?: StringFilter<"Giveaways"> | string
    Winners?: IntFilter<"Giveaways"> | number
    Time?: StringFilter<"Giveaways"> | string
    CreatedAt?: DateTimeFilter<"Giveaways"> | Date | string
    Ended?: BoolFilter<"Giveaways"> | boolean
    EndedAt?: DateTimeNullableFilter<"Giveaways"> | Date | string | null
    EndedBy?: StringNullableFilter<"Giveaways"> | string | null
    Paused?: BoolFilter<"Giveaways"> | boolean
    EndedMessage?: StringNullableFilter<"Giveaways"> | string | null
    Rerolled?: BoolFilter<"Giveaways"> | boolean
    WinnerIds?: StringNullableListFilter<"Giveaways">
    WinnerMessageTemplate?: StringNullableFilter<"Giveaways"> | string | null
    HostedBy?: StringFilter<"Giveaways"> | string
    MessageTemplate?: StringNullableFilter<"Giveaways"> | string | null
    Content?: StringNullableFilter<"Giveaways"> | string | null
    Entrys?: StringNullableListFilter<"Giveaways">
    Requirements?: StringNullableListFilter<"Giveaways">
    GuildId?: StringFilter<"Giveaways"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }

  export type GiveawaysOrderByWithRelationInput = {
    id?: SortOrder
    UUID?: SortOrder
    MessageId?: SortOrder
    ChannelId?: SortOrder
    Prize?: SortOrder
    Winners?: SortOrder
    Time?: SortOrder
    CreatedAt?: SortOrder
    Ended?: SortOrder
    EndedAt?: SortOrder
    EndedBy?: SortOrder
    Paused?: SortOrder
    EndedMessage?: SortOrder
    Rerolled?: SortOrder
    WinnerIds?: SortOrder
    WinnerMessageTemplate?: SortOrder
    HostedBy?: SortOrder
    MessageTemplate?: SortOrder
    Content?: SortOrder
    Entrys?: SortOrder
    Requirements?: SortOrder
    GuildId?: SortOrder
    Guilds?: GuildsOrderByWithRelationInput
  }

  export type GiveawaysWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    UUID?: string
    MessageId?: string
    AND?: GiveawaysWhereInput | GiveawaysWhereInput[]
    OR?: GiveawaysWhereInput[]
    NOT?: GiveawaysWhereInput | GiveawaysWhereInput[]
    ChannelId?: StringNullableFilter<"Giveaways"> | string | null
    Prize?: StringFilter<"Giveaways"> | string
    Winners?: IntFilter<"Giveaways"> | number
    Time?: StringFilter<"Giveaways"> | string
    CreatedAt?: DateTimeFilter<"Giveaways"> | Date | string
    Ended?: BoolFilter<"Giveaways"> | boolean
    EndedAt?: DateTimeNullableFilter<"Giveaways"> | Date | string | null
    EndedBy?: StringNullableFilter<"Giveaways"> | string | null
    Paused?: BoolFilter<"Giveaways"> | boolean
    EndedMessage?: StringNullableFilter<"Giveaways"> | string | null
    Rerolled?: BoolFilter<"Giveaways"> | boolean
    WinnerIds?: StringNullableListFilter<"Giveaways">
    WinnerMessageTemplate?: StringNullableFilter<"Giveaways"> | string | null
    HostedBy?: StringFilter<"Giveaways"> | string
    MessageTemplate?: StringNullableFilter<"Giveaways"> | string | null
    Content?: StringNullableFilter<"Giveaways"> | string | null
    Entrys?: StringNullableListFilter<"Giveaways">
    Requirements?: StringNullableListFilter<"Giveaways">
    GuildId?: StringFilter<"Giveaways"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }, "id" | "UUID" | "MessageId">

  export type GiveawaysOrderByWithAggregationInput = {
    id?: SortOrder
    UUID?: SortOrder
    MessageId?: SortOrder
    ChannelId?: SortOrder
    Prize?: SortOrder
    Winners?: SortOrder
    Time?: SortOrder
    CreatedAt?: SortOrder
    Ended?: SortOrder
    EndedAt?: SortOrder
    EndedBy?: SortOrder
    Paused?: SortOrder
    EndedMessage?: SortOrder
    Rerolled?: SortOrder
    WinnerIds?: SortOrder
    WinnerMessageTemplate?: SortOrder
    HostedBy?: SortOrder
    MessageTemplate?: SortOrder
    Content?: SortOrder
    Entrys?: SortOrder
    Requirements?: SortOrder
    GuildId?: SortOrder
    _count?: GiveawaysCountOrderByAggregateInput
    _avg?: GiveawaysAvgOrderByAggregateInput
    _max?: GiveawaysMaxOrderByAggregateInput
    _min?: GiveawaysMinOrderByAggregateInput
    _sum?: GiveawaysSumOrderByAggregateInput
  }

  export type GiveawaysScalarWhereWithAggregatesInput = {
    AND?: GiveawaysScalarWhereWithAggregatesInput | GiveawaysScalarWhereWithAggregatesInput[]
    OR?: GiveawaysScalarWhereWithAggregatesInput[]
    NOT?: GiveawaysScalarWhereWithAggregatesInput | GiveawaysScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Giveaways"> | string
    UUID?: StringWithAggregatesFilter<"Giveaways"> | string
    MessageId?: StringWithAggregatesFilter<"Giveaways"> | string
    ChannelId?: StringNullableWithAggregatesFilter<"Giveaways"> | string | null
    Prize?: StringWithAggregatesFilter<"Giveaways"> | string
    Winners?: IntWithAggregatesFilter<"Giveaways"> | number
    Time?: StringWithAggregatesFilter<"Giveaways"> | string
    CreatedAt?: DateTimeWithAggregatesFilter<"Giveaways"> | Date | string
    Ended?: BoolWithAggregatesFilter<"Giveaways"> | boolean
    EndedAt?: DateTimeNullableWithAggregatesFilter<"Giveaways"> | Date | string | null
    EndedBy?: StringNullableWithAggregatesFilter<"Giveaways"> | string | null
    Paused?: BoolWithAggregatesFilter<"Giveaways"> | boolean
    EndedMessage?: StringNullableWithAggregatesFilter<"Giveaways"> | string | null
    Rerolled?: BoolWithAggregatesFilter<"Giveaways"> | boolean
    WinnerIds?: StringNullableListFilter<"Giveaways">
    WinnerMessageTemplate?: StringNullableWithAggregatesFilter<"Giveaways"> | string | null
    HostedBy?: StringWithAggregatesFilter<"Giveaways"> | string
    MessageTemplate?: StringNullableWithAggregatesFilter<"Giveaways"> | string | null
    Content?: StringNullableWithAggregatesFilter<"Giveaways"> | string | null
    Entrys?: StringNullableListFilter<"Giveaways">
    Requirements?: StringNullableListFilter<"Giveaways">
    GuildId?: StringWithAggregatesFilter<"Giveaways"> | string
  }

  export type TempVoicesWhereInput = {
    AND?: TempVoicesWhereInput | TempVoicesWhereInput[]
    OR?: TempVoicesWhereInput[]
    NOT?: TempVoicesWhereInput | TempVoicesWhereInput[]
    id?: StringFilter<"TempVoices"> | string
    UUID?: StringFilter<"TempVoices"> | string
    Name?: StringFilter<"TempVoices"> | string
    JointoCreateChannel?: StringFilter<"TempVoices"> | string
    JointoCreateCategory?: StringFilter<"TempVoices"> | string
    Manage?: BoolFilter<"TempVoices"> | boolean
    PresetLimit?: IntFilter<"TempVoices"> | number
    GuildId?: StringFilter<"TempVoices"> | string
    TempVoiceChannels?: TempVoiceChannelsListRelationFilter
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }

  export type TempVoicesOrderByWithRelationInput = {
    id?: SortOrder
    UUID?: SortOrder
    Name?: SortOrder
    JointoCreateChannel?: SortOrder
    JointoCreateCategory?: SortOrder
    Manage?: SortOrder
    PresetLimit?: SortOrder
    GuildId?: SortOrder
    TempVoiceChannels?: TempVoiceChannelsOrderByRelationAggregateInput
    Guilds?: GuildsOrderByWithRelationInput
  }

  export type TempVoicesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    UUID?: string
    AND?: TempVoicesWhereInput | TempVoicesWhereInput[]
    OR?: TempVoicesWhereInput[]
    NOT?: TempVoicesWhereInput | TempVoicesWhereInput[]
    Name?: StringFilter<"TempVoices"> | string
    JointoCreateChannel?: StringFilter<"TempVoices"> | string
    JointoCreateCategory?: StringFilter<"TempVoices"> | string
    Manage?: BoolFilter<"TempVoices"> | boolean
    PresetLimit?: IntFilter<"TempVoices"> | number
    GuildId?: StringFilter<"TempVoices"> | string
    TempVoiceChannels?: TempVoiceChannelsListRelationFilter
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }, "id" | "UUID">

  export type TempVoicesOrderByWithAggregationInput = {
    id?: SortOrder
    UUID?: SortOrder
    Name?: SortOrder
    JointoCreateChannel?: SortOrder
    JointoCreateCategory?: SortOrder
    Manage?: SortOrder
    PresetLimit?: SortOrder
    GuildId?: SortOrder
    _count?: TempVoicesCountOrderByAggregateInput
    _avg?: TempVoicesAvgOrderByAggregateInput
    _max?: TempVoicesMaxOrderByAggregateInput
    _min?: TempVoicesMinOrderByAggregateInput
    _sum?: TempVoicesSumOrderByAggregateInput
  }

  export type TempVoicesScalarWhereWithAggregatesInput = {
    AND?: TempVoicesScalarWhereWithAggregatesInput | TempVoicesScalarWhereWithAggregatesInput[]
    OR?: TempVoicesScalarWhereWithAggregatesInput[]
    NOT?: TempVoicesScalarWhereWithAggregatesInput | TempVoicesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TempVoices"> | string
    UUID?: StringWithAggregatesFilter<"TempVoices"> | string
    Name?: StringWithAggregatesFilter<"TempVoices"> | string
    JointoCreateChannel?: StringWithAggregatesFilter<"TempVoices"> | string
    JointoCreateCategory?: StringWithAggregatesFilter<"TempVoices"> | string
    Manage?: BoolWithAggregatesFilter<"TempVoices"> | boolean
    PresetLimit?: IntWithAggregatesFilter<"TempVoices"> | number
    GuildId?: StringWithAggregatesFilter<"TempVoices"> | string
  }

  export type TempVoiceChannelsWhereInput = {
    AND?: TempVoiceChannelsWhereInput | TempVoiceChannelsWhereInput[]
    OR?: TempVoiceChannelsWhereInput[]
    NOT?: TempVoiceChannelsWhereInput | TempVoiceChannelsWhereInput[]
    id?: StringFilter<"TempVoiceChannels"> | string
    GuildId?: StringFilter<"TempVoiceChannels"> | string
    ChannelId?: StringFilter<"TempVoiceChannels"> | string
    OwnerId?: StringFilter<"TempVoiceChannels"> | string
    TempVoiceId?: StringFilter<"TempVoiceChannels"> | string
    TempVoices?: XOR<TempVoicesScalarRelationFilter, TempVoicesWhereInput>
  }

  export type TempVoiceChannelsOrderByWithRelationInput = {
    id?: SortOrder
    GuildId?: SortOrder
    ChannelId?: SortOrder
    OwnerId?: SortOrder
    TempVoiceId?: SortOrder
    TempVoices?: TempVoicesOrderByWithRelationInput
  }

  export type TempVoiceChannelsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ChannelId?: string
    OwnerId?: string
    AND?: TempVoiceChannelsWhereInput | TempVoiceChannelsWhereInput[]
    OR?: TempVoiceChannelsWhereInput[]
    NOT?: TempVoiceChannelsWhereInput | TempVoiceChannelsWhereInput[]
    GuildId?: StringFilter<"TempVoiceChannels"> | string
    TempVoiceId?: StringFilter<"TempVoiceChannels"> | string
    TempVoices?: XOR<TempVoicesScalarRelationFilter, TempVoicesWhereInput>
  }, "id" | "ChannelId" | "OwnerId">

  export type TempVoiceChannelsOrderByWithAggregationInput = {
    id?: SortOrder
    GuildId?: SortOrder
    ChannelId?: SortOrder
    OwnerId?: SortOrder
    TempVoiceId?: SortOrder
    _count?: TempVoiceChannelsCountOrderByAggregateInput
    _max?: TempVoiceChannelsMaxOrderByAggregateInput
    _min?: TempVoiceChannelsMinOrderByAggregateInput
  }

  export type TempVoiceChannelsScalarWhereWithAggregatesInput = {
    AND?: TempVoiceChannelsScalarWhereWithAggregatesInput | TempVoiceChannelsScalarWhereWithAggregatesInput[]
    OR?: TempVoiceChannelsScalarWhereWithAggregatesInput[]
    NOT?: TempVoiceChannelsScalarWhereWithAggregatesInput | TempVoiceChannelsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TempVoiceChannels"> | string
    GuildId?: StringWithAggregatesFilter<"TempVoiceChannels"> | string
    ChannelId?: StringWithAggregatesFilter<"TempVoiceChannels"> | string
    OwnerId?: StringWithAggregatesFilter<"TempVoiceChannels"> | string
    TempVoiceId?: StringWithAggregatesFilter<"TempVoiceChannels"> | string
  }

  export type GuildLeaveSetupsWhereInput = {
    AND?: GuildLeaveSetupsWhereInput | GuildLeaveSetupsWhereInput[]
    OR?: GuildLeaveSetupsWhereInput[]
    NOT?: GuildLeaveSetupsWhereInput | GuildLeaveSetupsWhereInput[]
    id?: StringFilter<"GuildLeaveSetups"> | string
    MessageTemplateId?: StringNullableFilter<"GuildLeaveSetups"> | string | null
    ChannelId?: StringFilter<"GuildLeaveSetups"> | string
    Image?: BoolNullableFilter<"GuildLeaveSetups"> | boolean | null
    ImageData?: XOR<WelcomeLeaveImageDataNullableCompositeFilter, WelcomeLeaveImageDataObjectEqualityInput> | null
    GuildId?: StringFilter<"GuildLeaveSetups"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }

  export type GuildLeaveSetupsOrderByWithRelationInput = {
    id?: SortOrder
    MessageTemplateId?: SortOrder
    ChannelId?: SortOrder
    Image?: SortOrder
    ImageData?: WelcomeLeaveImageDataOrderByInput
    GuildId?: SortOrder
    Guilds?: GuildsOrderByWithRelationInput
  }

  export type GuildLeaveSetupsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ChannelId?: string
    GuildId?: string
    AND?: GuildLeaveSetupsWhereInput | GuildLeaveSetupsWhereInput[]
    OR?: GuildLeaveSetupsWhereInput[]
    NOT?: GuildLeaveSetupsWhereInput | GuildLeaveSetupsWhereInput[]
    MessageTemplateId?: StringNullableFilter<"GuildLeaveSetups"> | string | null
    Image?: BoolNullableFilter<"GuildLeaveSetups"> | boolean | null
    ImageData?: XOR<WelcomeLeaveImageDataNullableCompositeFilter, WelcomeLeaveImageDataObjectEqualityInput> | null
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }, "id" | "ChannelId" | "GuildId">

  export type GuildLeaveSetupsOrderByWithAggregationInput = {
    id?: SortOrder
    MessageTemplateId?: SortOrder
    ChannelId?: SortOrder
    Image?: SortOrder
    GuildId?: SortOrder
    _count?: GuildLeaveSetupsCountOrderByAggregateInput
    _max?: GuildLeaveSetupsMaxOrderByAggregateInput
    _min?: GuildLeaveSetupsMinOrderByAggregateInput
  }

  export type GuildLeaveSetupsScalarWhereWithAggregatesInput = {
    AND?: GuildLeaveSetupsScalarWhereWithAggregatesInput | GuildLeaveSetupsScalarWhereWithAggregatesInput[]
    OR?: GuildLeaveSetupsScalarWhereWithAggregatesInput[]
    NOT?: GuildLeaveSetupsScalarWhereWithAggregatesInput | GuildLeaveSetupsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GuildLeaveSetups"> | string
    MessageTemplateId?: StringNullableWithAggregatesFilter<"GuildLeaveSetups"> | string | null
    ChannelId?: StringWithAggregatesFilter<"GuildLeaveSetups"> | string
    Image?: BoolNullableWithAggregatesFilter<"GuildLeaveSetups"> | boolean | null
    GuildId?: StringWithAggregatesFilter<"GuildLeaveSetups"> | string
  }

  export type GuildWelcomeSetupsWhereInput = {
    AND?: GuildWelcomeSetupsWhereInput | GuildWelcomeSetupsWhereInput[]
    OR?: GuildWelcomeSetupsWhereInput[]
    NOT?: GuildWelcomeSetupsWhereInput | GuildWelcomeSetupsWhereInput[]
    id?: StringFilter<"GuildWelcomeSetups"> | string
    MessageTemplateId?: StringFilter<"GuildWelcomeSetups"> | string
    ChannelId?: StringFilter<"GuildWelcomeSetups"> | string
    Image?: BoolFilter<"GuildWelcomeSetups"> | boolean
    ImageData?: XOR<WelcomeLeaveImageDataCompositeFilter, WelcomeLeaveImageDataObjectEqualityInput>
    GuildId?: StringFilter<"GuildWelcomeSetups"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }

  export type GuildWelcomeSetupsOrderByWithRelationInput = {
    id?: SortOrder
    MessageTemplateId?: SortOrder
    ChannelId?: SortOrder
    Image?: SortOrder
    ImageData?: WelcomeLeaveImageDataOrderByInput
    GuildId?: SortOrder
    Guilds?: GuildsOrderByWithRelationInput
  }

  export type GuildWelcomeSetupsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    GuildId?: string
    AND?: GuildWelcomeSetupsWhereInput | GuildWelcomeSetupsWhereInput[]
    OR?: GuildWelcomeSetupsWhereInput[]
    NOT?: GuildWelcomeSetupsWhereInput | GuildWelcomeSetupsWhereInput[]
    MessageTemplateId?: StringFilter<"GuildWelcomeSetups"> | string
    ChannelId?: StringFilter<"GuildWelcomeSetups"> | string
    Image?: BoolFilter<"GuildWelcomeSetups"> | boolean
    ImageData?: XOR<WelcomeLeaveImageDataCompositeFilter, WelcomeLeaveImageDataObjectEqualityInput>
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }, "id" | "GuildId">

  export type GuildWelcomeSetupsOrderByWithAggregationInput = {
    id?: SortOrder
    MessageTemplateId?: SortOrder
    ChannelId?: SortOrder
    Image?: SortOrder
    GuildId?: SortOrder
    _count?: GuildWelcomeSetupsCountOrderByAggregateInput
    _max?: GuildWelcomeSetupsMaxOrderByAggregateInput
    _min?: GuildWelcomeSetupsMinOrderByAggregateInput
  }

  export type GuildWelcomeSetupsScalarWhereWithAggregatesInput = {
    AND?: GuildWelcomeSetupsScalarWhereWithAggregatesInput | GuildWelcomeSetupsScalarWhereWithAggregatesInput[]
    OR?: GuildWelcomeSetupsScalarWhereWithAggregatesInput[]
    NOT?: GuildWelcomeSetupsScalarWhereWithAggregatesInput | GuildWelcomeSetupsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GuildWelcomeSetups"> | string
    MessageTemplateId?: StringWithAggregatesFilter<"GuildWelcomeSetups"> | string
    ChannelId?: StringWithAggregatesFilter<"GuildWelcomeSetups"> | string
    Image?: BoolWithAggregatesFilter<"GuildWelcomeSetups"> | boolean
    GuildId?: StringWithAggregatesFilter<"GuildWelcomeSetups"> | string
  }

  export type GuildLoggingsWhereInput = {
    AND?: GuildLoggingsWhereInput | GuildLoggingsWhereInput[]
    OR?: GuildLoggingsWhereInput[]
    NOT?: GuildLoggingsWhereInput | GuildLoggingsWhereInput[]
    id?: StringFilter<"GuildLoggings"> | string
    AutoMod?: StringNullableFilter<"GuildLoggings"> | string | null
    Channel?: StringNullableFilter<"GuildLoggings"> | string | null
    Emoji?: StringNullableFilter<"GuildLoggings"> | string | null
    Guild?: StringNullableFilter<"GuildLoggings"> | string | null
    Integration?: StringNullableFilter<"GuildLoggings"> | string | null
    Invite?: StringNullableFilter<"GuildLoggings"> | string | null
    Member?: StringNullableFilter<"GuildLoggings"> | string | null
    Message?: StringNullableFilter<"GuildLoggings"> | string | null
    Moderation?: StringNullableFilter<"GuildLoggings"> | string | null
    Reaction?: StringNullableFilter<"GuildLoggings"> | string | null
    Role?: StringNullableFilter<"GuildLoggings"> | string | null
    SoundBoard?: StringNullableFilter<"GuildLoggings"> | string | null
    Sticker?: StringNullableFilter<"GuildLoggings"> | string | null
    Thread?: StringNullableFilter<"GuildLoggings"> | string | null
    Voice?: StringNullableFilter<"GuildLoggings"> | string | null
    Webhook?: StringNullableFilter<"GuildLoggings"> | string | null
    Ban?: StringNullableFilter<"GuildLoggings"> | string | null
    Kick?: StringNullableFilter<"GuildLoggings"> | string | null
    Poll?: StringNullableFilter<"GuildLoggings"> | string | null
    Stage?: StringNullableFilter<"GuildLoggings"> | string | null
    Event?: StringNullableFilter<"GuildLoggings"> | string | null
    GuildId?: StringFilter<"GuildLoggings"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }

  export type GuildLoggingsOrderByWithRelationInput = {
    id?: SortOrder
    AutoMod?: SortOrder
    Channel?: SortOrder
    Emoji?: SortOrder
    Guild?: SortOrder
    Integration?: SortOrder
    Invite?: SortOrder
    Member?: SortOrder
    Message?: SortOrder
    Moderation?: SortOrder
    Reaction?: SortOrder
    Role?: SortOrder
    SoundBoard?: SortOrder
    Sticker?: SortOrder
    Thread?: SortOrder
    Voice?: SortOrder
    Webhook?: SortOrder
    Ban?: SortOrder
    Kick?: SortOrder
    Poll?: SortOrder
    Stage?: SortOrder
    Event?: SortOrder
    GuildId?: SortOrder
    Guilds?: GuildsOrderByWithRelationInput
  }

  export type GuildLoggingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    GuildId?: string
    AND?: GuildLoggingsWhereInput | GuildLoggingsWhereInput[]
    OR?: GuildLoggingsWhereInput[]
    NOT?: GuildLoggingsWhereInput | GuildLoggingsWhereInput[]
    AutoMod?: StringNullableFilter<"GuildLoggings"> | string | null
    Channel?: StringNullableFilter<"GuildLoggings"> | string | null
    Emoji?: StringNullableFilter<"GuildLoggings"> | string | null
    Guild?: StringNullableFilter<"GuildLoggings"> | string | null
    Integration?: StringNullableFilter<"GuildLoggings"> | string | null
    Invite?: StringNullableFilter<"GuildLoggings"> | string | null
    Member?: StringNullableFilter<"GuildLoggings"> | string | null
    Message?: StringNullableFilter<"GuildLoggings"> | string | null
    Moderation?: StringNullableFilter<"GuildLoggings"> | string | null
    Reaction?: StringNullableFilter<"GuildLoggings"> | string | null
    Role?: StringNullableFilter<"GuildLoggings"> | string | null
    SoundBoard?: StringNullableFilter<"GuildLoggings"> | string | null
    Sticker?: StringNullableFilter<"GuildLoggings"> | string | null
    Thread?: StringNullableFilter<"GuildLoggings"> | string | null
    Voice?: StringNullableFilter<"GuildLoggings"> | string | null
    Webhook?: StringNullableFilter<"GuildLoggings"> | string | null
    Ban?: StringNullableFilter<"GuildLoggings"> | string | null
    Kick?: StringNullableFilter<"GuildLoggings"> | string | null
    Poll?: StringNullableFilter<"GuildLoggings"> | string | null
    Stage?: StringNullableFilter<"GuildLoggings"> | string | null
    Event?: StringNullableFilter<"GuildLoggings"> | string | null
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }, "id" | "GuildId">

  export type GuildLoggingsOrderByWithAggregationInput = {
    id?: SortOrder
    AutoMod?: SortOrder
    Channel?: SortOrder
    Emoji?: SortOrder
    Guild?: SortOrder
    Integration?: SortOrder
    Invite?: SortOrder
    Member?: SortOrder
    Message?: SortOrder
    Moderation?: SortOrder
    Reaction?: SortOrder
    Role?: SortOrder
    SoundBoard?: SortOrder
    Sticker?: SortOrder
    Thread?: SortOrder
    Voice?: SortOrder
    Webhook?: SortOrder
    Ban?: SortOrder
    Kick?: SortOrder
    Poll?: SortOrder
    Stage?: SortOrder
    Event?: SortOrder
    GuildId?: SortOrder
    _count?: GuildLoggingsCountOrderByAggregateInput
    _max?: GuildLoggingsMaxOrderByAggregateInput
    _min?: GuildLoggingsMinOrderByAggregateInput
  }

  export type GuildLoggingsScalarWhereWithAggregatesInput = {
    AND?: GuildLoggingsScalarWhereWithAggregatesInput | GuildLoggingsScalarWhereWithAggregatesInput[]
    OR?: GuildLoggingsScalarWhereWithAggregatesInput[]
    NOT?: GuildLoggingsScalarWhereWithAggregatesInput | GuildLoggingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GuildLoggings"> | string
    AutoMod?: StringNullableWithAggregatesFilter<"GuildLoggings"> | string | null
    Channel?: StringNullableWithAggregatesFilter<"GuildLoggings"> | string | null
    Emoji?: StringNullableWithAggregatesFilter<"GuildLoggings"> | string | null
    Guild?: StringNullableWithAggregatesFilter<"GuildLoggings"> | string | null
    Integration?: StringNullableWithAggregatesFilter<"GuildLoggings"> | string | null
    Invite?: StringNullableWithAggregatesFilter<"GuildLoggings"> | string | null
    Member?: StringNullableWithAggregatesFilter<"GuildLoggings"> | string | null
    Message?: StringNullableWithAggregatesFilter<"GuildLoggings"> | string | null
    Moderation?: StringNullableWithAggregatesFilter<"GuildLoggings"> | string | null
    Reaction?: StringNullableWithAggregatesFilter<"GuildLoggings"> | string | null
    Role?: StringNullableWithAggregatesFilter<"GuildLoggings"> | string | null
    SoundBoard?: StringNullableWithAggregatesFilter<"GuildLoggings"> | string | null
    Sticker?: StringNullableWithAggregatesFilter<"GuildLoggings"> | string | null
    Thread?: StringNullableWithAggregatesFilter<"GuildLoggings"> | string | null
    Voice?: StringNullableWithAggregatesFilter<"GuildLoggings"> | string | null
    Webhook?: StringNullableWithAggregatesFilter<"GuildLoggings"> | string | null
    Ban?: StringNullableWithAggregatesFilter<"GuildLoggings"> | string | null
    Kick?: StringNullableWithAggregatesFilter<"GuildLoggings"> | string | null
    Poll?: StringNullableWithAggregatesFilter<"GuildLoggings"> | string | null
    Stage?: StringNullableWithAggregatesFilter<"GuildLoggings"> | string | null
    Event?: StringNullableWithAggregatesFilter<"GuildLoggings"> | string | null
    GuildId?: StringWithAggregatesFilter<"GuildLoggings"> | string
  }

  export type GuildLoggersWhereInput = {
    AND?: GuildLoggersWhereInput | GuildLoggersWhereInput[]
    OR?: GuildLoggersWhereInput[]
    NOT?: GuildLoggersWhereInput | GuildLoggersWhereInput[]
    id?: StringFilter<"GuildLoggers"> | string
    UUID?: StringFilter<"GuildLoggers"> | string
    Notes?: StringNullableListFilter<"GuildLoggers">
    LogMessage?: StringFilter<"GuildLoggers"> | string
    LogJSON?: StringFilter<"GuildLoggers"> | string
    GuildId?: StringFilter<"GuildLoggers"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }

  export type GuildLoggersOrderByWithRelationInput = {
    id?: SortOrder
    UUID?: SortOrder
    Notes?: SortOrder
    LogMessage?: SortOrder
    LogJSON?: SortOrder
    GuildId?: SortOrder
    Guilds?: GuildsOrderByWithRelationInput
  }

  export type GuildLoggersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    UUID?: string
    AND?: GuildLoggersWhereInput | GuildLoggersWhereInput[]
    OR?: GuildLoggersWhereInput[]
    NOT?: GuildLoggersWhereInput | GuildLoggersWhereInput[]
    Notes?: StringNullableListFilter<"GuildLoggers">
    LogMessage?: StringFilter<"GuildLoggers"> | string
    LogJSON?: StringFilter<"GuildLoggers"> | string
    GuildId?: StringFilter<"GuildLoggers"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }, "id" | "UUID">

  export type GuildLoggersOrderByWithAggregationInput = {
    id?: SortOrder
    UUID?: SortOrder
    Notes?: SortOrder
    LogMessage?: SortOrder
    LogJSON?: SortOrder
    GuildId?: SortOrder
    _count?: GuildLoggersCountOrderByAggregateInput
    _max?: GuildLoggersMaxOrderByAggregateInput
    _min?: GuildLoggersMinOrderByAggregateInput
  }

  export type GuildLoggersScalarWhereWithAggregatesInput = {
    AND?: GuildLoggersScalarWhereWithAggregatesInput | GuildLoggersScalarWhereWithAggregatesInput[]
    OR?: GuildLoggersScalarWhereWithAggregatesInput[]
    NOT?: GuildLoggersScalarWhereWithAggregatesInput | GuildLoggersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GuildLoggers"> | string
    UUID?: StringWithAggregatesFilter<"GuildLoggers"> | string
    Notes?: StringNullableListFilter<"GuildLoggers">
    LogMessage?: StringWithAggregatesFilter<"GuildLoggers"> | string
    LogJSON?: StringWithAggregatesFilter<"GuildLoggers"> | string
    GuildId?: StringWithAggregatesFilter<"GuildLoggers"> | string
  }

  export type MessageTemplatesWhereInput = {
    AND?: MessageTemplatesWhereInput | MessageTemplatesWhereInput[]
    OR?: MessageTemplatesWhereInput[]
    NOT?: MessageTemplatesWhereInput | MessageTemplatesWhereInput[]
    id?: StringFilter<"MessageTemplates"> | string
    Content?: StringNullableFilter<"MessageTemplates"> | string | null
    EmbedJSON?: StringNullableFilter<"MessageTemplates"> | string | null
    OtherEmbeds?: StringNullableListFilter<"MessageTemplates">
    Name?: StringFilter<"MessageTemplates"> | string
    GuildId?: StringFilter<"MessageTemplates"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }

  export type MessageTemplatesOrderByWithRelationInput = {
    id?: SortOrder
    Content?: SortOrder
    EmbedJSON?: SortOrder
    OtherEmbeds?: SortOrder
    Name?: SortOrder
    GuildId?: SortOrder
    Guilds?: GuildsOrderByWithRelationInput
  }

  export type MessageTemplatesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    Name?: string
    AND?: MessageTemplatesWhereInput | MessageTemplatesWhereInput[]
    OR?: MessageTemplatesWhereInput[]
    NOT?: MessageTemplatesWhereInput | MessageTemplatesWhereInput[]
    Content?: StringNullableFilter<"MessageTemplates"> | string | null
    EmbedJSON?: StringNullableFilter<"MessageTemplates"> | string | null
    OtherEmbeds?: StringNullableListFilter<"MessageTemplates">
    GuildId?: StringFilter<"MessageTemplates"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }, "id" | "Name">

  export type MessageTemplatesOrderByWithAggregationInput = {
    id?: SortOrder
    Content?: SortOrder
    EmbedJSON?: SortOrder
    OtherEmbeds?: SortOrder
    Name?: SortOrder
    GuildId?: SortOrder
    _count?: MessageTemplatesCountOrderByAggregateInput
    _max?: MessageTemplatesMaxOrderByAggregateInput
    _min?: MessageTemplatesMinOrderByAggregateInput
  }

  export type MessageTemplatesScalarWhereWithAggregatesInput = {
    AND?: MessageTemplatesScalarWhereWithAggregatesInput | MessageTemplatesScalarWhereWithAggregatesInput[]
    OR?: MessageTemplatesScalarWhereWithAggregatesInput[]
    NOT?: MessageTemplatesScalarWhereWithAggregatesInput | MessageTemplatesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageTemplates"> | string
    Content?: StringNullableWithAggregatesFilter<"MessageTemplates"> | string | null
    EmbedJSON?: StringNullableWithAggregatesFilter<"MessageTemplates"> | string | null
    OtherEmbeds?: StringNullableListFilter<"MessageTemplates">
    Name?: StringWithAggregatesFilter<"MessageTemplates"> | string
    GuildId?: StringWithAggregatesFilter<"MessageTemplates"> | string
  }

  export type PermissionsWhereInput = {
    AND?: PermissionsWhereInput | PermissionsWhereInput[]
    OR?: PermissionsWhereInput[]
    NOT?: PermissionsWhereInput | PermissionsWhereInput[]
    id?: StringFilter<"Permissions"> | string
    Permissions?: PermissionDataCompositeListFilter | PermissionDataObjectEqualityInput[]
    GuildId?: StringFilter<"Permissions"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }

  export type PermissionsOrderByWithRelationInput = {
    id?: SortOrder
    Permissions?: PermissionDataOrderByCompositeAggregateInput
    GuildId?: SortOrder
    Guilds?: GuildsOrderByWithRelationInput
  }

  export type PermissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    GuildId?: string
    AND?: PermissionsWhereInput | PermissionsWhereInput[]
    OR?: PermissionsWhereInput[]
    NOT?: PermissionsWhereInput | PermissionsWhereInput[]
    Permissions?: PermissionDataCompositeListFilter | PermissionDataObjectEqualityInput[]
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }, "id" | "GuildId">

  export type PermissionsOrderByWithAggregationInput = {
    id?: SortOrder
    GuildId?: SortOrder
    _count?: PermissionsCountOrderByAggregateInput
    _max?: PermissionsMaxOrderByAggregateInput
    _min?: PermissionsMinOrderByAggregateInput
  }

  export type PermissionsScalarWhereWithAggregatesInput = {
    AND?: PermissionsScalarWhereWithAggregatesInput | PermissionsScalarWhereWithAggregatesInput[]
    OR?: PermissionsScalarWhereWithAggregatesInput[]
    NOT?: PermissionsScalarWhereWithAggregatesInput | PermissionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permissions"> | string
    GuildId?: StringWithAggregatesFilter<"Permissions"> | string
  }

  export type ReactionRolesWhereInput = {
    AND?: ReactionRolesWhereInput | ReactionRolesWhereInput[]
    OR?: ReactionRolesWhereInput[]
    NOT?: ReactionRolesWhereInput | ReactionRolesWhereInput[]
    id?: StringFilter<"ReactionRoles"> | string
    UUID?: StringFilter<"ReactionRoles"> | string
    Roles?: StringNullableListFilter<"ReactionRoles">
    MessageId?: StringNullableFilter<"ReactionRoles"> | string | null
    ChannelId?: StringNullableFilter<"ReactionRoles"> | string | null
    AddMessage?: StringNullableFilter<"ReactionRoles"> | string | null
    RemoveMessage?: StringNullableFilter<"ReactionRoles"> | string | null
    Button?: XOR<ReactionRoleButtonNullableCompositeFilter, ReactionRoleButtonObjectEqualityInput> | null
    SelectMenu?: XOR<ReactionRoleSelectmenuNullableCompositeFilter, ReactionRoleSelectmenuObjectEqualityInput> | null
    Emoji?: StringNullableFilter<"ReactionRoles"> | string | null
    GuildId?: StringFilter<"ReactionRoles"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }

  export type ReactionRolesOrderByWithRelationInput = {
    id?: SortOrder
    UUID?: SortOrder
    Roles?: SortOrder
    MessageId?: SortOrder
    ChannelId?: SortOrder
    AddMessage?: SortOrder
    RemoveMessage?: SortOrder
    Button?: ReactionRoleButtonOrderByInput
    SelectMenu?: ReactionRoleSelectmenuOrderByInput
    Emoji?: SortOrder
    GuildId?: SortOrder
    Guilds?: GuildsOrderByWithRelationInput
  }

  export type ReactionRolesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    UUID?: string
    AND?: ReactionRolesWhereInput | ReactionRolesWhereInput[]
    OR?: ReactionRolesWhereInput[]
    NOT?: ReactionRolesWhereInput | ReactionRolesWhereInput[]
    Roles?: StringNullableListFilter<"ReactionRoles">
    MessageId?: StringNullableFilter<"ReactionRoles"> | string | null
    ChannelId?: StringNullableFilter<"ReactionRoles"> | string | null
    AddMessage?: StringNullableFilter<"ReactionRoles"> | string | null
    RemoveMessage?: StringNullableFilter<"ReactionRoles"> | string | null
    Button?: XOR<ReactionRoleButtonNullableCompositeFilter, ReactionRoleButtonObjectEqualityInput> | null
    SelectMenu?: XOR<ReactionRoleSelectmenuNullableCompositeFilter, ReactionRoleSelectmenuObjectEqualityInput> | null
    Emoji?: StringNullableFilter<"ReactionRoles"> | string | null
    GuildId?: StringFilter<"ReactionRoles"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }, "id" | "UUID">

  export type ReactionRolesOrderByWithAggregationInput = {
    id?: SortOrder
    UUID?: SortOrder
    Roles?: SortOrder
    MessageId?: SortOrder
    ChannelId?: SortOrder
    AddMessage?: SortOrder
    RemoveMessage?: SortOrder
    Emoji?: SortOrder
    GuildId?: SortOrder
    _count?: ReactionRolesCountOrderByAggregateInput
    _max?: ReactionRolesMaxOrderByAggregateInput
    _min?: ReactionRolesMinOrderByAggregateInput
  }

  export type ReactionRolesScalarWhereWithAggregatesInput = {
    AND?: ReactionRolesScalarWhereWithAggregatesInput | ReactionRolesScalarWhereWithAggregatesInput[]
    OR?: ReactionRolesScalarWhereWithAggregatesInput[]
    NOT?: ReactionRolesScalarWhereWithAggregatesInput | ReactionRolesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReactionRoles"> | string
    UUID?: StringWithAggregatesFilter<"ReactionRoles"> | string
    Roles?: StringNullableListFilter<"ReactionRoles">
    MessageId?: StringNullableWithAggregatesFilter<"ReactionRoles"> | string | null
    ChannelId?: StringNullableWithAggregatesFilter<"ReactionRoles"> | string | null
    AddMessage?: StringNullableWithAggregatesFilter<"ReactionRoles"> | string | null
    RemoveMessage?: StringNullableWithAggregatesFilter<"ReactionRoles"> | string | null
    Emoji?: StringNullableWithAggregatesFilter<"ReactionRoles"> | string | null
    GuildId?: StringWithAggregatesFilter<"ReactionRoles"> | string
  }

  export type SecuritysWhereInput = {
    AND?: SecuritysWhereInput | SecuritysWhereInput[]
    OR?: SecuritysWhereInput[]
    NOT?: SecuritysWhereInput | SecuritysWhereInput[]
    id?: StringFilter<"Securitys"> | string
    InviteLoggingActive?: StringNullableFilter<"Securitys"> | string | null
    MaxAccountAge?: IntNullableFilter<"Securitys"> | number | null
    GuildId?: StringFilter<"Securitys"> | string
    VerificationGates?: VerificationGatesListRelationFilter
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }

  export type SecuritysOrderByWithRelationInput = {
    id?: SortOrder
    InviteLoggingActive?: SortOrder
    MaxAccountAge?: SortOrder
    GuildId?: SortOrder
    VerificationGates?: VerificationGatesOrderByRelationAggregateInput
    Guilds?: GuildsOrderByWithRelationInput
  }

  export type SecuritysWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    GuildId?: string
    AND?: SecuritysWhereInput | SecuritysWhereInput[]
    OR?: SecuritysWhereInput[]
    NOT?: SecuritysWhereInput | SecuritysWhereInput[]
    InviteLoggingActive?: StringNullableFilter<"Securitys"> | string | null
    MaxAccountAge?: IntNullableFilter<"Securitys"> | number | null
    VerificationGates?: VerificationGatesListRelationFilter
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }, "id" | "GuildId">

  export type SecuritysOrderByWithAggregationInput = {
    id?: SortOrder
    InviteLoggingActive?: SortOrder
    MaxAccountAge?: SortOrder
    GuildId?: SortOrder
    _count?: SecuritysCountOrderByAggregateInput
    _avg?: SecuritysAvgOrderByAggregateInput
    _max?: SecuritysMaxOrderByAggregateInput
    _min?: SecuritysMinOrderByAggregateInput
    _sum?: SecuritysSumOrderByAggregateInput
  }

  export type SecuritysScalarWhereWithAggregatesInput = {
    AND?: SecuritysScalarWhereWithAggregatesInput | SecuritysScalarWhereWithAggregatesInput[]
    OR?: SecuritysScalarWhereWithAggregatesInput[]
    NOT?: SecuritysScalarWhereWithAggregatesInput | SecuritysScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Securitys"> | string
    InviteLoggingActive?: StringNullableWithAggregatesFilter<"Securitys"> | string | null
    MaxAccountAge?: IntNullableWithAggregatesFilter<"Securitys"> | number | null
    GuildId?: StringWithAggregatesFilter<"Securitys"> | string
  }

  export type VerificationGatesWhereInput = {
    AND?: VerificationGatesWhereInput | VerificationGatesWhereInput[]
    OR?: VerificationGatesWhereInput[]
    NOT?: VerificationGatesWhereInput | VerificationGatesWhereInput[]
    id?: StringFilter<"VerificationGates"> | string
    UUID?: StringFilter<"VerificationGates"> | string
    ChannelId?: StringFilter<"VerificationGates"> | string
    MessageId?: StringFilter<"VerificationGates"> | string
    Action?: StringNullableFilter<"VerificationGates"> | string | null
    ActionType?: StringNullableFilter<"VerificationGates"> | string | null
    Roles?: StringNullableListFilter<"VerificationGates">
    VerifiedUsers?: StringNullableListFilter<"VerificationGates">
    CreatedAt?: DateTimeFilter<"VerificationGates"> | Date | string
    Active?: BoolNullableFilter<"VerificationGates"> | boolean | null
    SecurityId?: StringFilter<"VerificationGates"> | string
    ChannelPermissions?: VerificationGatesPermissionListRelationFilter
    VerificationGates?: XOR<SecuritysScalarRelationFilter, SecuritysWhereInput>
  }

  export type VerificationGatesOrderByWithRelationInput = {
    id?: SortOrder
    UUID?: SortOrder
    ChannelId?: SortOrder
    MessageId?: SortOrder
    Action?: SortOrder
    ActionType?: SortOrder
    Roles?: SortOrder
    VerifiedUsers?: SortOrder
    CreatedAt?: SortOrder
    Active?: SortOrder
    SecurityId?: SortOrder
    ChannelPermissions?: VerificationGatesPermissionOrderByRelationAggregateInput
    VerificationGates?: SecuritysOrderByWithRelationInput
  }

  export type VerificationGatesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    UUID?: string
    AND?: VerificationGatesWhereInput | VerificationGatesWhereInput[]
    OR?: VerificationGatesWhereInput[]
    NOT?: VerificationGatesWhereInput | VerificationGatesWhereInput[]
    ChannelId?: StringFilter<"VerificationGates"> | string
    MessageId?: StringFilter<"VerificationGates"> | string
    Action?: StringNullableFilter<"VerificationGates"> | string | null
    ActionType?: StringNullableFilter<"VerificationGates"> | string | null
    Roles?: StringNullableListFilter<"VerificationGates">
    VerifiedUsers?: StringNullableListFilter<"VerificationGates">
    CreatedAt?: DateTimeFilter<"VerificationGates"> | Date | string
    Active?: BoolNullableFilter<"VerificationGates"> | boolean | null
    SecurityId?: StringFilter<"VerificationGates"> | string
    ChannelPermissions?: VerificationGatesPermissionListRelationFilter
    VerificationGates?: XOR<SecuritysScalarRelationFilter, SecuritysWhereInput>
  }, "id" | "UUID">

  export type VerificationGatesOrderByWithAggregationInput = {
    id?: SortOrder
    UUID?: SortOrder
    ChannelId?: SortOrder
    MessageId?: SortOrder
    Action?: SortOrder
    ActionType?: SortOrder
    Roles?: SortOrder
    VerifiedUsers?: SortOrder
    CreatedAt?: SortOrder
    Active?: SortOrder
    SecurityId?: SortOrder
    _count?: VerificationGatesCountOrderByAggregateInput
    _max?: VerificationGatesMaxOrderByAggregateInput
    _min?: VerificationGatesMinOrderByAggregateInput
  }

  export type VerificationGatesScalarWhereWithAggregatesInput = {
    AND?: VerificationGatesScalarWhereWithAggregatesInput | VerificationGatesScalarWhereWithAggregatesInput[]
    OR?: VerificationGatesScalarWhereWithAggregatesInput[]
    NOT?: VerificationGatesScalarWhereWithAggregatesInput | VerificationGatesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerificationGates"> | string
    UUID?: StringWithAggregatesFilter<"VerificationGates"> | string
    ChannelId?: StringWithAggregatesFilter<"VerificationGates"> | string
    MessageId?: StringWithAggregatesFilter<"VerificationGates"> | string
    Action?: StringNullableWithAggregatesFilter<"VerificationGates"> | string | null
    ActionType?: StringNullableWithAggregatesFilter<"VerificationGates"> | string | null
    Roles?: StringNullableListFilter<"VerificationGates">
    VerifiedUsers?: StringNullableListFilter<"VerificationGates">
    CreatedAt?: DateTimeWithAggregatesFilter<"VerificationGates"> | Date | string
    Active?: BoolNullableWithAggregatesFilter<"VerificationGates"> | boolean | null
    SecurityId?: StringWithAggregatesFilter<"VerificationGates"> | string
  }

  export type VerificationGatesPermissionWhereInput = {
    AND?: VerificationGatesPermissionWhereInput | VerificationGatesPermissionWhereInput[]
    OR?: VerificationGatesPermissionWhereInput[]
    NOT?: VerificationGatesPermissionWhereInput | VerificationGatesPermissionWhereInput[]
    id?: StringFilter<"VerificationGatesPermission"> | string
    Permission?: StringNullableListFilter<"VerificationGatesPermission">
    ChannelId?: StringFilter<"VerificationGatesPermission"> | string
    VerificationGateId?: StringFilter<"VerificationGatesPermission"> | string
    VerificationGates?: XOR<VerificationGatesScalarRelationFilter, VerificationGatesWhereInput>
  }

  export type VerificationGatesPermissionOrderByWithRelationInput = {
    id?: SortOrder
    Permission?: SortOrder
    ChannelId?: SortOrder
    VerificationGateId?: SortOrder
    VerificationGates?: VerificationGatesOrderByWithRelationInput
  }

  export type VerificationGatesPermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationGatesPermissionWhereInput | VerificationGatesPermissionWhereInput[]
    OR?: VerificationGatesPermissionWhereInput[]
    NOT?: VerificationGatesPermissionWhereInput | VerificationGatesPermissionWhereInput[]
    Permission?: StringNullableListFilter<"VerificationGatesPermission">
    ChannelId?: StringFilter<"VerificationGatesPermission"> | string
    VerificationGateId?: StringFilter<"VerificationGatesPermission"> | string
    VerificationGates?: XOR<VerificationGatesScalarRelationFilter, VerificationGatesWhereInput>
  }, "id">

  export type VerificationGatesPermissionOrderByWithAggregationInput = {
    id?: SortOrder
    Permission?: SortOrder
    ChannelId?: SortOrder
    VerificationGateId?: SortOrder
    _count?: VerificationGatesPermissionCountOrderByAggregateInput
    _max?: VerificationGatesPermissionMaxOrderByAggregateInput
    _min?: VerificationGatesPermissionMinOrderByAggregateInput
  }

  export type VerificationGatesPermissionScalarWhereWithAggregatesInput = {
    AND?: VerificationGatesPermissionScalarWhereWithAggregatesInput | VerificationGatesPermissionScalarWhereWithAggregatesInput[]
    OR?: VerificationGatesPermissionScalarWhereWithAggregatesInput[]
    NOT?: VerificationGatesPermissionScalarWhereWithAggregatesInput | VerificationGatesPermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerificationGatesPermission"> | string
    Permission?: StringNullableListFilter<"VerificationGatesPermission">
    ChannelId?: StringWithAggregatesFilter<"VerificationGatesPermission"> | string
    VerificationGateId?: StringWithAggregatesFilter<"VerificationGatesPermission"> | string
  }

  export type SpotifyNotificationsWhereInput = {
    AND?: SpotifyNotificationsWhereInput | SpotifyNotificationsWhereInput[]
    OR?: SpotifyNotificationsWhereInput[]
    NOT?: SpotifyNotificationsWhereInput | SpotifyNotificationsWhereInput[]
    id?: StringFilter<"SpotifyNotifications"> | string
    ShowId?: StringFilter<"SpotifyNotifications"> | string
    ChannelId?: StringFilter<"SpotifyNotifications"> | string
    Latests?: StringNullableListFilter<"SpotifyNotifications">
    MessageTemplateId?: StringFilter<"SpotifyNotifications"> | string
    PingRoles?: StringNullableListFilter<"SpotifyNotifications">
    UUID?: StringFilter<"SpotifyNotifications"> | string
    GuildId?: StringFilter<"SpotifyNotifications"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }

  export type SpotifyNotificationsOrderByWithRelationInput = {
    id?: SortOrder
    ShowId?: SortOrder
    ChannelId?: SortOrder
    Latests?: SortOrder
    MessageTemplateId?: SortOrder
    PingRoles?: SortOrder
    UUID?: SortOrder
    GuildId?: SortOrder
    Guilds?: GuildsOrderByWithRelationInput
  }

  export type SpotifyNotificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    UUID?: string
    AND?: SpotifyNotificationsWhereInput | SpotifyNotificationsWhereInput[]
    OR?: SpotifyNotificationsWhereInput[]
    NOT?: SpotifyNotificationsWhereInput | SpotifyNotificationsWhereInput[]
    ShowId?: StringFilter<"SpotifyNotifications"> | string
    ChannelId?: StringFilter<"SpotifyNotifications"> | string
    Latests?: StringNullableListFilter<"SpotifyNotifications">
    MessageTemplateId?: StringFilter<"SpotifyNotifications"> | string
    PingRoles?: StringNullableListFilter<"SpotifyNotifications">
    GuildId?: StringFilter<"SpotifyNotifications"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }, "id" | "UUID">

  export type SpotifyNotificationsOrderByWithAggregationInput = {
    id?: SortOrder
    ShowId?: SortOrder
    ChannelId?: SortOrder
    Latests?: SortOrder
    MessageTemplateId?: SortOrder
    PingRoles?: SortOrder
    UUID?: SortOrder
    GuildId?: SortOrder
    _count?: SpotifyNotificationsCountOrderByAggregateInput
    _max?: SpotifyNotificationsMaxOrderByAggregateInput
    _min?: SpotifyNotificationsMinOrderByAggregateInput
  }

  export type SpotifyNotificationsScalarWhereWithAggregatesInput = {
    AND?: SpotifyNotificationsScalarWhereWithAggregatesInput | SpotifyNotificationsScalarWhereWithAggregatesInput[]
    OR?: SpotifyNotificationsScalarWhereWithAggregatesInput[]
    NOT?: SpotifyNotificationsScalarWhereWithAggregatesInput | SpotifyNotificationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpotifyNotifications"> | string
    ShowId?: StringWithAggregatesFilter<"SpotifyNotifications"> | string
    ChannelId?: StringWithAggregatesFilter<"SpotifyNotifications"> | string
    Latests?: StringNullableListFilter<"SpotifyNotifications">
    MessageTemplateId?: StringWithAggregatesFilter<"SpotifyNotifications"> | string
    PingRoles?: StringNullableListFilter<"SpotifyNotifications">
    UUID?: StringWithAggregatesFilter<"SpotifyNotifications"> | string
    GuildId?: StringWithAggregatesFilter<"SpotifyNotifications"> | string
  }

  export type TagsWhereInput = {
    AND?: TagsWhereInput | TagsWhereInput[]
    OR?: TagsWhereInput[]
    NOT?: TagsWhereInput | TagsWhereInput[]
    id?: StringFilter<"Tags"> | string
    UUID?: StringFilter<"Tags"> | string
    TagId?: StringFilter<"Tags"> | string
    MessageId?: StringFilter<"Tags"> | string
    IsShlashCommand?: BoolFilter<"Tags"> | boolean
    ShlashCommandId?: StringFilter<"Tags"> | string
    IsTextInputCommand?: BoolFilter<"Tags"> | boolean
    IsEnabled?: BoolFilter<"Tags"> | boolean
    PermissionRoleId?: StringNullableFilter<"Tags"> | string | null
    CommandDescription?: StringNullableFilter<"Tags"> | string | null
    FilterTextFromMessages?: StringNullableListFilter<"Tags">
    GuildId?: StringFilter<"Tags"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }

  export type TagsOrderByWithRelationInput = {
    id?: SortOrder
    UUID?: SortOrder
    TagId?: SortOrder
    MessageId?: SortOrder
    IsShlashCommand?: SortOrder
    ShlashCommandId?: SortOrder
    IsTextInputCommand?: SortOrder
    IsEnabled?: SortOrder
    PermissionRoleId?: SortOrder
    CommandDescription?: SortOrder
    FilterTextFromMessages?: SortOrder
    GuildId?: SortOrder
    Guilds?: GuildsOrderByWithRelationInput
  }

  export type TagsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    UUID?: string
    TagId?: string
    ShlashCommandId?: string
    AND?: TagsWhereInput | TagsWhereInput[]
    OR?: TagsWhereInput[]
    NOT?: TagsWhereInput | TagsWhereInput[]
    MessageId?: StringFilter<"Tags"> | string
    IsShlashCommand?: BoolFilter<"Tags"> | boolean
    IsTextInputCommand?: BoolFilter<"Tags"> | boolean
    IsEnabled?: BoolFilter<"Tags"> | boolean
    PermissionRoleId?: StringNullableFilter<"Tags"> | string | null
    CommandDescription?: StringNullableFilter<"Tags"> | string | null
    FilterTextFromMessages?: StringNullableListFilter<"Tags">
    GuildId?: StringFilter<"Tags"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }, "id" | "UUID" | "TagId" | "ShlashCommandId">

  export type TagsOrderByWithAggregationInput = {
    id?: SortOrder
    UUID?: SortOrder
    TagId?: SortOrder
    MessageId?: SortOrder
    IsShlashCommand?: SortOrder
    ShlashCommandId?: SortOrder
    IsTextInputCommand?: SortOrder
    IsEnabled?: SortOrder
    PermissionRoleId?: SortOrder
    CommandDescription?: SortOrder
    FilterTextFromMessages?: SortOrder
    GuildId?: SortOrder
    _count?: TagsCountOrderByAggregateInput
    _max?: TagsMaxOrderByAggregateInput
    _min?: TagsMinOrderByAggregateInput
  }

  export type TagsScalarWhereWithAggregatesInput = {
    AND?: TagsScalarWhereWithAggregatesInput | TagsScalarWhereWithAggregatesInput[]
    OR?: TagsScalarWhereWithAggregatesInput[]
    NOT?: TagsScalarWhereWithAggregatesInput | TagsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tags"> | string
    UUID?: StringWithAggregatesFilter<"Tags"> | string
    TagId?: StringWithAggregatesFilter<"Tags"> | string
    MessageId?: StringWithAggregatesFilter<"Tags"> | string
    IsShlashCommand?: BoolWithAggregatesFilter<"Tags"> | boolean
    ShlashCommandId?: StringWithAggregatesFilter<"Tags"> | string
    IsTextInputCommand?: BoolWithAggregatesFilter<"Tags"> | boolean
    IsEnabled?: BoolWithAggregatesFilter<"Tags"> | boolean
    PermissionRoleId?: StringNullableWithAggregatesFilter<"Tags"> | string | null
    CommandDescription?: StringNullableWithAggregatesFilter<"Tags"> | string | null
    FilterTextFromMessages?: StringNullableListFilter<"Tags">
    GuildId?: StringWithAggregatesFilter<"Tags"> | string
  }

  export type TicketSetupsWhereInput = {
    AND?: TicketSetupsWhereInput | TicketSetupsWhereInput[]
    OR?: TicketSetupsWhereInput[]
    NOT?: TicketSetupsWhereInput | TicketSetupsWhereInput[]
    id?: StringFilter<"TicketSetups"> | string
    CategoryId?: StringNullableFilter<"TicketSetups"> | string | null
    Handlers?: StringNullableListFilter<"TicketSetups">
    HandlerWithShadowPing?: StringNullableListFilter<"TicketSetups">
    CustomId?: StringFilter<"TicketSetups"> | string
    TicketChannelName?: StringNullableFilter<"TicketSetups"> | string | null
    ChannelType?: IntNullableFilter<"TicketSetups"> | number | null
    MessageTempleateId?: StringNullableFilter<"TicketSetups"> | string | null
    TicketBlacklistRoles?: StringNullableListFilter<"TicketSetups">
    TranscriptChannelId?: StringNullableFilter<"TicketSetups"> | string | null
    HasModal?: BoolNullableFilter<"TicketSetups"> | boolean | null
    UserDMWhenCloseMessageTemplateId?: StringNullableFilter<"TicketSetups"> | string | null
    TicketLimit?: IntNullableFilter<"TicketSetups"> | number | null
    WithTicketFeedback?: BoolNullableFilter<"TicketSetups"> | boolean | null
    TicketFeedbackChannelId?: StringNullableFilter<"TicketSetups"> | string | null
    ModalTitle?: StringNullableFilter<"TicketSetups"> | string | null
    TicketCreationCooldownPerUser?: IntNullableFilter<"TicketSetups"> | number | null
    AutoCloseAfterInactivity?: IntNullableFilter<"TicketSetups"> | number | null
    AutoAssignHandler?: StringNullableFilter<"TicketSetups"> | string | null
    AutoReplyMessageTemplateId?: StringNullableFilter<"TicketSetups"> | string | null
    RequiredRoles?: StringNullableListFilter<"TicketSetups">
    OpenTicketWithCommand?: BoolNullableFilter<"TicketSetups"> | boolean | null
    SlashCommandId?: StringNullableFilter<"TicketSetups"> | string | null
    TextCommandName?: StringNullableFilter<"TicketSetups"> | string | null
    SendTranscriptToUser?: BoolNullableFilter<"TicketSetups"> | boolean | null
    GuildId?: StringFilter<"TicketSetups"> | string
    ModalOptions?: TicketModalDataListRelationFilter
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
    Tickets?: TicketsListRelationFilter
  }

  export type TicketSetupsOrderByWithRelationInput = {
    id?: SortOrder
    CategoryId?: SortOrder
    Handlers?: SortOrder
    HandlerWithShadowPing?: SortOrder
    CustomId?: SortOrder
    TicketChannelName?: SortOrder
    ChannelType?: SortOrder
    MessageTempleateId?: SortOrder
    TicketBlacklistRoles?: SortOrder
    TranscriptChannelId?: SortOrder
    HasModal?: SortOrder
    UserDMWhenCloseMessageTemplateId?: SortOrder
    TicketLimit?: SortOrder
    WithTicketFeedback?: SortOrder
    TicketFeedbackChannelId?: SortOrder
    ModalTitle?: SortOrder
    TicketCreationCooldownPerUser?: SortOrder
    AutoCloseAfterInactivity?: SortOrder
    AutoAssignHandler?: SortOrder
    AutoReplyMessageTemplateId?: SortOrder
    RequiredRoles?: SortOrder
    OpenTicketWithCommand?: SortOrder
    SlashCommandId?: SortOrder
    TextCommandName?: SortOrder
    SendTranscriptToUser?: SortOrder
    GuildId?: SortOrder
    ModalOptions?: TicketModalDataOrderByRelationAggregateInput
    Guilds?: GuildsOrderByWithRelationInput
    Tickets?: TicketsOrderByRelationAggregateInput
  }

  export type TicketSetupsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    CustomId?: string
    AND?: TicketSetupsWhereInput | TicketSetupsWhereInput[]
    OR?: TicketSetupsWhereInput[]
    NOT?: TicketSetupsWhereInput | TicketSetupsWhereInput[]
    CategoryId?: StringNullableFilter<"TicketSetups"> | string | null
    Handlers?: StringNullableListFilter<"TicketSetups">
    HandlerWithShadowPing?: StringNullableListFilter<"TicketSetups">
    TicketChannelName?: StringNullableFilter<"TicketSetups"> | string | null
    ChannelType?: IntNullableFilter<"TicketSetups"> | number | null
    MessageTempleateId?: StringNullableFilter<"TicketSetups"> | string | null
    TicketBlacklistRoles?: StringNullableListFilter<"TicketSetups">
    TranscriptChannelId?: StringNullableFilter<"TicketSetups"> | string | null
    HasModal?: BoolNullableFilter<"TicketSetups"> | boolean | null
    UserDMWhenCloseMessageTemplateId?: StringNullableFilter<"TicketSetups"> | string | null
    TicketLimit?: IntNullableFilter<"TicketSetups"> | number | null
    WithTicketFeedback?: BoolNullableFilter<"TicketSetups"> | boolean | null
    TicketFeedbackChannelId?: StringNullableFilter<"TicketSetups"> | string | null
    ModalTitle?: StringNullableFilter<"TicketSetups"> | string | null
    TicketCreationCooldownPerUser?: IntNullableFilter<"TicketSetups"> | number | null
    AutoCloseAfterInactivity?: IntNullableFilter<"TicketSetups"> | number | null
    AutoAssignHandler?: StringNullableFilter<"TicketSetups"> | string | null
    AutoReplyMessageTemplateId?: StringNullableFilter<"TicketSetups"> | string | null
    RequiredRoles?: StringNullableListFilter<"TicketSetups">
    OpenTicketWithCommand?: BoolNullableFilter<"TicketSetups"> | boolean | null
    SlashCommandId?: StringNullableFilter<"TicketSetups"> | string | null
    TextCommandName?: StringNullableFilter<"TicketSetups"> | string | null
    SendTranscriptToUser?: BoolNullableFilter<"TicketSetups"> | boolean | null
    GuildId?: StringFilter<"TicketSetups"> | string
    ModalOptions?: TicketModalDataListRelationFilter
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
    Tickets?: TicketsListRelationFilter
  }, "id" | "CustomId">

  export type TicketSetupsOrderByWithAggregationInput = {
    id?: SortOrder
    CategoryId?: SortOrder
    Handlers?: SortOrder
    HandlerWithShadowPing?: SortOrder
    CustomId?: SortOrder
    TicketChannelName?: SortOrder
    ChannelType?: SortOrder
    MessageTempleateId?: SortOrder
    TicketBlacklistRoles?: SortOrder
    TranscriptChannelId?: SortOrder
    HasModal?: SortOrder
    UserDMWhenCloseMessageTemplateId?: SortOrder
    TicketLimit?: SortOrder
    WithTicketFeedback?: SortOrder
    TicketFeedbackChannelId?: SortOrder
    ModalTitle?: SortOrder
    TicketCreationCooldownPerUser?: SortOrder
    AutoCloseAfterInactivity?: SortOrder
    AutoAssignHandler?: SortOrder
    AutoReplyMessageTemplateId?: SortOrder
    RequiredRoles?: SortOrder
    OpenTicketWithCommand?: SortOrder
    SlashCommandId?: SortOrder
    TextCommandName?: SortOrder
    SendTranscriptToUser?: SortOrder
    GuildId?: SortOrder
    _count?: TicketSetupsCountOrderByAggregateInput
    _avg?: TicketSetupsAvgOrderByAggregateInput
    _max?: TicketSetupsMaxOrderByAggregateInput
    _min?: TicketSetupsMinOrderByAggregateInput
    _sum?: TicketSetupsSumOrderByAggregateInput
  }

  export type TicketSetupsScalarWhereWithAggregatesInput = {
    AND?: TicketSetupsScalarWhereWithAggregatesInput | TicketSetupsScalarWhereWithAggregatesInput[]
    OR?: TicketSetupsScalarWhereWithAggregatesInput[]
    NOT?: TicketSetupsScalarWhereWithAggregatesInput | TicketSetupsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketSetups"> | string
    CategoryId?: StringNullableWithAggregatesFilter<"TicketSetups"> | string | null
    Handlers?: StringNullableListFilter<"TicketSetups">
    HandlerWithShadowPing?: StringNullableListFilter<"TicketSetups">
    CustomId?: StringWithAggregatesFilter<"TicketSetups"> | string
    TicketChannelName?: StringNullableWithAggregatesFilter<"TicketSetups"> | string | null
    ChannelType?: IntNullableWithAggregatesFilter<"TicketSetups"> | number | null
    MessageTempleateId?: StringNullableWithAggregatesFilter<"TicketSetups"> | string | null
    TicketBlacklistRoles?: StringNullableListFilter<"TicketSetups">
    TranscriptChannelId?: StringNullableWithAggregatesFilter<"TicketSetups"> | string | null
    HasModal?: BoolNullableWithAggregatesFilter<"TicketSetups"> | boolean | null
    UserDMWhenCloseMessageTemplateId?: StringNullableWithAggregatesFilter<"TicketSetups"> | string | null
    TicketLimit?: IntNullableWithAggregatesFilter<"TicketSetups"> | number | null
    WithTicketFeedback?: BoolNullableWithAggregatesFilter<"TicketSetups"> | boolean | null
    TicketFeedbackChannelId?: StringNullableWithAggregatesFilter<"TicketSetups"> | string | null
    ModalTitle?: StringNullableWithAggregatesFilter<"TicketSetups"> | string | null
    TicketCreationCooldownPerUser?: IntNullableWithAggregatesFilter<"TicketSetups"> | number | null
    AutoCloseAfterInactivity?: IntNullableWithAggregatesFilter<"TicketSetups"> | number | null
    AutoAssignHandler?: StringNullableWithAggregatesFilter<"TicketSetups"> | string | null
    AutoReplyMessageTemplateId?: StringNullableWithAggregatesFilter<"TicketSetups"> | string | null
    RequiredRoles?: StringNullableListFilter<"TicketSetups">
    OpenTicketWithCommand?: BoolNullableWithAggregatesFilter<"TicketSetups"> | boolean | null
    SlashCommandId?: StringNullableWithAggregatesFilter<"TicketSetups"> | string | null
    TextCommandName?: StringNullableWithAggregatesFilter<"TicketSetups"> | string | null
    SendTranscriptToUser?: BoolNullableWithAggregatesFilter<"TicketSetups"> | boolean | null
    GuildId?: StringWithAggregatesFilter<"TicketSetups"> | string
  }

  export type TicketModalDataWhereInput = {
    AND?: TicketModalDataWhereInput | TicketModalDataWhereInput[]
    OR?: TicketModalDataWhereInput[]
    NOT?: TicketModalDataWhereInput | TicketModalDataWhereInput[]
    id?: StringFilter<"TicketModalData"> | string
    Name?: StringFilter<"TicketModalData"> | string
    Placeholder?: StringFilter<"TicketModalData"> | string
    Type?: IntFilter<"TicketModalData"> | number
    TicketSetupId?: StringFilter<"TicketModalData"> | string
    TicketSetup?: XOR<TicketSetupsScalarRelationFilter, TicketSetupsWhereInput>
  }

  export type TicketModalDataOrderByWithRelationInput = {
    id?: SortOrder
    Name?: SortOrder
    Placeholder?: SortOrder
    Type?: SortOrder
    TicketSetupId?: SortOrder
    TicketSetup?: TicketSetupsOrderByWithRelationInput
  }

  export type TicketModalDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketModalDataWhereInput | TicketModalDataWhereInput[]
    OR?: TicketModalDataWhereInput[]
    NOT?: TicketModalDataWhereInput | TicketModalDataWhereInput[]
    Name?: StringFilter<"TicketModalData"> | string
    Placeholder?: StringFilter<"TicketModalData"> | string
    Type?: IntFilter<"TicketModalData"> | number
    TicketSetupId?: StringFilter<"TicketModalData"> | string
    TicketSetup?: XOR<TicketSetupsScalarRelationFilter, TicketSetupsWhereInput>
  }, "id">

  export type TicketModalDataOrderByWithAggregationInput = {
    id?: SortOrder
    Name?: SortOrder
    Placeholder?: SortOrder
    Type?: SortOrder
    TicketSetupId?: SortOrder
    _count?: TicketModalDataCountOrderByAggregateInput
    _avg?: TicketModalDataAvgOrderByAggregateInput
    _max?: TicketModalDataMaxOrderByAggregateInput
    _min?: TicketModalDataMinOrderByAggregateInput
    _sum?: TicketModalDataSumOrderByAggregateInput
  }

  export type TicketModalDataScalarWhereWithAggregatesInput = {
    AND?: TicketModalDataScalarWhereWithAggregatesInput | TicketModalDataScalarWhereWithAggregatesInput[]
    OR?: TicketModalDataScalarWhereWithAggregatesInput[]
    NOT?: TicketModalDataScalarWhereWithAggregatesInput | TicketModalDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketModalData"> | string
    Name?: StringWithAggregatesFilter<"TicketModalData"> | string
    Placeholder?: StringWithAggregatesFilter<"TicketModalData"> | string
    Type?: IntWithAggregatesFilter<"TicketModalData"> | number
    TicketSetupId?: StringWithAggregatesFilter<"TicketModalData"> | string
  }

  export type TicketHandlersWhereInput = {
    AND?: TicketHandlersWhereInput | TicketHandlersWhereInput[]
    OR?: TicketHandlersWhereInput[]
    NOT?: TicketHandlersWhereInput | TicketHandlersWhereInput[]
    id?: StringFilter<"TicketHandlers"> | string
    DiscordRoleId?: StringFilter<"TicketHandlers"> | string
    TicketPermission?: StringNullableFilter<"TicketHandlers"> | string | null
    AddedDiscordPermission?: StringNullableListFilter<"TicketHandlers">
    RemovedDiscordPermission?: StringNullableListFilter<"TicketHandlers">
  }

  export type TicketHandlersOrderByWithRelationInput = {
    id?: SortOrder
    DiscordRoleId?: SortOrder
    TicketPermission?: SortOrder
    AddedDiscordPermission?: SortOrder
    RemovedDiscordPermission?: SortOrder
  }

  export type TicketHandlersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketHandlersWhereInput | TicketHandlersWhereInput[]
    OR?: TicketHandlersWhereInput[]
    NOT?: TicketHandlersWhereInput | TicketHandlersWhereInput[]
    DiscordRoleId?: StringFilter<"TicketHandlers"> | string
    TicketPermission?: StringNullableFilter<"TicketHandlers"> | string | null
    AddedDiscordPermission?: StringNullableListFilter<"TicketHandlers">
    RemovedDiscordPermission?: StringNullableListFilter<"TicketHandlers">
  }, "id">

  export type TicketHandlersOrderByWithAggregationInput = {
    id?: SortOrder
    DiscordRoleId?: SortOrder
    TicketPermission?: SortOrder
    AddedDiscordPermission?: SortOrder
    RemovedDiscordPermission?: SortOrder
    _count?: TicketHandlersCountOrderByAggregateInput
    _max?: TicketHandlersMaxOrderByAggregateInput
    _min?: TicketHandlersMinOrderByAggregateInput
  }

  export type TicketHandlersScalarWhereWithAggregatesInput = {
    AND?: TicketHandlersScalarWhereWithAggregatesInput | TicketHandlersScalarWhereWithAggregatesInput[]
    OR?: TicketHandlersScalarWhereWithAggregatesInput[]
    NOT?: TicketHandlersScalarWhereWithAggregatesInput | TicketHandlersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketHandlers"> | string
    DiscordRoleId?: StringWithAggregatesFilter<"TicketHandlers"> | string
    TicketPermission?: StringNullableWithAggregatesFilter<"TicketHandlers"> | string | null
    AddedDiscordPermission?: StringNullableListFilter<"TicketHandlers">
    RemovedDiscordPermission?: StringNullableListFilter<"TicketHandlers">
  }

  export type TicketsWhereInput = {
    AND?: TicketsWhereInput | TicketsWhereInput[]
    OR?: TicketsWhereInput[]
    NOT?: TicketsWhereInput | TicketsWhereInput[]
    id?: StringFilter<"Tickets"> | string
    TicketId?: StringFilter<"Tickets"> | string
    GuildId?: StringFilter<"Tickets"> | string
    ChannelId?: StringNullableFilter<"Tickets"> | string | null
    ThreadId?: StringNullableFilter<"Tickets"> | string | null
    IsClaimed?: BoolNullableFilter<"Tickets"> | boolean | null
    IsArchived?: BoolNullableFilter<"Tickets"> | boolean | null
    ArchiveMessageId?: StringNullableFilter<"Tickets"> | string | null
    UserWhoHasClaimedId?: StringNullableFilter<"Tickets"> | string | null
    IsLooked?: BoolNullableFilter<"Tickets"> | boolean | null
    TicketOwnerId?: StringFilter<"Tickets"> | string
    AddedMemberIds?: StringNullableListFilter<"Tickets">
    Handlers?: StringNullableListFilter<"Tickets">
    TranscriptChannelId?: StringFilter<"Tickets"> | string
    TranscriptHTML?: StringNullableFilter<"Tickets"> | string | null
    TicketNotes?: StringNullableListFilter<"Tickets">
    TicketSetupId?: StringFilter<"Tickets"> | string
    TicketSetup?: XOR<TicketSetupsScalarRelationFilter, TicketSetupsWhereInput>
    TicketFeedback?: XOR<TicketFeedbackNullableScalarRelationFilter, TicketFeedbackWhereInput> | null
  }

  export type TicketsOrderByWithRelationInput = {
    id?: SortOrder
    TicketId?: SortOrder
    GuildId?: SortOrder
    ChannelId?: SortOrder
    ThreadId?: SortOrder
    IsClaimed?: SortOrder
    IsArchived?: SortOrder
    ArchiveMessageId?: SortOrder
    UserWhoHasClaimedId?: SortOrder
    IsLooked?: SortOrder
    TicketOwnerId?: SortOrder
    AddedMemberIds?: SortOrder
    Handlers?: SortOrder
    TranscriptChannelId?: SortOrder
    TranscriptHTML?: SortOrder
    TicketNotes?: SortOrder
    TicketSetupId?: SortOrder
    TicketSetup?: TicketSetupsOrderByWithRelationInput
    TicketFeedback?: TicketFeedbackOrderByWithRelationInput
  }

  export type TicketsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    TicketId?: string
    AND?: TicketsWhereInput | TicketsWhereInput[]
    OR?: TicketsWhereInput[]
    NOT?: TicketsWhereInput | TicketsWhereInput[]
    GuildId?: StringFilter<"Tickets"> | string
    ChannelId?: StringNullableFilter<"Tickets"> | string | null
    ThreadId?: StringNullableFilter<"Tickets"> | string | null
    IsClaimed?: BoolNullableFilter<"Tickets"> | boolean | null
    IsArchived?: BoolNullableFilter<"Tickets"> | boolean | null
    ArchiveMessageId?: StringNullableFilter<"Tickets"> | string | null
    UserWhoHasClaimedId?: StringNullableFilter<"Tickets"> | string | null
    IsLooked?: BoolNullableFilter<"Tickets"> | boolean | null
    TicketOwnerId?: StringFilter<"Tickets"> | string
    AddedMemberIds?: StringNullableListFilter<"Tickets">
    Handlers?: StringNullableListFilter<"Tickets">
    TranscriptChannelId?: StringFilter<"Tickets"> | string
    TranscriptHTML?: StringNullableFilter<"Tickets"> | string | null
    TicketNotes?: StringNullableListFilter<"Tickets">
    TicketSetupId?: StringFilter<"Tickets"> | string
    TicketSetup?: XOR<TicketSetupsScalarRelationFilter, TicketSetupsWhereInput>
    TicketFeedback?: XOR<TicketFeedbackNullableScalarRelationFilter, TicketFeedbackWhereInput> | null
  }, "id" | "TicketId">

  export type TicketsOrderByWithAggregationInput = {
    id?: SortOrder
    TicketId?: SortOrder
    GuildId?: SortOrder
    ChannelId?: SortOrder
    ThreadId?: SortOrder
    IsClaimed?: SortOrder
    IsArchived?: SortOrder
    ArchiveMessageId?: SortOrder
    UserWhoHasClaimedId?: SortOrder
    IsLooked?: SortOrder
    TicketOwnerId?: SortOrder
    AddedMemberIds?: SortOrder
    Handlers?: SortOrder
    TranscriptChannelId?: SortOrder
    TranscriptHTML?: SortOrder
    TicketNotes?: SortOrder
    TicketSetupId?: SortOrder
    _count?: TicketsCountOrderByAggregateInput
    _max?: TicketsMaxOrderByAggregateInput
    _min?: TicketsMinOrderByAggregateInput
  }

  export type TicketsScalarWhereWithAggregatesInput = {
    AND?: TicketsScalarWhereWithAggregatesInput | TicketsScalarWhereWithAggregatesInput[]
    OR?: TicketsScalarWhereWithAggregatesInput[]
    NOT?: TicketsScalarWhereWithAggregatesInput | TicketsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tickets"> | string
    TicketId?: StringWithAggregatesFilter<"Tickets"> | string
    GuildId?: StringWithAggregatesFilter<"Tickets"> | string
    ChannelId?: StringNullableWithAggregatesFilter<"Tickets"> | string | null
    ThreadId?: StringNullableWithAggregatesFilter<"Tickets"> | string | null
    IsClaimed?: BoolNullableWithAggregatesFilter<"Tickets"> | boolean | null
    IsArchived?: BoolNullableWithAggregatesFilter<"Tickets"> | boolean | null
    ArchiveMessageId?: StringNullableWithAggregatesFilter<"Tickets"> | string | null
    UserWhoHasClaimedId?: StringNullableWithAggregatesFilter<"Tickets"> | string | null
    IsLooked?: BoolNullableWithAggregatesFilter<"Tickets"> | boolean | null
    TicketOwnerId?: StringWithAggregatesFilter<"Tickets"> | string
    AddedMemberIds?: StringNullableListFilter<"Tickets">
    Handlers?: StringNullableListFilter<"Tickets">
    TranscriptChannelId?: StringWithAggregatesFilter<"Tickets"> | string
    TranscriptHTML?: StringNullableWithAggregatesFilter<"Tickets"> | string | null
    TicketNotes?: StringNullableListFilter<"Tickets">
    TicketSetupId?: StringWithAggregatesFilter<"Tickets"> | string
  }

  export type TicketFeedbackWhereInput = {
    AND?: TicketFeedbackWhereInput | TicketFeedbackWhereInput[]
    OR?: TicketFeedbackWhereInput[]
    NOT?: TicketFeedbackWhereInput | TicketFeedbackWhereInput[]
    id?: StringFilter<"TicketFeedback"> | string
    TicketId?: StringFilter<"TicketFeedback"> | string
    Rating?: IntFilter<"TicketFeedback"> | number
    Comment?: StringNullableFilter<"TicketFeedback"> | string | null
    SubmittedAt?: DateTimeFilter<"TicketFeedback"> | Date | string
    Ticket?: XOR<TicketsScalarRelationFilter, TicketsWhereInput>
  }

  export type TicketFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    TicketId?: SortOrder
    Rating?: SortOrder
    Comment?: SortOrder
    SubmittedAt?: SortOrder
    Ticket?: TicketsOrderByWithRelationInput
  }

  export type TicketFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    TicketId?: string
    AND?: TicketFeedbackWhereInput | TicketFeedbackWhereInput[]
    OR?: TicketFeedbackWhereInput[]
    NOT?: TicketFeedbackWhereInput | TicketFeedbackWhereInput[]
    Rating?: IntFilter<"TicketFeedback"> | number
    Comment?: StringNullableFilter<"TicketFeedback"> | string | null
    SubmittedAt?: DateTimeFilter<"TicketFeedback"> | Date | string
    Ticket?: XOR<TicketsScalarRelationFilter, TicketsWhereInput>
  }, "id" | "TicketId">

  export type TicketFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    TicketId?: SortOrder
    Rating?: SortOrder
    Comment?: SortOrder
    SubmittedAt?: SortOrder
    _count?: TicketFeedbackCountOrderByAggregateInput
    _avg?: TicketFeedbackAvgOrderByAggregateInput
    _max?: TicketFeedbackMaxOrderByAggregateInput
    _min?: TicketFeedbackMinOrderByAggregateInput
    _sum?: TicketFeedbackSumOrderByAggregateInput
  }

  export type TicketFeedbackScalarWhereWithAggregatesInput = {
    AND?: TicketFeedbackScalarWhereWithAggregatesInput | TicketFeedbackScalarWhereWithAggregatesInput[]
    OR?: TicketFeedbackScalarWhereWithAggregatesInput[]
    NOT?: TicketFeedbackScalarWhereWithAggregatesInput | TicketFeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketFeedback"> | string
    TicketId?: StringWithAggregatesFilter<"TicketFeedback"> | string
    Rating?: IntWithAggregatesFilter<"TicketFeedback"> | number
    Comment?: StringNullableWithAggregatesFilter<"TicketFeedback"> | string | null
    SubmittedAt?: DateTimeWithAggregatesFilter<"TicketFeedback"> | Date | string
  }

  export type GuildFeatureTogglesWhereInput = {
    AND?: GuildFeatureTogglesWhereInput | GuildFeatureTogglesWhereInput[]
    OR?: GuildFeatureTogglesWhereInput[]
    NOT?: GuildFeatureTogglesWhereInput | GuildFeatureTogglesWhereInput[]
    id?: StringFilter<"GuildFeatureToggles"> | string
    LevelEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    WecomeEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    LeaveEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    AutoreactEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    AutopublishEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    ConnectionsEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    ChatfilterEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    AutorolesEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    LoggingEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    TwitchEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    YoutubeEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    SpotifyEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    GuildId?: StringFilter<"GuildFeatureToggles"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }

  export type GuildFeatureTogglesOrderByWithRelationInput = {
    id?: SortOrder
    LevelEnabled?: SortOrder
    WecomeEnabled?: SortOrder
    LeaveEnabled?: SortOrder
    AutoreactEnabled?: SortOrder
    AutopublishEnabled?: SortOrder
    ConnectionsEnabled?: SortOrder
    ChatfilterEnabled?: SortOrder
    AutorolesEnabled?: SortOrder
    LoggingEnabled?: SortOrder
    TwitchEnabled?: SortOrder
    YoutubeEnabled?: SortOrder
    SpotifyEnabled?: SortOrder
    GuildId?: SortOrder
    Guilds?: GuildsOrderByWithRelationInput
  }

  export type GuildFeatureTogglesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    GuildId?: string
    AND?: GuildFeatureTogglesWhereInput | GuildFeatureTogglesWhereInput[]
    OR?: GuildFeatureTogglesWhereInput[]
    NOT?: GuildFeatureTogglesWhereInput | GuildFeatureTogglesWhereInput[]
    LevelEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    WecomeEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    LeaveEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    AutoreactEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    AutopublishEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    ConnectionsEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    ChatfilterEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    AutorolesEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    LoggingEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    TwitchEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    YoutubeEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    SpotifyEnabled?: BoolFilter<"GuildFeatureToggles"> | boolean
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }, "id" | "GuildId">

  export type GuildFeatureTogglesOrderByWithAggregationInput = {
    id?: SortOrder
    LevelEnabled?: SortOrder
    WecomeEnabled?: SortOrder
    LeaveEnabled?: SortOrder
    AutoreactEnabled?: SortOrder
    AutopublishEnabled?: SortOrder
    ConnectionsEnabled?: SortOrder
    ChatfilterEnabled?: SortOrder
    AutorolesEnabled?: SortOrder
    LoggingEnabled?: SortOrder
    TwitchEnabled?: SortOrder
    YoutubeEnabled?: SortOrder
    SpotifyEnabled?: SortOrder
    GuildId?: SortOrder
    _count?: GuildFeatureTogglesCountOrderByAggregateInput
    _max?: GuildFeatureTogglesMaxOrderByAggregateInput
    _min?: GuildFeatureTogglesMinOrderByAggregateInput
  }

  export type GuildFeatureTogglesScalarWhereWithAggregatesInput = {
    AND?: GuildFeatureTogglesScalarWhereWithAggregatesInput | GuildFeatureTogglesScalarWhereWithAggregatesInput[]
    OR?: GuildFeatureTogglesScalarWhereWithAggregatesInput[]
    NOT?: GuildFeatureTogglesScalarWhereWithAggregatesInput | GuildFeatureTogglesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GuildFeatureToggles"> | string
    LevelEnabled?: BoolWithAggregatesFilter<"GuildFeatureToggles"> | boolean
    WecomeEnabled?: BoolWithAggregatesFilter<"GuildFeatureToggles"> | boolean
    LeaveEnabled?: BoolWithAggregatesFilter<"GuildFeatureToggles"> | boolean
    AutoreactEnabled?: BoolWithAggregatesFilter<"GuildFeatureToggles"> | boolean
    AutopublishEnabled?: BoolWithAggregatesFilter<"GuildFeatureToggles"> | boolean
    ConnectionsEnabled?: BoolWithAggregatesFilter<"GuildFeatureToggles"> | boolean
    ChatfilterEnabled?: BoolWithAggregatesFilter<"GuildFeatureToggles"> | boolean
    AutorolesEnabled?: BoolWithAggregatesFilter<"GuildFeatureToggles"> | boolean
    LoggingEnabled?: BoolWithAggregatesFilter<"GuildFeatureToggles"> | boolean
    TwitchEnabled?: BoolWithAggregatesFilter<"GuildFeatureToggles"> | boolean
    YoutubeEnabled?: BoolWithAggregatesFilter<"GuildFeatureToggles"> | boolean
    SpotifyEnabled?: BoolWithAggregatesFilter<"GuildFeatureToggles"> | boolean
    GuildId?: StringWithAggregatesFilter<"GuildFeatureToggles"> | string
  }

  export type TwitchNotificationsWhereInput = {
    AND?: TwitchNotificationsWhereInput | TwitchNotificationsWhereInput[]
    OR?: TwitchNotificationsWhereInput[]
    NOT?: TwitchNotificationsWhereInput | TwitchNotificationsWhereInput[]
    id?: StringFilter<"TwitchNotifications"> | string
    UUID?: StringFilter<"TwitchNotifications"> | string
    TwitchChannelName?: StringFilter<"TwitchNotifications"> | string
    ChannelId?: StringFilter<"TwitchNotifications"> | string
    Live?: BoolFilter<"TwitchNotifications"> | boolean
    MessageTemplateId?: StringFilter<"TwitchNotifications"> | string
    PingRoles?: StringNullableListFilter<"TwitchNotifications">
    GuildId?: StringFilter<"TwitchNotifications"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }

  export type TwitchNotificationsOrderByWithRelationInput = {
    id?: SortOrder
    UUID?: SortOrder
    TwitchChannelName?: SortOrder
    ChannelId?: SortOrder
    Live?: SortOrder
    MessageTemplateId?: SortOrder
    PingRoles?: SortOrder
    GuildId?: SortOrder
    Guilds?: GuildsOrderByWithRelationInput
  }

  export type TwitchNotificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    UUID?: string
    AND?: TwitchNotificationsWhereInput | TwitchNotificationsWhereInput[]
    OR?: TwitchNotificationsWhereInput[]
    NOT?: TwitchNotificationsWhereInput | TwitchNotificationsWhereInput[]
    TwitchChannelName?: StringFilter<"TwitchNotifications"> | string
    ChannelId?: StringFilter<"TwitchNotifications"> | string
    Live?: BoolFilter<"TwitchNotifications"> | boolean
    MessageTemplateId?: StringFilter<"TwitchNotifications"> | string
    PingRoles?: StringNullableListFilter<"TwitchNotifications">
    GuildId?: StringFilter<"TwitchNotifications"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }, "id" | "UUID">

  export type TwitchNotificationsOrderByWithAggregationInput = {
    id?: SortOrder
    UUID?: SortOrder
    TwitchChannelName?: SortOrder
    ChannelId?: SortOrder
    Live?: SortOrder
    MessageTemplateId?: SortOrder
    PingRoles?: SortOrder
    GuildId?: SortOrder
    _count?: TwitchNotificationsCountOrderByAggregateInput
    _max?: TwitchNotificationsMaxOrderByAggregateInput
    _min?: TwitchNotificationsMinOrderByAggregateInput
  }

  export type TwitchNotificationsScalarWhereWithAggregatesInput = {
    AND?: TwitchNotificationsScalarWhereWithAggregatesInput | TwitchNotificationsScalarWhereWithAggregatesInput[]
    OR?: TwitchNotificationsScalarWhereWithAggregatesInput[]
    NOT?: TwitchNotificationsScalarWhereWithAggregatesInput | TwitchNotificationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TwitchNotifications"> | string
    UUID?: StringWithAggregatesFilter<"TwitchNotifications"> | string
    TwitchChannelName?: StringWithAggregatesFilter<"TwitchNotifications"> | string
    ChannelId?: StringWithAggregatesFilter<"TwitchNotifications"> | string
    Live?: BoolWithAggregatesFilter<"TwitchNotifications"> | boolean
    MessageTemplateId?: StringWithAggregatesFilter<"TwitchNotifications"> | string
    PingRoles?: StringNullableListFilter<"TwitchNotifications">
    GuildId?: StringWithAggregatesFilter<"TwitchNotifications"> | string
  }

  export type YoutubeNotificationsWhereInput = {
    AND?: YoutubeNotificationsWhereInput | YoutubeNotificationsWhereInput[]
    OR?: YoutubeNotificationsWhereInput[]
    NOT?: YoutubeNotificationsWhereInput | YoutubeNotificationsWhereInput[]
    id?: StringFilter<"YoutubeNotifications"> | string
    YoutubeChannelId?: StringFilter<"YoutubeNotifications"> | string
    ChannelId?: StringFilter<"YoutubeNotifications"> | string
    Latest?: StringNullableListFilter<"YoutubeNotifications">
    MessageTemplateId?: StringFilter<"YoutubeNotifications"> | string
    PingRoles?: StringNullableListFilter<"YoutubeNotifications">
    UUID?: StringFilter<"YoutubeNotifications"> | string
    GuildId?: StringFilter<"YoutubeNotifications"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }

  export type YoutubeNotificationsOrderByWithRelationInput = {
    id?: SortOrder
    YoutubeChannelId?: SortOrder
    ChannelId?: SortOrder
    Latest?: SortOrder
    MessageTemplateId?: SortOrder
    PingRoles?: SortOrder
    UUID?: SortOrder
    GuildId?: SortOrder
    Guilds?: GuildsOrderByWithRelationInput
  }

  export type YoutubeNotificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    UUID?: string
    AND?: YoutubeNotificationsWhereInput | YoutubeNotificationsWhereInput[]
    OR?: YoutubeNotificationsWhereInput[]
    NOT?: YoutubeNotificationsWhereInput | YoutubeNotificationsWhereInput[]
    YoutubeChannelId?: StringFilter<"YoutubeNotifications"> | string
    ChannelId?: StringFilter<"YoutubeNotifications"> | string
    Latest?: StringNullableListFilter<"YoutubeNotifications">
    MessageTemplateId?: StringFilter<"YoutubeNotifications"> | string
    PingRoles?: StringNullableListFilter<"YoutubeNotifications">
    GuildId?: StringFilter<"YoutubeNotifications"> | string
    Guilds?: XOR<GuildsScalarRelationFilter, GuildsWhereInput>
  }, "id" | "UUID">

  export type YoutubeNotificationsOrderByWithAggregationInput = {
    id?: SortOrder
    YoutubeChannelId?: SortOrder
    ChannelId?: SortOrder
    Latest?: SortOrder
    MessageTemplateId?: SortOrder
    PingRoles?: SortOrder
    UUID?: SortOrder
    GuildId?: SortOrder
    _count?: YoutubeNotificationsCountOrderByAggregateInput
    _max?: YoutubeNotificationsMaxOrderByAggregateInput
    _min?: YoutubeNotificationsMinOrderByAggregateInput
  }

  export type YoutubeNotificationsScalarWhereWithAggregatesInput = {
    AND?: YoutubeNotificationsScalarWhereWithAggregatesInput | YoutubeNotificationsScalarWhereWithAggregatesInput[]
    OR?: YoutubeNotificationsScalarWhereWithAggregatesInput[]
    NOT?: YoutubeNotificationsScalarWhereWithAggregatesInput | YoutubeNotificationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"YoutubeNotifications"> | string
    YoutubeChannelId?: StringWithAggregatesFilter<"YoutubeNotifications"> | string
    ChannelId?: StringWithAggregatesFilter<"YoutubeNotifications"> | string
    Latest?: StringNullableListFilter<"YoutubeNotifications">
    MessageTemplateId?: StringWithAggregatesFilter<"YoutubeNotifications"> | string
    PingRoles?: StringNullableListFilter<"YoutubeNotifications">
    UUID?: StringWithAggregatesFilter<"YoutubeNotifications"> | string
    GuildId?: StringWithAggregatesFilter<"YoutubeNotifications"> | string
  }

  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    id?: StringFilter<"Users"> | string
    Username?: StringFilter<"Users"> | string
    UserId?: StringFilter<"Users"> | string
    Votes?: IntFilter<"Users"> | number
    GloablVotes?: IntFilter<"Users"> | number
    CustomerBots?: IntFilter<"Users"> | number
    BackupCount?: IntFilter<"Users"> | number
    Apiss?: ApisListRelationFilter
    GuildBackups?: GuildBackupsListRelationFilter
    Customers?: CustomersListRelationFilter
    DisBotUserNotifications?: XOR<DisBotUserNotificationsNullableScalarRelationFilter, DisBotUserNotificationsWhereInput> | null
    Vanitys?: VanitysListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder
    Username?: SortOrder
    UserId?: SortOrder
    Votes?: SortOrder
    GloablVotes?: SortOrder
    CustomerBots?: SortOrder
    BackupCount?: SortOrder
    Apiss?: ApisOrderByRelationAggregateInput
    GuildBackups?: GuildBackupsOrderByRelationAggregateInput
    Customers?: CustomersOrderByRelationAggregateInput
    DisBotUserNotifications?: DisBotUserNotificationsOrderByWithRelationInput
    Vanitys?: VanitysOrderByRelationAggregateInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    UserId?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    Username?: StringFilter<"Users"> | string
    Votes?: IntFilter<"Users"> | number
    GloablVotes?: IntFilter<"Users"> | number
    CustomerBots?: IntFilter<"Users"> | number
    BackupCount?: IntFilter<"Users"> | number
    Apiss?: ApisListRelationFilter
    GuildBackups?: GuildBackupsListRelationFilter
    Customers?: CustomersListRelationFilter
    DisBotUserNotifications?: XOR<DisBotUserNotificationsNullableScalarRelationFilter, DisBotUserNotificationsWhereInput> | null
    Vanitys?: VanitysListRelationFilter
  }, "id" | "UserId">

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder
    Username?: SortOrder
    UserId?: SortOrder
    Votes?: SortOrder
    GloablVotes?: SortOrder
    CustomerBots?: SortOrder
    BackupCount?: SortOrder
    _count?: UsersCountOrderByAggregateInput
    _avg?: UsersAvgOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
    _sum?: UsersSumOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Users"> | string
    Username?: StringWithAggregatesFilter<"Users"> | string
    UserId?: StringWithAggregatesFilter<"Users"> | string
    Votes?: IntWithAggregatesFilter<"Users"> | number
    GloablVotes?: IntWithAggregatesFilter<"Users"> | number
    CustomerBots?: IntWithAggregatesFilter<"Users"> | number
    BackupCount?: IntWithAggregatesFilter<"Users"> | number
  }

  export type ApisWhereInput = {
    AND?: ApisWhereInput | ApisWhereInput[]
    OR?: ApisWhereInput[]
    NOT?: ApisWhereInput | ApisWhereInput[]
    id?: StringFilter<"Apis"> | string
    Flags?: StringNullableListFilter<"Apis">
    Guilds?: StringNullableListFilter<"Apis">
    Key?: StringFilter<"Apis"> | string
    UserId?: StringFilter<"Apis"> | string
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type ApisOrderByWithRelationInput = {
    id?: SortOrder
    Flags?: SortOrder
    Guilds?: SortOrder
    Key?: SortOrder
    UserId?: SortOrder
    Users?: UsersOrderByWithRelationInput
  }

  export type ApisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    Key?: string
    UserId?: string
    AND?: ApisWhereInput | ApisWhereInput[]
    OR?: ApisWhereInput[]
    NOT?: ApisWhereInput | ApisWhereInput[]
    Flags?: StringNullableListFilter<"Apis">
    Guilds?: StringNullableListFilter<"Apis">
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id" | "Key" | "UserId">

  export type ApisOrderByWithAggregationInput = {
    id?: SortOrder
    Flags?: SortOrder
    Guilds?: SortOrder
    Key?: SortOrder
    UserId?: SortOrder
    _count?: ApisCountOrderByAggregateInput
    _max?: ApisMaxOrderByAggregateInput
    _min?: ApisMinOrderByAggregateInput
  }

  export type ApisScalarWhereWithAggregatesInput = {
    AND?: ApisScalarWhereWithAggregatesInput | ApisScalarWhereWithAggregatesInput[]
    OR?: ApisScalarWhereWithAggregatesInput[]
    NOT?: ApisScalarWhereWithAggregatesInput | ApisScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Apis"> | string
    Flags?: StringNullableListFilter<"Apis">
    Guilds?: StringNullableListFilter<"Apis">
    Key?: StringWithAggregatesFilter<"Apis"> | string
    UserId?: StringWithAggregatesFilter<"Apis"> | string
  }

  export type GuildBackupsWhereInput = {
    AND?: GuildBackupsWhereInput | GuildBackupsWhereInput[]
    OR?: GuildBackupsWhereInput[]
    NOT?: GuildBackupsWhereInput | GuildBackupsWhereInput[]
    id?: StringFilter<"GuildBackups"> | string
    BackupJSON?: JsonFilter<"GuildBackups">
    CreatedAt?: DateTimeFilter<"GuildBackups"> | Date | string
    UUID?: StringFilter<"GuildBackups"> | string
    Name?: StringFilter<"GuildBackups"> | string
    GuildId?: StringFilter<"GuildBackups"> | string
    UserId?: StringFilter<"GuildBackups"> | string
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type GuildBackupsOrderByWithRelationInput = {
    id?: SortOrder
    BackupJSON?: SortOrder
    CreatedAt?: SortOrder
    UUID?: SortOrder
    Name?: SortOrder
    GuildId?: SortOrder
    UserId?: SortOrder
    Users?: UsersOrderByWithRelationInput
  }

  export type GuildBackupsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    UUID?: string
    AND?: GuildBackupsWhereInput | GuildBackupsWhereInput[]
    OR?: GuildBackupsWhereInput[]
    NOT?: GuildBackupsWhereInput | GuildBackupsWhereInput[]
    BackupJSON?: JsonFilter<"GuildBackups">
    CreatedAt?: DateTimeFilter<"GuildBackups"> | Date | string
    Name?: StringFilter<"GuildBackups"> | string
    GuildId?: StringFilter<"GuildBackups"> | string
    UserId?: StringFilter<"GuildBackups"> | string
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id" | "UUID">

  export type GuildBackupsOrderByWithAggregationInput = {
    id?: SortOrder
    BackupJSON?: SortOrder
    CreatedAt?: SortOrder
    UUID?: SortOrder
    Name?: SortOrder
    GuildId?: SortOrder
    UserId?: SortOrder
    _count?: GuildBackupsCountOrderByAggregateInput
    _max?: GuildBackupsMaxOrderByAggregateInput
    _min?: GuildBackupsMinOrderByAggregateInput
  }

  export type GuildBackupsScalarWhereWithAggregatesInput = {
    AND?: GuildBackupsScalarWhereWithAggregatesInput | GuildBackupsScalarWhereWithAggregatesInput[]
    OR?: GuildBackupsScalarWhereWithAggregatesInput[]
    NOT?: GuildBackupsScalarWhereWithAggregatesInput | GuildBackupsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GuildBackups"> | string
    BackupJSON?: JsonWithAggregatesFilter<"GuildBackups">
    CreatedAt?: DateTimeWithAggregatesFilter<"GuildBackups"> | Date | string
    UUID?: StringWithAggregatesFilter<"GuildBackups"> | string
    Name?: StringWithAggregatesFilter<"GuildBackups"> | string
    GuildId?: StringWithAggregatesFilter<"GuildBackups"> | string
    UserId?: StringWithAggregatesFilter<"GuildBackups"> | string
  }

  export type CustomersWhereInput = {
    AND?: CustomersWhereInput | CustomersWhereInput[]
    OR?: CustomersWhereInput[]
    NOT?: CustomersWhereInput | CustomersWhereInput[]
    id?: StringFilter<"Customers"> | string
    ExternalUUID?: StringFilter<"Customers"> | string
    RealUUID?: StringFilter<"Customers"> | string
    Application?: StringFilter<"Customers"> | string
    BotStatus?: XOR<BotStatusCompositeFilter, BotStatusObjectEqualityInput>
    DisplayName?: StringFilter<"Customers"> | string
    GuildIds?: StringNullableListFilter<"Customers">
    ServerPort?: StringFilter<"Customers"> | string
    WSAPI?: StringFilter<"Customers"> | string
    UserId?: StringFilter<"Customers"> | string
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type CustomersOrderByWithRelationInput = {
    id?: SortOrder
    ExternalUUID?: SortOrder
    RealUUID?: SortOrder
    Application?: SortOrder
    BotStatus?: BotStatusOrderByInput
    DisplayName?: SortOrder
    GuildIds?: SortOrder
    ServerPort?: SortOrder
    WSAPI?: SortOrder
    UserId?: SortOrder
    Users?: UsersOrderByWithRelationInput
  }

  export type CustomersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomersWhereInput | CustomersWhereInput[]
    OR?: CustomersWhereInput[]
    NOT?: CustomersWhereInput | CustomersWhereInput[]
    ExternalUUID?: StringFilter<"Customers"> | string
    RealUUID?: StringFilter<"Customers"> | string
    Application?: StringFilter<"Customers"> | string
    BotStatus?: XOR<BotStatusCompositeFilter, BotStatusObjectEqualityInput>
    DisplayName?: StringFilter<"Customers"> | string
    GuildIds?: StringNullableListFilter<"Customers">
    ServerPort?: StringFilter<"Customers"> | string
    WSAPI?: StringFilter<"Customers"> | string
    UserId?: StringFilter<"Customers"> | string
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id">

  export type CustomersOrderByWithAggregationInput = {
    id?: SortOrder
    ExternalUUID?: SortOrder
    RealUUID?: SortOrder
    Application?: SortOrder
    DisplayName?: SortOrder
    GuildIds?: SortOrder
    ServerPort?: SortOrder
    WSAPI?: SortOrder
    UserId?: SortOrder
    _count?: CustomersCountOrderByAggregateInput
    _max?: CustomersMaxOrderByAggregateInput
    _min?: CustomersMinOrderByAggregateInput
  }

  export type CustomersScalarWhereWithAggregatesInput = {
    AND?: CustomersScalarWhereWithAggregatesInput | CustomersScalarWhereWithAggregatesInput[]
    OR?: CustomersScalarWhereWithAggregatesInput[]
    NOT?: CustomersScalarWhereWithAggregatesInput | CustomersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customers"> | string
    ExternalUUID?: StringWithAggregatesFilter<"Customers"> | string
    RealUUID?: StringWithAggregatesFilter<"Customers"> | string
    Application?: StringWithAggregatesFilter<"Customers"> | string
    DisplayName?: StringWithAggregatesFilter<"Customers"> | string
    GuildIds?: StringNullableListFilter<"Customers">
    ServerPort?: StringWithAggregatesFilter<"Customers"> | string
    WSAPI?: StringWithAggregatesFilter<"Customers"> | string
    UserId?: StringWithAggregatesFilter<"Customers"> | string
  }

  export type VanitysWhereInput = {
    AND?: VanitysWhereInput | VanitysWhereInput[]
    OR?: VanitysWhereInput[]
    NOT?: VanitysWhereInput | VanitysWhereInput[]
    id?: StringFilter<"Vanitys"> | string
    UUID?: StringFilter<"Vanitys"> | string
    Slug?: StringFilter<"Vanitys"> | string
    Host?: StringFilter<"Vanitys"> | string
    GuildId?: StringFilter<"Vanitys"> | string
    Invite?: StringFilter<"Vanitys"> | string
    CreatedAt?: DateTimeFilter<"Vanitys"> | Date | string
    UserId?: StringFilter<"Vanitys"> | string
    Analytics?: XOR<VanityAnalyticsNullableScalarRelationFilter, VanityAnalyticsWhereInput> | null
    Embed?: XOR<VanityEmbedsNullableScalarRelationFilter, VanityEmbedsWhereInput> | null
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type VanitysOrderByWithRelationInput = {
    id?: SortOrder
    UUID?: SortOrder
    Slug?: SortOrder
    Host?: SortOrder
    GuildId?: SortOrder
    Invite?: SortOrder
    CreatedAt?: SortOrder
    UserId?: SortOrder
    Analytics?: VanityAnalyticsOrderByWithRelationInput
    Embed?: VanityEmbedsOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type VanitysWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    UUID?: string
    AND?: VanitysWhereInput | VanitysWhereInput[]
    OR?: VanitysWhereInput[]
    NOT?: VanitysWhereInput | VanitysWhereInput[]
    Slug?: StringFilter<"Vanitys"> | string
    Host?: StringFilter<"Vanitys"> | string
    GuildId?: StringFilter<"Vanitys"> | string
    Invite?: StringFilter<"Vanitys"> | string
    CreatedAt?: DateTimeFilter<"Vanitys"> | Date | string
    UserId?: StringFilter<"Vanitys"> | string
    Analytics?: XOR<VanityAnalyticsNullableScalarRelationFilter, VanityAnalyticsWhereInput> | null
    Embed?: XOR<VanityEmbedsNullableScalarRelationFilter, VanityEmbedsWhereInput> | null
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id" | "UUID">

  export type VanitysOrderByWithAggregationInput = {
    id?: SortOrder
    UUID?: SortOrder
    Slug?: SortOrder
    Host?: SortOrder
    GuildId?: SortOrder
    Invite?: SortOrder
    CreatedAt?: SortOrder
    UserId?: SortOrder
    _count?: VanitysCountOrderByAggregateInput
    _max?: VanitysMaxOrderByAggregateInput
    _min?: VanitysMinOrderByAggregateInput
  }

  export type VanitysScalarWhereWithAggregatesInput = {
    AND?: VanitysScalarWhereWithAggregatesInput | VanitysScalarWhereWithAggregatesInput[]
    OR?: VanitysScalarWhereWithAggregatesInput[]
    NOT?: VanitysScalarWhereWithAggregatesInput | VanitysScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vanitys"> | string
    UUID?: StringWithAggregatesFilter<"Vanitys"> | string
    Slug?: StringWithAggregatesFilter<"Vanitys"> | string
    Host?: StringWithAggregatesFilter<"Vanitys"> | string
    GuildId?: StringWithAggregatesFilter<"Vanitys"> | string
    Invite?: StringWithAggregatesFilter<"Vanitys"> | string
    CreatedAt?: DateTimeWithAggregatesFilter<"Vanitys"> | Date | string
    UserId?: StringWithAggregatesFilter<"Vanitys"> | string
  }

  export type VanityEmbedsWhereInput = {
    AND?: VanityEmbedsWhereInput | VanityEmbedsWhereInput[]
    OR?: VanityEmbedsWhereInput[]
    NOT?: VanityEmbedsWhereInput | VanityEmbedsWhereInput[]
    id?: StringFilter<"VanityEmbeds"> | string
    Title?: StringFilter<"VanityEmbeds"> | string
    Description?: StringFilter<"VanityEmbeds"> | string
    Color?: StringFilter<"VanityEmbeds"> | string
    ImageUrl?: StringFilter<"VanityEmbeds"> | string
    ThumbnailUrl?: StringFilter<"VanityEmbeds"> | string
    VanityId?: StringFilter<"VanityEmbeds"> | string
    Author?: XOR<VanityEmbedAuthorsNullableScalarRelationFilter, VanityEmbedAuthorsWhereInput> | null
    Vanitys?: XOR<VanitysScalarRelationFilter, VanitysWhereInput>
  }

  export type VanityEmbedsOrderByWithRelationInput = {
    id?: SortOrder
    Title?: SortOrder
    Description?: SortOrder
    Color?: SortOrder
    ImageUrl?: SortOrder
    ThumbnailUrl?: SortOrder
    VanityId?: SortOrder
    Author?: VanityEmbedAuthorsOrderByWithRelationInput
    Vanitys?: VanitysOrderByWithRelationInput
  }

  export type VanityEmbedsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    VanityId?: string
    AND?: VanityEmbedsWhereInput | VanityEmbedsWhereInput[]
    OR?: VanityEmbedsWhereInput[]
    NOT?: VanityEmbedsWhereInput | VanityEmbedsWhereInput[]
    Title?: StringFilter<"VanityEmbeds"> | string
    Description?: StringFilter<"VanityEmbeds"> | string
    Color?: StringFilter<"VanityEmbeds"> | string
    ImageUrl?: StringFilter<"VanityEmbeds"> | string
    ThumbnailUrl?: StringFilter<"VanityEmbeds"> | string
    Author?: XOR<VanityEmbedAuthorsNullableScalarRelationFilter, VanityEmbedAuthorsWhereInput> | null
    Vanitys?: XOR<VanitysScalarRelationFilter, VanitysWhereInput>
  }, "id" | "VanityId">

  export type VanityEmbedsOrderByWithAggregationInput = {
    id?: SortOrder
    Title?: SortOrder
    Description?: SortOrder
    Color?: SortOrder
    ImageUrl?: SortOrder
    ThumbnailUrl?: SortOrder
    VanityId?: SortOrder
    _count?: VanityEmbedsCountOrderByAggregateInput
    _max?: VanityEmbedsMaxOrderByAggregateInput
    _min?: VanityEmbedsMinOrderByAggregateInput
  }

  export type VanityEmbedsScalarWhereWithAggregatesInput = {
    AND?: VanityEmbedsScalarWhereWithAggregatesInput | VanityEmbedsScalarWhereWithAggregatesInput[]
    OR?: VanityEmbedsScalarWhereWithAggregatesInput[]
    NOT?: VanityEmbedsScalarWhereWithAggregatesInput | VanityEmbedsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VanityEmbeds"> | string
    Title?: StringWithAggregatesFilter<"VanityEmbeds"> | string
    Description?: StringWithAggregatesFilter<"VanityEmbeds"> | string
    Color?: StringWithAggregatesFilter<"VanityEmbeds"> | string
    ImageUrl?: StringWithAggregatesFilter<"VanityEmbeds"> | string
    ThumbnailUrl?: StringWithAggregatesFilter<"VanityEmbeds"> | string
    VanityId?: StringWithAggregatesFilter<"VanityEmbeds"> | string
  }

  export type VanityEmbedAuthorsWhereInput = {
    AND?: VanityEmbedAuthorsWhereInput | VanityEmbedAuthorsWhereInput[]
    OR?: VanityEmbedAuthorsWhereInput[]
    NOT?: VanityEmbedAuthorsWhereInput | VanityEmbedAuthorsWhereInput[]
    id?: StringFilter<"VanityEmbedAuthors"> | string
    Name?: StringFilter<"VanityEmbedAuthors"> | string
    URL?: StringFilter<"VanityEmbedAuthors"> | string
    IconURL?: StringFilter<"VanityEmbedAuthors"> | string
    VanityEmbedsId?: StringFilter<"VanityEmbedAuthors"> | string
    VanityEmbeds?: XOR<VanityEmbedsScalarRelationFilter, VanityEmbedsWhereInput>
  }

  export type VanityEmbedAuthorsOrderByWithRelationInput = {
    id?: SortOrder
    Name?: SortOrder
    URL?: SortOrder
    IconURL?: SortOrder
    VanityEmbedsId?: SortOrder
    VanityEmbeds?: VanityEmbedsOrderByWithRelationInput
  }

  export type VanityEmbedAuthorsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    VanityEmbedsId?: string
    AND?: VanityEmbedAuthorsWhereInput | VanityEmbedAuthorsWhereInput[]
    OR?: VanityEmbedAuthorsWhereInput[]
    NOT?: VanityEmbedAuthorsWhereInput | VanityEmbedAuthorsWhereInput[]
    Name?: StringFilter<"VanityEmbedAuthors"> | string
    URL?: StringFilter<"VanityEmbedAuthors"> | string
    IconURL?: StringFilter<"VanityEmbedAuthors"> | string
    VanityEmbeds?: XOR<VanityEmbedsScalarRelationFilter, VanityEmbedsWhereInput>
  }, "id" | "VanityEmbedsId">

  export type VanityEmbedAuthorsOrderByWithAggregationInput = {
    id?: SortOrder
    Name?: SortOrder
    URL?: SortOrder
    IconURL?: SortOrder
    VanityEmbedsId?: SortOrder
    _count?: VanityEmbedAuthorsCountOrderByAggregateInput
    _max?: VanityEmbedAuthorsMaxOrderByAggregateInput
    _min?: VanityEmbedAuthorsMinOrderByAggregateInput
  }

  export type VanityEmbedAuthorsScalarWhereWithAggregatesInput = {
    AND?: VanityEmbedAuthorsScalarWhereWithAggregatesInput | VanityEmbedAuthorsScalarWhereWithAggregatesInput[]
    OR?: VanityEmbedAuthorsScalarWhereWithAggregatesInput[]
    NOT?: VanityEmbedAuthorsScalarWhereWithAggregatesInput | VanityEmbedAuthorsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VanityEmbedAuthors"> | string
    Name?: StringWithAggregatesFilter<"VanityEmbedAuthors"> | string
    URL?: StringWithAggregatesFilter<"VanityEmbedAuthors"> | string
    IconURL?: StringWithAggregatesFilter<"VanityEmbedAuthors"> | string
    VanityEmbedsId?: StringWithAggregatesFilter<"VanityEmbedAuthors"> | string
  }

  export type VanityAnalyticsWhereInput = {
    AND?: VanityAnalyticsWhereInput | VanityAnalyticsWhereInput[]
    OR?: VanityAnalyticsWhereInput[]
    NOT?: VanityAnalyticsWhereInput | VanityAnalyticsWhereInput[]
    id?: StringFilter<"VanityAnalytics"> | string
    Click?: IntFilter<"VanityAnalytics"> | number
    TrackInviteWithLog?: StringNullableFilter<"VanityAnalytics"> | string | null
    TrackMessageId?: StringNullableFilter<"VanityAnalytics"> | string | null
    Update?: DateTimeNullableFilter<"VanityAnalytics"> | Date | string | null
    UniqueClick?: IntNullableFilter<"VanityAnalytics"> | number | null
    JoinedWithCode?: IntNullableFilter<"VanityAnalytics"> | number | null
    LoggedIPs?: StringNullableListFilter<"VanityAnalytics">
    VanityId?: StringFilter<"VanityAnalytics"> | string
    Latest30Days?: XOR<AnalyticsLatest30DaysNullableScalarRelationFilter, AnalyticsLatest30DaysWhereInput> | null
    Vanitys?: XOR<VanitysScalarRelationFilter, VanitysWhereInput>
  }

  export type VanityAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    Click?: SortOrder
    TrackInviteWithLog?: SortOrder
    TrackMessageId?: SortOrder
    Update?: SortOrder
    UniqueClick?: SortOrder
    JoinedWithCode?: SortOrder
    LoggedIPs?: SortOrder
    VanityId?: SortOrder
    Latest30Days?: AnalyticsLatest30DaysOrderByWithRelationInput
    Vanitys?: VanitysOrderByWithRelationInput
  }

  export type VanityAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    VanityId?: string
    AND?: VanityAnalyticsWhereInput | VanityAnalyticsWhereInput[]
    OR?: VanityAnalyticsWhereInput[]
    NOT?: VanityAnalyticsWhereInput | VanityAnalyticsWhereInput[]
    Click?: IntFilter<"VanityAnalytics"> | number
    TrackInviteWithLog?: StringNullableFilter<"VanityAnalytics"> | string | null
    TrackMessageId?: StringNullableFilter<"VanityAnalytics"> | string | null
    Update?: DateTimeNullableFilter<"VanityAnalytics"> | Date | string | null
    UniqueClick?: IntNullableFilter<"VanityAnalytics"> | number | null
    JoinedWithCode?: IntNullableFilter<"VanityAnalytics"> | number | null
    LoggedIPs?: StringNullableListFilter<"VanityAnalytics">
    Latest30Days?: XOR<AnalyticsLatest30DaysNullableScalarRelationFilter, AnalyticsLatest30DaysWhereInput> | null
    Vanitys?: XOR<VanitysScalarRelationFilter, VanitysWhereInput>
  }, "id" | "VanityId">

  export type VanityAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    Click?: SortOrder
    TrackInviteWithLog?: SortOrder
    TrackMessageId?: SortOrder
    Update?: SortOrder
    UniqueClick?: SortOrder
    JoinedWithCode?: SortOrder
    LoggedIPs?: SortOrder
    VanityId?: SortOrder
    _count?: VanityAnalyticsCountOrderByAggregateInput
    _avg?: VanityAnalyticsAvgOrderByAggregateInput
    _max?: VanityAnalyticsMaxOrderByAggregateInput
    _min?: VanityAnalyticsMinOrderByAggregateInput
    _sum?: VanityAnalyticsSumOrderByAggregateInput
  }

  export type VanityAnalyticsScalarWhereWithAggregatesInput = {
    AND?: VanityAnalyticsScalarWhereWithAggregatesInput | VanityAnalyticsScalarWhereWithAggregatesInput[]
    OR?: VanityAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: VanityAnalyticsScalarWhereWithAggregatesInput | VanityAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VanityAnalytics"> | string
    Click?: IntWithAggregatesFilter<"VanityAnalytics"> | number
    TrackInviteWithLog?: StringNullableWithAggregatesFilter<"VanityAnalytics"> | string | null
    TrackMessageId?: StringNullableWithAggregatesFilter<"VanityAnalytics"> | string | null
    Update?: DateTimeNullableWithAggregatesFilter<"VanityAnalytics"> | Date | string | null
    UniqueClick?: IntNullableWithAggregatesFilter<"VanityAnalytics"> | number | null
    JoinedWithCode?: IntNullableWithAggregatesFilter<"VanityAnalytics"> | number | null
    LoggedIPs?: StringNullableListFilter<"VanityAnalytics">
    VanityId?: StringWithAggregatesFilter<"VanityAnalytics"> | string
  }

  export type AnalyticsLatest30DaysWhereInput = {
    AND?: AnalyticsLatest30DaysWhereInput | AnalyticsLatest30DaysWhereInput[]
    OR?: AnalyticsLatest30DaysWhereInput[]
    NOT?: AnalyticsLatest30DaysWhereInput | AnalyticsLatest30DaysWhereInput[]
    id?: StringFilter<"AnalyticsLatest30Days"> | string
    Click?: IntNullableFilter<"AnalyticsLatest30Days"> | number | null
    UniqueClick?: IntNullableFilter<"AnalyticsLatest30Days"> | number | null
    Date?: DateTimeNullableFilter<"AnalyticsLatest30Days"> | Date | string | null
    JoinedWithCode?: IntNullableFilter<"AnalyticsLatest30Days"> | number | null
    VanityAnalyticsId?: StringFilter<"AnalyticsLatest30Days"> | string
    VanityAnalytics?: XOR<VanityAnalyticsScalarRelationFilter, VanityAnalyticsWhereInput>
  }

  export type AnalyticsLatest30DaysOrderByWithRelationInput = {
    id?: SortOrder
    Click?: SortOrder
    UniqueClick?: SortOrder
    Date?: SortOrder
    JoinedWithCode?: SortOrder
    VanityAnalyticsId?: SortOrder
    VanityAnalytics?: VanityAnalyticsOrderByWithRelationInput
  }

  export type AnalyticsLatest30DaysWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    VanityAnalyticsId?: string
    AND?: AnalyticsLatest30DaysWhereInput | AnalyticsLatest30DaysWhereInput[]
    OR?: AnalyticsLatest30DaysWhereInput[]
    NOT?: AnalyticsLatest30DaysWhereInput | AnalyticsLatest30DaysWhereInput[]
    Click?: IntNullableFilter<"AnalyticsLatest30Days"> | number | null
    UniqueClick?: IntNullableFilter<"AnalyticsLatest30Days"> | number | null
    Date?: DateTimeNullableFilter<"AnalyticsLatest30Days"> | Date | string | null
    JoinedWithCode?: IntNullableFilter<"AnalyticsLatest30Days"> | number | null
    VanityAnalytics?: XOR<VanityAnalyticsScalarRelationFilter, VanityAnalyticsWhereInput>
  }, "id" | "VanityAnalyticsId">

  export type AnalyticsLatest30DaysOrderByWithAggregationInput = {
    id?: SortOrder
    Click?: SortOrder
    UniqueClick?: SortOrder
    Date?: SortOrder
    JoinedWithCode?: SortOrder
    VanityAnalyticsId?: SortOrder
    _count?: AnalyticsLatest30DaysCountOrderByAggregateInput
    _avg?: AnalyticsLatest30DaysAvgOrderByAggregateInput
    _max?: AnalyticsLatest30DaysMaxOrderByAggregateInput
    _min?: AnalyticsLatest30DaysMinOrderByAggregateInput
    _sum?: AnalyticsLatest30DaysSumOrderByAggregateInput
  }

  export type AnalyticsLatest30DaysScalarWhereWithAggregatesInput = {
    AND?: AnalyticsLatest30DaysScalarWhereWithAggregatesInput | AnalyticsLatest30DaysScalarWhereWithAggregatesInput[]
    OR?: AnalyticsLatest30DaysScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsLatest30DaysScalarWhereWithAggregatesInput | AnalyticsLatest30DaysScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalyticsLatest30Days"> | string
    Click?: IntNullableWithAggregatesFilter<"AnalyticsLatest30Days"> | number | null
    UniqueClick?: IntNullableWithAggregatesFilter<"AnalyticsLatest30Days"> | number | null
    Date?: DateTimeNullableWithAggregatesFilter<"AnalyticsLatest30Days"> | Date | string | null
    JoinedWithCode?: IntNullableWithAggregatesFilter<"AnalyticsLatest30Days"> | number | null
    VanityAnalyticsId?: StringWithAggregatesFilter<"AnalyticsLatest30Days"> | string
  }

  export type DisBotUserNotificationsWhereInput = {
    AND?: DisBotUserNotificationsWhereInput | DisBotUserNotificationsWhereInput[]
    OR?: DisBotUserNotificationsWhereInput[]
    NOT?: DisBotUserNotificationsWhereInput | DisBotUserNotificationsWhereInput[]
    id?: StringFilter<"DisBotUserNotifications"> | string
    Updates?: BoolFilter<"DisBotUserNotifications"> | boolean
    Status?: BoolFilter<"DisBotUserNotifications"> | boolean
    Announcements?: BoolFilter<"DisBotUserNotifications"> | boolean
    Customer?: BoolFilter<"DisBotUserNotifications"> | boolean
    UserId?: StringFilter<"DisBotUserNotifications"> | string
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type DisBotUserNotificationsOrderByWithRelationInput = {
    id?: SortOrder
    Updates?: SortOrder
    Status?: SortOrder
    Announcements?: SortOrder
    Customer?: SortOrder
    UserId?: SortOrder
    Users?: UsersOrderByWithRelationInput
  }

  export type DisBotUserNotificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    UserId?: string
    AND?: DisBotUserNotificationsWhereInput | DisBotUserNotificationsWhereInput[]
    OR?: DisBotUserNotificationsWhereInput[]
    NOT?: DisBotUserNotificationsWhereInput | DisBotUserNotificationsWhereInput[]
    Updates?: BoolFilter<"DisBotUserNotifications"> | boolean
    Status?: BoolFilter<"DisBotUserNotifications"> | boolean
    Announcements?: BoolFilter<"DisBotUserNotifications"> | boolean
    Customer?: BoolFilter<"DisBotUserNotifications"> | boolean
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id" | "UserId">

  export type DisBotUserNotificationsOrderByWithAggregationInput = {
    id?: SortOrder
    Updates?: SortOrder
    Status?: SortOrder
    Announcements?: SortOrder
    Customer?: SortOrder
    UserId?: SortOrder
    _count?: DisBotUserNotificationsCountOrderByAggregateInput
    _max?: DisBotUserNotificationsMaxOrderByAggregateInput
    _min?: DisBotUserNotificationsMinOrderByAggregateInput
  }

  export type DisBotUserNotificationsScalarWhereWithAggregatesInput = {
    AND?: DisBotUserNotificationsScalarWhereWithAggregatesInput | DisBotUserNotificationsScalarWhereWithAggregatesInput[]
    OR?: DisBotUserNotificationsScalarWhereWithAggregatesInput[]
    NOT?: DisBotUserNotificationsScalarWhereWithAggregatesInput | DisBotUserNotificationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DisBotUserNotifications"> | string
    Updates?: BoolWithAggregatesFilter<"DisBotUserNotifications"> | boolean
    Status?: BoolWithAggregatesFilter<"DisBotUserNotifications"> | boolean
    Announcements?: BoolWithAggregatesFilter<"DisBotUserNotifications"> | boolean
    Customer?: BoolWithAggregatesFilter<"DisBotUserNotifications"> | boolean
    UserId?: StringWithAggregatesFilter<"DisBotUserNotifications"> | string
  }

  export type DisBotWhereInput = {
    AND?: DisBotWhereInput | DisBotWhereInput[]
    OR?: DisBotWhereInput[]
    NOT?: DisBotWhereInput | DisBotWhereInput[]
    id?: StringFilter<"DisBot"> | string
    Logs?: DisbotsLogsCompositeListFilter | DisbotsLogsObjectEqualityInput[]
    SpotifyToken?: StringFilter<"DisBot"> | string
    TwitchToken?: StringFilter<"DisBot"> | string
    Version?: StringFilter<"DisBot"> | string
    GetConf?: StringFilter<"DisBot"> | string
  }

  export type DisBotOrderByWithRelationInput = {
    id?: SortOrder
    Logs?: DisbotsLogsOrderByCompositeAggregateInput
    SpotifyToken?: SortOrder
    TwitchToken?: SortOrder
    Version?: SortOrder
    GetConf?: SortOrder
  }

  export type DisBotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    GetConf?: string
    AND?: DisBotWhereInput | DisBotWhereInput[]
    OR?: DisBotWhereInput[]
    NOT?: DisBotWhereInput | DisBotWhereInput[]
    Logs?: DisbotsLogsCompositeListFilter | DisbotsLogsObjectEqualityInput[]
    SpotifyToken?: StringFilter<"DisBot"> | string
    TwitchToken?: StringFilter<"DisBot"> | string
    Version?: StringFilter<"DisBot"> | string
  }, "id" | "GetConf">

  export type DisBotOrderByWithAggregationInput = {
    id?: SortOrder
    SpotifyToken?: SortOrder
    TwitchToken?: SortOrder
    Version?: SortOrder
    GetConf?: SortOrder
    _count?: DisBotCountOrderByAggregateInput
    _max?: DisBotMaxOrderByAggregateInput
    _min?: DisBotMinOrderByAggregateInput
  }

  export type DisBotScalarWhereWithAggregatesInput = {
    AND?: DisBotScalarWhereWithAggregatesInput | DisBotScalarWhereWithAggregatesInput[]
    OR?: DisBotScalarWhereWithAggregatesInput[]
    NOT?: DisBotScalarWhereWithAggregatesInput | DisBotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DisBot"> | string
    SpotifyToken?: StringWithAggregatesFilter<"DisBot"> | string
    TwitchToken?: StringWithAggregatesFilter<"DisBot"> | string
    Version?: StringWithAggregatesFilter<"DisBot"> | string
    GetConf?: StringWithAggregatesFilter<"DisBot"> | string
  }

  export type ImageApisWhereInput = {
    AND?: ImageApisWhereInput | ImageApisWhereInput[]
    OR?: ImageApisWhereInput[]
    NOT?: ImageApisWhereInput | ImageApisWhereInput[]
    id?: StringFilter<"ImageApis"> | string
    UUID?: StringFilter<"ImageApis"> | string
    ImageBase64?: StringFilter<"ImageApis"> | string
    URL?: StringFilter<"ImageApis"> | string
  }

  export type ImageApisOrderByWithRelationInput = {
    id?: SortOrder
    UUID?: SortOrder
    ImageBase64?: SortOrder
    URL?: SortOrder
  }

  export type ImageApisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    UUID?: string
    AND?: ImageApisWhereInput | ImageApisWhereInput[]
    OR?: ImageApisWhereInput[]
    NOT?: ImageApisWhereInput | ImageApisWhereInput[]
    ImageBase64?: StringFilter<"ImageApis"> | string
    URL?: StringFilter<"ImageApis"> | string
  }, "id" | "UUID">

  export type ImageApisOrderByWithAggregationInput = {
    id?: SortOrder
    UUID?: SortOrder
    ImageBase64?: SortOrder
    URL?: SortOrder
    _count?: ImageApisCountOrderByAggregateInput
    _max?: ImageApisMaxOrderByAggregateInput
    _min?: ImageApisMinOrderByAggregateInput
  }

  export type ImageApisScalarWhereWithAggregatesInput = {
    AND?: ImageApisScalarWhereWithAggregatesInput | ImageApisScalarWhereWithAggregatesInput[]
    OR?: ImageApisScalarWhereWithAggregatesInput[]
    NOT?: ImageApisScalarWhereWithAggregatesInput | ImageApisScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ImageApis"> | string
    UUID?: StringWithAggregatesFilter<"ImageApis"> | string
    ImageBase64?: StringWithAggregatesFilter<"ImageApis"> | string
    URL?: StringWithAggregatesFilter<"ImageApis"> | string
  }

  export type GuildsCreateInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUpdateInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsCreateManyInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
  }

  export type GuildsUpdateManyMutationInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
  }

  export type GuildsUncheckedUpdateManyInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
  }

  export type AutoDeletesCreateInput = {
    id?: string
    ChannelId?: string | null
    IsActive?: boolean | null
    Time?: string | null
    UUID?: string | null
    WhitelistedMessages?: AutoDeletesCreateWhitelistedMessagesInput | string[]
    WhitelistedRoles?: AutoDeletesCreateWhitelistedRolesInput | string[]
    WhitelistedUsers?: AutoDeletesCreateWhitelistedUsersInput | string[]
    Guilds: GuildsCreateNestedOneWithoutAutoAutoDeletesInput
  }

  export type AutoDeletesUncheckedCreateInput = {
    id?: string
    ChannelId?: string | null
    IsActive?: boolean | null
    Time?: string | null
    UUID?: string | null
    WhitelistedMessages?: AutoDeletesCreateWhitelistedMessagesInput | string[]
    WhitelistedRoles?: AutoDeletesCreateWhitelistedRolesInput | string[]
    WhitelistedUsers?: AutoDeletesCreateWhitelistedUsersInput | string[]
    GuildId: string
  }

  export type AutoDeletesUpdateInput = {
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Time?: NullableStringFieldUpdateOperationsInput | string | null
    UUID?: NullableStringFieldUpdateOperationsInput | string | null
    WhitelistedMessages?: AutoDeletesUpdateWhitelistedMessagesInput | string[]
    WhitelistedRoles?: AutoDeletesUpdateWhitelistedRolesInput | string[]
    WhitelistedUsers?: AutoDeletesUpdateWhitelistedUsersInput | string[]
    Guilds?: GuildsUpdateOneRequiredWithoutAutoAutoDeletesNestedInput
  }

  export type AutoDeletesUncheckedUpdateInput = {
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Time?: NullableStringFieldUpdateOperationsInput | string | null
    UUID?: NullableStringFieldUpdateOperationsInput | string | null
    WhitelistedMessages?: AutoDeletesUpdateWhitelistedMessagesInput | string[]
    WhitelistedRoles?: AutoDeletesUpdateWhitelistedRolesInput | string[]
    WhitelistedUsers?: AutoDeletesUpdateWhitelistedUsersInput | string[]
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type AutoDeletesCreateManyInput = {
    id?: string
    ChannelId?: string | null
    IsActive?: boolean | null
    Time?: string | null
    UUID?: string | null
    WhitelistedMessages?: AutoDeletesCreateWhitelistedMessagesInput | string[]
    WhitelistedRoles?: AutoDeletesCreateWhitelistedRolesInput | string[]
    WhitelistedUsers?: AutoDeletesCreateWhitelistedUsersInput | string[]
    GuildId: string
  }

  export type AutoDeletesUpdateManyMutationInput = {
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Time?: NullableStringFieldUpdateOperationsInput | string | null
    UUID?: NullableStringFieldUpdateOperationsInput | string | null
    WhitelistedMessages?: AutoDeletesUpdateWhitelistedMessagesInput | string[]
    WhitelistedRoles?: AutoDeletesUpdateWhitelistedRolesInput | string[]
    WhitelistedUsers?: AutoDeletesUpdateWhitelistedUsersInput | string[]
  }

  export type AutoDeletesUncheckedUpdateManyInput = {
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Time?: NullableStringFieldUpdateOperationsInput | string | null
    UUID?: NullableStringFieldUpdateOperationsInput | string | null
    WhitelistedMessages?: AutoDeletesUpdateWhitelistedMessagesInput | string[]
    WhitelistedRoles?: AutoDeletesUpdateWhitelistedRolesInput | string[]
    WhitelistedUsers?: AutoDeletesUpdateWhitelistedUsersInput | string[]
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type AutoPublishCreateInput = {
    id?: string
    Channels?: AutoPublishCreateChannelsInput | string[]
    Guilds: GuildsCreateNestedOneWithoutAutoPublishInput
  }

  export type AutoPublishUncheckedCreateInput = {
    id?: string
    Channels?: AutoPublishCreateChannelsInput | string[]
    GuildId: string
  }

  export type AutoPublishUpdateInput = {
    Channels?: AutoPublishUpdateChannelsInput | string[]
    Guilds?: GuildsUpdateOneRequiredWithoutAutoPublishNestedInput
  }

  export type AutoPublishUncheckedUpdateInput = {
    Channels?: AutoPublishUpdateChannelsInput | string[]
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type AutoPublishCreateManyInput = {
    id?: string
    Channels?: AutoPublishCreateChannelsInput | string[]
    GuildId: string
  }

  export type AutoPublishUpdateManyMutationInput = {
    Channels?: AutoPublishUpdateChannelsInput | string[]
  }

  export type AutoPublishUncheckedUpdateManyInput = {
    Channels?: AutoPublishUpdateChannelsInput | string[]
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type AutoReactsCreateInput = {
    id?: string
    ChannelId: string
    Emoji: string
    Guilds: GuildsCreateNestedOneWithoutAutoReactsInput
  }

  export type AutoReactsUncheckedCreateInput = {
    id?: string
    ChannelId: string
    Emoji: string
    GuildId: string
  }

  export type AutoReactsUpdateInput = {
    ChannelId?: StringFieldUpdateOperationsInput | string
    Emoji?: StringFieldUpdateOperationsInput | string
    Guilds?: GuildsUpdateOneRequiredWithoutAutoReactsNestedInput
  }

  export type AutoReactsUncheckedUpdateInput = {
    ChannelId?: StringFieldUpdateOperationsInput | string
    Emoji?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type AutoReactsCreateManyInput = {
    id?: string
    ChannelId: string
    Emoji: string
    GuildId: string
  }

  export type AutoReactsUpdateManyMutationInput = {
    ChannelId?: StringFieldUpdateOperationsInput | string
    Emoji?: StringFieldUpdateOperationsInput | string
  }

  export type AutoReactsUncheckedUpdateManyInput = {
    ChannelId?: StringFieldUpdateOperationsInput | string
    Emoji?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type AutoRolesCreateInput = {
    id?: string
    RoleId: string
    Guilds: GuildsCreateNestedOneWithoutAutoRolesInput
  }

  export type AutoRolesUncheckedCreateInput = {
    id?: string
    RoleId: string
    GuildId: string
  }

  export type AutoRolesUpdateInput = {
    RoleId?: StringFieldUpdateOperationsInput | string
    Guilds?: GuildsUpdateOneRequiredWithoutAutoRolesNestedInput
  }

  export type AutoRolesUncheckedUpdateInput = {
    RoleId?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type AutoRolesCreateManyInput = {
    id?: string
    RoleId: string
    GuildId: string
  }

  export type AutoRolesUpdateManyMutationInput = {
    RoleId?: StringFieldUpdateOperationsInput | string
  }

  export type AutoRolesUncheckedUpdateManyInput = {
    RoleId?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type GuildBansCreateInput = {
    id?: string
    UUID: string
    Time?: string | null
    UserId?: GuildBansCreateUserIdInput | string[]
    Reason?: string | null
    ModeratorId?: string | null
    DmMessage?: string | null
    Banned?: boolean | null
    CreatedAt?: Date | string | null
    Guilds: GuildsCreateNestedOneWithoutGuildBansInput
  }

  export type GuildBansUncheckedCreateInput = {
    id?: string
    UUID: string
    Time?: string | null
    UserId?: GuildBansCreateUserIdInput | string[]
    Reason?: string | null
    ModeratorId?: string | null
    DmMessage?: string | null
    Banned?: boolean | null
    CreatedAt?: Date | string | null
    GuildId: string
  }

  export type GuildBansUpdateInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Time?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: GuildBansUpdateUserIdInput | string[]
    Reason?: NullableStringFieldUpdateOperationsInput | string | null
    ModeratorId?: NullableStringFieldUpdateOperationsInput | string | null
    DmMessage?: NullableStringFieldUpdateOperationsInput | string | null
    Banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Guilds?: GuildsUpdateOneRequiredWithoutGuildBansNestedInput
  }

  export type GuildBansUncheckedUpdateInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Time?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: GuildBansUpdateUserIdInput | string[]
    Reason?: NullableStringFieldUpdateOperationsInput | string | null
    ModeratorId?: NullableStringFieldUpdateOperationsInput | string | null
    DmMessage?: NullableStringFieldUpdateOperationsInput | string | null
    Banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type GuildBansCreateManyInput = {
    id?: string
    UUID: string
    Time?: string | null
    UserId?: GuildBansCreateUserIdInput | string[]
    Reason?: string | null
    ModeratorId?: string | null
    DmMessage?: string | null
    Banned?: boolean | null
    CreatedAt?: Date | string | null
    GuildId: string
  }

  export type GuildBansUpdateManyMutationInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Time?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: GuildBansUpdateUserIdInput | string[]
    Reason?: NullableStringFieldUpdateOperationsInput | string | null
    ModeratorId?: NullableStringFieldUpdateOperationsInput | string | null
    DmMessage?: NullableStringFieldUpdateOperationsInput | string | null
    Banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GuildBansUncheckedUpdateManyInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Time?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: GuildBansUpdateUserIdInput | string[]
    Reason?: NullableStringFieldUpdateOperationsInput | string | null
    ModeratorId?: NullableStringFieldUpdateOperationsInput | string | null
    DmMessage?: NullableStringFieldUpdateOperationsInput | string | null
    Banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatModerationsCreateInput = {
    id?: string
    LogChannelId: string
    Words?: ChatModerationsCreateWordsInput | string[]
    WhiteListRole?: ChatModerationsCreateWhiteListRoleInput | string[]
    WhiteListChannel?: ChatModerationsCreateWhiteListChannelInput | string[]
    Guilds: GuildsCreateNestedOneWithoutChatModerationsInput
  }

  export type ChatModerationsUncheckedCreateInput = {
    id?: string
    LogChannelId: string
    Words?: ChatModerationsCreateWordsInput | string[]
    WhiteListRole?: ChatModerationsCreateWhiteListRoleInput | string[]
    WhiteListChannel?: ChatModerationsCreateWhiteListChannelInput | string[]
    GuildId: string
  }

  export type ChatModerationsUpdateInput = {
    LogChannelId?: StringFieldUpdateOperationsInput | string
    Words?: ChatModerationsUpdateWordsInput | string[]
    WhiteListRole?: ChatModerationsUpdateWhiteListRoleInput | string[]
    WhiteListChannel?: ChatModerationsUpdateWhiteListChannelInput | string[]
    Guilds?: GuildsUpdateOneRequiredWithoutChatModerationsNestedInput
  }

  export type ChatModerationsUncheckedUpdateInput = {
    LogChannelId?: StringFieldUpdateOperationsInput | string
    Words?: ChatModerationsUpdateWordsInput | string[]
    WhiteListRole?: ChatModerationsUpdateWhiteListRoleInput | string[]
    WhiteListChannel?: ChatModerationsUpdateWhiteListChannelInput | string[]
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatModerationsCreateManyInput = {
    id?: string
    LogChannelId: string
    Words?: ChatModerationsCreateWordsInput | string[]
    WhiteListRole?: ChatModerationsCreateWhiteListRoleInput | string[]
    WhiteListChannel?: ChatModerationsCreateWhiteListChannelInput | string[]
    GuildId: string
  }

  export type ChatModerationsUpdateManyMutationInput = {
    LogChannelId?: StringFieldUpdateOperationsInput | string
    Words?: ChatModerationsUpdateWordsInput | string[]
    WhiteListRole?: ChatModerationsUpdateWhiteListRoleInput | string[]
    WhiteListChannel?: ChatModerationsUpdateWhiteListChannelInput | string[]
  }

  export type ChatModerationsUncheckedUpdateManyInput = {
    LogChannelId?: StringFieldUpdateOperationsInput | string
    Words?: ChatModerationsUpdateWordsInput | string[]
    WhiteListRole?: ChatModerationsUpdateWhiteListRoleInput | string[]
    WhiteListChannel?: ChatModerationsUpdateWhiteListChannelInput | string[]
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type ChannelLinksCreateInput = {
    id?: string
    UUID: string
    ChannelId: string
    WebhookUrls?: ChannelLinksCreateWebhookUrlsInput | string[]
    SyncedChannelLinkMessage?: SyncedChannelLinkMessagesCreateNestedManyWithoutChannelLinksInput
    Guilds: GuildsCreateNestedOneWithoutChannelLinksInput
  }

  export type ChannelLinksUncheckedCreateInput = {
    id?: string
    UUID: string
    ChannelId: string
    WebhookUrls?: ChannelLinksCreateWebhookUrlsInput | string[]
    GuildId: string
    SyncedChannelLinkMessage?: SyncedChannelLinkMessagesUncheckedCreateNestedManyWithoutChannelLinksInput
  }

  export type ChannelLinksUpdateInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    WebhookUrls?: ChannelLinksUpdateWebhookUrlsInput | string[]
    SyncedChannelLinkMessage?: SyncedChannelLinkMessagesUpdateManyWithoutChannelLinksNestedInput
    Guilds?: GuildsUpdateOneRequiredWithoutChannelLinksNestedInput
  }

  export type ChannelLinksUncheckedUpdateInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    WebhookUrls?: ChannelLinksUpdateWebhookUrlsInput | string[]
    GuildId?: StringFieldUpdateOperationsInput | string
    SyncedChannelLinkMessage?: SyncedChannelLinkMessagesUncheckedUpdateManyWithoutChannelLinksNestedInput
  }

  export type ChannelLinksCreateManyInput = {
    id?: string
    UUID: string
    ChannelId: string
    WebhookUrls?: ChannelLinksCreateWebhookUrlsInput | string[]
    GuildId: string
  }

  export type ChannelLinksUpdateManyMutationInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    WebhookUrls?: ChannelLinksUpdateWebhookUrlsInput | string[]
  }

  export type ChannelLinksUncheckedUpdateManyInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    WebhookUrls?: ChannelLinksUpdateWebhookUrlsInput | string[]
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type SyncedChannelLinkMessagesCreateInput = {
    id?: string
    GuildId: string
    UserMessageId: string
    WebhookMessageId: string
    WebhookURL: string
    ChannelId: string
    ChannelLinks: ChannelLinksCreateNestedOneWithoutSyncedChannelLinkMessageInput
  }

  export type SyncedChannelLinkMessagesUncheckedCreateInput = {
    id?: string
    GuildId: string
    UserMessageId: string
    WebhookMessageId: string
    WebhookURL: string
    ChannelId: string
    ChannelLinkId: string
  }

  export type SyncedChannelLinkMessagesUpdateInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    UserMessageId?: StringFieldUpdateOperationsInput | string
    WebhookMessageId?: StringFieldUpdateOperationsInput | string
    WebhookURL?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    ChannelLinks?: ChannelLinksUpdateOneRequiredWithoutSyncedChannelLinkMessageNestedInput
  }

  export type SyncedChannelLinkMessagesUncheckedUpdateInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    UserMessageId?: StringFieldUpdateOperationsInput | string
    WebhookMessageId?: StringFieldUpdateOperationsInput | string
    WebhookURL?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    ChannelLinkId?: StringFieldUpdateOperationsInput | string
  }

  export type SyncedChannelLinkMessagesCreateManyInput = {
    id?: string
    GuildId: string
    UserMessageId: string
    WebhookMessageId: string
    WebhookURL: string
    ChannelId: string
    ChannelLinkId: string
  }

  export type SyncedChannelLinkMessagesUpdateManyMutationInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    UserMessageId?: StringFieldUpdateOperationsInput | string
    WebhookMessageId?: StringFieldUpdateOperationsInput | string
    WebhookURL?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
  }

  export type SyncedChannelLinkMessagesUncheckedUpdateManyInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    UserMessageId?: StringFieldUpdateOperationsInput | string
    WebhookMessageId?: StringFieldUpdateOperationsInput | string
    WebhookURL?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    ChannelLinkId?: StringFieldUpdateOperationsInput | string
  }

  export type DiscordAddonsCreateInput = {
    id?: string
    OnlyMedia?: DiscordAddonsCreateOnlyMediaInput | string[]
    NoLinkEmbeds?: DiscordAddonsCreateNoLinkEmbedsInput | string[]
    InvitesPaused: boolean
    Guilds: GuildsCreateNestedOneWithoutDiscordAddonsInput
  }

  export type DiscordAddonsUncheckedCreateInput = {
    id?: string
    OnlyMedia?: DiscordAddonsCreateOnlyMediaInput | string[]
    NoLinkEmbeds?: DiscordAddonsCreateNoLinkEmbedsInput | string[]
    InvitesPaused: boolean
    GuildId: string
  }

  export type DiscordAddonsUpdateInput = {
    OnlyMedia?: DiscordAddonsUpdateOnlyMediaInput | string[]
    NoLinkEmbeds?: DiscordAddonsUpdateNoLinkEmbedsInput | string[]
    InvitesPaused?: BoolFieldUpdateOperationsInput | boolean
    Guilds?: GuildsUpdateOneRequiredWithoutDiscordAddonsNestedInput
  }

  export type DiscordAddonsUncheckedUpdateInput = {
    OnlyMedia?: DiscordAddonsUpdateOnlyMediaInput | string[]
    NoLinkEmbeds?: DiscordAddonsUpdateNoLinkEmbedsInput | string[]
    InvitesPaused?: BoolFieldUpdateOperationsInput | boolean
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type DiscordAddonsCreateManyInput = {
    id?: string
    OnlyMedia?: DiscordAddonsCreateOnlyMediaInput | string[]
    NoLinkEmbeds?: DiscordAddonsCreateNoLinkEmbedsInput | string[]
    InvitesPaused: boolean
    GuildId: string
  }

  export type DiscordAddonsUpdateManyMutationInput = {
    OnlyMedia?: DiscordAddonsUpdateOnlyMediaInput | string[]
    NoLinkEmbeds?: DiscordAddonsUpdateNoLinkEmbedsInput | string[]
    InvitesPaused?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DiscordAddonsUncheckedUpdateManyInput = {
    OnlyMedia?: DiscordAddonsUpdateOnlyMediaInput | string[]
    NoLinkEmbeds?: DiscordAddonsUpdateNoLinkEmbedsInput | string[]
    InvitesPaused?: BoolFieldUpdateOperationsInput | boolean
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type GiveawaysCreateInput = {
    id?: string
    UUID: string
    MessageId: string
    ChannelId?: string | null
    Prize: string
    Winners: number
    Time: string
    CreatedAt: Date | string
    Ended: boolean
    EndedAt?: Date | string | null
    EndedBy?: string | null
    Paused: boolean
    EndedMessage?: string | null
    Rerolled: boolean
    WinnerIds?: GiveawaysCreateWinnerIdsInput | string[]
    WinnerMessageTemplate?: string | null
    HostedBy: string
    MessageTemplate?: string | null
    Content?: string | null
    Entrys?: GiveawaysCreateEntrysInput | string[]
    Requirements?: GiveawaysCreateRequirementsInput | string[]
    Guilds: GuildsCreateNestedOneWithoutGiveawaysInput
  }

  export type GiveawaysUncheckedCreateInput = {
    id?: string
    UUID: string
    MessageId: string
    ChannelId?: string | null
    Prize: string
    Winners: number
    Time: string
    CreatedAt: Date | string
    Ended: boolean
    EndedAt?: Date | string | null
    EndedBy?: string | null
    Paused: boolean
    EndedMessage?: string | null
    Rerolled: boolean
    WinnerIds?: GiveawaysCreateWinnerIdsInput | string[]
    WinnerMessageTemplate?: string | null
    HostedBy: string
    MessageTemplate?: string | null
    Content?: string | null
    Entrys?: GiveawaysCreateEntrysInput | string[]
    Requirements?: GiveawaysCreateRequirementsInput | string[]
    GuildId: string
  }

  export type GiveawaysUpdateInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    Prize?: StringFieldUpdateOperationsInput | string
    Winners?: IntFieldUpdateOperationsInput | number
    Time?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ended?: BoolFieldUpdateOperationsInput | boolean
    EndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndedBy?: NullableStringFieldUpdateOperationsInput | string | null
    Paused?: BoolFieldUpdateOperationsInput | boolean
    EndedMessage?: NullableStringFieldUpdateOperationsInput | string | null
    Rerolled?: BoolFieldUpdateOperationsInput | boolean
    WinnerIds?: GiveawaysUpdateWinnerIdsInput | string[]
    WinnerMessageTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    HostedBy?: StringFieldUpdateOperationsInput | string
    MessageTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    Entrys?: GiveawaysUpdateEntrysInput | string[]
    Requirements?: GiveawaysUpdateRequirementsInput | string[]
    Guilds?: GuildsUpdateOneRequiredWithoutGiveawaysNestedInput
  }

  export type GiveawaysUncheckedUpdateInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    Prize?: StringFieldUpdateOperationsInput | string
    Winners?: IntFieldUpdateOperationsInput | number
    Time?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ended?: BoolFieldUpdateOperationsInput | boolean
    EndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndedBy?: NullableStringFieldUpdateOperationsInput | string | null
    Paused?: BoolFieldUpdateOperationsInput | boolean
    EndedMessage?: NullableStringFieldUpdateOperationsInput | string | null
    Rerolled?: BoolFieldUpdateOperationsInput | boolean
    WinnerIds?: GiveawaysUpdateWinnerIdsInput | string[]
    WinnerMessageTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    HostedBy?: StringFieldUpdateOperationsInput | string
    MessageTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    Entrys?: GiveawaysUpdateEntrysInput | string[]
    Requirements?: GiveawaysUpdateRequirementsInput | string[]
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type GiveawaysCreateManyInput = {
    id?: string
    UUID: string
    MessageId: string
    ChannelId?: string | null
    Prize: string
    Winners: number
    Time: string
    CreatedAt: Date | string
    Ended: boolean
    EndedAt?: Date | string | null
    EndedBy?: string | null
    Paused: boolean
    EndedMessage?: string | null
    Rerolled: boolean
    WinnerIds?: GiveawaysCreateWinnerIdsInput | string[]
    WinnerMessageTemplate?: string | null
    HostedBy: string
    MessageTemplate?: string | null
    Content?: string | null
    Entrys?: GiveawaysCreateEntrysInput | string[]
    Requirements?: GiveawaysCreateRequirementsInput | string[]
    GuildId: string
  }

  export type GiveawaysUpdateManyMutationInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    Prize?: StringFieldUpdateOperationsInput | string
    Winners?: IntFieldUpdateOperationsInput | number
    Time?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ended?: BoolFieldUpdateOperationsInput | boolean
    EndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndedBy?: NullableStringFieldUpdateOperationsInput | string | null
    Paused?: BoolFieldUpdateOperationsInput | boolean
    EndedMessage?: NullableStringFieldUpdateOperationsInput | string | null
    Rerolled?: BoolFieldUpdateOperationsInput | boolean
    WinnerIds?: GiveawaysUpdateWinnerIdsInput | string[]
    WinnerMessageTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    HostedBy?: StringFieldUpdateOperationsInput | string
    MessageTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    Entrys?: GiveawaysUpdateEntrysInput | string[]
    Requirements?: GiveawaysUpdateRequirementsInput | string[]
  }

  export type GiveawaysUncheckedUpdateManyInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    Prize?: StringFieldUpdateOperationsInput | string
    Winners?: IntFieldUpdateOperationsInput | number
    Time?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ended?: BoolFieldUpdateOperationsInput | boolean
    EndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndedBy?: NullableStringFieldUpdateOperationsInput | string | null
    Paused?: BoolFieldUpdateOperationsInput | boolean
    EndedMessage?: NullableStringFieldUpdateOperationsInput | string | null
    Rerolled?: BoolFieldUpdateOperationsInput | boolean
    WinnerIds?: GiveawaysUpdateWinnerIdsInput | string[]
    WinnerMessageTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    HostedBy?: StringFieldUpdateOperationsInput | string
    MessageTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    Entrys?: GiveawaysUpdateEntrysInput | string[]
    Requirements?: GiveawaysUpdateRequirementsInput | string[]
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type TempVoicesCreateInput = {
    id?: string
    UUID: string
    Name: string
    JointoCreateChannel: string
    JointoCreateCategory: string
    Manage: boolean
    PresetLimit: number
    TempVoiceChannels?: TempVoiceChannelsCreateNestedManyWithoutTempVoicesInput
    Guilds: GuildsCreateNestedOneWithoutTempVoicesInput
  }

  export type TempVoicesUncheckedCreateInput = {
    id?: string
    UUID: string
    Name: string
    JointoCreateChannel: string
    JointoCreateCategory: string
    Manage: boolean
    PresetLimit: number
    GuildId: string
    TempVoiceChannels?: TempVoiceChannelsUncheckedCreateNestedManyWithoutTempVoicesInput
  }

  export type TempVoicesUpdateInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    JointoCreateChannel?: StringFieldUpdateOperationsInput | string
    JointoCreateCategory?: StringFieldUpdateOperationsInput | string
    Manage?: BoolFieldUpdateOperationsInput | boolean
    PresetLimit?: IntFieldUpdateOperationsInput | number
    TempVoiceChannels?: TempVoiceChannelsUpdateManyWithoutTempVoicesNestedInput
    Guilds?: GuildsUpdateOneRequiredWithoutTempVoicesNestedInput
  }

  export type TempVoicesUncheckedUpdateInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    JointoCreateChannel?: StringFieldUpdateOperationsInput | string
    JointoCreateCategory?: StringFieldUpdateOperationsInput | string
    Manage?: BoolFieldUpdateOperationsInput | boolean
    PresetLimit?: IntFieldUpdateOperationsInput | number
    GuildId?: StringFieldUpdateOperationsInput | string
    TempVoiceChannels?: TempVoiceChannelsUncheckedUpdateManyWithoutTempVoicesNestedInput
  }

  export type TempVoicesCreateManyInput = {
    id?: string
    UUID: string
    Name: string
    JointoCreateChannel: string
    JointoCreateCategory: string
    Manage: boolean
    PresetLimit: number
    GuildId: string
  }

  export type TempVoicesUpdateManyMutationInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    JointoCreateChannel?: StringFieldUpdateOperationsInput | string
    JointoCreateCategory?: StringFieldUpdateOperationsInput | string
    Manage?: BoolFieldUpdateOperationsInput | boolean
    PresetLimit?: IntFieldUpdateOperationsInput | number
  }

  export type TempVoicesUncheckedUpdateManyInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    JointoCreateChannel?: StringFieldUpdateOperationsInput | string
    JointoCreateCategory?: StringFieldUpdateOperationsInput | string
    Manage?: BoolFieldUpdateOperationsInput | boolean
    PresetLimit?: IntFieldUpdateOperationsInput | number
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type TempVoiceChannelsCreateInput = {
    id?: string
    GuildId: string
    ChannelId: string
    OwnerId: string
    TempVoices: TempVoicesCreateNestedOneWithoutTempVoiceChannelsInput
  }

  export type TempVoiceChannelsUncheckedCreateInput = {
    id?: string
    GuildId: string
    ChannelId: string
    OwnerId: string
    TempVoiceId: string
  }

  export type TempVoiceChannelsUpdateInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    OwnerId?: StringFieldUpdateOperationsInput | string
    TempVoices?: TempVoicesUpdateOneRequiredWithoutTempVoiceChannelsNestedInput
  }

  export type TempVoiceChannelsUncheckedUpdateInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    OwnerId?: StringFieldUpdateOperationsInput | string
    TempVoiceId?: StringFieldUpdateOperationsInput | string
  }

  export type TempVoiceChannelsCreateManyInput = {
    id?: string
    GuildId: string
    ChannelId: string
    OwnerId: string
    TempVoiceId: string
  }

  export type TempVoiceChannelsUpdateManyMutationInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    OwnerId?: StringFieldUpdateOperationsInput | string
  }

  export type TempVoiceChannelsUncheckedUpdateManyInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    OwnerId?: StringFieldUpdateOperationsInput | string
    TempVoiceId?: StringFieldUpdateOperationsInput | string
  }

  export type GuildLeaveSetupsCreateInput = {
    id?: string
    MessageTemplateId?: string | null
    ChannelId: string
    Image?: boolean | null
    ImageData?: XOR<WelcomeLeaveImageDataNullableCreateEnvelopeInput, WelcomeLeaveImageDataCreateInput> | null
    Guilds: GuildsCreateNestedOneWithoutGuildLeaveSetupInput
  }

  export type GuildLeaveSetupsUncheckedCreateInput = {
    id?: string
    MessageTemplateId?: string | null
    ChannelId: string
    Image?: boolean | null
    ImageData?: XOR<WelcomeLeaveImageDataNullableCreateEnvelopeInput, WelcomeLeaveImageDataCreateInput> | null
    GuildId: string
  }

  export type GuildLeaveSetupsUpdateInput = {
    MessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelId?: StringFieldUpdateOperationsInput | string
    Image?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ImageData?: XOR<WelcomeLeaveImageDataNullableUpdateEnvelopeInput, WelcomeLeaveImageDataCreateInput> | null
    Guilds?: GuildsUpdateOneRequiredWithoutGuildLeaveSetupNestedInput
  }

  export type GuildLeaveSetupsUncheckedUpdateInput = {
    MessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelId?: StringFieldUpdateOperationsInput | string
    Image?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ImageData?: XOR<WelcomeLeaveImageDataNullableUpdateEnvelopeInput, WelcomeLeaveImageDataCreateInput> | null
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type GuildLeaveSetupsCreateManyInput = {
    id?: string
    MessageTemplateId?: string | null
    ChannelId: string
    Image?: boolean | null
    ImageData?: XOR<WelcomeLeaveImageDataNullableCreateEnvelopeInput, WelcomeLeaveImageDataCreateInput> | null
    GuildId: string
  }

  export type GuildLeaveSetupsUpdateManyMutationInput = {
    MessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelId?: StringFieldUpdateOperationsInput | string
    Image?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ImageData?: XOR<WelcomeLeaveImageDataNullableUpdateEnvelopeInput, WelcomeLeaveImageDataCreateInput> | null
  }

  export type GuildLeaveSetupsUncheckedUpdateManyInput = {
    MessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelId?: StringFieldUpdateOperationsInput | string
    Image?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ImageData?: XOR<WelcomeLeaveImageDataNullableUpdateEnvelopeInput, WelcomeLeaveImageDataCreateInput> | null
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type GuildWelcomeSetupsCreateInput = {
    id?: string
    MessageTemplateId: string
    ChannelId: string
    Image: boolean
    ImageData: XOR<WelcomeLeaveImageDataCreateEnvelopeInput, WelcomeLeaveImageDataCreateInput>
    Guilds: GuildsCreateNestedOneWithoutGuildWelcomeSetupInput
  }

  export type GuildWelcomeSetupsUncheckedCreateInput = {
    id?: string
    MessageTemplateId: string
    ChannelId: string
    Image: boolean
    ImageData: XOR<WelcomeLeaveImageDataCreateEnvelopeInput, WelcomeLeaveImageDataCreateInput>
    GuildId: string
  }

  export type GuildWelcomeSetupsUpdateInput = {
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Image?: BoolFieldUpdateOperationsInput | boolean
    ImageData?: XOR<WelcomeLeaveImageDataUpdateEnvelopeInput, WelcomeLeaveImageDataCreateInput>
    Guilds?: GuildsUpdateOneRequiredWithoutGuildWelcomeSetupNestedInput
  }

  export type GuildWelcomeSetupsUncheckedUpdateInput = {
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Image?: BoolFieldUpdateOperationsInput | boolean
    ImageData?: XOR<WelcomeLeaveImageDataUpdateEnvelopeInput, WelcomeLeaveImageDataCreateInput>
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type GuildWelcomeSetupsCreateManyInput = {
    id?: string
    MessageTemplateId: string
    ChannelId: string
    Image: boolean
    ImageData: XOR<WelcomeLeaveImageDataCreateEnvelopeInput, WelcomeLeaveImageDataCreateInput>
    GuildId: string
  }

  export type GuildWelcomeSetupsUpdateManyMutationInput = {
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Image?: BoolFieldUpdateOperationsInput | boolean
    ImageData?: XOR<WelcomeLeaveImageDataUpdateEnvelopeInput, WelcomeLeaveImageDataCreateInput>
  }

  export type GuildWelcomeSetupsUncheckedUpdateManyInput = {
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Image?: BoolFieldUpdateOperationsInput | boolean
    ImageData?: XOR<WelcomeLeaveImageDataUpdateEnvelopeInput, WelcomeLeaveImageDataCreateInput>
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type GuildLoggingsCreateInput = {
    id?: string
    AutoMod?: string | null
    Channel?: string | null
    Emoji?: string | null
    Guild?: string | null
    Integration?: string | null
    Invite?: string | null
    Member?: string | null
    Message?: string | null
    Moderation?: string | null
    Reaction?: string | null
    Role?: string | null
    SoundBoard?: string | null
    Sticker?: string | null
    Thread?: string | null
    Voice?: string | null
    Webhook?: string | null
    Ban?: string | null
    Kick?: string | null
    Poll?: string | null
    Stage?: string | null
    Event?: string | null
    Guilds: GuildsCreateNestedOneWithoutGuildLoggingInput
  }

  export type GuildLoggingsUncheckedCreateInput = {
    id?: string
    AutoMod?: string | null
    Channel?: string | null
    Emoji?: string | null
    Guild?: string | null
    Integration?: string | null
    Invite?: string | null
    Member?: string | null
    Message?: string | null
    Moderation?: string | null
    Reaction?: string | null
    Role?: string | null
    SoundBoard?: string | null
    Sticker?: string | null
    Thread?: string | null
    Voice?: string | null
    Webhook?: string | null
    Ban?: string | null
    Kick?: string | null
    Poll?: string | null
    Stage?: string | null
    Event?: string | null
    GuildId: string
  }

  export type GuildLoggingsUpdateInput = {
    AutoMod?: NullableStringFieldUpdateOperationsInput | string | null
    Channel?: NullableStringFieldUpdateOperationsInput | string | null
    Emoji?: NullableStringFieldUpdateOperationsInput | string | null
    Guild?: NullableStringFieldUpdateOperationsInput | string | null
    Integration?: NullableStringFieldUpdateOperationsInput | string | null
    Invite?: NullableStringFieldUpdateOperationsInput | string | null
    Member?: NullableStringFieldUpdateOperationsInput | string | null
    Message?: NullableStringFieldUpdateOperationsInput | string | null
    Moderation?: NullableStringFieldUpdateOperationsInput | string | null
    Reaction?: NullableStringFieldUpdateOperationsInput | string | null
    Role?: NullableStringFieldUpdateOperationsInput | string | null
    SoundBoard?: NullableStringFieldUpdateOperationsInput | string | null
    Sticker?: NullableStringFieldUpdateOperationsInput | string | null
    Thread?: NullableStringFieldUpdateOperationsInput | string | null
    Voice?: NullableStringFieldUpdateOperationsInput | string | null
    Webhook?: NullableStringFieldUpdateOperationsInput | string | null
    Ban?: NullableStringFieldUpdateOperationsInput | string | null
    Kick?: NullableStringFieldUpdateOperationsInput | string | null
    Poll?: NullableStringFieldUpdateOperationsInput | string | null
    Stage?: NullableStringFieldUpdateOperationsInput | string | null
    Event?: NullableStringFieldUpdateOperationsInput | string | null
    Guilds?: GuildsUpdateOneRequiredWithoutGuildLoggingNestedInput
  }

  export type GuildLoggingsUncheckedUpdateInput = {
    AutoMod?: NullableStringFieldUpdateOperationsInput | string | null
    Channel?: NullableStringFieldUpdateOperationsInput | string | null
    Emoji?: NullableStringFieldUpdateOperationsInput | string | null
    Guild?: NullableStringFieldUpdateOperationsInput | string | null
    Integration?: NullableStringFieldUpdateOperationsInput | string | null
    Invite?: NullableStringFieldUpdateOperationsInput | string | null
    Member?: NullableStringFieldUpdateOperationsInput | string | null
    Message?: NullableStringFieldUpdateOperationsInput | string | null
    Moderation?: NullableStringFieldUpdateOperationsInput | string | null
    Reaction?: NullableStringFieldUpdateOperationsInput | string | null
    Role?: NullableStringFieldUpdateOperationsInput | string | null
    SoundBoard?: NullableStringFieldUpdateOperationsInput | string | null
    Sticker?: NullableStringFieldUpdateOperationsInput | string | null
    Thread?: NullableStringFieldUpdateOperationsInput | string | null
    Voice?: NullableStringFieldUpdateOperationsInput | string | null
    Webhook?: NullableStringFieldUpdateOperationsInput | string | null
    Ban?: NullableStringFieldUpdateOperationsInput | string | null
    Kick?: NullableStringFieldUpdateOperationsInput | string | null
    Poll?: NullableStringFieldUpdateOperationsInput | string | null
    Stage?: NullableStringFieldUpdateOperationsInput | string | null
    Event?: NullableStringFieldUpdateOperationsInput | string | null
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type GuildLoggingsCreateManyInput = {
    id?: string
    AutoMod?: string | null
    Channel?: string | null
    Emoji?: string | null
    Guild?: string | null
    Integration?: string | null
    Invite?: string | null
    Member?: string | null
    Message?: string | null
    Moderation?: string | null
    Reaction?: string | null
    Role?: string | null
    SoundBoard?: string | null
    Sticker?: string | null
    Thread?: string | null
    Voice?: string | null
    Webhook?: string | null
    Ban?: string | null
    Kick?: string | null
    Poll?: string | null
    Stage?: string | null
    Event?: string | null
    GuildId: string
  }

  export type GuildLoggingsUpdateManyMutationInput = {
    AutoMod?: NullableStringFieldUpdateOperationsInput | string | null
    Channel?: NullableStringFieldUpdateOperationsInput | string | null
    Emoji?: NullableStringFieldUpdateOperationsInput | string | null
    Guild?: NullableStringFieldUpdateOperationsInput | string | null
    Integration?: NullableStringFieldUpdateOperationsInput | string | null
    Invite?: NullableStringFieldUpdateOperationsInput | string | null
    Member?: NullableStringFieldUpdateOperationsInput | string | null
    Message?: NullableStringFieldUpdateOperationsInput | string | null
    Moderation?: NullableStringFieldUpdateOperationsInput | string | null
    Reaction?: NullableStringFieldUpdateOperationsInput | string | null
    Role?: NullableStringFieldUpdateOperationsInput | string | null
    SoundBoard?: NullableStringFieldUpdateOperationsInput | string | null
    Sticker?: NullableStringFieldUpdateOperationsInput | string | null
    Thread?: NullableStringFieldUpdateOperationsInput | string | null
    Voice?: NullableStringFieldUpdateOperationsInput | string | null
    Webhook?: NullableStringFieldUpdateOperationsInput | string | null
    Ban?: NullableStringFieldUpdateOperationsInput | string | null
    Kick?: NullableStringFieldUpdateOperationsInput | string | null
    Poll?: NullableStringFieldUpdateOperationsInput | string | null
    Stage?: NullableStringFieldUpdateOperationsInput | string | null
    Event?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GuildLoggingsUncheckedUpdateManyInput = {
    AutoMod?: NullableStringFieldUpdateOperationsInput | string | null
    Channel?: NullableStringFieldUpdateOperationsInput | string | null
    Emoji?: NullableStringFieldUpdateOperationsInput | string | null
    Guild?: NullableStringFieldUpdateOperationsInput | string | null
    Integration?: NullableStringFieldUpdateOperationsInput | string | null
    Invite?: NullableStringFieldUpdateOperationsInput | string | null
    Member?: NullableStringFieldUpdateOperationsInput | string | null
    Message?: NullableStringFieldUpdateOperationsInput | string | null
    Moderation?: NullableStringFieldUpdateOperationsInput | string | null
    Reaction?: NullableStringFieldUpdateOperationsInput | string | null
    Role?: NullableStringFieldUpdateOperationsInput | string | null
    SoundBoard?: NullableStringFieldUpdateOperationsInput | string | null
    Sticker?: NullableStringFieldUpdateOperationsInput | string | null
    Thread?: NullableStringFieldUpdateOperationsInput | string | null
    Voice?: NullableStringFieldUpdateOperationsInput | string | null
    Webhook?: NullableStringFieldUpdateOperationsInput | string | null
    Ban?: NullableStringFieldUpdateOperationsInput | string | null
    Kick?: NullableStringFieldUpdateOperationsInput | string | null
    Poll?: NullableStringFieldUpdateOperationsInput | string | null
    Stage?: NullableStringFieldUpdateOperationsInput | string | null
    Event?: NullableStringFieldUpdateOperationsInput | string | null
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type GuildLoggersCreateInput = {
    id?: string
    UUID: string
    Notes?: GuildLoggersCreateNotesInput | string[]
    LogMessage: string
    LogJSON: string
    Guilds: GuildsCreateNestedOneWithoutGuildLoggersInput
  }

  export type GuildLoggersUncheckedCreateInput = {
    id?: string
    UUID: string
    Notes?: GuildLoggersCreateNotesInput | string[]
    LogMessage: string
    LogJSON: string
    GuildId: string
  }

  export type GuildLoggersUpdateInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Notes?: GuildLoggersUpdateNotesInput | string[]
    LogMessage?: StringFieldUpdateOperationsInput | string
    LogJSON?: StringFieldUpdateOperationsInput | string
    Guilds?: GuildsUpdateOneRequiredWithoutGuildLoggersNestedInput
  }

  export type GuildLoggersUncheckedUpdateInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Notes?: GuildLoggersUpdateNotesInput | string[]
    LogMessage?: StringFieldUpdateOperationsInput | string
    LogJSON?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type GuildLoggersCreateManyInput = {
    id?: string
    UUID: string
    Notes?: GuildLoggersCreateNotesInput | string[]
    LogMessage: string
    LogJSON: string
    GuildId: string
  }

  export type GuildLoggersUpdateManyMutationInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Notes?: GuildLoggersUpdateNotesInput | string[]
    LogMessage?: StringFieldUpdateOperationsInput | string
    LogJSON?: StringFieldUpdateOperationsInput | string
  }

  export type GuildLoggersUncheckedUpdateManyInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Notes?: GuildLoggersUpdateNotesInput | string[]
    LogMessage?: StringFieldUpdateOperationsInput | string
    LogJSON?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageTemplatesCreateInput = {
    id?: string
    Content?: string | null
    EmbedJSON?: string | null
    OtherEmbeds?: MessageTemplatesCreateOtherEmbedsInput | string[]
    Name: string
    Guilds: GuildsCreateNestedOneWithoutMessageTemplatesInput
  }

  export type MessageTemplatesUncheckedCreateInput = {
    id?: string
    Content?: string | null
    EmbedJSON?: string | null
    OtherEmbeds?: MessageTemplatesCreateOtherEmbedsInput | string[]
    Name: string
    GuildId: string
  }

  export type MessageTemplatesUpdateInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    EmbedJSON?: NullableStringFieldUpdateOperationsInput | string | null
    OtherEmbeds?: MessageTemplatesUpdateOtherEmbedsInput | string[]
    Name?: StringFieldUpdateOperationsInput | string
    Guilds?: GuildsUpdateOneRequiredWithoutMessageTemplatesNestedInput
  }

  export type MessageTemplatesUncheckedUpdateInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    EmbedJSON?: NullableStringFieldUpdateOperationsInput | string | null
    OtherEmbeds?: MessageTemplatesUpdateOtherEmbedsInput | string[]
    Name?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageTemplatesCreateManyInput = {
    id?: string
    Content?: string | null
    EmbedJSON?: string | null
    OtherEmbeds?: MessageTemplatesCreateOtherEmbedsInput | string[]
    Name: string
    GuildId: string
  }

  export type MessageTemplatesUpdateManyMutationInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    EmbedJSON?: NullableStringFieldUpdateOperationsInput | string | null
    OtherEmbeds?: MessageTemplatesUpdateOtherEmbedsInput | string[]
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type MessageTemplatesUncheckedUpdateManyInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    EmbedJSON?: NullableStringFieldUpdateOperationsInput | string | null
    OtherEmbeds?: MessageTemplatesUpdateOtherEmbedsInput | string[]
    Name?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type PermissionsCreateInput = {
    id?: string
    Permissions?: XOR<PermissionDataListCreateEnvelopeInput, PermissionDataCreateInput> | PermissionDataCreateInput[]
    Guilds: GuildsCreateNestedOneWithoutPermissionsInput
  }

  export type PermissionsUncheckedCreateInput = {
    id?: string
    Permissions?: XOR<PermissionDataListCreateEnvelopeInput, PermissionDataCreateInput> | PermissionDataCreateInput[]
    GuildId: string
  }

  export type PermissionsUpdateInput = {
    Permissions?: XOR<PermissionDataListUpdateEnvelopeInput, PermissionDataCreateInput> | PermissionDataCreateInput[]
    Guilds?: GuildsUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type PermissionsUncheckedUpdateInput = {
    Permissions?: XOR<PermissionDataListUpdateEnvelopeInput, PermissionDataCreateInput> | PermissionDataCreateInput[]
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type PermissionsCreateManyInput = {
    id?: string
    Permissions?: XOR<PermissionDataListCreateEnvelopeInput, PermissionDataCreateInput> | PermissionDataCreateInput[]
    GuildId: string
  }

  export type PermissionsUpdateManyMutationInput = {
    Permissions?: XOR<PermissionDataListUpdateEnvelopeInput, PermissionDataCreateInput> | PermissionDataCreateInput[]
  }

  export type PermissionsUncheckedUpdateManyInput = {
    Permissions?: XOR<PermissionDataListUpdateEnvelopeInput, PermissionDataCreateInput> | PermissionDataCreateInput[]
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type ReactionRolesCreateInput = {
    id?: string
    UUID: string
    Roles?: ReactionRolesCreateRolesInput | string[]
    MessageId?: string | null
    ChannelId?: string | null
    AddMessage?: string | null
    RemoveMessage?: string | null
    Button?: XOR<ReactionRoleButtonNullableCreateEnvelopeInput, ReactionRoleButtonCreateInput> | null
    SelectMenu?: XOR<ReactionRoleSelectmenuNullableCreateEnvelopeInput, ReactionRoleSelectmenuCreateInput> | null
    Emoji?: string | null
    Guilds: GuildsCreateNestedOneWithoutReactionRoleInput
  }

  export type ReactionRolesUncheckedCreateInput = {
    id?: string
    UUID: string
    Roles?: ReactionRolesCreateRolesInput | string[]
    MessageId?: string | null
    ChannelId?: string | null
    AddMessage?: string | null
    RemoveMessage?: string | null
    Button?: XOR<ReactionRoleButtonNullableCreateEnvelopeInput, ReactionRoleButtonCreateInput> | null
    SelectMenu?: XOR<ReactionRoleSelectmenuNullableCreateEnvelopeInput, ReactionRoleSelectmenuCreateInput> | null
    Emoji?: string | null
    GuildId: string
  }

  export type ReactionRolesUpdateInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Roles?: ReactionRolesUpdateRolesInput | string[]
    MessageId?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    AddMessage?: NullableStringFieldUpdateOperationsInput | string | null
    RemoveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    Button?: XOR<ReactionRoleButtonNullableUpdateEnvelopeInput, ReactionRoleButtonCreateInput> | null
    SelectMenu?: XOR<ReactionRoleSelectmenuNullableUpdateEnvelopeInput, ReactionRoleSelectmenuCreateInput> | null
    Emoji?: NullableStringFieldUpdateOperationsInput | string | null
    Guilds?: GuildsUpdateOneRequiredWithoutReactionRoleNestedInput
  }

  export type ReactionRolesUncheckedUpdateInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Roles?: ReactionRolesUpdateRolesInput | string[]
    MessageId?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    AddMessage?: NullableStringFieldUpdateOperationsInput | string | null
    RemoveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    Button?: XOR<ReactionRoleButtonNullableUpdateEnvelopeInput, ReactionRoleButtonCreateInput> | null
    SelectMenu?: XOR<ReactionRoleSelectmenuNullableUpdateEnvelopeInput, ReactionRoleSelectmenuCreateInput> | null
    Emoji?: NullableStringFieldUpdateOperationsInput | string | null
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type ReactionRolesCreateManyInput = {
    id?: string
    UUID: string
    Roles?: ReactionRolesCreateRolesInput | string[]
    MessageId?: string | null
    ChannelId?: string | null
    AddMessage?: string | null
    RemoveMessage?: string | null
    Button?: XOR<ReactionRoleButtonNullableCreateEnvelopeInput, ReactionRoleButtonCreateInput> | null
    SelectMenu?: XOR<ReactionRoleSelectmenuNullableCreateEnvelopeInput, ReactionRoleSelectmenuCreateInput> | null
    Emoji?: string | null
    GuildId: string
  }

  export type ReactionRolesUpdateManyMutationInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Roles?: ReactionRolesUpdateRolesInput | string[]
    MessageId?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    AddMessage?: NullableStringFieldUpdateOperationsInput | string | null
    RemoveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    Button?: XOR<ReactionRoleButtonNullableUpdateEnvelopeInput, ReactionRoleButtonCreateInput> | null
    SelectMenu?: XOR<ReactionRoleSelectmenuNullableUpdateEnvelopeInput, ReactionRoleSelectmenuCreateInput> | null
    Emoji?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReactionRolesUncheckedUpdateManyInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Roles?: ReactionRolesUpdateRolesInput | string[]
    MessageId?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    AddMessage?: NullableStringFieldUpdateOperationsInput | string | null
    RemoveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    Button?: XOR<ReactionRoleButtonNullableUpdateEnvelopeInput, ReactionRoleButtonCreateInput> | null
    SelectMenu?: XOR<ReactionRoleSelectmenuNullableUpdateEnvelopeInput, ReactionRoleSelectmenuCreateInput> | null
    Emoji?: NullableStringFieldUpdateOperationsInput | string | null
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type SecuritysCreateInput = {
    id?: string
    InviteLoggingActive?: string | null
    MaxAccountAge?: number | null
    VerificationGates?: VerificationGatesCreateNestedManyWithoutVerificationGatesInput
    Guilds: GuildsCreateNestedOneWithoutSecurityInput
  }

  export type SecuritysUncheckedCreateInput = {
    id?: string
    InviteLoggingActive?: string | null
    MaxAccountAge?: number | null
    GuildId: string
    VerificationGates?: VerificationGatesUncheckedCreateNestedManyWithoutVerificationGatesInput
  }

  export type SecuritysUpdateInput = {
    InviteLoggingActive?: NullableStringFieldUpdateOperationsInput | string | null
    MaxAccountAge?: NullableIntFieldUpdateOperationsInput | number | null
    VerificationGates?: VerificationGatesUpdateManyWithoutVerificationGatesNestedInput
    Guilds?: GuildsUpdateOneRequiredWithoutSecurityNestedInput
  }

  export type SecuritysUncheckedUpdateInput = {
    InviteLoggingActive?: NullableStringFieldUpdateOperationsInput | string | null
    MaxAccountAge?: NullableIntFieldUpdateOperationsInput | number | null
    GuildId?: StringFieldUpdateOperationsInput | string
    VerificationGates?: VerificationGatesUncheckedUpdateManyWithoutVerificationGatesNestedInput
  }

  export type SecuritysCreateManyInput = {
    id?: string
    InviteLoggingActive?: string | null
    MaxAccountAge?: number | null
    GuildId: string
  }

  export type SecuritysUpdateManyMutationInput = {
    InviteLoggingActive?: NullableStringFieldUpdateOperationsInput | string | null
    MaxAccountAge?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SecuritysUncheckedUpdateManyInput = {
    InviteLoggingActive?: NullableStringFieldUpdateOperationsInput | string | null
    MaxAccountAge?: NullableIntFieldUpdateOperationsInput | number | null
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationGatesCreateInput = {
    id?: string
    UUID: string
    ChannelId: string
    MessageId: string
    Action?: string | null
    ActionType?: string | null
    Roles?: VerificationGatesCreateRolesInput | string[]
    VerifiedUsers?: VerificationGatesCreateVerifiedUsersInput | string[]
    CreatedAt: Date | string
    Active?: boolean | null
    ChannelPermissions?: VerificationGatesPermissionCreateNestedManyWithoutVerificationGatesInput
    VerificationGates: SecuritysCreateNestedOneWithoutVerificationGatesInput
  }

  export type VerificationGatesUncheckedCreateInput = {
    id?: string
    UUID: string
    ChannelId: string
    MessageId: string
    Action?: string | null
    ActionType?: string | null
    Roles?: VerificationGatesCreateRolesInput | string[]
    VerifiedUsers?: VerificationGatesCreateVerifiedUsersInput | string[]
    CreatedAt: Date | string
    Active?: boolean | null
    SecurityId: string
    ChannelPermissions?: VerificationGatesPermissionUncheckedCreateNestedManyWithoutVerificationGatesInput
  }

  export type VerificationGatesUpdateInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    Action?: NullableStringFieldUpdateOperationsInput | string | null
    ActionType?: NullableStringFieldUpdateOperationsInput | string | null
    Roles?: VerificationGatesUpdateRolesInput | string[]
    VerifiedUsers?: VerificationGatesUpdateVerifiedUsersInput | string[]
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ChannelPermissions?: VerificationGatesPermissionUpdateManyWithoutVerificationGatesNestedInput
    VerificationGates?: SecuritysUpdateOneRequiredWithoutVerificationGatesNestedInput
  }

  export type VerificationGatesUncheckedUpdateInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    Action?: NullableStringFieldUpdateOperationsInput | string | null
    ActionType?: NullableStringFieldUpdateOperationsInput | string | null
    Roles?: VerificationGatesUpdateRolesInput | string[]
    VerifiedUsers?: VerificationGatesUpdateVerifiedUsersInput | string[]
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SecurityId?: StringFieldUpdateOperationsInput | string
    ChannelPermissions?: VerificationGatesPermissionUncheckedUpdateManyWithoutVerificationGatesNestedInput
  }

  export type VerificationGatesCreateManyInput = {
    id?: string
    UUID: string
    ChannelId: string
    MessageId: string
    Action?: string | null
    ActionType?: string | null
    Roles?: VerificationGatesCreateRolesInput | string[]
    VerifiedUsers?: VerificationGatesCreateVerifiedUsersInput | string[]
    CreatedAt: Date | string
    Active?: boolean | null
    SecurityId: string
  }

  export type VerificationGatesUpdateManyMutationInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    Action?: NullableStringFieldUpdateOperationsInput | string | null
    ActionType?: NullableStringFieldUpdateOperationsInput | string | null
    Roles?: VerificationGatesUpdateRolesInput | string[]
    VerifiedUsers?: VerificationGatesUpdateVerifiedUsersInput | string[]
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type VerificationGatesUncheckedUpdateManyInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    Action?: NullableStringFieldUpdateOperationsInput | string | null
    ActionType?: NullableStringFieldUpdateOperationsInput | string | null
    Roles?: VerificationGatesUpdateRolesInput | string[]
    VerifiedUsers?: VerificationGatesUpdateVerifiedUsersInput | string[]
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SecurityId?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationGatesPermissionCreateInput = {
    id?: string
    Permission?: VerificationGatesPermissionCreatePermissionInput | string[]
    ChannelId: string
    VerificationGates: VerificationGatesCreateNestedOneWithoutChannelPermissionsInput
  }

  export type VerificationGatesPermissionUncheckedCreateInput = {
    id?: string
    Permission?: VerificationGatesPermissionCreatePermissionInput | string[]
    ChannelId: string
    VerificationGateId: string
  }

  export type VerificationGatesPermissionUpdateInput = {
    Permission?: VerificationGatesPermissionUpdatePermissionInput | string[]
    ChannelId?: StringFieldUpdateOperationsInput | string
    VerificationGates?: VerificationGatesUpdateOneRequiredWithoutChannelPermissionsNestedInput
  }

  export type VerificationGatesPermissionUncheckedUpdateInput = {
    Permission?: VerificationGatesPermissionUpdatePermissionInput | string[]
    ChannelId?: StringFieldUpdateOperationsInput | string
    VerificationGateId?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationGatesPermissionCreateManyInput = {
    id?: string
    Permission?: VerificationGatesPermissionCreatePermissionInput | string[]
    ChannelId: string
    VerificationGateId: string
  }

  export type VerificationGatesPermissionUpdateManyMutationInput = {
    Permission?: VerificationGatesPermissionUpdatePermissionInput | string[]
    ChannelId?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationGatesPermissionUncheckedUpdateManyInput = {
    Permission?: VerificationGatesPermissionUpdatePermissionInput | string[]
    ChannelId?: StringFieldUpdateOperationsInput | string
    VerificationGateId?: StringFieldUpdateOperationsInput | string
  }

  export type SpotifyNotificationsCreateInput = {
    id?: string
    ShowId: string
    ChannelId: string
    Latests?: SpotifyNotificationsCreateLatestsInput | string[]
    MessageTemplateId: string
    PingRoles?: SpotifyNotificationsCreatePingRolesInput | string[]
    UUID: string
    Guilds: GuildsCreateNestedOneWithoutSpotifyNotificationsInput
  }

  export type SpotifyNotificationsUncheckedCreateInput = {
    id?: string
    ShowId: string
    ChannelId: string
    Latests?: SpotifyNotificationsCreateLatestsInput | string[]
    MessageTemplateId: string
    PingRoles?: SpotifyNotificationsCreatePingRolesInput | string[]
    UUID: string
    GuildId: string
  }

  export type SpotifyNotificationsUpdateInput = {
    ShowId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Latests?: SpotifyNotificationsUpdateLatestsInput | string[]
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    PingRoles?: SpotifyNotificationsUpdatePingRolesInput | string[]
    UUID?: StringFieldUpdateOperationsInput | string
    Guilds?: GuildsUpdateOneRequiredWithoutSpotifyNotificationsNestedInput
  }

  export type SpotifyNotificationsUncheckedUpdateInput = {
    ShowId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Latests?: SpotifyNotificationsUpdateLatestsInput | string[]
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    PingRoles?: SpotifyNotificationsUpdatePingRolesInput | string[]
    UUID?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type SpotifyNotificationsCreateManyInput = {
    id?: string
    ShowId: string
    ChannelId: string
    Latests?: SpotifyNotificationsCreateLatestsInput | string[]
    MessageTemplateId: string
    PingRoles?: SpotifyNotificationsCreatePingRolesInput | string[]
    UUID: string
    GuildId: string
  }

  export type SpotifyNotificationsUpdateManyMutationInput = {
    ShowId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Latests?: SpotifyNotificationsUpdateLatestsInput | string[]
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    PingRoles?: SpotifyNotificationsUpdatePingRolesInput | string[]
    UUID?: StringFieldUpdateOperationsInput | string
  }

  export type SpotifyNotificationsUncheckedUpdateManyInput = {
    ShowId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Latests?: SpotifyNotificationsUpdateLatestsInput | string[]
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    PingRoles?: SpotifyNotificationsUpdatePingRolesInput | string[]
    UUID?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type TagsCreateInput = {
    id?: string
    UUID: string
    TagId: string
    MessageId: string
    IsShlashCommand: boolean
    ShlashCommandId: string
    IsTextInputCommand: boolean
    IsEnabled: boolean
    PermissionRoleId?: string | null
    CommandDescription?: string | null
    FilterTextFromMessages?: TagsCreateFilterTextFromMessagesInput | string[]
    Guilds: GuildsCreateNestedOneWithoutTagsInput
  }

  export type TagsUncheckedCreateInput = {
    id?: string
    UUID: string
    TagId: string
    MessageId: string
    IsShlashCommand: boolean
    ShlashCommandId: string
    IsTextInputCommand: boolean
    IsEnabled: boolean
    PermissionRoleId?: string | null
    CommandDescription?: string | null
    FilterTextFromMessages?: TagsCreateFilterTextFromMessagesInput | string[]
    GuildId: string
  }

  export type TagsUpdateInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    TagId?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    IsShlashCommand?: BoolFieldUpdateOperationsInput | boolean
    ShlashCommandId?: StringFieldUpdateOperationsInput | string
    IsTextInputCommand?: BoolFieldUpdateOperationsInput | boolean
    IsEnabled?: BoolFieldUpdateOperationsInput | boolean
    PermissionRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    CommandDescription?: NullableStringFieldUpdateOperationsInput | string | null
    FilterTextFromMessages?: TagsUpdateFilterTextFromMessagesInput | string[]
    Guilds?: GuildsUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagsUncheckedUpdateInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    TagId?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    IsShlashCommand?: BoolFieldUpdateOperationsInput | boolean
    ShlashCommandId?: StringFieldUpdateOperationsInput | string
    IsTextInputCommand?: BoolFieldUpdateOperationsInput | boolean
    IsEnabled?: BoolFieldUpdateOperationsInput | boolean
    PermissionRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    CommandDescription?: NullableStringFieldUpdateOperationsInput | string | null
    FilterTextFromMessages?: TagsUpdateFilterTextFromMessagesInput | string[]
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type TagsCreateManyInput = {
    id?: string
    UUID: string
    TagId: string
    MessageId: string
    IsShlashCommand: boolean
    ShlashCommandId: string
    IsTextInputCommand: boolean
    IsEnabled: boolean
    PermissionRoleId?: string | null
    CommandDescription?: string | null
    FilterTextFromMessages?: TagsCreateFilterTextFromMessagesInput | string[]
    GuildId: string
  }

  export type TagsUpdateManyMutationInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    TagId?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    IsShlashCommand?: BoolFieldUpdateOperationsInput | boolean
    ShlashCommandId?: StringFieldUpdateOperationsInput | string
    IsTextInputCommand?: BoolFieldUpdateOperationsInput | boolean
    IsEnabled?: BoolFieldUpdateOperationsInput | boolean
    PermissionRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    CommandDescription?: NullableStringFieldUpdateOperationsInput | string | null
    FilterTextFromMessages?: TagsUpdateFilterTextFromMessagesInput | string[]
  }

  export type TagsUncheckedUpdateManyInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    TagId?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    IsShlashCommand?: BoolFieldUpdateOperationsInput | boolean
    ShlashCommandId?: StringFieldUpdateOperationsInput | string
    IsTextInputCommand?: BoolFieldUpdateOperationsInput | boolean
    IsEnabled?: BoolFieldUpdateOperationsInput | boolean
    PermissionRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    CommandDescription?: NullableStringFieldUpdateOperationsInput | string | null
    FilterTextFromMessages?: TagsUpdateFilterTextFromMessagesInput | string[]
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketSetupsCreateInput = {
    id?: string
    CategoryId?: string | null
    Handlers?: TicketSetupsCreateHandlersInput | string[]
    HandlerWithShadowPing?: TicketSetupsCreateHandlerWithShadowPingInput | string[]
    CustomId: string
    TicketChannelName?: string | null
    ChannelType?: number | null
    MessageTempleateId?: string | null
    TicketBlacklistRoles?: TicketSetupsCreateTicketBlacklistRolesInput | string[]
    TranscriptChannelId?: string | null
    HasModal?: boolean | null
    UserDMWhenCloseMessageTemplateId?: string | null
    TicketLimit?: number | null
    WithTicketFeedback?: boolean | null
    TicketFeedbackChannelId?: string | null
    ModalTitle?: string | null
    TicketCreationCooldownPerUser?: number | null
    AutoCloseAfterInactivity?: number | null
    AutoAssignHandler?: string | null
    AutoReplyMessageTemplateId?: string | null
    RequiredRoles?: TicketSetupsCreateRequiredRolesInput | string[]
    OpenTicketWithCommand?: boolean | null
    SlashCommandId?: string | null
    TextCommandName?: string | null
    SendTranscriptToUser?: boolean | null
    ModalOptions?: TicketModalDataCreateNestedManyWithoutTicketSetupInput
    Guilds: GuildsCreateNestedOneWithoutTicketSetupsInput
    Tickets?: TicketsCreateNestedManyWithoutTicketSetupInput
  }

  export type TicketSetupsUncheckedCreateInput = {
    id?: string
    CategoryId?: string | null
    Handlers?: TicketSetupsCreateHandlersInput | string[]
    HandlerWithShadowPing?: TicketSetupsCreateHandlerWithShadowPingInput | string[]
    CustomId: string
    TicketChannelName?: string | null
    ChannelType?: number | null
    MessageTempleateId?: string | null
    TicketBlacklistRoles?: TicketSetupsCreateTicketBlacklistRolesInput | string[]
    TranscriptChannelId?: string | null
    HasModal?: boolean | null
    UserDMWhenCloseMessageTemplateId?: string | null
    TicketLimit?: number | null
    WithTicketFeedback?: boolean | null
    TicketFeedbackChannelId?: string | null
    ModalTitle?: string | null
    TicketCreationCooldownPerUser?: number | null
    AutoCloseAfterInactivity?: number | null
    AutoAssignHandler?: string | null
    AutoReplyMessageTemplateId?: string | null
    RequiredRoles?: TicketSetupsCreateRequiredRolesInput | string[]
    OpenTicketWithCommand?: boolean | null
    SlashCommandId?: string | null
    TextCommandName?: string | null
    SendTranscriptToUser?: boolean | null
    GuildId: string
    ModalOptions?: TicketModalDataUncheckedCreateNestedManyWithoutTicketSetupInput
    Tickets?: TicketsUncheckedCreateNestedManyWithoutTicketSetupInput
  }

  export type TicketSetupsUpdateInput = {
    CategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    Handlers?: TicketSetupsUpdateHandlersInput | string[]
    HandlerWithShadowPing?: TicketSetupsUpdateHandlerWithShadowPingInput | string[]
    CustomId?: StringFieldUpdateOperationsInput | string
    TicketChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelType?: NullableIntFieldUpdateOperationsInput | number | null
    MessageTempleateId?: NullableStringFieldUpdateOperationsInput | string | null
    TicketBlacklistRoles?: TicketSetupsUpdateTicketBlacklistRolesInput | string[]
    TranscriptChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    HasModal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UserDMWhenCloseMessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    TicketLimit?: NullableIntFieldUpdateOperationsInput | number | null
    WithTicketFeedback?: NullableBoolFieldUpdateOperationsInput | boolean | null
    TicketFeedbackChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    ModalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    TicketCreationCooldownPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    AutoCloseAfterInactivity?: NullableIntFieldUpdateOperationsInput | number | null
    AutoAssignHandler?: NullableStringFieldUpdateOperationsInput | string | null
    AutoReplyMessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    RequiredRoles?: TicketSetupsUpdateRequiredRolesInput | string[]
    OpenTicketWithCommand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SlashCommandId?: NullableStringFieldUpdateOperationsInput | string | null
    TextCommandName?: NullableStringFieldUpdateOperationsInput | string | null
    SendTranscriptToUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ModalOptions?: TicketModalDataUpdateManyWithoutTicketSetupNestedInput
    Guilds?: GuildsUpdateOneRequiredWithoutTicketSetupsNestedInput
    Tickets?: TicketsUpdateManyWithoutTicketSetupNestedInput
  }

  export type TicketSetupsUncheckedUpdateInput = {
    CategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    Handlers?: TicketSetupsUpdateHandlersInput | string[]
    HandlerWithShadowPing?: TicketSetupsUpdateHandlerWithShadowPingInput | string[]
    CustomId?: StringFieldUpdateOperationsInput | string
    TicketChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelType?: NullableIntFieldUpdateOperationsInput | number | null
    MessageTempleateId?: NullableStringFieldUpdateOperationsInput | string | null
    TicketBlacklistRoles?: TicketSetupsUpdateTicketBlacklistRolesInput | string[]
    TranscriptChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    HasModal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UserDMWhenCloseMessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    TicketLimit?: NullableIntFieldUpdateOperationsInput | number | null
    WithTicketFeedback?: NullableBoolFieldUpdateOperationsInput | boolean | null
    TicketFeedbackChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    ModalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    TicketCreationCooldownPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    AutoCloseAfterInactivity?: NullableIntFieldUpdateOperationsInput | number | null
    AutoAssignHandler?: NullableStringFieldUpdateOperationsInput | string | null
    AutoReplyMessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    RequiredRoles?: TicketSetupsUpdateRequiredRolesInput | string[]
    OpenTicketWithCommand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SlashCommandId?: NullableStringFieldUpdateOperationsInput | string | null
    TextCommandName?: NullableStringFieldUpdateOperationsInput | string | null
    SendTranscriptToUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    GuildId?: StringFieldUpdateOperationsInput | string
    ModalOptions?: TicketModalDataUncheckedUpdateManyWithoutTicketSetupNestedInput
    Tickets?: TicketsUncheckedUpdateManyWithoutTicketSetupNestedInput
  }

  export type TicketSetupsCreateManyInput = {
    id?: string
    CategoryId?: string | null
    Handlers?: TicketSetupsCreateHandlersInput | string[]
    HandlerWithShadowPing?: TicketSetupsCreateHandlerWithShadowPingInput | string[]
    CustomId: string
    TicketChannelName?: string | null
    ChannelType?: number | null
    MessageTempleateId?: string | null
    TicketBlacklistRoles?: TicketSetupsCreateTicketBlacklistRolesInput | string[]
    TranscriptChannelId?: string | null
    HasModal?: boolean | null
    UserDMWhenCloseMessageTemplateId?: string | null
    TicketLimit?: number | null
    WithTicketFeedback?: boolean | null
    TicketFeedbackChannelId?: string | null
    ModalTitle?: string | null
    TicketCreationCooldownPerUser?: number | null
    AutoCloseAfterInactivity?: number | null
    AutoAssignHandler?: string | null
    AutoReplyMessageTemplateId?: string | null
    RequiredRoles?: TicketSetupsCreateRequiredRolesInput | string[]
    OpenTicketWithCommand?: boolean | null
    SlashCommandId?: string | null
    TextCommandName?: string | null
    SendTranscriptToUser?: boolean | null
    GuildId: string
  }

  export type TicketSetupsUpdateManyMutationInput = {
    CategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    Handlers?: TicketSetupsUpdateHandlersInput | string[]
    HandlerWithShadowPing?: TicketSetupsUpdateHandlerWithShadowPingInput | string[]
    CustomId?: StringFieldUpdateOperationsInput | string
    TicketChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelType?: NullableIntFieldUpdateOperationsInput | number | null
    MessageTempleateId?: NullableStringFieldUpdateOperationsInput | string | null
    TicketBlacklistRoles?: TicketSetupsUpdateTicketBlacklistRolesInput | string[]
    TranscriptChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    HasModal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UserDMWhenCloseMessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    TicketLimit?: NullableIntFieldUpdateOperationsInput | number | null
    WithTicketFeedback?: NullableBoolFieldUpdateOperationsInput | boolean | null
    TicketFeedbackChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    ModalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    TicketCreationCooldownPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    AutoCloseAfterInactivity?: NullableIntFieldUpdateOperationsInput | number | null
    AutoAssignHandler?: NullableStringFieldUpdateOperationsInput | string | null
    AutoReplyMessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    RequiredRoles?: TicketSetupsUpdateRequiredRolesInput | string[]
    OpenTicketWithCommand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SlashCommandId?: NullableStringFieldUpdateOperationsInput | string | null
    TextCommandName?: NullableStringFieldUpdateOperationsInput | string | null
    SendTranscriptToUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TicketSetupsUncheckedUpdateManyInput = {
    CategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    Handlers?: TicketSetupsUpdateHandlersInput | string[]
    HandlerWithShadowPing?: TicketSetupsUpdateHandlerWithShadowPingInput | string[]
    CustomId?: StringFieldUpdateOperationsInput | string
    TicketChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelType?: NullableIntFieldUpdateOperationsInput | number | null
    MessageTempleateId?: NullableStringFieldUpdateOperationsInput | string | null
    TicketBlacklistRoles?: TicketSetupsUpdateTicketBlacklistRolesInput | string[]
    TranscriptChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    HasModal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UserDMWhenCloseMessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    TicketLimit?: NullableIntFieldUpdateOperationsInput | number | null
    WithTicketFeedback?: NullableBoolFieldUpdateOperationsInput | boolean | null
    TicketFeedbackChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    ModalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    TicketCreationCooldownPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    AutoCloseAfterInactivity?: NullableIntFieldUpdateOperationsInput | number | null
    AutoAssignHandler?: NullableStringFieldUpdateOperationsInput | string | null
    AutoReplyMessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    RequiredRoles?: TicketSetupsUpdateRequiredRolesInput | string[]
    OpenTicketWithCommand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SlashCommandId?: NullableStringFieldUpdateOperationsInput | string | null
    TextCommandName?: NullableStringFieldUpdateOperationsInput | string | null
    SendTranscriptToUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketModalDataCreateInput = {
    id?: string
    Name: string
    Placeholder: string
    Type: number
    TicketSetup: TicketSetupsCreateNestedOneWithoutModalOptionsInput
  }

  export type TicketModalDataUncheckedCreateInput = {
    id?: string
    Name: string
    Placeholder: string
    Type: number
    TicketSetupId: string
  }

  export type TicketModalDataUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Placeholder?: StringFieldUpdateOperationsInput | string
    Type?: IntFieldUpdateOperationsInput | number
    TicketSetup?: TicketSetupsUpdateOneRequiredWithoutModalOptionsNestedInput
  }

  export type TicketModalDataUncheckedUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Placeholder?: StringFieldUpdateOperationsInput | string
    Type?: IntFieldUpdateOperationsInput | number
    TicketSetupId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketModalDataCreateManyInput = {
    id?: string
    Name: string
    Placeholder: string
    Type: number
    TicketSetupId: string
  }

  export type TicketModalDataUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Placeholder?: StringFieldUpdateOperationsInput | string
    Type?: IntFieldUpdateOperationsInput | number
  }

  export type TicketModalDataUncheckedUpdateManyInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Placeholder?: StringFieldUpdateOperationsInput | string
    Type?: IntFieldUpdateOperationsInput | number
    TicketSetupId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketHandlersCreateInput = {
    id?: string
    DiscordRoleId: string
    TicketPermission?: string | null
    AddedDiscordPermission?: TicketHandlersCreateAddedDiscordPermissionInput | string[]
    RemovedDiscordPermission?: TicketHandlersCreateRemovedDiscordPermissionInput | string[]
  }

  export type TicketHandlersUncheckedCreateInput = {
    id?: string
    DiscordRoleId: string
    TicketPermission?: string | null
    AddedDiscordPermission?: TicketHandlersCreateAddedDiscordPermissionInput | string[]
    RemovedDiscordPermission?: TicketHandlersCreateRemovedDiscordPermissionInput | string[]
  }

  export type TicketHandlersUpdateInput = {
    DiscordRoleId?: StringFieldUpdateOperationsInput | string
    TicketPermission?: NullableStringFieldUpdateOperationsInput | string | null
    AddedDiscordPermission?: TicketHandlersUpdateAddedDiscordPermissionInput | string[]
    RemovedDiscordPermission?: TicketHandlersUpdateRemovedDiscordPermissionInput | string[]
  }

  export type TicketHandlersUncheckedUpdateInput = {
    DiscordRoleId?: StringFieldUpdateOperationsInput | string
    TicketPermission?: NullableStringFieldUpdateOperationsInput | string | null
    AddedDiscordPermission?: TicketHandlersUpdateAddedDiscordPermissionInput | string[]
    RemovedDiscordPermission?: TicketHandlersUpdateRemovedDiscordPermissionInput | string[]
  }

  export type TicketHandlersCreateManyInput = {
    id?: string
    DiscordRoleId: string
    TicketPermission?: string | null
    AddedDiscordPermission?: TicketHandlersCreateAddedDiscordPermissionInput | string[]
    RemovedDiscordPermission?: TicketHandlersCreateRemovedDiscordPermissionInput | string[]
  }

  export type TicketHandlersUpdateManyMutationInput = {
    DiscordRoleId?: StringFieldUpdateOperationsInput | string
    TicketPermission?: NullableStringFieldUpdateOperationsInput | string | null
    AddedDiscordPermission?: TicketHandlersUpdateAddedDiscordPermissionInput | string[]
    RemovedDiscordPermission?: TicketHandlersUpdateRemovedDiscordPermissionInput | string[]
  }

  export type TicketHandlersUncheckedUpdateManyInput = {
    DiscordRoleId?: StringFieldUpdateOperationsInput | string
    TicketPermission?: NullableStringFieldUpdateOperationsInput | string | null
    AddedDiscordPermission?: TicketHandlersUpdateAddedDiscordPermissionInput | string[]
    RemovedDiscordPermission?: TicketHandlersUpdateRemovedDiscordPermissionInput | string[]
  }

  export type TicketsCreateInput = {
    id?: string
    TicketId: string
    GuildId: string
    ChannelId?: string | null
    ThreadId?: string | null
    IsClaimed?: boolean | null
    IsArchived?: boolean | null
    ArchiveMessageId?: string | null
    UserWhoHasClaimedId?: string | null
    IsLooked?: boolean | null
    TicketOwnerId: string
    AddedMemberIds?: TicketsCreateAddedMemberIdsInput | string[]
    Handlers?: TicketsCreateHandlersInput | string[]
    TranscriptChannelId: string
    TranscriptHTML?: string | null
    TicketNotes?: TicketsCreateTicketNotesInput | string[]
    TicketSetup: TicketSetupsCreateNestedOneWithoutTicketsInput
    TicketFeedback?: TicketFeedbackCreateNestedOneWithoutTicketInput
  }

  export type TicketsUncheckedCreateInput = {
    id?: string
    TicketId: string
    GuildId: string
    ChannelId?: string | null
    ThreadId?: string | null
    IsClaimed?: boolean | null
    IsArchived?: boolean | null
    ArchiveMessageId?: string | null
    UserWhoHasClaimedId?: string | null
    IsLooked?: boolean | null
    TicketOwnerId: string
    AddedMemberIds?: TicketsCreateAddedMemberIdsInput | string[]
    Handlers?: TicketsCreateHandlersInput | string[]
    TranscriptChannelId: string
    TranscriptHTML?: string | null
    TicketNotes?: TicketsCreateTicketNotesInput | string[]
    TicketSetupId: string
    TicketFeedback?: TicketFeedbackUncheckedCreateNestedOneWithoutTicketInput
  }

  export type TicketsUpdateInput = {
    TicketId?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    ThreadId?: NullableStringFieldUpdateOperationsInput | string | null
    IsClaimed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsArchived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ArchiveMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    UserWhoHasClaimedId?: NullableStringFieldUpdateOperationsInput | string | null
    IsLooked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    TicketOwnerId?: StringFieldUpdateOperationsInput | string
    AddedMemberIds?: TicketsUpdateAddedMemberIdsInput | string[]
    Handlers?: TicketsUpdateHandlersInput | string[]
    TranscriptChannelId?: StringFieldUpdateOperationsInput | string
    TranscriptHTML?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNotes?: TicketsUpdateTicketNotesInput | string[]
    TicketSetup?: TicketSetupsUpdateOneRequiredWithoutTicketsNestedInput
    TicketFeedback?: TicketFeedbackUpdateOneWithoutTicketNestedInput
  }

  export type TicketsUncheckedUpdateInput = {
    TicketId?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    ThreadId?: NullableStringFieldUpdateOperationsInput | string | null
    IsClaimed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsArchived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ArchiveMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    UserWhoHasClaimedId?: NullableStringFieldUpdateOperationsInput | string | null
    IsLooked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    TicketOwnerId?: StringFieldUpdateOperationsInput | string
    AddedMemberIds?: TicketsUpdateAddedMemberIdsInput | string[]
    Handlers?: TicketsUpdateHandlersInput | string[]
    TranscriptChannelId?: StringFieldUpdateOperationsInput | string
    TranscriptHTML?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNotes?: TicketsUpdateTicketNotesInput | string[]
    TicketSetupId?: StringFieldUpdateOperationsInput | string
    TicketFeedback?: TicketFeedbackUncheckedUpdateOneWithoutTicketNestedInput
  }

  export type TicketsCreateManyInput = {
    id?: string
    TicketId: string
    GuildId: string
    ChannelId?: string | null
    ThreadId?: string | null
    IsClaimed?: boolean | null
    IsArchived?: boolean | null
    ArchiveMessageId?: string | null
    UserWhoHasClaimedId?: string | null
    IsLooked?: boolean | null
    TicketOwnerId: string
    AddedMemberIds?: TicketsCreateAddedMemberIdsInput | string[]
    Handlers?: TicketsCreateHandlersInput | string[]
    TranscriptChannelId: string
    TranscriptHTML?: string | null
    TicketNotes?: TicketsCreateTicketNotesInput | string[]
    TicketSetupId: string
  }

  export type TicketsUpdateManyMutationInput = {
    TicketId?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    ThreadId?: NullableStringFieldUpdateOperationsInput | string | null
    IsClaimed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsArchived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ArchiveMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    UserWhoHasClaimedId?: NullableStringFieldUpdateOperationsInput | string | null
    IsLooked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    TicketOwnerId?: StringFieldUpdateOperationsInput | string
    AddedMemberIds?: TicketsUpdateAddedMemberIdsInput | string[]
    Handlers?: TicketsUpdateHandlersInput | string[]
    TranscriptChannelId?: StringFieldUpdateOperationsInput | string
    TranscriptHTML?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNotes?: TicketsUpdateTicketNotesInput | string[]
  }

  export type TicketsUncheckedUpdateManyInput = {
    TicketId?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    ThreadId?: NullableStringFieldUpdateOperationsInput | string | null
    IsClaimed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsArchived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ArchiveMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    UserWhoHasClaimedId?: NullableStringFieldUpdateOperationsInput | string | null
    IsLooked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    TicketOwnerId?: StringFieldUpdateOperationsInput | string
    AddedMemberIds?: TicketsUpdateAddedMemberIdsInput | string[]
    Handlers?: TicketsUpdateHandlersInput | string[]
    TranscriptChannelId?: StringFieldUpdateOperationsInput | string
    TranscriptHTML?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNotes?: TicketsUpdateTicketNotesInput | string[]
    TicketSetupId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketFeedbackCreateInput = {
    id?: string
    Rating: number
    Comment?: string | null
    SubmittedAt?: Date | string
    Ticket: TicketsCreateNestedOneWithoutTicketFeedbackInput
  }

  export type TicketFeedbackUncheckedCreateInput = {
    id?: string
    TicketId: string
    Rating: number
    Comment?: string | null
    SubmittedAt?: Date | string
  }

  export type TicketFeedbackUpdateInput = {
    Rating?: IntFieldUpdateOperationsInput | number
    Comment?: NullableStringFieldUpdateOperationsInput | string | null
    SubmittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ticket?: TicketsUpdateOneRequiredWithoutTicketFeedbackNestedInput
  }

  export type TicketFeedbackUncheckedUpdateInput = {
    TicketId?: StringFieldUpdateOperationsInput | string
    Rating?: IntFieldUpdateOperationsInput | number
    Comment?: NullableStringFieldUpdateOperationsInput | string | null
    SubmittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketFeedbackCreateManyInput = {
    id?: string
    TicketId: string
    Rating: number
    Comment?: string | null
    SubmittedAt?: Date | string
  }

  export type TicketFeedbackUpdateManyMutationInput = {
    Rating?: IntFieldUpdateOperationsInput | number
    Comment?: NullableStringFieldUpdateOperationsInput | string | null
    SubmittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketFeedbackUncheckedUpdateManyInput = {
    TicketId?: StringFieldUpdateOperationsInput | string
    Rating?: IntFieldUpdateOperationsInput | number
    Comment?: NullableStringFieldUpdateOperationsInput | string | null
    SubmittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuildFeatureTogglesCreateInput = {
    id?: string
    LevelEnabled?: boolean
    WecomeEnabled?: boolean
    LeaveEnabled?: boolean
    AutoreactEnabled?: boolean
    AutopublishEnabled?: boolean
    ConnectionsEnabled?: boolean
    ChatfilterEnabled?: boolean
    AutorolesEnabled?: boolean
    LoggingEnabled?: boolean
    TwitchEnabled?: boolean
    YoutubeEnabled?: boolean
    SpotifyEnabled?: boolean
    Guilds: GuildsCreateNestedOneWithoutGuildFeatureToggleInput
  }

  export type GuildFeatureTogglesUncheckedCreateInput = {
    id?: string
    LevelEnabled?: boolean
    WecomeEnabled?: boolean
    LeaveEnabled?: boolean
    AutoreactEnabled?: boolean
    AutopublishEnabled?: boolean
    ConnectionsEnabled?: boolean
    ChatfilterEnabled?: boolean
    AutorolesEnabled?: boolean
    LoggingEnabled?: boolean
    TwitchEnabled?: boolean
    YoutubeEnabled?: boolean
    SpotifyEnabled?: boolean
    GuildId: string
  }

  export type GuildFeatureTogglesUpdateInput = {
    LevelEnabled?: BoolFieldUpdateOperationsInput | boolean
    WecomeEnabled?: BoolFieldUpdateOperationsInput | boolean
    LeaveEnabled?: BoolFieldUpdateOperationsInput | boolean
    AutoreactEnabled?: BoolFieldUpdateOperationsInput | boolean
    AutopublishEnabled?: BoolFieldUpdateOperationsInput | boolean
    ConnectionsEnabled?: BoolFieldUpdateOperationsInput | boolean
    ChatfilterEnabled?: BoolFieldUpdateOperationsInput | boolean
    AutorolesEnabled?: BoolFieldUpdateOperationsInput | boolean
    LoggingEnabled?: BoolFieldUpdateOperationsInput | boolean
    TwitchEnabled?: BoolFieldUpdateOperationsInput | boolean
    YoutubeEnabled?: BoolFieldUpdateOperationsInput | boolean
    SpotifyEnabled?: BoolFieldUpdateOperationsInput | boolean
    Guilds?: GuildsUpdateOneRequiredWithoutGuildFeatureToggleNestedInput
  }

  export type GuildFeatureTogglesUncheckedUpdateInput = {
    LevelEnabled?: BoolFieldUpdateOperationsInput | boolean
    WecomeEnabled?: BoolFieldUpdateOperationsInput | boolean
    LeaveEnabled?: BoolFieldUpdateOperationsInput | boolean
    AutoreactEnabled?: BoolFieldUpdateOperationsInput | boolean
    AutopublishEnabled?: BoolFieldUpdateOperationsInput | boolean
    ConnectionsEnabled?: BoolFieldUpdateOperationsInput | boolean
    ChatfilterEnabled?: BoolFieldUpdateOperationsInput | boolean
    AutorolesEnabled?: BoolFieldUpdateOperationsInput | boolean
    LoggingEnabled?: BoolFieldUpdateOperationsInput | boolean
    TwitchEnabled?: BoolFieldUpdateOperationsInput | boolean
    YoutubeEnabled?: BoolFieldUpdateOperationsInput | boolean
    SpotifyEnabled?: BoolFieldUpdateOperationsInput | boolean
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type GuildFeatureTogglesCreateManyInput = {
    id?: string
    LevelEnabled?: boolean
    WecomeEnabled?: boolean
    LeaveEnabled?: boolean
    AutoreactEnabled?: boolean
    AutopublishEnabled?: boolean
    ConnectionsEnabled?: boolean
    ChatfilterEnabled?: boolean
    AutorolesEnabled?: boolean
    LoggingEnabled?: boolean
    TwitchEnabled?: boolean
    YoutubeEnabled?: boolean
    SpotifyEnabled?: boolean
    GuildId: string
  }

  export type GuildFeatureTogglesUpdateManyMutationInput = {
    LevelEnabled?: BoolFieldUpdateOperationsInput | boolean
    WecomeEnabled?: BoolFieldUpdateOperationsInput | boolean
    LeaveEnabled?: BoolFieldUpdateOperationsInput | boolean
    AutoreactEnabled?: BoolFieldUpdateOperationsInput | boolean
    AutopublishEnabled?: BoolFieldUpdateOperationsInput | boolean
    ConnectionsEnabled?: BoolFieldUpdateOperationsInput | boolean
    ChatfilterEnabled?: BoolFieldUpdateOperationsInput | boolean
    AutorolesEnabled?: BoolFieldUpdateOperationsInput | boolean
    LoggingEnabled?: BoolFieldUpdateOperationsInput | boolean
    TwitchEnabled?: BoolFieldUpdateOperationsInput | boolean
    YoutubeEnabled?: BoolFieldUpdateOperationsInput | boolean
    SpotifyEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GuildFeatureTogglesUncheckedUpdateManyInput = {
    LevelEnabled?: BoolFieldUpdateOperationsInput | boolean
    WecomeEnabled?: BoolFieldUpdateOperationsInput | boolean
    LeaveEnabled?: BoolFieldUpdateOperationsInput | boolean
    AutoreactEnabled?: BoolFieldUpdateOperationsInput | boolean
    AutopublishEnabled?: BoolFieldUpdateOperationsInput | boolean
    ConnectionsEnabled?: BoolFieldUpdateOperationsInput | boolean
    ChatfilterEnabled?: BoolFieldUpdateOperationsInput | boolean
    AutorolesEnabled?: BoolFieldUpdateOperationsInput | boolean
    LoggingEnabled?: BoolFieldUpdateOperationsInput | boolean
    TwitchEnabled?: BoolFieldUpdateOperationsInput | boolean
    YoutubeEnabled?: BoolFieldUpdateOperationsInput | boolean
    SpotifyEnabled?: BoolFieldUpdateOperationsInput | boolean
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type TwitchNotificationsCreateInput = {
    id?: string
    UUID: string
    TwitchChannelName: string
    ChannelId: string
    Live: boolean
    MessageTemplateId: string
    PingRoles?: TwitchNotificationsCreatePingRolesInput | string[]
    Guilds: GuildsCreateNestedOneWithoutTwitchNotificationsInput
  }

  export type TwitchNotificationsUncheckedCreateInput = {
    id?: string
    UUID: string
    TwitchChannelName: string
    ChannelId: string
    Live: boolean
    MessageTemplateId: string
    PingRoles?: TwitchNotificationsCreatePingRolesInput | string[]
    GuildId: string
  }

  export type TwitchNotificationsUpdateInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    TwitchChannelName?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Live?: BoolFieldUpdateOperationsInput | boolean
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    PingRoles?: TwitchNotificationsUpdatePingRolesInput | string[]
    Guilds?: GuildsUpdateOneRequiredWithoutTwitchNotificationsNestedInput
  }

  export type TwitchNotificationsUncheckedUpdateInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    TwitchChannelName?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Live?: BoolFieldUpdateOperationsInput | boolean
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    PingRoles?: TwitchNotificationsUpdatePingRolesInput | string[]
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type TwitchNotificationsCreateManyInput = {
    id?: string
    UUID: string
    TwitchChannelName: string
    ChannelId: string
    Live: boolean
    MessageTemplateId: string
    PingRoles?: TwitchNotificationsCreatePingRolesInput | string[]
    GuildId: string
  }

  export type TwitchNotificationsUpdateManyMutationInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    TwitchChannelName?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Live?: BoolFieldUpdateOperationsInput | boolean
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    PingRoles?: TwitchNotificationsUpdatePingRolesInput | string[]
  }

  export type TwitchNotificationsUncheckedUpdateManyInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    TwitchChannelName?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Live?: BoolFieldUpdateOperationsInput | boolean
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    PingRoles?: TwitchNotificationsUpdatePingRolesInput | string[]
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type YoutubeNotificationsCreateInput = {
    id?: string
    YoutubeChannelId: string
    ChannelId: string
    Latest?: YoutubeNotificationsCreateLatestInput | string[]
    MessageTemplateId: string
    PingRoles?: YoutubeNotificationsCreatePingRolesInput | string[]
    UUID: string
    Guilds: GuildsCreateNestedOneWithoutYoutubeNotificationsInput
  }

  export type YoutubeNotificationsUncheckedCreateInput = {
    id?: string
    YoutubeChannelId: string
    ChannelId: string
    Latest?: YoutubeNotificationsCreateLatestInput | string[]
    MessageTemplateId: string
    PingRoles?: YoutubeNotificationsCreatePingRolesInput | string[]
    UUID: string
    GuildId: string
  }

  export type YoutubeNotificationsUpdateInput = {
    YoutubeChannelId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Latest?: YoutubeNotificationsUpdateLatestInput | string[]
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    PingRoles?: YoutubeNotificationsUpdatePingRolesInput | string[]
    UUID?: StringFieldUpdateOperationsInput | string
    Guilds?: GuildsUpdateOneRequiredWithoutYoutubeNotificationsNestedInput
  }

  export type YoutubeNotificationsUncheckedUpdateInput = {
    YoutubeChannelId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Latest?: YoutubeNotificationsUpdateLatestInput | string[]
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    PingRoles?: YoutubeNotificationsUpdatePingRolesInput | string[]
    UUID?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type YoutubeNotificationsCreateManyInput = {
    id?: string
    YoutubeChannelId: string
    ChannelId: string
    Latest?: YoutubeNotificationsCreateLatestInput | string[]
    MessageTemplateId: string
    PingRoles?: YoutubeNotificationsCreatePingRolesInput | string[]
    UUID: string
    GuildId: string
  }

  export type YoutubeNotificationsUpdateManyMutationInput = {
    YoutubeChannelId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Latest?: YoutubeNotificationsUpdateLatestInput | string[]
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    PingRoles?: YoutubeNotificationsUpdatePingRolesInput | string[]
    UUID?: StringFieldUpdateOperationsInput | string
  }

  export type YoutubeNotificationsUncheckedUpdateManyInput = {
    YoutubeChannelId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Latest?: YoutubeNotificationsUpdateLatestInput | string[]
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    PingRoles?: YoutubeNotificationsUpdatePingRolesInput | string[]
    UUID?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type UsersCreateInput = {
    id?: string
    Username: string
    UserId: string
    Votes?: number
    GloablVotes?: number
    CustomerBots?: number
    BackupCount?: number
    Apiss?: ApisCreateNestedManyWithoutUsersInput
    GuildBackups?: GuildBackupsCreateNestedManyWithoutUsersInput
    Customers?: CustomersCreateNestedManyWithoutUsersInput
    DisBotUserNotifications?: DisBotUserNotificationsCreateNestedOneWithoutUsersInput
    Vanitys?: VanitysCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateInput = {
    id?: string
    Username: string
    UserId: string
    Votes?: number
    GloablVotes?: number
    CustomerBots?: number
    BackupCount?: number
    Apiss?: ApisUncheckedCreateNestedManyWithoutUsersInput
    GuildBackups?: GuildBackupsUncheckedCreateNestedManyWithoutUsersInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutUsersInput
    DisBotUserNotifications?: DisBotUserNotificationsUncheckedCreateNestedOneWithoutUsersInput
    Vanitys?: VanitysUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersUpdateInput = {
    Username?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    Votes?: IntFieldUpdateOperationsInput | number
    GloablVotes?: IntFieldUpdateOperationsInput | number
    CustomerBots?: IntFieldUpdateOperationsInput | number
    BackupCount?: IntFieldUpdateOperationsInput | number
    Apiss?: ApisUpdateManyWithoutUsersNestedInput
    GuildBackups?: GuildBackupsUpdateManyWithoutUsersNestedInput
    Customers?: CustomersUpdateManyWithoutUsersNestedInput
    DisBotUserNotifications?: DisBotUserNotificationsUpdateOneWithoutUsersNestedInput
    Vanitys?: VanitysUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    Username?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    Votes?: IntFieldUpdateOperationsInput | number
    GloablVotes?: IntFieldUpdateOperationsInput | number
    CustomerBots?: IntFieldUpdateOperationsInput | number
    BackupCount?: IntFieldUpdateOperationsInput | number
    Apiss?: ApisUncheckedUpdateManyWithoutUsersNestedInput
    GuildBackups?: GuildBackupsUncheckedUpdateManyWithoutUsersNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutUsersNestedInput
    DisBotUserNotifications?: DisBotUserNotificationsUncheckedUpdateOneWithoutUsersNestedInput
    Vanitys?: VanitysUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateManyInput = {
    id?: string
    Username: string
    UserId: string
    Votes?: number
    GloablVotes?: number
    CustomerBots?: number
    BackupCount?: number
  }

  export type UsersUpdateManyMutationInput = {
    Username?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    Votes?: IntFieldUpdateOperationsInput | number
    GloablVotes?: IntFieldUpdateOperationsInput | number
    CustomerBots?: IntFieldUpdateOperationsInput | number
    BackupCount?: IntFieldUpdateOperationsInput | number
  }

  export type UsersUncheckedUpdateManyInput = {
    Username?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    Votes?: IntFieldUpdateOperationsInput | number
    GloablVotes?: IntFieldUpdateOperationsInput | number
    CustomerBots?: IntFieldUpdateOperationsInput | number
    BackupCount?: IntFieldUpdateOperationsInput | number
  }

  export type ApisCreateInput = {
    id?: string
    Flags?: ApisCreateFlagsInput | string[]
    Guilds?: ApisCreateGuildsInput | string[]
    Key: string
    Users: UsersCreateNestedOneWithoutApissInput
  }

  export type ApisUncheckedCreateInput = {
    id?: string
    Flags?: ApisCreateFlagsInput | string[]
    Guilds?: ApisCreateGuildsInput | string[]
    Key: string
    UserId: string
  }

  export type ApisUpdateInput = {
    Flags?: ApisUpdateFlagsInput | string[]
    Guilds?: ApisUpdateGuildsInput | string[]
    Key?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateOneRequiredWithoutApissNestedInput
  }

  export type ApisUncheckedUpdateInput = {
    Flags?: ApisUpdateFlagsInput | string[]
    Guilds?: ApisUpdateGuildsInput | string[]
    Key?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
  }

  export type ApisCreateManyInput = {
    id?: string
    Flags?: ApisCreateFlagsInput | string[]
    Guilds?: ApisCreateGuildsInput | string[]
    Key: string
    UserId: string
  }

  export type ApisUpdateManyMutationInput = {
    Flags?: ApisUpdateFlagsInput | string[]
    Guilds?: ApisUpdateGuildsInput | string[]
    Key?: StringFieldUpdateOperationsInput | string
  }

  export type ApisUncheckedUpdateManyInput = {
    Flags?: ApisUpdateFlagsInput | string[]
    Guilds?: ApisUpdateGuildsInput | string[]
    Key?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
  }

  export type GuildBackupsCreateInput = {
    id?: string
    BackupJSON: InputJsonValue
    CreatedAt: Date | string
    UUID: string
    Name: string
    GuildId: string
    Users: UsersCreateNestedOneWithoutGuildBackupsInput
  }

  export type GuildBackupsUncheckedCreateInput = {
    id?: string
    BackupJSON: InputJsonValue
    CreatedAt: Date | string
    UUID: string
    Name: string
    GuildId: string
    UserId: string
  }

  export type GuildBackupsUpdateInput = {
    BackupJSON?: InputJsonValue | InputJsonValue
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UUID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateOneRequiredWithoutGuildBackupsNestedInput
  }

  export type GuildBackupsUncheckedUpdateInput = {
    BackupJSON?: InputJsonValue | InputJsonValue
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UUID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
  }

  export type GuildBackupsCreateManyInput = {
    id?: string
    BackupJSON: InputJsonValue
    CreatedAt: Date | string
    UUID: string
    Name: string
    GuildId: string
    UserId: string
  }

  export type GuildBackupsUpdateManyMutationInput = {
    BackupJSON?: InputJsonValue | InputJsonValue
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UUID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type GuildBackupsUncheckedUpdateManyInput = {
    BackupJSON?: InputJsonValue | InputJsonValue
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UUID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
  }

  export type CustomersCreateInput = {
    id?: string
    ExternalUUID: string
    RealUUID: string
    Application: string
    BotStatus: XOR<BotStatusCreateEnvelopeInput, BotStatusCreateInput>
    DisplayName: string
    GuildIds?: CustomersCreateGuildIdsInput | string[]
    ServerPort: string
    WSAPI: string
    Users: UsersCreateNestedOneWithoutCustomersInput
  }

  export type CustomersUncheckedCreateInput = {
    id?: string
    ExternalUUID: string
    RealUUID: string
    Application: string
    BotStatus: XOR<BotStatusCreateEnvelopeInput, BotStatusCreateInput>
    DisplayName: string
    GuildIds?: CustomersCreateGuildIdsInput | string[]
    ServerPort: string
    WSAPI: string
    UserId: string
  }

  export type CustomersUpdateInput = {
    ExternalUUID?: StringFieldUpdateOperationsInput | string
    RealUUID?: StringFieldUpdateOperationsInput | string
    Application?: StringFieldUpdateOperationsInput | string
    BotStatus?: XOR<BotStatusUpdateEnvelopeInput, BotStatusCreateInput>
    DisplayName?: StringFieldUpdateOperationsInput | string
    GuildIds?: CustomersUpdateGuildIdsInput | string[]
    ServerPort?: StringFieldUpdateOperationsInput | string
    WSAPI?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateOneRequiredWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateInput = {
    ExternalUUID?: StringFieldUpdateOperationsInput | string
    RealUUID?: StringFieldUpdateOperationsInput | string
    Application?: StringFieldUpdateOperationsInput | string
    BotStatus?: XOR<BotStatusUpdateEnvelopeInput, BotStatusCreateInput>
    DisplayName?: StringFieldUpdateOperationsInput | string
    GuildIds?: CustomersUpdateGuildIdsInput | string[]
    ServerPort?: StringFieldUpdateOperationsInput | string
    WSAPI?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
  }

  export type CustomersCreateManyInput = {
    id?: string
    ExternalUUID: string
    RealUUID: string
    Application: string
    BotStatus: XOR<BotStatusCreateEnvelopeInput, BotStatusCreateInput>
    DisplayName: string
    GuildIds?: CustomersCreateGuildIdsInput | string[]
    ServerPort: string
    WSAPI: string
    UserId: string
  }

  export type CustomersUpdateManyMutationInput = {
    ExternalUUID?: StringFieldUpdateOperationsInput | string
    RealUUID?: StringFieldUpdateOperationsInput | string
    Application?: StringFieldUpdateOperationsInput | string
    BotStatus?: XOR<BotStatusUpdateEnvelopeInput, BotStatusCreateInput>
    DisplayName?: StringFieldUpdateOperationsInput | string
    GuildIds?: CustomersUpdateGuildIdsInput | string[]
    ServerPort?: StringFieldUpdateOperationsInput | string
    WSAPI?: StringFieldUpdateOperationsInput | string
  }

  export type CustomersUncheckedUpdateManyInput = {
    ExternalUUID?: StringFieldUpdateOperationsInput | string
    RealUUID?: StringFieldUpdateOperationsInput | string
    Application?: StringFieldUpdateOperationsInput | string
    BotStatus?: XOR<BotStatusUpdateEnvelopeInput, BotStatusCreateInput>
    DisplayName?: StringFieldUpdateOperationsInput | string
    GuildIds?: CustomersUpdateGuildIdsInput | string[]
    ServerPort?: StringFieldUpdateOperationsInput | string
    WSAPI?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
  }

  export type VanitysCreateInput = {
    id?: string
    UUID: string
    Slug: string
    Host: string
    GuildId: string
    Invite: string
    CreatedAt: Date | string
    Analytics?: VanityAnalyticsCreateNestedOneWithoutVanitysInput
    Embed?: VanityEmbedsCreateNestedOneWithoutVanitysInput
    Users: UsersCreateNestedOneWithoutVanitysInput
  }

  export type VanitysUncheckedCreateInput = {
    id?: string
    UUID: string
    Slug: string
    Host: string
    GuildId: string
    Invite: string
    CreatedAt: Date | string
    UserId: string
    Analytics?: VanityAnalyticsUncheckedCreateNestedOneWithoutVanitysInput
    Embed?: VanityEmbedsUncheckedCreateNestedOneWithoutVanitysInput
  }

  export type VanitysUpdateInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Slug?: StringFieldUpdateOperationsInput | string
    Host?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    Invite?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Analytics?: VanityAnalyticsUpdateOneWithoutVanitysNestedInput
    Embed?: VanityEmbedsUpdateOneWithoutVanitysNestedInput
    Users?: UsersUpdateOneRequiredWithoutVanitysNestedInput
  }

  export type VanitysUncheckedUpdateInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Slug?: StringFieldUpdateOperationsInput | string
    Host?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    Invite?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: StringFieldUpdateOperationsInput | string
    Analytics?: VanityAnalyticsUncheckedUpdateOneWithoutVanitysNestedInput
    Embed?: VanityEmbedsUncheckedUpdateOneWithoutVanitysNestedInput
  }

  export type VanitysCreateManyInput = {
    id?: string
    UUID: string
    Slug: string
    Host: string
    GuildId: string
    Invite: string
    CreatedAt: Date | string
    UserId: string
  }

  export type VanitysUpdateManyMutationInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Slug?: StringFieldUpdateOperationsInput | string
    Host?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    Invite?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VanitysUncheckedUpdateManyInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Slug?: StringFieldUpdateOperationsInput | string
    Host?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    Invite?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: StringFieldUpdateOperationsInput | string
  }

  export type VanityEmbedsCreateInput = {
    id?: string
    Title: string
    Description: string
    Color: string
    ImageUrl: string
    ThumbnailUrl: string
    Author?: VanityEmbedAuthorsCreateNestedOneWithoutVanityEmbedsInput
    Vanitys: VanitysCreateNestedOneWithoutEmbedInput
  }

  export type VanityEmbedsUncheckedCreateInput = {
    id?: string
    Title: string
    Description: string
    Color: string
    ImageUrl: string
    ThumbnailUrl: string
    VanityId: string
    Author?: VanityEmbedAuthorsUncheckedCreateNestedOneWithoutVanityEmbedsInput
  }

  export type VanityEmbedsUpdateInput = {
    Title?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Color?: StringFieldUpdateOperationsInput | string
    ImageUrl?: StringFieldUpdateOperationsInput | string
    ThumbnailUrl?: StringFieldUpdateOperationsInput | string
    Author?: VanityEmbedAuthorsUpdateOneWithoutVanityEmbedsNestedInput
    Vanitys?: VanitysUpdateOneRequiredWithoutEmbedNestedInput
  }

  export type VanityEmbedsUncheckedUpdateInput = {
    Title?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Color?: StringFieldUpdateOperationsInput | string
    ImageUrl?: StringFieldUpdateOperationsInput | string
    ThumbnailUrl?: StringFieldUpdateOperationsInput | string
    VanityId?: StringFieldUpdateOperationsInput | string
    Author?: VanityEmbedAuthorsUncheckedUpdateOneWithoutVanityEmbedsNestedInput
  }

  export type VanityEmbedsCreateManyInput = {
    id?: string
    Title: string
    Description: string
    Color: string
    ImageUrl: string
    ThumbnailUrl: string
    VanityId: string
  }

  export type VanityEmbedsUpdateManyMutationInput = {
    Title?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Color?: StringFieldUpdateOperationsInput | string
    ImageUrl?: StringFieldUpdateOperationsInput | string
    ThumbnailUrl?: StringFieldUpdateOperationsInput | string
  }

  export type VanityEmbedsUncheckedUpdateManyInput = {
    Title?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Color?: StringFieldUpdateOperationsInput | string
    ImageUrl?: StringFieldUpdateOperationsInput | string
    ThumbnailUrl?: StringFieldUpdateOperationsInput | string
    VanityId?: StringFieldUpdateOperationsInput | string
  }

  export type VanityEmbedAuthorsCreateInput = {
    id?: string
    Name: string
    URL: string
    IconURL: string
    VanityEmbeds: VanityEmbedsCreateNestedOneWithoutAuthorInput
  }

  export type VanityEmbedAuthorsUncheckedCreateInput = {
    id?: string
    Name: string
    URL: string
    IconURL: string
    VanityEmbedsId: string
  }

  export type VanityEmbedAuthorsUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    URL?: StringFieldUpdateOperationsInput | string
    IconURL?: StringFieldUpdateOperationsInput | string
    VanityEmbeds?: VanityEmbedsUpdateOneRequiredWithoutAuthorNestedInput
  }

  export type VanityEmbedAuthorsUncheckedUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    URL?: StringFieldUpdateOperationsInput | string
    IconURL?: StringFieldUpdateOperationsInput | string
    VanityEmbedsId?: StringFieldUpdateOperationsInput | string
  }

  export type VanityEmbedAuthorsCreateManyInput = {
    id?: string
    Name: string
    URL: string
    IconURL: string
    VanityEmbedsId: string
  }

  export type VanityEmbedAuthorsUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    URL?: StringFieldUpdateOperationsInput | string
    IconURL?: StringFieldUpdateOperationsInput | string
  }

  export type VanityEmbedAuthorsUncheckedUpdateManyInput = {
    Name?: StringFieldUpdateOperationsInput | string
    URL?: StringFieldUpdateOperationsInput | string
    IconURL?: StringFieldUpdateOperationsInput | string
    VanityEmbedsId?: StringFieldUpdateOperationsInput | string
  }

  export type VanityAnalyticsCreateInput = {
    id?: string
    Click: number
    TrackInviteWithLog?: string | null
    TrackMessageId?: string | null
    Update?: Date | string | null
    UniqueClick?: number | null
    JoinedWithCode?: number | null
    LoggedIPs?: VanityAnalyticsCreateLoggedIPsInput | string[]
    Latest30Days?: AnalyticsLatest30DaysCreateNestedOneWithoutVanityAnalyticsInput
    Vanitys: VanitysCreateNestedOneWithoutAnalyticsInput
  }

  export type VanityAnalyticsUncheckedCreateInput = {
    id?: string
    Click: number
    TrackInviteWithLog?: string | null
    TrackMessageId?: string | null
    Update?: Date | string | null
    UniqueClick?: number | null
    JoinedWithCode?: number | null
    LoggedIPs?: VanityAnalyticsCreateLoggedIPsInput | string[]
    VanityId: string
    Latest30Days?: AnalyticsLatest30DaysUncheckedCreateNestedOneWithoutVanityAnalyticsInput
  }

  export type VanityAnalyticsUpdateInput = {
    Click?: IntFieldUpdateOperationsInput | number
    TrackInviteWithLog?: NullableStringFieldUpdateOperationsInput | string | null
    TrackMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    Update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UniqueClick?: NullableIntFieldUpdateOperationsInput | number | null
    JoinedWithCode?: NullableIntFieldUpdateOperationsInput | number | null
    LoggedIPs?: VanityAnalyticsUpdateLoggedIPsInput | string[]
    Latest30Days?: AnalyticsLatest30DaysUpdateOneWithoutVanityAnalyticsNestedInput
    Vanitys?: VanitysUpdateOneRequiredWithoutAnalyticsNestedInput
  }

  export type VanityAnalyticsUncheckedUpdateInput = {
    Click?: IntFieldUpdateOperationsInput | number
    TrackInviteWithLog?: NullableStringFieldUpdateOperationsInput | string | null
    TrackMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    Update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UniqueClick?: NullableIntFieldUpdateOperationsInput | number | null
    JoinedWithCode?: NullableIntFieldUpdateOperationsInput | number | null
    LoggedIPs?: VanityAnalyticsUpdateLoggedIPsInput | string[]
    VanityId?: StringFieldUpdateOperationsInput | string
    Latest30Days?: AnalyticsLatest30DaysUncheckedUpdateOneWithoutVanityAnalyticsNestedInput
  }

  export type VanityAnalyticsCreateManyInput = {
    id?: string
    Click: number
    TrackInviteWithLog?: string | null
    TrackMessageId?: string | null
    Update?: Date | string | null
    UniqueClick?: number | null
    JoinedWithCode?: number | null
    LoggedIPs?: VanityAnalyticsCreateLoggedIPsInput | string[]
    VanityId: string
  }

  export type VanityAnalyticsUpdateManyMutationInput = {
    Click?: IntFieldUpdateOperationsInput | number
    TrackInviteWithLog?: NullableStringFieldUpdateOperationsInput | string | null
    TrackMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    Update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UniqueClick?: NullableIntFieldUpdateOperationsInput | number | null
    JoinedWithCode?: NullableIntFieldUpdateOperationsInput | number | null
    LoggedIPs?: VanityAnalyticsUpdateLoggedIPsInput | string[]
  }

  export type VanityAnalyticsUncheckedUpdateManyInput = {
    Click?: IntFieldUpdateOperationsInput | number
    TrackInviteWithLog?: NullableStringFieldUpdateOperationsInput | string | null
    TrackMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    Update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UniqueClick?: NullableIntFieldUpdateOperationsInput | number | null
    JoinedWithCode?: NullableIntFieldUpdateOperationsInput | number | null
    LoggedIPs?: VanityAnalyticsUpdateLoggedIPsInput | string[]
    VanityId?: StringFieldUpdateOperationsInput | string
  }

  export type AnalyticsLatest30DaysCreateInput = {
    id?: string
    Click?: number | null
    UniqueClick?: number | null
    Date?: Date | string | null
    JoinedWithCode?: number | null
    VanityAnalytics: VanityAnalyticsCreateNestedOneWithoutLatest30DaysInput
  }

  export type AnalyticsLatest30DaysUncheckedCreateInput = {
    id?: string
    Click?: number | null
    UniqueClick?: number | null
    Date?: Date | string | null
    JoinedWithCode?: number | null
    VanityAnalyticsId: string
  }

  export type AnalyticsLatest30DaysUpdateInput = {
    Click?: NullableIntFieldUpdateOperationsInput | number | null
    UniqueClick?: NullableIntFieldUpdateOperationsInput | number | null
    Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JoinedWithCode?: NullableIntFieldUpdateOperationsInput | number | null
    VanityAnalytics?: VanityAnalyticsUpdateOneRequiredWithoutLatest30DaysNestedInput
  }

  export type AnalyticsLatest30DaysUncheckedUpdateInput = {
    Click?: NullableIntFieldUpdateOperationsInput | number | null
    UniqueClick?: NullableIntFieldUpdateOperationsInput | number | null
    Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JoinedWithCode?: NullableIntFieldUpdateOperationsInput | number | null
    VanityAnalyticsId?: StringFieldUpdateOperationsInput | string
  }

  export type AnalyticsLatest30DaysCreateManyInput = {
    id?: string
    Click?: number | null
    UniqueClick?: number | null
    Date?: Date | string | null
    JoinedWithCode?: number | null
    VanityAnalyticsId: string
  }

  export type AnalyticsLatest30DaysUpdateManyMutationInput = {
    Click?: NullableIntFieldUpdateOperationsInput | number | null
    UniqueClick?: NullableIntFieldUpdateOperationsInput | number | null
    Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JoinedWithCode?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AnalyticsLatest30DaysUncheckedUpdateManyInput = {
    Click?: NullableIntFieldUpdateOperationsInput | number | null
    UniqueClick?: NullableIntFieldUpdateOperationsInput | number | null
    Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JoinedWithCode?: NullableIntFieldUpdateOperationsInput | number | null
    VanityAnalyticsId?: StringFieldUpdateOperationsInput | string
  }

  export type DisBotUserNotificationsCreateInput = {
    id?: string
    Updates: boolean
    Status: boolean
    Announcements: boolean
    Customer: boolean
    Users: UsersCreateNestedOneWithoutDisBotUserNotificationsInput
  }

  export type DisBotUserNotificationsUncheckedCreateInput = {
    id?: string
    Updates: boolean
    Status: boolean
    Announcements: boolean
    Customer: boolean
    UserId: string
  }

  export type DisBotUserNotificationsUpdateInput = {
    Updates?: BoolFieldUpdateOperationsInput | boolean
    Status?: BoolFieldUpdateOperationsInput | boolean
    Announcements?: BoolFieldUpdateOperationsInput | boolean
    Customer?: BoolFieldUpdateOperationsInput | boolean
    Users?: UsersUpdateOneRequiredWithoutDisBotUserNotificationsNestedInput
  }

  export type DisBotUserNotificationsUncheckedUpdateInput = {
    Updates?: BoolFieldUpdateOperationsInput | boolean
    Status?: BoolFieldUpdateOperationsInput | boolean
    Announcements?: BoolFieldUpdateOperationsInput | boolean
    Customer?: BoolFieldUpdateOperationsInput | boolean
    UserId?: StringFieldUpdateOperationsInput | string
  }

  export type DisBotUserNotificationsCreateManyInput = {
    id?: string
    Updates: boolean
    Status: boolean
    Announcements: boolean
    Customer: boolean
    UserId: string
  }

  export type DisBotUserNotificationsUpdateManyMutationInput = {
    Updates?: BoolFieldUpdateOperationsInput | boolean
    Status?: BoolFieldUpdateOperationsInput | boolean
    Announcements?: BoolFieldUpdateOperationsInput | boolean
    Customer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DisBotUserNotificationsUncheckedUpdateManyInput = {
    Updates?: BoolFieldUpdateOperationsInput | boolean
    Status?: BoolFieldUpdateOperationsInput | boolean
    Announcements?: BoolFieldUpdateOperationsInput | boolean
    Customer?: BoolFieldUpdateOperationsInput | boolean
    UserId?: StringFieldUpdateOperationsInput | string
  }

  export type DisBotCreateInput = {
    id?: string
    Logs?: XOR<DisbotsLogsListCreateEnvelopeInput, DisbotsLogsCreateInput> | DisbotsLogsCreateInput[]
    SpotifyToken: string
    TwitchToken: string
    Version: string
    GetConf: string
  }

  export type DisBotUncheckedCreateInput = {
    id?: string
    Logs?: XOR<DisbotsLogsListCreateEnvelopeInput, DisbotsLogsCreateInput> | DisbotsLogsCreateInput[]
    SpotifyToken: string
    TwitchToken: string
    Version: string
    GetConf: string
  }

  export type DisBotUpdateInput = {
    Logs?: XOR<DisbotsLogsListUpdateEnvelopeInput, DisbotsLogsCreateInput> | DisbotsLogsCreateInput[]
    SpotifyToken?: StringFieldUpdateOperationsInput | string
    TwitchToken?: StringFieldUpdateOperationsInput | string
    Version?: StringFieldUpdateOperationsInput | string
    GetConf?: StringFieldUpdateOperationsInput | string
  }

  export type DisBotUncheckedUpdateInput = {
    Logs?: XOR<DisbotsLogsListUpdateEnvelopeInput, DisbotsLogsCreateInput> | DisbotsLogsCreateInput[]
    SpotifyToken?: StringFieldUpdateOperationsInput | string
    TwitchToken?: StringFieldUpdateOperationsInput | string
    Version?: StringFieldUpdateOperationsInput | string
    GetConf?: StringFieldUpdateOperationsInput | string
  }

  export type DisBotCreateManyInput = {
    id?: string
    Logs?: XOR<DisbotsLogsListCreateEnvelopeInput, DisbotsLogsCreateInput> | DisbotsLogsCreateInput[]
    SpotifyToken: string
    TwitchToken: string
    Version: string
    GetConf: string
  }

  export type DisBotUpdateManyMutationInput = {
    Logs?: XOR<DisbotsLogsListUpdateEnvelopeInput, DisbotsLogsCreateInput> | DisbotsLogsCreateInput[]
    SpotifyToken?: StringFieldUpdateOperationsInput | string
    TwitchToken?: StringFieldUpdateOperationsInput | string
    Version?: StringFieldUpdateOperationsInput | string
    GetConf?: StringFieldUpdateOperationsInput | string
  }

  export type DisBotUncheckedUpdateManyInput = {
    Logs?: XOR<DisbotsLogsListUpdateEnvelopeInput, DisbotsLogsCreateInput> | DisbotsLogsCreateInput[]
    SpotifyToken?: StringFieldUpdateOperationsInput | string
    TwitchToken?: StringFieldUpdateOperationsInput | string
    Version?: StringFieldUpdateOperationsInput | string
    GetConf?: StringFieldUpdateOperationsInput | string
  }

  export type ImageApisCreateInput = {
    id?: string
    UUID: string
    ImageBase64: string
    URL: string
  }

  export type ImageApisUncheckedCreateInput = {
    id?: string
    UUID: string
    ImageBase64: string
    URL: string
  }

  export type ImageApisUpdateInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    ImageBase64?: StringFieldUpdateOperationsInput | string
    URL?: StringFieldUpdateOperationsInput | string
  }

  export type ImageApisUncheckedUpdateInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    ImageBase64?: StringFieldUpdateOperationsInput | string
    URL?: StringFieldUpdateOperationsInput | string
  }

  export type ImageApisCreateManyInput = {
    id?: string
    UUID: string
    ImageBase64: string
    URL: string
  }

  export type ImageApisUpdateManyMutationInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    ImageBase64?: StringFieldUpdateOperationsInput | string
    URL?: StringFieldUpdateOperationsInput | string
  }

  export type ImageApisUncheckedUpdateManyInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    ImageBase64?: StringFieldUpdateOperationsInput | string
    URL?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type AutoDeletesListRelationFilter = {
    every?: AutoDeletesWhereInput
    some?: AutoDeletesWhereInput
    none?: AutoDeletesWhereInput
  }

  export type AutoPublishNullableScalarRelationFilter = {
    is?: AutoPublishWhereInput | null
    isNot?: AutoPublishWhereInput | null
  }

  export type AutoReactsListRelationFilter = {
    every?: AutoReactsWhereInput
    some?: AutoReactsWhereInput
    none?: AutoReactsWhereInput
  }

  export type AutoRolesListRelationFilter = {
    every?: AutoRolesWhereInput
    some?: AutoRolesWhereInput
    none?: AutoRolesWhereInput
  }

  export type GuildBansListRelationFilter = {
    every?: GuildBansWhereInput
    some?: GuildBansWhereInput
    none?: GuildBansWhereInput
  }

  export type ChatModerationsNullableScalarRelationFilter = {
    is?: ChatModerationsWhereInput | null
    isNot?: ChatModerationsWhereInput | null
  }

  export type ChannelLinksListRelationFilter = {
    every?: ChannelLinksWhereInput
    some?: ChannelLinksWhereInput
    none?: ChannelLinksWhereInput
  }

  export type DiscordAddonsNullableScalarRelationFilter = {
    is?: DiscordAddonsWhereInput | null
    isNot?: DiscordAddonsWhereInput | null
  }

  export type GiveawaysListRelationFilter = {
    every?: GiveawaysWhereInput
    some?: GiveawaysWhereInput
    none?: GiveawaysWhereInput
  }

  export type TempVoicesListRelationFilter = {
    every?: TempVoicesWhereInput
    some?: TempVoicesWhereInput
    none?: TempVoicesWhereInput
  }

  export type GuildLeaveSetupsNullableScalarRelationFilter = {
    is?: GuildLeaveSetupsWhereInput | null
    isNot?: GuildLeaveSetupsWhereInput | null
  }

  export type GuildLoggingsNullableScalarRelationFilter = {
    is?: GuildLoggingsWhereInput | null
    isNot?: GuildLoggingsWhereInput | null
  }

  export type MessageTemplatesListRelationFilter = {
    every?: MessageTemplatesWhereInput
    some?: MessageTemplatesWhereInput
    none?: MessageTemplatesWhereInput
  }

  export type PermissionsNullableScalarRelationFilter = {
    is?: PermissionsWhereInput | null
    isNot?: PermissionsWhereInput | null
  }

  export type ReactionRolesListRelationFilter = {
    every?: ReactionRolesWhereInput
    some?: ReactionRolesWhereInput
    none?: ReactionRolesWhereInput
  }

  export type SecuritysNullableScalarRelationFilter = {
    is?: SecuritysWhereInput | null
    isNot?: SecuritysWhereInput | null
  }

  export type SpotifyNotificationsListRelationFilter = {
    every?: SpotifyNotificationsWhereInput
    some?: SpotifyNotificationsWhereInput
    none?: SpotifyNotificationsWhereInput
  }

  export type TagsListRelationFilter = {
    every?: TagsWhereInput
    some?: TagsWhereInput
    none?: TagsWhereInput
  }

  export type TicketSetupsListRelationFilter = {
    every?: TicketSetupsWhereInput
    some?: TicketSetupsWhereInput
    none?: TicketSetupsWhereInput
  }

  export type GuildFeatureTogglesNullableScalarRelationFilter = {
    is?: GuildFeatureTogglesWhereInput | null
    isNot?: GuildFeatureTogglesWhereInput | null
  }

  export type TwitchNotificationsListRelationFilter = {
    every?: TwitchNotificationsWhereInput
    some?: TwitchNotificationsWhereInput
    none?: TwitchNotificationsWhereInput
  }

  export type GuildWelcomeSetupsNullableScalarRelationFilter = {
    is?: GuildWelcomeSetupsWhereInput | null
    isNot?: GuildWelcomeSetupsWhereInput | null
  }

  export type YoutubeNotificationsListRelationFilter = {
    every?: YoutubeNotificationsWhereInput
    some?: YoutubeNotificationsWhereInput
    none?: YoutubeNotificationsWhereInput
  }

  export type GuildLoggersListRelationFilter = {
    every?: GuildLoggersWhereInput
    some?: GuildLoggersWhereInput
    none?: GuildLoggersWhereInput
  }

  export type AutoDeletesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutoReactsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutoRolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GuildBansOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChannelLinksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GiveawaysOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TempVoicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageTemplatesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReactionRolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpotifyNotificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketSetupsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwitchNotificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YoutubeNotificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GuildLoggersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GuildsCountOrderByAggregateInput = {
    id?: SortOrder
    GuildId?: SortOrder
    GuildName?: SortOrder
    GuildOwner?: SortOrder
  }

  export type GuildsMaxOrderByAggregateInput = {
    id?: SortOrder
    GuildId?: SortOrder
    GuildName?: SortOrder
    GuildOwner?: SortOrder
  }

  export type GuildsMinOrderByAggregateInput = {
    id?: SortOrder
    GuildId?: SortOrder
    GuildName?: SortOrder
    GuildOwner?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type GuildsScalarRelationFilter = {
    is?: GuildsWhereInput
    isNot?: GuildsWhereInput
  }

  export type AutoDeletesCountOrderByAggregateInput = {
    id?: SortOrder
    ChannelId?: SortOrder
    IsActive?: SortOrder
    Time?: SortOrder
    UUID?: SortOrder
    WhitelistedMessages?: SortOrder
    WhitelistedRoles?: SortOrder
    WhitelistedUsers?: SortOrder
    GuildId?: SortOrder
  }

  export type AutoDeletesMaxOrderByAggregateInput = {
    id?: SortOrder
    ChannelId?: SortOrder
    IsActive?: SortOrder
    Time?: SortOrder
    UUID?: SortOrder
    GuildId?: SortOrder
  }

  export type AutoDeletesMinOrderByAggregateInput = {
    id?: SortOrder
    ChannelId?: SortOrder
    IsActive?: SortOrder
    Time?: SortOrder
    UUID?: SortOrder
    GuildId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type AutoPublishCountOrderByAggregateInput = {
    id?: SortOrder
    Channels?: SortOrder
    GuildId?: SortOrder
  }

  export type AutoPublishMaxOrderByAggregateInput = {
    id?: SortOrder
    GuildId?: SortOrder
  }

  export type AutoPublishMinOrderByAggregateInput = {
    id?: SortOrder
    GuildId?: SortOrder
  }

  export type AutoReactsCountOrderByAggregateInput = {
    id?: SortOrder
    ChannelId?: SortOrder
    Emoji?: SortOrder
    GuildId?: SortOrder
  }

  export type AutoReactsMaxOrderByAggregateInput = {
    id?: SortOrder
    ChannelId?: SortOrder
    Emoji?: SortOrder
    GuildId?: SortOrder
  }

  export type AutoReactsMinOrderByAggregateInput = {
    id?: SortOrder
    ChannelId?: SortOrder
    Emoji?: SortOrder
    GuildId?: SortOrder
  }

  export type AutoRolesCountOrderByAggregateInput = {
    id?: SortOrder
    RoleId?: SortOrder
    GuildId?: SortOrder
  }

  export type AutoRolesMaxOrderByAggregateInput = {
    id?: SortOrder
    RoleId?: SortOrder
    GuildId?: SortOrder
  }

  export type AutoRolesMinOrderByAggregateInput = {
    id?: SortOrder
    RoleId?: SortOrder
    GuildId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type GuildBansCountOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    Time?: SortOrder
    UserId?: SortOrder
    Reason?: SortOrder
    ModeratorId?: SortOrder
    DmMessage?: SortOrder
    Banned?: SortOrder
    CreatedAt?: SortOrder
    GuildId?: SortOrder
  }

  export type GuildBansMaxOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    Time?: SortOrder
    Reason?: SortOrder
    ModeratorId?: SortOrder
    DmMessage?: SortOrder
    Banned?: SortOrder
    CreatedAt?: SortOrder
    GuildId?: SortOrder
  }

  export type GuildBansMinOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    Time?: SortOrder
    Reason?: SortOrder
    ModeratorId?: SortOrder
    DmMessage?: SortOrder
    Banned?: SortOrder
    CreatedAt?: SortOrder
    GuildId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type ChatModerationsCountOrderByAggregateInput = {
    id?: SortOrder
    LogChannelId?: SortOrder
    Words?: SortOrder
    WhiteListRole?: SortOrder
    WhiteListChannel?: SortOrder
    GuildId?: SortOrder
  }

  export type ChatModerationsMaxOrderByAggregateInput = {
    id?: SortOrder
    LogChannelId?: SortOrder
    GuildId?: SortOrder
  }

  export type ChatModerationsMinOrderByAggregateInput = {
    id?: SortOrder
    LogChannelId?: SortOrder
    GuildId?: SortOrder
  }

  export type SyncedChannelLinkMessagesListRelationFilter = {
    every?: SyncedChannelLinkMessagesWhereInput
    some?: SyncedChannelLinkMessagesWhereInput
    none?: SyncedChannelLinkMessagesWhereInput
  }

  export type SyncedChannelLinkMessagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChannelLinksCountOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    ChannelId?: SortOrder
    WebhookUrls?: SortOrder
    GuildId?: SortOrder
  }

  export type ChannelLinksMaxOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    ChannelId?: SortOrder
    GuildId?: SortOrder
  }

  export type ChannelLinksMinOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    ChannelId?: SortOrder
    GuildId?: SortOrder
  }

  export type ChannelLinksScalarRelationFilter = {
    is?: ChannelLinksWhereInput
    isNot?: ChannelLinksWhereInput
  }

  export type SyncedChannelLinkMessagesCountOrderByAggregateInput = {
    id?: SortOrder
    GuildId?: SortOrder
    UserMessageId?: SortOrder
    WebhookMessageId?: SortOrder
    WebhookURL?: SortOrder
    ChannelId?: SortOrder
    ChannelLinkId?: SortOrder
  }

  export type SyncedChannelLinkMessagesMaxOrderByAggregateInput = {
    id?: SortOrder
    GuildId?: SortOrder
    UserMessageId?: SortOrder
    WebhookMessageId?: SortOrder
    WebhookURL?: SortOrder
    ChannelId?: SortOrder
    ChannelLinkId?: SortOrder
  }

  export type SyncedChannelLinkMessagesMinOrderByAggregateInput = {
    id?: SortOrder
    GuildId?: SortOrder
    UserMessageId?: SortOrder
    WebhookMessageId?: SortOrder
    WebhookURL?: SortOrder
    ChannelId?: SortOrder
    ChannelLinkId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DiscordAddonsCountOrderByAggregateInput = {
    id?: SortOrder
    OnlyMedia?: SortOrder
    NoLinkEmbeds?: SortOrder
    InvitesPaused?: SortOrder
    GuildId?: SortOrder
  }

  export type DiscordAddonsMaxOrderByAggregateInput = {
    id?: SortOrder
    InvitesPaused?: SortOrder
    GuildId?: SortOrder
  }

  export type DiscordAddonsMinOrderByAggregateInput = {
    id?: SortOrder
    InvitesPaused?: SortOrder
    GuildId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type GiveawaysCountOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    MessageId?: SortOrder
    ChannelId?: SortOrder
    Prize?: SortOrder
    Winners?: SortOrder
    Time?: SortOrder
    CreatedAt?: SortOrder
    Ended?: SortOrder
    EndedAt?: SortOrder
    EndedBy?: SortOrder
    Paused?: SortOrder
    EndedMessage?: SortOrder
    Rerolled?: SortOrder
    WinnerIds?: SortOrder
    WinnerMessageTemplate?: SortOrder
    HostedBy?: SortOrder
    MessageTemplate?: SortOrder
    Content?: SortOrder
    Entrys?: SortOrder
    Requirements?: SortOrder
    GuildId?: SortOrder
  }

  export type GiveawaysAvgOrderByAggregateInput = {
    Winners?: SortOrder
  }

  export type GiveawaysMaxOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    MessageId?: SortOrder
    ChannelId?: SortOrder
    Prize?: SortOrder
    Winners?: SortOrder
    Time?: SortOrder
    CreatedAt?: SortOrder
    Ended?: SortOrder
    EndedAt?: SortOrder
    EndedBy?: SortOrder
    Paused?: SortOrder
    EndedMessage?: SortOrder
    Rerolled?: SortOrder
    WinnerMessageTemplate?: SortOrder
    HostedBy?: SortOrder
    MessageTemplate?: SortOrder
    Content?: SortOrder
    GuildId?: SortOrder
  }

  export type GiveawaysMinOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    MessageId?: SortOrder
    ChannelId?: SortOrder
    Prize?: SortOrder
    Winners?: SortOrder
    Time?: SortOrder
    CreatedAt?: SortOrder
    Ended?: SortOrder
    EndedAt?: SortOrder
    EndedBy?: SortOrder
    Paused?: SortOrder
    EndedMessage?: SortOrder
    Rerolled?: SortOrder
    WinnerMessageTemplate?: SortOrder
    HostedBy?: SortOrder
    MessageTemplate?: SortOrder
    Content?: SortOrder
    GuildId?: SortOrder
  }

  export type GiveawaysSumOrderByAggregateInput = {
    Winners?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type TempVoiceChannelsListRelationFilter = {
    every?: TempVoiceChannelsWhereInput
    some?: TempVoiceChannelsWhereInput
    none?: TempVoiceChannelsWhereInput
  }

  export type TempVoiceChannelsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TempVoicesCountOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    Name?: SortOrder
    JointoCreateChannel?: SortOrder
    JointoCreateCategory?: SortOrder
    Manage?: SortOrder
    PresetLimit?: SortOrder
    GuildId?: SortOrder
  }

  export type TempVoicesAvgOrderByAggregateInput = {
    PresetLimit?: SortOrder
  }

  export type TempVoicesMaxOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    Name?: SortOrder
    JointoCreateChannel?: SortOrder
    JointoCreateCategory?: SortOrder
    Manage?: SortOrder
    PresetLimit?: SortOrder
    GuildId?: SortOrder
  }

  export type TempVoicesMinOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    Name?: SortOrder
    JointoCreateChannel?: SortOrder
    JointoCreateCategory?: SortOrder
    Manage?: SortOrder
    PresetLimit?: SortOrder
    GuildId?: SortOrder
  }

  export type TempVoicesSumOrderByAggregateInput = {
    PresetLimit?: SortOrder
  }

  export type TempVoicesScalarRelationFilter = {
    is?: TempVoicesWhereInput
    isNot?: TempVoicesWhereInput
  }

  export type TempVoiceChannelsCountOrderByAggregateInput = {
    id?: SortOrder
    GuildId?: SortOrder
    ChannelId?: SortOrder
    OwnerId?: SortOrder
    TempVoiceId?: SortOrder
  }

  export type TempVoiceChannelsMaxOrderByAggregateInput = {
    id?: SortOrder
    GuildId?: SortOrder
    ChannelId?: SortOrder
    OwnerId?: SortOrder
    TempVoiceId?: SortOrder
  }

  export type TempVoiceChannelsMinOrderByAggregateInput = {
    id?: SortOrder
    GuildId?: SortOrder
    ChannelId?: SortOrder
    OwnerId?: SortOrder
    TempVoiceId?: SortOrder
  }

  export type WelcomeLeaveImageDataNullableCompositeFilter = {
    equals?: WelcomeLeaveImageDataObjectEqualityInput | null
    is?: WelcomeLeaveImageDataWhereInput | null
    isNot?: WelcomeLeaveImageDataWhereInput | null
    isSet?: boolean
  }

  export type WelcomeLeaveImageDataObjectEqualityInput = {
    Title: string
    Text: string
    Subtitle: string
    Background: string
    Theme: string
    Color: string
    Gradient: string
  }

  export type WelcomeLeaveImageDataOrderByInput = {
    Title?: SortOrder
    Text?: SortOrder
    Subtitle?: SortOrder
    Background?: SortOrder
    Theme?: SortOrder
    Color?: SortOrder
    Gradient?: SortOrder
  }

  export type GuildLeaveSetupsCountOrderByAggregateInput = {
    id?: SortOrder
    MessageTemplateId?: SortOrder
    ChannelId?: SortOrder
    Image?: SortOrder
    GuildId?: SortOrder
  }

  export type GuildLeaveSetupsMaxOrderByAggregateInput = {
    id?: SortOrder
    MessageTemplateId?: SortOrder
    ChannelId?: SortOrder
    Image?: SortOrder
    GuildId?: SortOrder
  }

  export type GuildLeaveSetupsMinOrderByAggregateInput = {
    id?: SortOrder
    MessageTemplateId?: SortOrder
    ChannelId?: SortOrder
    Image?: SortOrder
    GuildId?: SortOrder
  }

  export type WelcomeLeaveImageDataCompositeFilter = {
    equals?: WelcomeLeaveImageDataObjectEqualityInput
    is?: WelcomeLeaveImageDataWhereInput
    isNot?: WelcomeLeaveImageDataWhereInput
  }

  export type GuildWelcomeSetupsCountOrderByAggregateInput = {
    id?: SortOrder
    MessageTemplateId?: SortOrder
    ChannelId?: SortOrder
    Image?: SortOrder
    GuildId?: SortOrder
  }

  export type GuildWelcomeSetupsMaxOrderByAggregateInput = {
    id?: SortOrder
    MessageTemplateId?: SortOrder
    ChannelId?: SortOrder
    Image?: SortOrder
    GuildId?: SortOrder
  }

  export type GuildWelcomeSetupsMinOrderByAggregateInput = {
    id?: SortOrder
    MessageTemplateId?: SortOrder
    ChannelId?: SortOrder
    Image?: SortOrder
    GuildId?: SortOrder
  }

  export type GuildLoggingsCountOrderByAggregateInput = {
    id?: SortOrder
    AutoMod?: SortOrder
    Channel?: SortOrder
    Emoji?: SortOrder
    Guild?: SortOrder
    Integration?: SortOrder
    Invite?: SortOrder
    Member?: SortOrder
    Message?: SortOrder
    Moderation?: SortOrder
    Reaction?: SortOrder
    Role?: SortOrder
    SoundBoard?: SortOrder
    Sticker?: SortOrder
    Thread?: SortOrder
    Voice?: SortOrder
    Webhook?: SortOrder
    Ban?: SortOrder
    Kick?: SortOrder
    Poll?: SortOrder
    Stage?: SortOrder
    Event?: SortOrder
    GuildId?: SortOrder
  }

  export type GuildLoggingsMaxOrderByAggregateInput = {
    id?: SortOrder
    AutoMod?: SortOrder
    Channel?: SortOrder
    Emoji?: SortOrder
    Guild?: SortOrder
    Integration?: SortOrder
    Invite?: SortOrder
    Member?: SortOrder
    Message?: SortOrder
    Moderation?: SortOrder
    Reaction?: SortOrder
    Role?: SortOrder
    SoundBoard?: SortOrder
    Sticker?: SortOrder
    Thread?: SortOrder
    Voice?: SortOrder
    Webhook?: SortOrder
    Ban?: SortOrder
    Kick?: SortOrder
    Poll?: SortOrder
    Stage?: SortOrder
    Event?: SortOrder
    GuildId?: SortOrder
  }

  export type GuildLoggingsMinOrderByAggregateInput = {
    id?: SortOrder
    AutoMod?: SortOrder
    Channel?: SortOrder
    Emoji?: SortOrder
    Guild?: SortOrder
    Integration?: SortOrder
    Invite?: SortOrder
    Member?: SortOrder
    Message?: SortOrder
    Moderation?: SortOrder
    Reaction?: SortOrder
    Role?: SortOrder
    SoundBoard?: SortOrder
    Sticker?: SortOrder
    Thread?: SortOrder
    Voice?: SortOrder
    Webhook?: SortOrder
    Ban?: SortOrder
    Kick?: SortOrder
    Poll?: SortOrder
    Stage?: SortOrder
    Event?: SortOrder
    GuildId?: SortOrder
  }

  export type GuildLoggersCountOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    Notes?: SortOrder
    LogMessage?: SortOrder
    LogJSON?: SortOrder
    GuildId?: SortOrder
  }

  export type GuildLoggersMaxOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    LogMessage?: SortOrder
    LogJSON?: SortOrder
    GuildId?: SortOrder
  }

  export type GuildLoggersMinOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    LogMessage?: SortOrder
    LogJSON?: SortOrder
    GuildId?: SortOrder
  }

  export type MessageTemplatesCountOrderByAggregateInput = {
    id?: SortOrder
    Content?: SortOrder
    EmbedJSON?: SortOrder
    OtherEmbeds?: SortOrder
    Name?: SortOrder
    GuildId?: SortOrder
  }

  export type MessageTemplatesMaxOrderByAggregateInput = {
    id?: SortOrder
    Content?: SortOrder
    EmbedJSON?: SortOrder
    Name?: SortOrder
    GuildId?: SortOrder
  }

  export type MessageTemplatesMinOrderByAggregateInput = {
    id?: SortOrder
    Content?: SortOrder
    EmbedJSON?: SortOrder
    Name?: SortOrder
    GuildId?: SortOrder
  }

  export type PermissionDataCompositeListFilter = {
    equals?: PermissionDataObjectEqualityInput[]
    every?: PermissionDataWhereInput
    some?: PermissionDataWhereInput
    none?: PermissionDataWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type PermissionDataObjectEqualityInput = {
    RoleId: string
    Type: string
  }

  export type PermissionDataOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionsCountOrderByAggregateInput = {
    id?: SortOrder
    GuildId?: SortOrder
  }

  export type PermissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    GuildId?: SortOrder
  }

  export type PermissionsMinOrderByAggregateInput = {
    id?: SortOrder
    GuildId?: SortOrder
  }

  export type ReactionRoleButtonNullableCompositeFilter = {
    equals?: ReactionRoleButtonObjectEqualityInput | null
    is?: ReactionRoleButtonWhereInput | null
    isNot?: ReactionRoleButtonWhereInput | null
    isSet?: boolean
  }

  export type ReactionRoleButtonObjectEqualityInput = {
    Emoji: string
    Type: string
    Label: string
  }

  export type ReactionRoleSelectmenuNullableCompositeFilter = {
    equals?: ReactionRoleSelectmenuObjectEqualityInput | null
    is?: ReactionRoleSelectmenuWhereInput | null
    isNot?: ReactionRoleSelectmenuWhereInput | null
    isSet?: boolean
  }

  export type ReactionRoleSelectmenuObjectEqualityInput = {
    Emoji: string
    Label: string
    Description: string
  }

  export type ReactionRoleButtonOrderByInput = {
    Emoji?: SortOrder
    Type?: SortOrder
    Label?: SortOrder
  }

  export type ReactionRoleSelectmenuOrderByInput = {
    Emoji?: SortOrder
    Label?: SortOrder
    Description?: SortOrder
  }

  export type ReactionRolesCountOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    Roles?: SortOrder
    MessageId?: SortOrder
    ChannelId?: SortOrder
    AddMessage?: SortOrder
    RemoveMessage?: SortOrder
    Emoji?: SortOrder
    GuildId?: SortOrder
  }

  export type ReactionRolesMaxOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    MessageId?: SortOrder
    ChannelId?: SortOrder
    AddMessage?: SortOrder
    RemoveMessage?: SortOrder
    Emoji?: SortOrder
    GuildId?: SortOrder
  }

  export type ReactionRolesMinOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    MessageId?: SortOrder
    ChannelId?: SortOrder
    AddMessage?: SortOrder
    RemoveMessage?: SortOrder
    Emoji?: SortOrder
    GuildId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type VerificationGatesListRelationFilter = {
    every?: VerificationGatesWhereInput
    some?: VerificationGatesWhereInput
    none?: VerificationGatesWhereInput
  }

  export type VerificationGatesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SecuritysCountOrderByAggregateInput = {
    id?: SortOrder
    InviteLoggingActive?: SortOrder
    MaxAccountAge?: SortOrder
    GuildId?: SortOrder
  }

  export type SecuritysAvgOrderByAggregateInput = {
    MaxAccountAge?: SortOrder
  }

  export type SecuritysMaxOrderByAggregateInput = {
    id?: SortOrder
    InviteLoggingActive?: SortOrder
    MaxAccountAge?: SortOrder
    GuildId?: SortOrder
  }

  export type SecuritysMinOrderByAggregateInput = {
    id?: SortOrder
    InviteLoggingActive?: SortOrder
    MaxAccountAge?: SortOrder
    GuildId?: SortOrder
  }

  export type SecuritysSumOrderByAggregateInput = {
    MaxAccountAge?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type VerificationGatesPermissionListRelationFilter = {
    every?: VerificationGatesPermissionWhereInput
    some?: VerificationGatesPermissionWhereInput
    none?: VerificationGatesPermissionWhereInput
  }

  export type SecuritysScalarRelationFilter = {
    is?: SecuritysWhereInput
    isNot?: SecuritysWhereInput
  }

  export type VerificationGatesPermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerificationGatesCountOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    ChannelId?: SortOrder
    MessageId?: SortOrder
    Action?: SortOrder
    ActionType?: SortOrder
    Roles?: SortOrder
    VerifiedUsers?: SortOrder
    CreatedAt?: SortOrder
    Active?: SortOrder
    SecurityId?: SortOrder
  }

  export type VerificationGatesMaxOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    ChannelId?: SortOrder
    MessageId?: SortOrder
    Action?: SortOrder
    ActionType?: SortOrder
    CreatedAt?: SortOrder
    Active?: SortOrder
    SecurityId?: SortOrder
  }

  export type VerificationGatesMinOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    ChannelId?: SortOrder
    MessageId?: SortOrder
    Action?: SortOrder
    ActionType?: SortOrder
    CreatedAt?: SortOrder
    Active?: SortOrder
    SecurityId?: SortOrder
  }

  export type VerificationGatesScalarRelationFilter = {
    is?: VerificationGatesWhereInput
    isNot?: VerificationGatesWhereInput
  }

  export type VerificationGatesPermissionCountOrderByAggregateInput = {
    id?: SortOrder
    Permission?: SortOrder
    ChannelId?: SortOrder
    VerificationGateId?: SortOrder
  }

  export type VerificationGatesPermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    ChannelId?: SortOrder
    VerificationGateId?: SortOrder
  }

  export type VerificationGatesPermissionMinOrderByAggregateInput = {
    id?: SortOrder
    ChannelId?: SortOrder
    VerificationGateId?: SortOrder
  }

  export type SpotifyNotificationsCountOrderByAggregateInput = {
    id?: SortOrder
    ShowId?: SortOrder
    ChannelId?: SortOrder
    Latests?: SortOrder
    MessageTemplateId?: SortOrder
    PingRoles?: SortOrder
    UUID?: SortOrder
    GuildId?: SortOrder
  }

  export type SpotifyNotificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    ShowId?: SortOrder
    ChannelId?: SortOrder
    MessageTemplateId?: SortOrder
    UUID?: SortOrder
    GuildId?: SortOrder
  }

  export type SpotifyNotificationsMinOrderByAggregateInput = {
    id?: SortOrder
    ShowId?: SortOrder
    ChannelId?: SortOrder
    MessageTemplateId?: SortOrder
    UUID?: SortOrder
    GuildId?: SortOrder
  }

  export type TagsCountOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    TagId?: SortOrder
    MessageId?: SortOrder
    IsShlashCommand?: SortOrder
    ShlashCommandId?: SortOrder
    IsTextInputCommand?: SortOrder
    IsEnabled?: SortOrder
    PermissionRoleId?: SortOrder
    CommandDescription?: SortOrder
    FilterTextFromMessages?: SortOrder
    GuildId?: SortOrder
  }

  export type TagsMaxOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    TagId?: SortOrder
    MessageId?: SortOrder
    IsShlashCommand?: SortOrder
    ShlashCommandId?: SortOrder
    IsTextInputCommand?: SortOrder
    IsEnabled?: SortOrder
    PermissionRoleId?: SortOrder
    CommandDescription?: SortOrder
    GuildId?: SortOrder
  }

  export type TagsMinOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    TagId?: SortOrder
    MessageId?: SortOrder
    IsShlashCommand?: SortOrder
    ShlashCommandId?: SortOrder
    IsTextInputCommand?: SortOrder
    IsEnabled?: SortOrder
    PermissionRoleId?: SortOrder
    CommandDescription?: SortOrder
    GuildId?: SortOrder
  }

  export type TicketModalDataListRelationFilter = {
    every?: TicketModalDataWhereInput
    some?: TicketModalDataWhereInput
    none?: TicketModalDataWhereInput
  }

  export type TicketsListRelationFilter = {
    every?: TicketsWhereInput
    some?: TicketsWhereInput
    none?: TicketsWhereInput
  }

  export type TicketModalDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketSetupsCountOrderByAggregateInput = {
    id?: SortOrder
    CategoryId?: SortOrder
    Handlers?: SortOrder
    HandlerWithShadowPing?: SortOrder
    CustomId?: SortOrder
    TicketChannelName?: SortOrder
    ChannelType?: SortOrder
    MessageTempleateId?: SortOrder
    TicketBlacklistRoles?: SortOrder
    TranscriptChannelId?: SortOrder
    HasModal?: SortOrder
    UserDMWhenCloseMessageTemplateId?: SortOrder
    TicketLimit?: SortOrder
    WithTicketFeedback?: SortOrder
    TicketFeedbackChannelId?: SortOrder
    ModalTitle?: SortOrder
    TicketCreationCooldownPerUser?: SortOrder
    AutoCloseAfterInactivity?: SortOrder
    AutoAssignHandler?: SortOrder
    AutoReplyMessageTemplateId?: SortOrder
    RequiredRoles?: SortOrder
    OpenTicketWithCommand?: SortOrder
    SlashCommandId?: SortOrder
    TextCommandName?: SortOrder
    SendTranscriptToUser?: SortOrder
    GuildId?: SortOrder
  }

  export type TicketSetupsAvgOrderByAggregateInput = {
    ChannelType?: SortOrder
    TicketLimit?: SortOrder
    TicketCreationCooldownPerUser?: SortOrder
    AutoCloseAfterInactivity?: SortOrder
  }

  export type TicketSetupsMaxOrderByAggregateInput = {
    id?: SortOrder
    CategoryId?: SortOrder
    CustomId?: SortOrder
    TicketChannelName?: SortOrder
    ChannelType?: SortOrder
    MessageTempleateId?: SortOrder
    TranscriptChannelId?: SortOrder
    HasModal?: SortOrder
    UserDMWhenCloseMessageTemplateId?: SortOrder
    TicketLimit?: SortOrder
    WithTicketFeedback?: SortOrder
    TicketFeedbackChannelId?: SortOrder
    ModalTitle?: SortOrder
    TicketCreationCooldownPerUser?: SortOrder
    AutoCloseAfterInactivity?: SortOrder
    AutoAssignHandler?: SortOrder
    AutoReplyMessageTemplateId?: SortOrder
    OpenTicketWithCommand?: SortOrder
    SlashCommandId?: SortOrder
    TextCommandName?: SortOrder
    SendTranscriptToUser?: SortOrder
    GuildId?: SortOrder
  }

  export type TicketSetupsMinOrderByAggregateInput = {
    id?: SortOrder
    CategoryId?: SortOrder
    CustomId?: SortOrder
    TicketChannelName?: SortOrder
    ChannelType?: SortOrder
    MessageTempleateId?: SortOrder
    TranscriptChannelId?: SortOrder
    HasModal?: SortOrder
    UserDMWhenCloseMessageTemplateId?: SortOrder
    TicketLimit?: SortOrder
    WithTicketFeedback?: SortOrder
    TicketFeedbackChannelId?: SortOrder
    ModalTitle?: SortOrder
    TicketCreationCooldownPerUser?: SortOrder
    AutoCloseAfterInactivity?: SortOrder
    AutoAssignHandler?: SortOrder
    AutoReplyMessageTemplateId?: SortOrder
    OpenTicketWithCommand?: SortOrder
    SlashCommandId?: SortOrder
    TextCommandName?: SortOrder
    SendTranscriptToUser?: SortOrder
    GuildId?: SortOrder
  }

  export type TicketSetupsSumOrderByAggregateInput = {
    ChannelType?: SortOrder
    TicketLimit?: SortOrder
    TicketCreationCooldownPerUser?: SortOrder
    AutoCloseAfterInactivity?: SortOrder
  }

  export type TicketSetupsScalarRelationFilter = {
    is?: TicketSetupsWhereInput
    isNot?: TicketSetupsWhereInput
  }

  export type TicketModalDataCountOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Placeholder?: SortOrder
    Type?: SortOrder
    TicketSetupId?: SortOrder
  }

  export type TicketModalDataAvgOrderByAggregateInput = {
    Type?: SortOrder
  }

  export type TicketModalDataMaxOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Placeholder?: SortOrder
    Type?: SortOrder
    TicketSetupId?: SortOrder
  }

  export type TicketModalDataMinOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Placeholder?: SortOrder
    Type?: SortOrder
    TicketSetupId?: SortOrder
  }

  export type TicketModalDataSumOrderByAggregateInput = {
    Type?: SortOrder
  }

  export type TicketHandlersCountOrderByAggregateInput = {
    id?: SortOrder
    DiscordRoleId?: SortOrder
    TicketPermission?: SortOrder
    AddedDiscordPermission?: SortOrder
    RemovedDiscordPermission?: SortOrder
  }

  export type TicketHandlersMaxOrderByAggregateInput = {
    id?: SortOrder
    DiscordRoleId?: SortOrder
    TicketPermission?: SortOrder
  }

  export type TicketHandlersMinOrderByAggregateInput = {
    id?: SortOrder
    DiscordRoleId?: SortOrder
    TicketPermission?: SortOrder
  }

  export type TicketFeedbackNullableScalarRelationFilter = {
    is?: TicketFeedbackWhereInput | null
    isNot?: TicketFeedbackWhereInput | null
  }

  export type TicketsCountOrderByAggregateInput = {
    id?: SortOrder
    TicketId?: SortOrder
    GuildId?: SortOrder
    ChannelId?: SortOrder
    ThreadId?: SortOrder
    IsClaimed?: SortOrder
    IsArchived?: SortOrder
    ArchiveMessageId?: SortOrder
    UserWhoHasClaimedId?: SortOrder
    IsLooked?: SortOrder
    TicketOwnerId?: SortOrder
    AddedMemberIds?: SortOrder
    Handlers?: SortOrder
    TranscriptChannelId?: SortOrder
    TranscriptHTML?: SortOrder
    TicketNotes?: SortOrder
    TicketSetupId?: SortOrder
  }

  export type TicketsMaxOrderByAggregateInput = {
    id?: SortOrder
    TicketId?: SortOrder
    GuildId?: SortOrder
    ChannelId?: SortOrder
    ThreadId?: SortOrder
    IsClaimed?: SortOrder
    IsArchived?: SortOrder
    ArchiveMessageId?: SortOrder
    UserWhoHasClaimedId?: SortOrder
    IsLooked?: SortOrder
    TicketOwnerId?: SortOrder
    TranscriptChannelId?: SortOrder
    TranscriptHTML?: SortOrder
    TicketSetupId?: SortOrder
  }

  export type TicketsMinOrderByAggregateInput = {
    id?: SortOrder
    TicketId?: SortOrder
    GuildId?: SortOrder
    ChannelId?: SortOrder
    ThreadId?: SortOrder
    IsClaimed?: SortOrder
    IsArchived?: SortOrder
    ArchiveMessageId?: SortOrder
    UserWhoHasClaimedId?: SortOrder
    IsLooked?: SortOrder
    TicketOwnerId?: SortOrder
    TranscriptChannelId?: SortOrder
    TranscriptHTML?: SortOrder
    TicketSetupId?: SortOrder
  }

  export type TicketsScalarRelationFilter = {
    is?: TicketsWhereInput
    isNot?: TicketsWhereInput
  }

  export type TicketFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    TicketId?: SortOrder
    Rating?: SortOrder
    Comment?: SortOrder
    SubmittedAt?: SortOrder
  }

  export type TicketFeedbackAvgOrderByAggregateInput = {
    Rating?: SortOrder
  }

  export type TicketFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    TicketId?: SortOrder
    Rating?: SortOrder
    Comment?: SortOrder
    SubmittedAt?: SortOrder
  }

  export type TicketFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    TicketId?: SortOrder
    Rating?: SortOrder
    Comment?: SortOrder
    SubmittedAt?: SortOrder
  }

  export type TicketFeedbackSumOrderByAggregateInput = {
    Rating?: SortOrder
  }

  export type GuildFeatureTogglesCountOrderByAggregateInput = {
    id?: SortOrder
    LevelEnabled?: SortOrder
    WecomeEnabled?: SortOrder
    LeaveEnabled?: SortOrder
    AutoreactEnabled?: SortOrder
    AutopublishEnabled?: SortOrder
    ConnectionsEnabled?: SortOrder
    ChatfilterEnabled?: SortOrder
    AutorolesEnabled?: SortOrder
    LoggingEnabled?: SortOrder
    TwitchEnabled?: SortOrder
    YoutubeEnabled?: SortOrder
    SpotifyEnabled?: SortOrder
    GuildId?: SortOrder
  }

  export type GuildFeatureTogglesMaxOrderByAggregateInput = {
    id?: SortOrder
    LevelEnabled?: SortOrder
    WecomeEnabled?: SortOrder
    LeaveEnabled?: SortOrder
    AutoreactEnabled?: SortOrder
    AutopublishEnabled?: SortOrder
    ConnectionsEnabled?: SortOrder
    ChatfilterEnabled?: SortOrder
    AutorolesEnabled?: SortOrder
    LoggingEnabled?: SortOrder
    TwitchEnabled?: SortOrder
    YoutubeEnabled?: SortOrder
    SpotifyEnabled?: SortOrder
    GuildId?: SortOrder
  }

  export type GuildFeatureTogglesMinOrderByAggregateInput = {
    id?: SortOrder
    LevelEnabled?: SortOrder
    WecomeEnabled?: SortOrder
    LeaveEnabled?: SortOrder
    AutoreactEnabled?: SortOrder
    AutopublishEnabled?: SortOrder
    ConnectionsEnabled?: SortOrder
    ChatfilterEnabled?: SortOrder
    AutorolesEnabled?: SortOrder
    LoggingEnabled?: SortOrder
    TwitchEnabled?: SortOrder
    YoutubeEnabled?: SortOrder
    SpotifyEnabled?: SortOrder
    GuildId?: SortOrder
  }

  export type TwitchNotificationsCountOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    TwitchChannelName?: SortOrder
    ChannelId?: SortOrder
    Live?: SortOrder
    MessageTemplateId?: SortOrder
    PingRoles?: SortOrder
    GuildId?: SortOrder
  }

  export type TwitchNotificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    TwitchChannelName?: SortOrder
    ChannelId?: SortOrder
    Live?: SortOrder
    MessageTemplateId?: SortOrder
    GuildId?: SortOrder
  }

  export type TwitchNotificationsMinOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    TwitchChannelName?: SortOrder
    ChannelId?: SortOrder
    Live?: SortOrder
    MessageTemplateId?: SortOrder
    GuildId?: SortOrder
  }

  export type YoutubeNotificationsCountOrderByAggregateInput = {
    id?: SortOrder
    YoutubeChannelId?: SortOrder
    ChannelId?: SortOrder
    Latest?: SortOrder
    MessageTemplateId?: SortOrder
    PingRoles?: SortOrder
    UUID?: SortOrder
    GuildId?: SortOrder
  }

  export type YoutubeNotificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    YoutubeChannelId?: SortOrder
    ChannelId?: SortOrder
    MessageTemplateId?: SortOrder
    UUID?: SortOrder
    GuildId?: SortOrder
  }

  export type YoutubeNotificationsMinOrderByAggregateInput = {
    id?: SortOrder
    YoutubeChannelId?: SortOrder
    ChannelId?: SortOrder
    MessageTemplateId?: SortOrder
    UUID?: SortOrder
    GuildId?: SortOrder
  }

  export type ApisListRelationFilter = {
    every?: ApisWhereInput
    some?: ApisWhereInput
    none?: ApisWhereInput
  }

  export type GuildBackupsListRelationFilter = {
    every?: GuildBackupsWhereInput
    some?: GuildBackupsWhereInput
    none?: GuildBackupsWhereInput
  }

  export type CustomersListRelationFilter = {
    every?: CustomersWhereInput
    some?: CustomersWhereInput
    none?: CustomersWhereInput
  }

  export type DisBotUserNotificationsNullableScalarRelationFilter = {
    is?: DisBotUserNotificationsWhereInput | null
    isNot?: DisBotUserNotificationsWhereInput | null
  }

  export type VanitysListRelationFilter = {
    every?: VanitysWhereInput
    some?: VanitysWhereInput
    none?: VanitysWhereInput
  }

  export type ApisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GuildBackupsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VanitysOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder
    Username?: SortOrder
    UserId?: SortOrder
    Votes?: SortOrder
    GloablVotes?: SortOrder
    CustomerBots?: SortOrder
    BackupCount?: SortOrder
  }

  export type UsersAvgOrderByAggregateInput = {
    Votes?: SortOrder
    GloablVotes?: SortOrder
    CustomerBots?: SortOrder
    BackupCount?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder
    Username?: SortOrder
    UserId?: SortOrder
    Votes?: SortOrder
    GloablVotes?: SortOrder
    CustomerBots?: SortOrder
    BackupCount?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder
    Username?: SortOrder
    UserId?: SortOrder
    Votes?: SortOrder
    GloablVotes?: SortOrder
    CustomerBots?: SortOrder
    BackupCount?: SortOrder
  }

  export type UsersSumOrderByAggregateInput = {
    Votes?: SortOrder
    GloablVotes?: SortOrder
    CustomerBots?: SortOrder
    BackupCount?: SortOrder
  }

  export type UsersScalarRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type ApisCountOrderByAggregateInput = {
    id?: SortOrder
    Flags?: SortOrder
    Guilds?: SortOrder
    Key?: SortOrder
    UserId?: SortOrder
  }

  export type ApisMaxOrderByAggregateInput = {
    id?: SortOrder
    Key?: SortOrder
    UserId?: SortOrder
  }

  export type ApisMinOrderByAggregateInput = {
    id?: SortOrder
    Key?: SortOrder
    UserId?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type GuildBackupsCountOrderByAggregateInput = {
    id?: SortOrder
    BackupJSON?: SortOrder
    CreatedAt?: SortOrder
    UUID?: SortOrder
    Name?: SortOrder
    GuildId?: SortOrder
    UserId?: SortOrder
  }

  export type GuildBackupsMaxOrderByAggregateInput = {
    id?: SortOrder
    CreatedAt?: SortOrder
    UUID?: SortOrder
    Name?: SortOrder
    GuildId?: SortOrder
    UserId?: SortOrder
  }

  export type GuildBackupsMinOrderByAggregateInput = {
    id?: SortOrder
    CreatedAt?: SortOrder
    UUID?: SortOrder
    Name?: SortOrder
    GuildId?: SortOrder
    UserId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BotStatusCompositeFilter = {
    equals?: BotStatusObjectEqualityInput
    is?: BotStatusWhereInput
    isNot?: BotStatusWhereInput
  }

  export type BotStatusObjectEqualityInput = {
    Type: number
    Text: string
    Status: string
    URL: string
  }

  export type BotStatusOrderByInput = {
    Type?: SortOrder
    Text?: SortOrder
    Status?: SortOrder
    URL?: SortOrder
  }

  export type CustomersCountOrderByAggregateInput = {
    id?: SortOrder
    ExternalUUID?: SortOrder
    RealUUID?: SortOrder
    Application?: SortOrder
    DisplayName?: SortOrder
    GuildIds?: SortOrder
    ServerPort?: SortOrder
    WSAPI?: SortOrder
    UserId?: SortOrder
  }

  export type CustomersMaxOrderByAggregateInput = {
    id?: SortOrder
    ExternalUUID?: SortOrder
    RealUUID?: SortOrder
    Application?: SortOrder
    DisplayName?: SortOrder
    ServerPort?: SortOrder
    WSAPI?: SortOrder
    UserId?: SortOrder
  }

  export type CustomersMinOrderByAggregateInput = {
    id?: SortOrder
    ExternalUUID?: SortOrder
    RealUUID?: SortOrder
    Application?: SortOrder
    DisplayName?: SortOrder
    ServerPort?: SortOrder
    WSAPI?: SortOrder
    UserId?: SortOrder
  }

  export type VanityAnalyticsNullableScalarRelationFilter = {
    is?: VanityAnalyticsWhereInput | null
    isNot?: VanityAnalyticsWhereInput | null
  }

  export type VanityEmbedsNullableScalarRelationFilter = {
    is?: VanityEmbedsWhereInput | null
    isNot?: VanityEmbedsWhereInput | null
  }

  export type VanitysCountOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    Slug?: SortOrder
    Host?: SortOrder
    GuildId?: SortOrder
    Invite?: SortOrder
    CreatedAt?: SortOrder
    UserId?: SortOrder
  }

  export type VanitysMaxOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    Slug?: SortOrder
    Host?: SortOrder
    GuildId?: SortOrder
    Invite?: SortOrder
    CreatedAt?: SortOrder
    UserId?: SortOrder
  }

  export type VanitysMinOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    Slug?: SortOrder
    Host?: SortOrder
    GuildId?: SortOrder
    Invite?: SortOrder
    CreatedAt?: SortOrder
    UserId?: SortOrder
  }

  export type VanityEmbedAuthorsNullableScalarRelationFilter = {
    is?: VanityEmbedAuthorsWhereInput | null
    isNot?: VanityEmbedAuthorsWhereInput | null
  }

  export type VanitysScalarRelationFilter = {
    is?: VanitysWhereInput
    isNot?: VanitysWhereInput
  }

  export type VanityEmbedsCountOrderByAggregateInput = {
    id?: SortOrder
    Title?: SortOrder
    Description?: SortOrder
    Color?: SortOrder
    ImageUrl?: SortOrder
    ThumbnailUrl?: SortOrder
    VanityId?: SortOrder
  }

  export type VanityEmbedsMaxOrderByAggregateInput = {
    id?: SortOrder
    Title?: SortOrder
    Description?: SortOrder
    Color?: SortOrder
    ImageUrl?: SortOrder
    ThumbnailUrl?: SortOrder
    VanityId?: SortOrder
  }

  export type VanityEmbedsMinOrderByAggregateInput = {
    id?: SortOrder
    Title?: SortOrder
    Description?: SortOrder
    Color?: SortOrder
    ImageUrl?: SortOrder
    ThumbnailUrl?: SortOrder
    VanityId?: SortOrder
  }

  export type VanityEmbedsScalarRelationFilter = {
    is?: VanityEmbedsWhereInput
    isNot?: VanityEmbedsWhereInput
  }

  export type VanityEmbedAuthorsCountOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    URL?: SortOrder
    IconURL?: SortOrder
    VanityEmbedsId?: SortOrder
  }

  export type VanityEmbedAuthorsMaxOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    URL?: SortOrder
    IconURL?: SortOrder
    VanityEmbedsId?: SortOrder
  }

  export type VanityEmbedAuthorsMinOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    URL?: SortOrder
    IconURL?: SortOrder
    VanityEmbedsId?: SortOrder
  }

  export type AnalyticsLatest30DaysNullableScalarRelationFilter = {
    is?: AnalyticsLatest30DaysWhereInput | null
    isNot?: AnalyticsLatest30DaysWhereInput | null
  }

  export type VanityAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    Click?: SortOrder
    TrackInviteWithLog?: SortOrder
    TrackMessageId?: SortOrder
    Update?: SortOrder
    UniqueClick?: SortOrder
    JoinedWithCode?: SortOrder
    LoggedIPs?: SortOrder
    VanityId?: SortOrder
  }

  export type VanityAnalyticsAvgOrderByAggregateInput = {
    Click?: SortOrder
    UniqueClick?: SortOrder
    JoinedWithCode?: SortOrder
  }

  export type VanityAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    Click?: SortOrder
    TrackInviteWithLog?: SortOrder
    TrackMessageId?: SortOrder
    Update?: SortOrder
    UniqueClick?: SortOrder
    JoinedWithCode?: SortOrder
    VanityId?: SortOrder
  }

  export type VanityAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    Click?: SortOrder
    TrackInviteWithLog?: SortOrder
    TrackMessageId?: SortOrder
    Update?: SortOrder
    UniqueClick?: SortOrder
    JoinedWithCode?: SortOrder
    VanityId?: SortOrder
  }

  export type VanityAnalyticsSumOrderByAggregateInput = {
    Click?: SortOrder
    UniqueClick?: SortOrder
    JoinedWithCode?: SortOrder
  }

  export type VanityAnalyticsScalarRelationFilter = {
    is?: VanityAnalyticsWhereInput
    isNot?: VanityAnalyticsWhereInput
  }

  export type AnalyticsLatest30DaysCountOrderByAggregateInput = {
    id?: SortOrder
    Click?: SortOrder
    UniqueClick?: SortOrder
    Date?: SortOrder
    JoinedWithCode?: SortOrder
    VanityAnalyticsId?: SortOrder
  }

  export type AnalyticsLatest30DaysAvgOrderByAggregateInput = {
    Click?: SortOrder
    UniqueClick?: SortOrder
    JoinedWithCode?: SortOrder
  }

  export type AnalyticsLatest30DaysMaxOrderByAggregateInput = {
    id?: SortOrder
    Click?: SortOrder
    UniqueClick?: SortOrder
    Date?: SortOrder
    JoinedWithCode?: SortOrder
    VanityAnalyticsId?: SortOrder
  }

  export type AnalyticsLatest30DaysMinOrderByAggregateInput = {
    id?: SortOrder
    Click?: SortOrder
    UniqueClick?: SortOrder
    Date?: SortOrder
    JoinedWithCode?: SortOrder
    VanityAnalyticsId?: SortOrder
  }

  export type AnalyticsLatest30DaysSumOrderByAggregateInput = {
    Click?: SortOrder
    UniqueClick?: SortOrder
    JoinedWithCode?: SortOrder
  }

  export type DisBotUserNotificationsCountOrderByAggregateInput = {
    id?: SortOrder
    Updates?: SortOrder
    Status?: SortOrder
    Announcements?: SortOrder
    Customer?: SortOrder
    UserId?: SortOrder
  }

  export type DisBotUserNotificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    Updates?: SortOrder
    Status?: SortOrder
    Announcements?: SortOrder
    Customer?: SortOrder
    UserId?: SortOrder
  }

  export type DisBotUserNotificationsMinOrderByAggregateInput = {
    id?: SortOrder
    Updates?: SortOrder
    Status?: SortOrder
    Announcements?: SortOrder
    Customer?: SortOrder
    UserId?: SortOrder
  }

  export type DisbotsLogsCompositeListFilter = {
    equals?: DisbotsLogsObjectEqualityInput[]
    every?: DisbotsLogsWhereInput
    some?: DisbotsLogsWhereInput
    none?: DisbotsLogsWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type DisbotsLogsObjectEqualityInput = {
    Action: string
    BotType: string
    ChannelId: string
    GuildId: string
    Label: string
    Level: string
    Message: string
    MessageId: string
    Timestamp: string
    UUID: string
    UserId: string
  }

  export type DisbotsLogsOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type DisBotCountOrderByAggregateInput = {
    id?: SortOrder
    SpotifyToken?: SortOrder
    TwitchToken?: SortOrder
    Version?: SortOrder
    GetConf?: SortOrder
  }

  export type DisBotMaxOrderByAggregateInput = {
    id?: SortOrder
    SpotifyToken?: SortOrder
    TwitchToken?: SortOrder
    Version?: SortOrder
    GetConf?: SortOrder
  }

  export type DisBotMinOrderByAggregateInput = {
    id?: SortOrder
    SpotifyToken?: SortOrder
    TwitchToken?: SortOrder
    Version?: SortOrder
    GetConf?: SortOrder
  }

  export type ImageApisCountOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    ImageBase64?: SortOrder
    URL?: SortOrder
  }

  export type ImageApisMaxOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    ImageBase64?: SortOrder
    URL?: SortOrder
  }

  export type ImageApisMinOrderByAggregateInput = {
    id?: SortOrder
    UUID?: SortOrder
    ImageBase64?: SortOrder
    URL?: SortOrder
  }

  export type AutoDeletesCreateNestedManyWithoutGuildsInput = {
    create?: XOR<AutoDeletesCreateWithoutGuildsInput, AutoDeletesUncheckedCreateWithoutGuildsInput> | AutoDeletesCreateWithoutGuildsInput[] | AutoDeletesUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: AutoDeletesCreateOrConnectWithoutGuildsInput | AutoDeletesCreateOrConnectWithoutGuildsInput[]
    createMany?: AutoDeletesCreateManyGuildsInputEnvelope
    connect?: AutoDeletesWhereUniqueInput | AutoDeletesWhereUniqueInput[]
  }

  export type AutoPublishCreateNestedOneWithoutGuildsInput = {
    create?: XOR<AutoPublishCreateWithoutGuildsInput, AutoPublishUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: AutoPublishCreateOrConnectWithoutGuildsInput
    connect?: AutoPublishWhereUniqueInput
  }

  export type AutoReactsCreateNestedManyWithoutGuildsInput = {
    create?: XOR<AutoReactsCreateWithoutGuildsInput, AutoReactsUncheckedCreateWithoutGuildsInput> | AutoReactsCreateWithoutGuildsInput[] | AutoReactsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: AutoReactsCreateOrConnectWithoutGuildsInput | AutoReactsCreateOrConnectWithoutGuildsInput[]
    createMany?: AutoReactsCreateManyGuildsInputEnvelope
    connect?: AutoReactsWhereUniqueInput | AutoReactsWhereUniqueInput[]
  }

  export type AutoRolesCreateNestedManyWithoutGuildsInput = {
    create?: XOR<AutoRolesCreateWithoutGuildsInput, AutoRolesUncheckedCreateWithoutGuildsInput> | AutoRolesCreateWithoutGuildsInput[] | AutoRolesUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: AutoRolesCreateOrConnectWithoutGuildsInput | AutoRolesCreateOrConnectWithoutGuildsInput[]
    createMany?: AutoRolesCreateManyGuildsInputEnvelope
    connect?: AutoRolesWhereUniqueInput | AutoRolesWhereUniqueInput[]
  }

  export type GuildBansCreateNestedManyWithoutGuildsInput = {
    create?: XOR<GuildBansCreateWithoutGuildsInput, GuildBansUncheckedCreateWithoutGuildsInput> | GuildBansCreateWithoutGuildsInput[] | GuildBansUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: GuildBansCreateOrConnectWithoutGuildsInput | GuildBansCreateOrConnectWithoutGuildsInput[]
    createMany?: GuildBansCreateManyGuildsInputEnvelope
    connect?: GuildBansWhereUniqueInput | GuildBansWhereUniqueInput[]
  }

  export type ChatModerationsCreateNestedOneWithoutGuildsInput = {
    create?: XOR<ChatModerationsCreateWithoutGuildsInput, ChatModerationsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: ChatModerationsCreateOrConnectWithoutGuildsInput
    connect?: ChatModerationsWhereUniqueInput
  }

  export type ChannelLinksCreateNestedManyWithoutGuildsInput = {
    create?: XOR<ChannelLinksCreateWithoutGuildsInput, ChannelLinksUncheckedCreateWithoutGuildsInput> | ChannelLinksCreateWithoutGuildsInput[] | ChannelLinksUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: ChannelLinksCreateOrConnectWithoutGuildsInput | ChannelLinksCreateOrConnectWithoutGuildsInput[]
    createMany?: ChannelLinksCreateManyGuildsInputEnvelope
    connect?: ChannelLinksWhereUniqueInput | ChannelLinksWhereUniqueInput[]
  }

  export type DiscordAddonsCreateNestedOneWithoutGuildsInput = {
    create?: XOR<DiscordAddonsCreateWithoutGuildsInput, DiscordAddonsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: DiscordAddonsCreateOrConnectWithoutGuildsInput
    connect?: DiscordAddonsWhereUniqueInput
  }

  export type GiveawaysCreateNestedManyWithoutGuildsInput = {
    create?: XOR<GiveawaysCreateWithoutGuildsInput, GiveawaysUncheckedCreateWithoutGuildsInput> | GiveawaysCreateWithoutGuildsInput[] | GiveawaysUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: GiveawaysCreateOrConnectWithoutGuildsInput | GiveawaysCreateOrConnectWithoutGuildsInput[]
    createMany?: GiveawaysCreateManyGuildsInputEnvelope
    connect?: GiveawaysWhereUniqueInput | GiveawaysWhereUniqueInput[]
  }

  export type TempVoicesCreateNestedManyWithoutGuildsInput = {
    create?: XOR<TempVoicesCreateWithoutGuildsInput, TempVoicesUncheckedCreateWithoutGuildsInput> | TempVoicesCreateWithoutGuildsInput[] | TempVoicesUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: TempVoicesCreateOrConnectWithoutGuildsInput | TempVoicesCreateOrConnectWithoutGuildsInput[]
    createMany?: TempVoicesCreateManyGuildsInputEnvelope
    connect?: TempVoicesWhereUniqueInput | TempVoicesWhereUniqueInput[]
  }

  export type GuildLeaveSetupsCreateNestedOneWithoutGuildsInput = {
    create?: XOR<GuildLeaveSetupsCreateWithoutGuildsInput, GuildLeaveSetupsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: GuildLeaveSetupsCreateOrConnectWithoutGuildsInput
    connect?: GuildLeaveSetupsWhereUniqueInput
  }

  export type GuildLoggingsCreateNestedOneWithoutGuildsInput = {
    create?: XOR<GuildLoggingsCreateWithoutGuildsInput, GuildLoggingsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: GuildLoggingsCreateOrConnectWithoutGuildsInput
    connect?: GuildLoggingsWhereUniqueInput
  }

  export type MessageTemplatesCreateNestedManyWithoutGuildsInput = {
    create?: XOR<MessageTemplatesCreateWithoutGuildsInput, MessageTemplatesUncheckedCreateWithoutGuildsInput> | MessageTemplatesCreateWithoutGuildsInput[] | MessageTemplatesUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: MessageTemplatesCreateOrConnectWithoutGuildsInput | MessageTemplatesCreateOrConnectWithoutGuildsInput[]
    createMany?: MessageTemplatesCreateManyGuildsInputEnvelope
    connect?: MessageTemplatesWhereUniqueInput | MessageTemplatesWhereUniqueInput[]
  }

  export type PermissionsCreateNestedOneWithoutGuildsInput = {
    create?: XOR<PermissionsCreateWithoutGuildsInput, PermissionsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: PermissionsCreateOrConnectWithoutGuildsInput
    connect?: PermissionsWhereUniqueInput
  }

  export type ReactionRolesCreateNestedManyWithoutGuildsInput = {
    create?: XOR<ReactionRolesCreateWithoutGuildsInput, ReactionRolesUncheckedCreateWithoutGuildsInput> | ReactionRolesCreateWithoutGuildsInput[] | ReactionRolesUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: ReactionRolesCreateOrConnectWithoutGuildsInput | ReactionRolesCreateOrConnectWithoutGuildsInput[]
    createMany?: ReactionRolesCreateManyGuildsInputEnvelope
    connect?: ReactionRolesWhereUniqueInput | ReactionRolesWhereUniqueInput[]
  }

  export type SecuritysCreateNestedOneWithoutGuildsInput = {
    create?: XOR<SecuritysCreateWithoutGuildsInput, SecuritysUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: SecuritysCreateOrConnectWithoutGuildsInput
    connect?: SecuritysWhereUniqueInput
  }

  export type SpotifyNotificationsCreateNestedManyWithoutGuildsInput = {
    create?: XOR<SpotifyNotificationsCreateWithoutGuildsInput, SpotifyNotificationsUncheckedCreateWithoutGuildsInput> | SpotifyNotificationsCreateWithoutGuildsInput[] | SpotifyNotificationsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: SpotifyNotificationsCreateOrConnectWithoutGuildsInput | SpotifyNotificationsCreateOrConnectWithoutGuildsInput[]
    createMany?: SpotifyNotificationsCreateManyGuildsInputEnvelope
    connect?: SpotifyNotificationsWhereUniqueInput | SpotifyNotificationsWhereUniqueInput[]
  }

  export type TagsCreateNestedManyWithoutGuildsInput = {
    create?: XOR<TagsCreateWithoutGuildsInput, TagsUncheckedCreateWithoutGuildsInput> | TagsCreateWithoutGuildsInput[] | TagsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutGuildsInput | TagsCreateOrConnectWithoutGuildsInput[]
    createMany?: TagsCreateManyGuildsInputEnvelope
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
  }

  export type TicketSetupsCreateNestedManyWithoutGuildsInput = {
    create?: XOR<TicketSetupsCreateWithoutGuildsInput, TicketSetupsUncheckedCreateWithoutGuildsInput> | TicketSetupsCreateWithoutGuildsInput[] | TicketSetupsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: TicketSetupsCreateOrConnectWithoutGuildsInput | TicketSetupsCreateOrConnectWithoutGuildsInput[]
    createMany?: TicketSetupsCreateManyGuildsInputEnvelope
    connect?: TicketSetupsWhereUniqueInput | TicketSetupsWhereUniqueInput[]
  }

  export type GuildFeatureTogglesCreateNestedOneWithoutGuildsInput = {
    create?: XOR<GuildFeatureTogglesCreateWithoutGuildsInput, GuildFeatureTogglesUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: GuildFeatureTogglesCreateOrConnectWithoutGuildsInput
    connect?: GuildFeatureTogglesWhereUniqueInput
  }

  export type TwitchNotificationsCreateNestedManyWithoutGuildsInput = {
    create?: XOR<TwitchNotificationsCreateWithoutGuildsInput, TwitchNotificationsUncheckedCreateWithoutGuildsInput> | TwitchNotificationsCreateWithoutGuildsInput[] | TwitchNotificationsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: TwitchNotificationsCreateOrConnectWithoutGuildsInput | TwitchNotificationsCreateOrConnectWithoutGuildsInput[]
    createMany?: TwitchNotificationsCreateManyGuildsInputEnvelope
    connect?: TwitchNotificationsWhereUniqueInput | TwitchNotificationsWhereUniqueInput[]
  }

  export type GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput = {
    create?: XOR<GuildWelcomeSetupsCreateWithoutGuildsInput, GuildWelcomeSetupsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: GuildWelcomeSetupsCreateOrConnectWithoutGuildsInput
    connect?: GuildWelcomeSetupsWhereUniqueInput
  }

  export type YoutubeNotificationsCreateNestedManyWithoutGuildsInput = {
    create?: XOR<YoutubeNotificationsCreateWithoutGuildsInput, YoutubeNotificationsUncheckedCreateWithoutGuildsInput> | YoutubeNotificationsCreateWithoutGuildsInput[] | YoutubeNotificationsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: YoutubeNotificationsCreateOrConnectWithoutGuildsInput | YoutubeNotificationsCreateOrConnectWithoutGuildsInput[]
    createMany?: YoutubeNotificationsCreateManyGuildsInputEnvelope
    connect?: YoutubeNotificationsWhereUniqueInput | YoutubeNotificationsWhereUniqueInput[]
  }

  export type GuildLoggersCreateNestedManyWithoutGuildsInput = {
    create?: XOR<GuildLoggersCreateWithoutGuildsInput, GuildLoggersUncheckedCreateWithoutGuildsInput> | GuildLoggersCreateWithoutGuildsInput[] | GuildLoggersUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: GuildLoggersCreateOrConnectWithoutGuildsInput | GuildLoggersCreateOrConnectWithoutGuildsInput[]
    createMany?: GuildLoggersCreateManyGuildsInputEnvelope
    connect?: GuildLoggersWhereUniqueInput | GuildLoggersWhereUniqueInput[]
  }

  export type AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput = {
    create?: XOR<AutoDeletesCreateWithoutGuildsInput, AutoDeletesUncheckedCreateWithoutGuildsInput> | AutoDeletesCreateWithoutGuildsInput[] | AutoDeletesUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: AutoDeletesCreateOrConnectWithoutGuildsInput | AutoDeletesCreateOrConnectWithoutGuildsInput[]
    createMany?: AutoDeletesCreateManyGuildsInputEnvelope
    connect?: AutoDeletesWhereUniqueInput | AutoDeletesWhereUniqueInput[]
  }

  export type AutoPublishUncheckedCreateNestedOneWithoutGuildsInput = {
    create?: XOR<AutoPublishCreateWithoutGuildsInput, AutoPublishUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: AutoPublishCreateOrConnectWithoutGuildsInput
    connect?: AutoPublishWhereUniqueInput
  }

  export type AutoReactsUncheckedCreateNestedManyWithoutGuildsInput = {
    create?: XOR<AutoReactsCreateWithoutGuildsInput, AutoReactsUncheckedCreateWithoutGuildsInput> | AutoReactsCreateWithoutGuildsInput[] | AutoReactsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: AutoReactsCreateOrConnectWithoutGuildsInput | AutoReactsCreateOrConnectWithoutGuildsInput[]
    createMany?: AutoReactsCreateManyGuildsInputEnvelope
    connect?: AutoReactsWhereUniqueInput | AutoReactsWhereUniqueInput[]
  }

  export type AutoRolesUncheckedCreateNestedManyWithoutGuildsInput = {
    create?: XOR<AutoRolesCreateWithoutGuildsInput, AutoRolesUncheckedCreateWithoutGuildsInput> | AutoRolesCreateWithoutGuildsInput[] | AutoRolesUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: AutoRolesCreateOrConnectWithoutGuildsInput | AutoRolesCreateOrConnectWithoutGuildsInput[]
    createMany?: AutoRolesCreateManyGuildsInputEnvelope
    connect?: AutoRolesWhereUniqueInput | AutoRolesWhereUniqueInput[]
  }

  export type GuildBansUncheckedCreateNestedManyWithoutGuildsInput = {
    create?: XOR<GuildBansCreateWithoutGuildsInput, GuildBansUncheckedCreateWithoutGuildsInput> | GuildBansCreateWithoutGuildsInput[] | GuildBansUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: GuildBansCreateOrConnectWithoutGuildsInput | GuildBansCreateOrConnectWithoutGuildsInput[]
    createMany?: GuildBansCreateManyGuildsInputEnvelope
    connect?: GuildBansWhereUniqueInput | GuildBansWhereUniqueInput[]
  }

  export type ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput = {
    create?: XOR<ChatModerationsCreateWithoutGuildsInput, ChatModerationsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: ChatModerationsCreateOrConnectWithoutGuildsInput
    connect?: ChatModerationsWhereUniqueInput
  }

  export type ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput = {
    create?: XOR<ChannelLinksCreateWithoutGuildsInput, ChannelLinksUncheckedCreateWithoutGuildsInput> | ChannelLinksCreateWithoutGuildsInput[] | ChannelLinksUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: ChannelLinksCreateOrConnectWithoutGuildsInput | ChannelLinksCreateOrConnectWithoutGuildsInput[]
    createMany?: ChannelLinksCreateManyGuildsInputEnvelope
    connect?: ChannelLinksWhereUniqueInput | ChannelLinksWhereUniqueInput[]
  }

  export type DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput = {
    create?: XOR<DiscordAddonsCreateWithoutGuildsInput, DiscordAddonsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: DiscordAddonsCreateOrConnectWithoutGuildsInput
    connect?: DiscordAddonsWhereUniqueInput
  }

  export type GiveawaysUncheckedCreateNestedManyWithoutGuildsInput = {
    create?: XOR<GiveawaysCreateWithoutGuildsInput, GiveawaysUncheckedCreateWithoutGuildsInput> | GiveawaysCreateWithoutGuildsInput[] | GiveawaysUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: GiveawaysCreateOrConnectWithoutGuildsInput | GiveawaysCreateOrConnectWithoutGuildsInput[]
    createMany?: GiveawaysCreateManyGuildsInputEnvelope
    connect?: GiveawaysWhereUniqueInput | GiveawaysWhereUniqueInput[]
  }

  export type TempVoicesUncheckedCreateNestedManyWithoutGuildsInput = {
    create?: XOR<TempVoicesCreateWithoutGuildsInput, TempVoicesUncheckedCreateWithoutGuildsInput> | TempVoicesCreateWithoutGuildsInput[] | TempVoicesUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: TempVoicesCreateOrConnectWithoutGuildsInput | TempVoicesCreateOrConnectWithoutGuildsInput[]
    createMany?: TempVoicesCreateManyGuildsInputEnvelope
    connect?: TempVoicesWhereUniqueInput | TempVoicesWhereUniqueInput[]
  }

  export type GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput = {
    create?: XOR<GuildLeaveSetupsCreateWithoutGuildsInput, GuildLeaveSetupsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: GuildLeaveSetupsCreateOrConnectWithoutGuildsInput
    connect?: GuildLeaveSetupsWhereUniqueInput
  }

  export type GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput = {
    create?: XOR<GuildLoggingsCreateWithoutGuildsInput, GuildLoggingsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: GuildLoggingsCreateOrConnectWithoutGuildsInput
    connect?: GuildLoggingsWhereUniqueInput
  }

  export type MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput = {
    create?: XOR<MessageTemplatesCreateWithoutGuildsInput, MessageTemplatesUncheckedCreateWithoutGuildsInput> | MessageTemplatesCreateWithoutGuildsInput[] | MessageTemplatesUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: MessageTemplatesCreateOrConnectWithoutGuildsInput | MessageTemplatesCreateOrConnectWithoutGuildsInput[]
    createMany?: MessageTemplatesCreateManyGuildsInputEnvelope
    connect?: MessageTemplatesWhereUniqueInput | MessageTemplatesWhereUniqueInput[]
  }

  export type PermissionsUncheckedCreateNestedOneWithoutGuildsInput = {
    create?: XOR<PermissionsCreateWithoutGuildsInput, PermissionsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: PermissionsCreateOrConnectWithoutGuildsInput
    connect?: PermissionsWhereUniqueInput
  }

  export type ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput = {
    create?: XOR<ReactionRolesCreateWithoutGuildsInput, ReactionRolesUncheckedCreateWithoutGuildsInput> | ReactionRolesCreateWithoutGuildsInput[] | ReactionRolesUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: ReactionRolesCreateOrConnectWithoutGuildsInput | ReactionRolesCreateOrConnectWithoutGuildsInput[]
    createMany?: ReactionRolesCreateManyGuildsInputEnvelope
    connect?: ReactionRolesWhereUniqueInput | ReactionRolesWhereUniqueInput[]
  }

  export type SecuritysUncheckedCreateNestedOneWithoutGuildsInput = {
    create?: XOR<SecuritysCreateWithoutGuildsInput, SecuritysUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: SecuritysCreateOrConnectWithoutGuildsInput
    connect?: SecuritysWhereUniqueInput
  }

  export type SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput = {
    create?: XOR<SpotifyNotificationsCreateWithoutGuildsInput, SpotifyNotificationsUncheckedCreateWithoutGuildsInput> | SpotifyNotificationsCreateWithoutGuildsInput[] | SpotifyNotificationsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: SpotifyNotificationsCreateOrConnectWithoutGuildsInput | SpotifyNotificationsCreateOrConnectWithoutGuildsInput[]
    createMany?: SpotifyNotificationsCreateManyGuildsInputEnvelope
    connect?: SpotifyNotificationsWhereUniqueInput | SpotifyNotificationsWhereUniqueInput[]
  }

  export type TagsUncheckedCreateNestedManyWithoutGuildsInput = {
    create?: XOR<TagsCreateWithoutGuildsInput, TagsUncheckedCreateWithoutGuildsInput> | TagsCreateWithoutGuildsInput[] | TagsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutGuildsInput | TagsCreateOrConnectWithoutGuildsInput[]
    createMany?: TagsCreateManyGuildsInputEnvelope
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
  }

  export type TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput = {
    create?: XOR<TicketSetupsCreateWithoutGuildsInput, TicketSetupsUncheckedCreateWithoutGuildsInput> | TicketSetupsCreateWithoutGuildsInput[] | TicketSetupsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: TicketSetupsCreateOrConnectWithoutGuildsInput | TicketSetupsCreateOrConnectWithoutGuildsInput[]
    createMany?: TicketSetupsCreateManyGuildsInputEnvelope
    connect?: TicketSetupsWhereUniqueInput | TicketSetupsWhereUniqueInput[]
  }

  export type GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput = {
    create?: XOR<GuildFeatureTogglesCreateWithoutGuildsInput, GuildFeatureTogglesUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: GuildFeatureTogglesCreateOrConnectWithoutGuildsInput
    connect?: GuildFeatureTogglesWhereUniqueInput
  }

  export type TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput = {
    create?: XOR<TwitchNotificationsCreateWithoutGuildsInput, TwitchNotificationsUncheckedCreateWithoutGuildsInput> | TwitchNotificationsCreateWithoutGuildsInput[] | TwitchNotificationsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: TwitchNotificationsCreateOrConnectWithoutGuildsInput | TwitchNotificationsCreateOrConnectWithoutGuildsInput[]
    createMany?: TwitchNotificationsCreateManyGuildsInputEnvelope
    connect?: TwitchNotificationsWhereUniqueInput | TwitchNotificationsWhereUniqueInput[]
  }

  export type GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput = {
    create?: XOR<GuildWelcomeSetupsCreateWithoutGuildsInput, GuildWelcomeSetupsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: GuildWelcomeSetupsCreateOrConnectWithoutGuildsInput
    connect?: GuildWelcomeSetupsWhereUniqueInput
  }

  export type YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput = {
    create?: XOR<YoutubeNotificationsCreateWithoutGuildsInput, YoutubeNotificationsUncheckedCreateWithoutGuildsInput> | YoutubeNotificationsCreateWithoutGuildsInput[] | YoutubeNotificationsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: YoutubeNotificationsCreateOrConnectWithoutGuildsInput | YoutubeNotificationsCreateOrConnectWithoutGuildsInput[]
    createMany?: YoutubeNotificationsCreateManyGuildsInputEnvelope
    connect?: YoutubeNotificationsWhereUniqueInput | YoutubeNotificationsWhereUniqueInput[]
  }

  export type GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput = {
    create?: XOR<GuildLoggersCreateWithoutGuildsInput, GuildLoggersUncheckedCreateWithoutGuildsInput> | GuildLoggersCreateWithoutGuildsInput[] | GuildLoggersUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: GuildLoggersCreateOrConnectWithoutGuildsInput | GuildLoggersCreateOrConnectWithoutGuildsInput[]
    createMany?: GuildLoggersCreateManyGuildsInputEnvelope
    connect?: GuildLoggersWhereUniqueInput | GuildLoggersWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type AutoDeletesUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<AutoDeletesCreateWithoutGuildsInput, AutoDeletesUncheckedCreateWithoutGuildsInput> | AutoDeletesCreateWithoutGuildsInput[] | AutoDeletesUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: AutoDeletesCreateOrConnectWithoutGuildsInput | AutoDeletesCreateOrConnectWithoutGuildsInput[]
    upsert?: AutoDeletesUpsertWithWhereUniqueWithoutGuildsInput | AutoDeletesUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: AutoDeletesCreateManyGuildsInputEnvelope
    set?: AutoDeletesWhereUniqueInput | AutoDeletesWhereUniqueInput[]
    disconnect?: AutoDeletesWhereUniqueInput | AutoDeletesWhereUniqueInput[]
    delete?: AutoDeletesWhereUniqueInput | AutoDeletesWhereUniqueInput[]
    connect?: AutoDeletesWhereUniqueInput | AutoDeletesWhereUniqueInput[]
    update?: AutoDeletesUpdateWithWhereUniqueWithoutGuildsInput | AutoDeletesUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: AutoDeletesUpdateManyWithWhereWithoutGuildsInput | AutoDeletesUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: AutoDeletesScalarWhereInput | AutoDeletesScalarWhereInput[]
  }

  export type AutoPublishUpdateOneWithoutGuildsNestedInput = {
    create?: XOR<AutoPublishCreateWithoutGuildsInput, AutoPublishUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: AutoPublishCreateOrConnectWithoutGuildsInput
    upsert?: AutoPublishUpsertWithoutGuildsInput
    disconnect?: AutoPublishWhereInput | boolean
    delete?: AutoPublishWhereInput | boolean
    connect?: AutoPublishWhereUniqueInput
    update?: XOR<XOR<AutoPublishUpdateToOneWithWhereWithoutGuildsInput, AutoPublishUpdateWithoutGuildsInput>, AutoPublishUncheckedUpdateWithoutGuildsInput>
  }

  export type AutoReactsUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<AutoReactsCreateWithoutGuildsInput, AutoReactsUncheckedCreateWithoutGuildsInput> | AutoReactsCreateWithoutGuildsInput[] | AutoReactsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: AutoReactsCreateOrConnectWithoutGuildsInput | AutoReactsCreateOrConnectWithoutGuildsInput[]
    upsert?: AutoReactsUpsertWithWhereUniqueWithoutGuildsInput | AutoReactsUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: AutoReactsCreateManyGuildsInputEnvelope
    set?: AutoReactsWhereUniqueInput | AutoReactsWhereUniqueInput[]
    disconnect?: AutoReactsWhereUniqueInput | AutoReactsWhereUniqueInput[]
    delete?: AutoReactsWhereUniqueInput | AutoReactsWhereUniqueInput[]
    connect?: AutoReactsWhereUniqueInput | AutoReactsWhereUniqueInput[]
    update?: AutoReactsUpdateWithWhereUniqueWithoutGuildsInput | AutoReactsUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: AutoReactsUpdateManyWithWhereWithoutGuildsInput | AutoReactsUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: AutoReactsScalarWhereInput | AutoReactsScalarWhereInput[]
  }

  export type AutoRolesUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<AutoRolesCreateWithoutGuildsInput, AutoRolesUncheckedCreateWithoutGuildsInput> | AutoRolesCreateWithoutGuildsInput[] | AutoRolesUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: AutoRolesCreateOrConnectWithoutGuildsInput | AutoRolesCreateOrConnectWithoutGuildsInput[]
    upsert?: AutoRolesUpsertWithWhereUniqueWithoutGuildsInput | AutoRolesUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: AutoRolesCreateManyGuildsInputEnvelope
    set?: AutoRolesWhereUniqueInput | AutoRolesWhereUniqueInput[]
    disconnect?: AutoRolesWhereUniqueInput | AutoRolesWhereUniqueInput[]
    delete?: AutoRolesWhereUniqueInput | AutoRolesWhereUniqueInput[]
    connect?: AutoRolesWhereUniqueInput | AutoRolesWhereUniqueInput[]
    update?: AutoRolesUpdateWithWhereUniqueWithoutGuildsInput | AutoRolesUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: AutoRolesUpdateManyWithWhereWithoutGuildsInput | AutoRolesUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: AutoRolesScalarWhereInput | AutoRolesScalarWhereInput[]
  }

  export type GuildBansUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<GuildBansCreateWithoutGuildsInput, GuildBansUncheckedCreateWithoutGuildsInput> | GuildBansCreateWithoutGuildsInput[] | GuildBansUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: GuildBansCreateOrConnectWithoutGuildsInput | GuildBansCreateOrConnectWithoutGuildsInput[]
    upsert?: GuildBansUpsertWithWhereUniqueWithoutGuildsInput | GuildBansUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: GuildBansCreateManyGuildsInputEnvelope
    set?: GuildBansWhereUniqueInput | GuildBansWhereUniqueInput[]
    disconnect?: GuildBansWhereUniqueInput | GuildBansWhereUniqueInput[]
    delete?: GuildBansWhereUniqueInput | GuildBansWhereUniqueInput[]
    connect?: GuildBansWhereUniqueInput | GuildBansWhereUniqueInput[]
    update?: GuildBansUpdateWithWhereUniqueWithoutGuildsInput | GuildBansUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: GuildBansUpdateManyWithWhereWithoutGuildsInput | GuildBansUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: GuildBansScalarWhereInput | GuildBansScalarWhereInput[]
  }

  export type ChatModerationsUpdateOneWithoutGuildsNestedInput = {
    create?: XOR<ChatModerationsCreateWithoutGuildsInput, ChatModerationsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: ChatModerationsCreateOrConnectWithoutGuildsInput
    upsert?: ChatModerationsUpsertWithoutGuildsInput
    disconnect?: ChatModerationsWhereInput | boolean
    delete?: ChatModerationsWhereInput | boolean
    connect?: ChatModerationsWhereUniqueInput
    update?: XOR<XOR<ChatModerationsUpdateToOneWithWhereWithoutGuildsInput, ChatModerationsUpdateWithoutGuildsInput>, ChatModerationsUncheckedUpdateWithoutGuildsInput>
  }

  export type ChannelLinksUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<ChannelLinksCreateWithoutGuildsInput, ChannelLinksUncheckedCreateWithoutGuildsInput> | ChannelLinksCreateWithoutGuildsInput[] | ChannelLinksUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: ChannelLinksCreateOrConnectWithoutGuildsInput | ChannelLinksCreateOrConnectWithoutGuildsInput[]
    upsert?: ChannelLinksUpsertWithWhereUniqueWithoutGuildsInput | ChannelLinksUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: ChannelLinksCreateManyGuildsInputEnvelope
    set?: ChannelLinksWhereUniqueInput | ChannelLinksWhereUniqueInput[]
    disconnect?: ChannelLinksWhereUniqueInput | ChannelLinksWhereUniqueInput[]
    delete?: ChannelLinksWhereUniqueInput | ChannelLinksWhereUniqueInput[]
    connect?: ChannelLinksWhereUniqueInput | ChannelLinksWhereUniqueInput[]
    update?: ChannelLinksUpdateWithWhereUniqueWithoutGuildsInput | ChannelLinksUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: ChannelLinksUpdateManyWithWhereWithoutGuildsInput | ChannelLinksUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: ChannelLinksScalarWhereInput | ChannelLinksScalarWhereInput[]
  }

  export type DiscordAddonsUpdateOneWithoutGuildsNestedInput = {
    create?: XOR<DiscordAddonsCreateWithoutGuildsInput, DiscordAddonsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: DiscordAddonsCreateOrConnectWithoutGuildsInput
    upsert?: DiscordAddonsUpsertWithoutGuildsInput
    disconnect?: DiscordAddonsWhereInput | boolean
    delete?: DiscordAddonsWhereInput | boolean
    connect?: DiscordAddonsWhereUniqueInput
    update?: XOR<XOR<DiscordAddonsUpdateToOneWithWhereWithoutGuildsInput, DiscordAddonsUpdateWithoutGuildsInput>, DiscordAddonsUncheckedUpdateWithoutGuildsInput>
  }

  export type GiveawaysUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<GiveawaysCreateWithoutGuildsInput, GiveawaysUncheckedCreateWithoutGuildsInput> | GiveawaysCreateWithoutGuildsInput[] | GiveawaysUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: GiveawaysCreateOrConnectWithoutGuildsInput | GiveawaysCreateOrConnectWithoutGuildsInput[]
    upsert?: GiveawaysUpsertWithWhereUniqueWithoutGuildsInput | GiveawaysUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: GiveawaysCreateManyGuildsInputEnvelope
    set?: GiveawaysWhereUniqueInput | GiveawaysWhereUniqueInput[]
    disconnect?: GiveawaysWhereUniqueInput | GiveawaysWhereUniqueInput[]
    delete?: GiveawaysWhereUniqueInput | GiveawaysWhereUniqueInput[]
    connect?: GiveawaysWhereUniqueInput | GiveawaysWhereUniqueInput[]
    update?: GiveawaysUpdateWithWhereUniqueWithoutGuildsInput | GiveawaysUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: GiveawaysUpdateManyWithWhereWithoutGuildsInput | GiveawaysUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: GiveawaysScalarWhereInput | GiveawaysScalarWhereInput[]
  }

  export type TempVoicesUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<TempVoicesCreateWithoutGuildsInput, TempVoicesUncheckedCreateWithoutGuildsInput> | TempVoicesCreateWithoutGuildsInput[] | TempVoicesUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: TempVoicesCreateOrConnectWithoutGuildsInput | TempVoicesCreateOrConnectWithoutGuildsInput[]
    upsert?: TempVoicesUpsertWithWhereUniqueWithoutGuildsInput | TempVoicesUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: TempVoicesCreateManyGuildsInputEnvelope
    set?: TempVoicesWhereUniqueInput | TempVoicesWhereUniqueInput[]
    disconnect?: TempVoicesWhereUniqueInput | TempVoicesWhereUniqueInput[]
    delete?: TempVoicesWhereUniqueInput | TempVoicesWhereUniqueInput[]
    connect?: TempVoicesWhereUniqueInput | TempVoicesWhereUniqueInput[]
    update?: TempVoicesUpdateWithWhereUniqueWithoutGuildsInput | TempVoicesUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: TempVoicesUpdateManyWithWhereWithoutGuildsInput | TempVoicesUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: TempVoicesScalarWhereInput | TempVoicesScalarWhereInput[]
  }

  export type GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput = {
    create?: XOR<GuildLeaveSetupsCreateWithoutGuildsInput, GuildLeaveSetupsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: GuildLeaveSetupsCreateOrConnectWithoutGuildsInput
    upsert?: GuildLeaveSetupsUpsertWithoutGuildsInput
    disconnect?: GuildLeaveSetupsWhereInput | boolean
    delete?: GuildLeaveSetupsWhereInput | boolean
    connect?: GuildLeaveSetupsWhereUniqueInput
    update?: XOR<XOR<GuildLeaveSetupsUpdateToOneWithWhereWithoutGuildsInput, GuildLeaveSetupsUpdateWithoutGuildsInput>, GuildLeaveSetupsUncheckedUpdateWithoutGuildsInput>
  }

  export type GuildLoggingsUpdateOneWithoutGuildsNestedInput = {
    create?: XOR<GuildLoggingsCreateWithoutGuildsInput, GuildLoggingsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: GuildLoggingsCreateOrConnectWithoutGuildsInput
    upsert?: GuildLoggingsUpsertWithoutGuildsInput
    disconnect?: GuildLoggingsWhereInput | boolean
    delete?: GuildLoggingsWhereInput | boolean
    connect?: GuildLoggingsWhereUniqueInput
    update?: XOR<XOR<GuildLoggingsUpdateToOneWithWhereWithoutGuildsInput, GuildLoggingsUpdateWithoutGuildsInput>, GuildLoggingsUncheckedUpdateWithoutGuildsInput>
  }

  export type MessageTemplatesUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<MessageTemplatesCreateWithoutGuildsInput, MessageTemplatesUncheckedCreateWithoutGuildsInput> | MessageTemplatesCreateWithoutGuildsInput[] | MessageTemplatesUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: MessageTemplatesCreateOrConnectWithoutGuildsInput | MessageTemplatesCreateOrConnectWithoutGuildsInput[]
    upsert?: MessageTemplatesUpsertWithWhereUniqueWithoutGuildsInput | MessageTemplatesUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: MessageTemplatesCreateManyGuildsInputEnvelope
    set?: MessageTemplatesWhereUniqueInput | MessageTemplatesWhereUniqueInput[]
    disconnect?: MessageTemplatesWhereUniqueInput | MessageTemplatesWhereUniqueInput[]
    delete?: MessageTemplatesWhereUniqueInput | MessageTemplatesWhereUniqueInput[]
    connect?: MessageTemplatesWhereUniqueInput | MessageTemplatesWhereUniqueInput[]
    update?: MessageTemplatesUpdateWithWhereUniqueWithoutGuildsInput | MessageTemplatesUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: MessageTemplatesUpdateManyWithWhereWithoutGuildsInput | MessageTemplatesUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: MessageTemplatesScalarWhereInput | MessageTemplatesScalarWhereInput[]
  }

  export type PermissionsUpdateOneWithoutGuildsNestedInput = {
    create?: XOR<PermissionsCreateWithoutGuildsInput, PermissionsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: PermissionsCreateOrConnectWithoutGuildsInput
    upsert?: PermissionsUpsertWithoutGuildsInput
    disconnect?: PermissionsWhereInput | boolean
    delete?: PermissionsWhereInput | boolean
    connect?: PermissionsWhereUniqueInput
    update?: XOR<XOR<PermissionsUpdateToOneWithWhereWithoutGuildsInput, PermissionsUpdateWithoutGuildsInput>, PermissionsUncheckedUpdateWithoutGuildsInput>
  }

  export type ReactionRolesUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<ReactionRolesCreateWithoutGuildsInput, ReactionRolesUncheckedCreateWithoutGuildsInput> | ReactionRolesCreateWithoutGuildsInput[] | ReactionRolesUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: ReactionRolesCreateOrConnectWithoutGuildsInput | ReactionRolesCreateOrConnectWithoutGuildsInput[]
    upsert?: ReactionRolesUpsertWithWhereUniqueWithoutGuildsInput | ReactionRolesUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: ReactionRolesCreateManyGuildsInputEnvelope
    set?: ReactionRolesWhereUniqueInput | ReactionRolesWhereUniqueInput[]
    disconnect?: ReactionRolesWhereUniqueInput | ReactionRolesWhereUniqueInput[]
    delete?: ReactionRolesWhereUniqueInput | ReactionRolesWhereUniqueInput[]
    connect?: ReactionRolesWhereUniqueInput | ReactionRolesWhereUniqueInput[]
    update?: ReactionRolesUpdateWithWhereUniqueWithoutGuildsInput | ReactionRolesUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: ReactionRolesUpdateManyWithWhereWithoutGuildsInput | ReactionRolesUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: ReactionRolesScalarWhereInput | ReactionRolesScalarWhereInput[]
  }

  export type SecuritysUpdateOneWithoutGuildsNestedInput = {
    create?: XOR<SecuritysCreateWithoutGuildsInput, SecuritysUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: SecuritysCreateOrConnectWithoutGuildsInput
    upsert?: SecuritysUpsertWithoutGuildsInput
    disconnect?: SecuritysWhereInput | boolean
    delete?: SecuritysWhereInput | boolean
    connect?: SecuritysWhereUniqueInput
    update?: XOR<XOR<SecuritysUpdateToOneWithWhereWithoutGuildsInput, SecuritysUpdateWithoutGuildsInput>, SecuritysUncheckedUpdateWithoutGuildsInput>
  }

  export type SpotifyNotificationsUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<SpotifyNotificationsCreateWithoutGuildsInput, SpotifyNotificationsUncheckedCreateWithoutGuildsInput> | SpotifyNotificationsCreateWithoutGuildsInput[] | SpotifyNotificationsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: SpotifyNotificationsCreateOrConnectWithoutGuildsInput | SpotifyNotificationsCreateOrConnectWithoutGuildsInput[]
    upsert?: SpotifyNotificationsUpsertWithWhereUniqueWithoutGuildsInput | SpotifyNotificationsUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: SpotifyNotificationsCreateManyGuildsInputEnvelope
    set?: SpotifyNotificationsWhereUniqueInput | SpotifyNotificationsWhereUniqueInput[]
    disconnect?: SpotifyNotificationsWhereUniqueInput | SpotifyNotificationsWhereUniqueInput[]
    delete?: SpotifyNotificationsWhereUniqueInput | SpotifyNotificationsWhereUniqueInput[]
    connect?: SpotifyNotificationsWhereUniqueInput | SpotifyNotificationsWhereUniqueInput[]
    update?: SpotifyNotificationsUpdateWithWhereUniqueWithoutGuildsInput | SpotifyNotificationsUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: SpotifyNotificationsUpdateManyWithWhereWithoutGuildsInput | SpotifyNotificationsUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: SpotifyNotificationsScalarWhereInput | SpotifyNotificationsScalarWhereInput[]
  }

  export type TagsUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<TagsCreateWithoutGuildsInput, TagsUncheckedCreateWithoutGuildsInput> | TagsCreateWithoutGuildsInput[] | TagsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutGuildsInput | TagsCreateOrConnectWithoutGuildsInput[]
    upsert?: TagsUpsertWithWhereUniqueWithoutGuildsInput | TagsUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: TagsCreateManyGuildsInputEnvelope
    set?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    disconnect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    delete?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    update?: TagsUpdateWithWhereUniqueWithoutGuildsInput | TagsUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: TagsUpdateManyWithWhereWithoutGuildsInput | TagsUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: TagsScalarWhereInput | TagsScalarWhereInput[]
  }

  export type TicketSetupsUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<TicketSetupsCreateWithoutGuildsInput, TicketSetupsUncheckedCreateWithoutGuildsInput> | TicketSetupsCreateWithoutGuildsInput[] | TicketSetupsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: TicketSetupsCreateOrConnectWithoutGuildsInput | TicketSetupsCreateOrConnectWithoutGuildsInput[]
    upsert?: TicketSetupsUpsertWithWhereUniqueWithoutGuildsInput | TicketSetupsUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: TicketSetupsCreateManyGuildsInputEnvelope
    set?: TicketSetupsWhereUniqueInput | TicketSetupsWhereUniqueInput[]
    disconnect?: TicketSetupsWhereUniqueInput | TicketSetupsWhereUniqueInput[]
    delete?: TicketSetupsWhereUniqueInput | TicketSetupsWhereUniqueInput[]
    connect?: TicketSetupsWhereUniqueInput | TicketSetupsWhereUniqueInput[]
    update?: TicketSetupsUpdateWithWhereUniqueWithoutGuildsInput | TicketSetupsUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: TicketSetupsUpdateManyWithWhereWithoutGuildsInput | TicketSetupsUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: TicketSetupsScalarWhereInput | TicketSetupsScalarWhereInput[]
  }

  export type GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput = {
    create?: XOR<GuildFeatureTogglesCreateWithoutGuildsInput, GuildFeatureTogglesUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: GuildFeatureTogglesCreateOrConnectWithoutGuildsInput
    upsert?: GuildFeatureTogglesUpsertWithoutGuildsInput
    disconnect?: GuildFeatureTogglesWhereInput | boolean
    delete?: GuildFeatureTogglesWhereInput | boolean
    connect?: GuildFeatureTogglesWhereUniqueInput
    update?: XOR<XOR<GuildFeatureTogglesUpdateToOneWithWhereWithoutGuildsInput, GuildFeatureTogglesUpdateWithoutGuildsInput>, GuildFeatureTogglesUncheckedUpdateWithoutGuildsInput>
  }

  export type TwitchNotificationsUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<TwitchNotificationsCreateWithoutGuildsInput, TwitchNotificationsUncheckedCreateWithoutGuildsInput> | TwitchNotificationsCreateWithoutGuildsInput[] | TwitchNotificationsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: TwitchNotificationsCreateOrConnectWithoutGuildsInput | TwitchNotificationsCreateOrConnectWithoutGuildsInput[]
    upsert?: TwitchNotificationsUpsertWithWhereUniqueWithoutGuildsInput | TwitchNotificationsUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: TwitchNotificationsCreateManyGuildsInputEnvelope
    set?: TwitchNotificationsWhereUniqueInput | TwitchNotificationsWhereUniqueInput[]
    disconnect?: TwitchNotificationsWhereUniqueInput | TwitchNotificationsWhereUniqueInput[]
    delete?: TwitchNotificationsWhereUniqueInput | TwitchNotificationsWhereUniqueInput[]
    connect?: TwitchNotificationsWhereUniqueInput | TwitchNotificationsWhereUniqueInput[]
    update?: TwitchNotificationsUpdateWithWhereUniqueWithoutGuildsInput | TwitchNotificationsUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: TwitchNotificationsUpdateManyWithWhereWithoutGuildsInput | TwitchNotificationsUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: TwitchNotificationsScalarWhereInput | TwitchNotificationsScalarWhereInput[]
  }

  export type GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput = {
    create?: XOR<GuildWelcomeSetupsCreateWithoutGuildsInput, GuildWelcomeSetupsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: GuildWelcomeSetupsCreateOrConnectWithoutGuildsInput
    upsert?: GuildWelcomeSetupsUpsertWithoutGuildsInput
    disconnect?: GuildWelcomeSetupsWhereInput | boolean
    delete?: GuildWelcomeSetupsWhereInput | boolean
    connect?: GuildWelcomeSetupsWhereUniqueInput
    update?: XOR<XOR<GuildWelcomeSetupsUpdateToOneWithWhereWithoutGuildsInput, GuildWelcomeSetupsUpdateWithoutGuildsInput>, GuildWelcomeSetupsUncheckedUpdateWithoutGuildsInput>
  }

  export type YoutubeNotificationsUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<YoutubeNotificationsCreateWithoutGuildsInput, YoutubeNotificationsUncheckedCreateWithoutGuildsInput> | YoutubeNotificationsCreateWithoutGuildsInput[] | YoutubeNotificationsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: YoutubeNotificationsCreateOrConnectWithoutGuildsInput | YoutubeNotificationsCreateOrConnectWithoutGuildsInput[]
    upsert?: YoutubeNotificationsUpsertWithWhereUniqueWithoutGuildsInput | YoutubeNotificationsUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: YoutubeNotificationsCreateManyGuildsInputEnvelope
    set?: YoutubeNotificationsWhereUniqueInput | YoutubeNotificationsWhereUniqueInput[]
    disconnect?: YoutubeNotificationsWhereUniqueInput | YoutubeNotificationsWhereUniqueInput[]
    delete?: YoutubeNotificationsWhereUniqueInput | YoutubeNotificationsWhereUniqueInput[]
    connect?: YoutubeNotificationsWhereUniqueInput | YoutubeNotificationsWhereUniqueInput[]
    update?: YoutubeNotificationsUpdateWithWhereUniqueWithoutGuildsInput | YoutubeNotificationsUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: YoutubeNotificationsUpdateManyWithWhereWithoutGuildsInput | YoutubeNotificationsUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: YoutubeNotificationsScalarWhereInput | YoutubeNotificationsScalarWhereInput[]
  }

  export type GuildLoggersUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<GuildLoggersCreateWithoutGuildsInput, GuildLoggersUncheckedCreateWithoutGuildsInput> | GuildLoggersCreateWithoutGuildsInput[] | GuildLoggersUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: GuildLoggersCreateOrConnectWithoutGuildsInput | GuildLoggersCreateOrConnectWithoutGuildsInput[]
    upsert?: GuildLoggersUpsertWithWhereUniqueWithoutGuildsInput | GuildLoggersUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: GuildLoggersCreateManyGuildsInputEnvelope
    set?: GuildLoggersWhereUniqueInput | GuildLoggersWhereUniqueInput[]
    disconnect?: GuildLoggersWhereUniqueInput | GuildLoggersWhereUniqueInput[]
    delete?: GuildLoggersWhereUniqueInput | GuildLoggersWhereUniqueInput[]
    connect?: GuildLoggersWhereUniqueInput | GuildLoggersWhereUniqueInput[]
    update?: GuildLoggersUpdateWithWhereUniqueWithoutGuildsInput | GuildLoggersUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: GuildLoggersUpdateManyWithWhereWithoutGuildsInput | GuildLoggersUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: GuildLoggersScalarWhereInput | GuildLoggersScalarWhereInput[]
  }

  export type AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<AutoDeletesCreateWithoutGuildsInput, AutoDeletesUncheckedCreateWithoutGuildsInput> | AutoDeletesCreateWithoutGuildsInput[] | AutoDeletesUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: AutoDeletesCreateOrConnectWithoutGuildsInput | AutoDeletesCreateOrConnectWithoutGuildsInput[]
    upsert?: AutoDeletesUpsertWithWhereUniqueWithoutGuildsInput | AutoDeletesUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: AutoDeletesCreateManyGuildsInputEnvelope
    set?: AutoDeletesWhereUniqueInput | AutoDeletesWhereUniqueInput[]
    disconnect?: AutoDeletesWhereUniqueInput | AutoDeletesWhereUniqueInput[]
    delete?: AutoDeletesWhereUniqueInput | AutoDeletesWhereUniqueInput[]
    connect?: AutoDeletesWhereUniqueInput | AutoDeletesWhereUniqueInput[]
    update?: AutoDeletesUpdateWithWhereUniqueWithoutGuildsInput | AutoDeletesUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: AutoDeletesUpdateManyWithWhereWithoutGuildsInput | AutoDeletesUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: AutoDeletesScalarWhereInput | AutoDeletesScalarWhereInput[]
  }

  export type AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput = {
    create?: XOR<AutoPublishCreateWithoutGuildsInput, AutoPublishUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: AutoPublishCreateOrConnectWithoutGuildsInput
    upsert?: AutoPublishUpsertWithoutGuildsInput
    disconnect?: AutoPublishWhereInput | boolean
    delete?: AutoPublishWhereInput | boolean
    connect?: AutoPublishWhereUniqueInput
    update?: XOR<XOR<AutoPublishUpdateToOneWithWhereWithoutGuildsInput, AutoPublishUpdateWithoutGuildsInput>, AutoPublishUncheckedUpdateWithoutGuildsInput>
  }

  export type AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<AutoReactsCreateWithoutGuildsInput, AutoReactsUncheckedCreateWithoutGuildsInput> | AutoReactsCreateWithoutGuildsInput[] | AutoReactsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: AutoReactsCreateOrConnectWithoutGuildsInput | AutoReactsCreateOrConnectWithoutGuildsInput[]
    upsert?: AutoReactsUpsertWithWhereUniqueWithoutGuildsInput | AutoReactsUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: AutoReactsCreateManyGuildsInputEnvelope
    set?: AutoReactsWhereUniqueInput | AutoReactsWhereUniqueInput[]
    disconnect?: AutoReactsWhereUniqueInput | AutoReactsWhereUniqueInput[]
    delete?: AutoReactsWhereUniqueInput | AutoReactsWhereUniqueInput[]
    connect?: AutoReactsWhereUniqueInput | AutoReactsWhereUniqueInput[]
    update?: AutoReactsUpdateWithWhereUniqueWithoutGuildsInput | AutoReactsUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: AutoReactsUpdateManyWithWhereWithoutGuildsInput | AutoReactsUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: AutoReactsScalarWhereInput | AutoReactsScalarWhereInput[]
  }

  export type AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<AutoRolesCreateWithoutGuildsInput, AutoRolesUncheckedCreateWithoutGuildsInput> | AutoRolesCreateWithoutGuildsInput[] | AutoRolesUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: AutoRolesCreateOrConnectWithoutGuildsInput | AutoRolesCreateOrConnectWithoutGuildsInput[]
    upsert?: AutoRolesUpsertWithWhereUniqueWithoutGuildsInput | AutoRolesUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: AutoRolesCreateManyGuildsInputEnvelope
    set?: AutoRolesWhereUniqueInput | AutoRolesWhereUniqueInput[]
    disconnect?: AutoRolesWhereUniqueInput | AutoRolesWhereUniqueInput[]
    delete?: AutoRolesWhereUniqueInput | AutoRolesWhereUniqueInput[]
    connect?: AutoRolesWhereUniqueInput | AutoRolesWhereUniqueInput[]
    update?: AutoRolesUpdateWithWhereUniqueWithoutGuildsInput | AutoRolesUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: AutoRolesUpdateManyWithWhereWithoutGuildsInput | AutoRolesUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: AutoRolesScalarWhereInput | AutoRolesScalarWhereInput[]
  }

  export type GuildBansUncheckedUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<GuildBansCreateWithoutGuildsInput, GuildBansUncheckedCreateWithoutGuildsInput> | GuildBansCreateWithoutGuildsInput[] | GuildBansUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: GuildBansCreateOrConnectWithoutGuildsInput | GuildBansCreateOrConnectWithoutGuildsInput[]
    upsert?: GuildBansUpsertWithWhereUniqueWithoutGuildsInput | GuildBansUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: GuildBansCreateManyGuildsInputEnvelope
    set?: GuildBansWhereUniqueInput | GuildBansWhereUniqueInput[]
    disconnect?: GuildBansWhereUniqueInput | GuildBansWhereUniqueInput[]
    delete?: GuildBansWhereUniqueInput | GuildBansWhereUniqueInput[]
    connect?: GuildBansWhereUniqueInput | GuildBansWhereUniqueInput[]
    update?: GuildBansUpdateWithWhereUniqueWithoutGuildsInput | GuildBansUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: GuildBansUpdateManyWithWhereWithoutGuildsInput | GuildBansUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: GuildBansScalarWhereInput | GuildBansScalarWhereInput[]
  }

  export type ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput = {
    create?: XOR<ChatModerationsCreateWithoutGuildsInput, ChatModerationsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: ChatModerationsCreateOrConnectWithoutGuildsInput
    upsert?: ChatModerationsUpsertWithoutGuildsInput
    disconnect?: ChatModerationsWhereInput | boolean
    delete?: ChatModerationsWhereInput | boolean
    connect?: ChatModerationsWhereUniqueInput
    update?: XOR<XOR<ChatModerationsUpdateToOneWithWhereWithoutGuildsInput, ChatModerationsUpdateWithoutGuildsInput>, ChatModerationsUncheckedUpdateWithoutGuildsInput>
  }

  export type ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<ChannelLinksCreateWithoutGuildsInput, ChannelLinksUncheckedCreateWithoutGuildsInput> | ChannelLinksCreateWithoutGuildsInput[] | ChannelLinksUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: ChannelLinksCreateOrConnectWithoutGuildsInput | ChannelLinksCreateOrConnectWithoutGuildsInput[]
    upsert?: ChannelLinksUpsertWithWhereUniqueWithoutGuildsInput | ChannelLinksUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: ChannelLinksCreateManyGuildsInputEnvelope
    set?: ChannelLinksWhereUniqueInput | ChannelLinksWhereUniqueInput[]
    disconnect?: ChannelLinksWhereUniqueInput | ChannelLinksWhereUniqueInput[]
    delete?: ChannelLinksWhereUniqueInput | ChannelLinksWhereUniqueInput[]
    connect?: ChannelLinksWhereUniqueInput | ChannelLinksWhereUniqueInput[]
    update?: ChannelLinksUpdateWithWhereUniqueWithoutGuildsInput | ChannelLinksUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: ChannelLinksUpdateManyWithWhereWithoutGuildsInput | ChannelLinksUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: ChannelLinksScalarWhereInput | ChannelLinksScalarWhereInput[]
  }

  export type DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput = {
    create?: XOR<DiscordAddonsCreateWithoutGuildsInput, DiscordAddonsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: DiscordAddonsCreateOrConnectWithoutGuildsInput
    upsert?: DiscordAddonsUpsertWithoutGuildsInput
    disconnect?: DiscordAddonsWhereInput | boolean
    delete?: DiscordAddonsWhereInput | boolean
    connect?: DiscordAddonsWhereUniqueInput
    update?: XOR<XOR<DiscordAddonsUpdateToOneWithWhereWithoutGuildsInput, DiscordAddonsUpdateWithoutGuildsInput>, DiscordAddonsUncheckedUpdateWithoutGuildsInput>
  }

  export type GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<GiveawaysCreateWithoutGuildsInput, GiveawaysUncheckedCreateWithoutGuildsInput> | GiveawaysCreateWithoutGuildsInput[] | GiveawaysUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: GiveawaysCreateOrConnectWithoutGuildsInput | GiveawaysCreateOrConnectWithoutGuildsInput[]
    upsert?: GiveawaysUpsertWithWhereUniqueWithoutGuildsInput | GiveawaysUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: GiveawaysCreateManyGuildsInputEnvelope
    set?: GiveawaysWhereUniqueInput | GiveawaysWhereUniqueInput[]
    disconnect?: GiveawaysWhereUniqueInput | GiveawaysWhereUniqueInput[]
    delete?: GiveawaysWhereUniqueInput | GiveawaysWhereUniqueInput[]
    connect?: GiveawaysWhereUniqueInput | GiveawaysWhereUniqueInput[]
    update?: GiveawaysUpdateWithWhereUniqueWithoutGuildsInput | GiveawaysUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: GiveawaysUpdateManyWithWhereWithoutGuildsInput | GiveawaysUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: GiveawaysScalarWhereInput | GiveawaysScalarWhereInput[]
  }

  export type TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<TempVoicesCreateWithoutGuildsInput, TempVoicesUncheckedCreateWithoutGuildsInput> | TempVoicesCreateWithoutGuildsInput[] | TempVoicesUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: TempVoicesCreateOrConnectWithoutGuildsInput | TempVoicesCreateOrConnectWithoutGuildsInput[]
    upsert?: TempVoicesUpsertWithWhereUniqueWithoutGuildsInput | TempVoicesUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: TempVoicesCreateManyGuildsInputEnvelope
    set?: TempVoicesWhereUniqueInput | TempVoicesWhereUniqueInput[]
    disconnect?: TempVoicesWhereUniqueInput | TempVoicesWhereUniqueInput[]
    delete?: TempVoicesWhereUniqueInput | TempVoicesWhereUniqueInput[]
    connect?: TempVoicesWhereUniqueInput | TempVoicesWhereUniqueInput[]
    update?: TempVoicesUpdateWithWhereUniqueWithoutGuildsInput | TempVoicesUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: TempVoicesUpdateManyWithWhereWithoutGuildsInput | TempVoicesUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: TempVoicesScalarWhereInput | TempVoicesScalarWhereInput[]
  }

  export type GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput = {
    create?: XOR<GuildLeaveSetupsCreateWithoutGuildsInput, GuildLeaveSetupsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: GuildLeaveSetupsCreateOrConnectWithoutGuildsInput
    upsert?: GuildLeaveSetupsUpsertWithoutGuildsInput
    disconnect?: GuildLeaveSetupsWhereInput | boolean
    delete?: GuildLeaveSetupsWhereInput | boolean
    connect?: GuildLeaveSetupsWhereUniqueInput
    update?: XOR<XOR<GuildLeaveSetupsUpdateToOneWithWhereWithoutGuildsInput, GuildLeaveSetupsUpdateWithoutGuildsInput>, GuildLeaveSetupsUncheckedUpdateWithoutGuildsInput>
  }

  export type GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput = {
    create?: XOR<GuildLoggingsCreateWithoutGuildsInput, GuildLoggingsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: GuildLoggingsCreateOrConnectWithoutGuildsInput
    upsert?: GuildLoggingsUpsertWithoutGuildsInput
    disconnect?: GuildLoggingsWhereInput | boolean
    delete?: GuildLoggingsWhereInput | boolean
    connect?: GuildLoggingsWhereUniqueInput
    update?: XOR<XOR<GuildLoggingsUpdateToOneWithWhereWithoutGuildsInput, GuildLoggingsUpdateWithoutGuildsInput>, GuildLoggingsUncheckedUpdateWithoutGuildsInput>
  }

  export type MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<MessageTemplatesCreateWithoutGuildsInput, MessageTemplatesUncheckedCreateWithoutGuildsInput> | MessageTemplatesCreateWithoutGuildsInput[] | MessageTemplatesUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: MessageTemplatesCreateOrConnectWithoutGuildsInput | MessageTemplatesCreateOrConnectWithoutGuildsInput[]
    upsert?: MessageTemplatesUpsertWithWhereUniqueWithoutGuildsInput | MessageTemplatesUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: MessageTemplatesCreateManyGuildsInputEnvelope
    set?: MessageTemplatesWhereUniqueInput | MessageTemplatesWhereUniqueInput[]
    disconnect?: MessageTemplatesWhereUniqueInput | MessageTemplatesWhereUniqueInput[]
    delete?: MessageTemplatesWhereUniqueInput | MessageTemplatesWhereUniqueInput[]
    connect?: MessageTemplatesWhereUniqueInput | MessageTemplatesWhereUniqueInput[]
    update?: MessageTemplatesUpdateWithWhereUniqueWithoutGuildsInput | MessageTemplatesUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: MessageTemplatesUpdateManyWithWhereWithoutGuildsInput | MessageTemplatesUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: MessageTemplatesScalarWhereInput | MessageTemplatesScalarWhereInput[]
  }

  export type PermissionsUncheckedUpdateOneWithoutGuildsNestedInput = {
    create?: XOR<PermissionsCreateWithoutGuildsInput, PermissionsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: PermissionsCreateOrConnectWithoutGuildsInput
    upsert?: PermissionsUpsertWithoutGuildsInput
    disconnect?: PermissionsWhereInput | boolean
    delete?: PermissionsWhereInput | boolean
    connect?: PermissionsWhereUniqueInput
    update?: XOR<XOR<PermissionsUpdateToOneWithWhereWithoutGuildsInput, PermissionsUpdateWithoutGuildsInput>, PermissionsUncheckedUpdateWithoutGuildsInput>
  }

  export type ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<ReactionRolesCreateWithoutGuildsInput, ReactionRolesUncheckedCreateWithoutGuildsInput> | ReactionRolesCreateWithoutGuildsInput[] | ReactionRolesUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: ReactionRolesCreateOrConnectWithoutGuildsInput | ReactionRolesCreateOrConnectWithoutGuildsInput[]
    upsert?: ReactionRolesUpsertWithWhereUniqueWithoutGuildsInput | ReactionRolesUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: ReactionRolesCreateManyGuildsInputEnvelope
    set?: ReactionRolesWhereUniqueInput | ReactionRolesWhereUniqueInput[]
    disconnect?: ReactionRolesWhereUniqueInput | ReactionRolesWhereUniqueInput[]
    delete?: ReactionRolesWhereUniqueInput | ReactionRolesWhereUniqueInput[]
    connect?: ReactionRolesWhereUniqueInput | ReactionRolesWhereUniqueInput[]
    update?: ReactionRolesUpdateWithWhereUniqueWithoutGuildsInput | ReactionRolesUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: ReactionRolesUpdateManyWithWhereWithoutGuildsInput | ReactionRolesUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: ReactionRolesScalarWhereInput | ReactionRolesScalarWhereInput[]
  }

  export type SecuritysUncheckedUpdateOneWithoutGuildsNestedInput = {
    create?: XOR<SecuritysCreateWithoutGuildsInput, SecuritysUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: SecuritysCreateOrConnectWithoutGuildsInput
    upsert?: SecuritysUpsertWithoutGuildsInput
    disconnect?: SecuritysWhereInput | boolean
    delete?: SecuritysWhereInput | boolean
    connect?: SecuritysWhereUniqueInput
    update?: XOR<XOR<SecuritysUpdateToOneWithWhereWithoutGuildsInput, SecuritysUpdateWithoutGuildsInput>, SecuritysUncheckedUpdateWithoutGuildsInput>
  }

  export type SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<SpotifyNotificationsCreateWithoutGuildsInput, SpotifyNotificationsUncheckedCreateWithoutGuildsInput> | SpotifyNotificationsCreateWithoutGuildsInput[] | SpotifyNotificationsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: SpotifyNotificationsCreateOrConnectWithoutGuildsInput | SpotifyNotificationsCreateOrConnectWithoutGuildsInput[]
    upsert?: SpotifyNotificationsUpsertWithWhereUniqueWithoutGuildsInput | SpotifyNotificationsUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: SpotifyNotificationsCreateManyGuildsInputEnvelope
    set?: SpotifyNotificationsWhereUniqueInput | SpotifyNotificationsWhereUniqueInput[]
    disconnect?: SpotifyNotificationsWhereUniqueInput | SpotifyNotificationsWhereUniqueInput[]
    delete?: SpotifyNotificationsWhereUniqueInput | SpotifyNotificationsWhereUniqueInput[]
    connect?: SpotifyNotificationsWhereUniqueInput | SpotifyNotificationsWhereUniqueInput[]
    update?: SpotifyNotificationsUpdateWithWhereUniqueWithoutGuildsInput | SpotifyNotificationsUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: SpotifyNotificationsUpdateManyWithWhereWithoutGuildsInput | SpotifyNotificationsUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: SpotifyNotificationsScalarWhereInput | SpotifyNotificationsScalarWhereInput[]
  }

  export type TagsUncheckedUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<TagsCreateWithoutGuildsInput, TagsUncheckedCreateWithoutGuildsInput> | TagsCreateWithoutGuildsInput[] | TagsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutGuildsInput | TagsCreateOrConnectWithoutGuildsInput[]
    upsert?: TagsUpsertWithWhereUniqueWithoutGuildsInput | TagsUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: TagsCreateManyGuildsInputEnvelope
    set?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    disconnect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    delete?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    update?: TagsUpdateWithWhereUniqueWithoutGuildsInput | TagsUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: TagsUpdateManyWithWhereWithoutGuildsInput | TagsUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: TagsScalarWhereInput | TagsScalarWhereInput[]
  }

  export type TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<TicketSetupsCreateWithoutGuildsInput, TicketSetupsUncheckedCreateWithoutGuildsInput> | TicketSetupsCreateWithoutGuildsInput[] | TicketSetupsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: TicketSetupsCreateOrConnectWithoutGuildsInput | TicketSetupsCreateOrConnectWithoutGuildsInput[]
    upsert?: TicketSetupsUpsertWithWhereUniqueWithoutGuildsInput | TicketSetupsUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: TicketSetupsCreateManyGuildsInputEnvelope
    set?: TicketSetupsWhereUniqueInput | TicketSetupsWhereUniqueInput[]
    disconnect?: TicketSetupsWhereUniqueInput | TicketSetupsWhereUniqueInput[]
    delete?: TicketSetupsWhereUniqueInput | TicketSetupsWhereUniqueInput[]
    connect?: TicketSetupsWhereUniqueInput | TicketSetupsWhereUniqueInput[]
    update?: TicketSetupsUpdateWithWhereUniqueWithoutGuildsInput | TicketSetupsUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: TicketSetupsUpdateManyWithWhereWithoutGuildsInput | TicketSetupsUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: TicketSetupsScalarWhereInput | TicketSetupsScalarWhereInput[]
  }

  export type GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput = {
    create?: XOR<GuildFeatureTogglesCreateWithoutGuildsInput, GuildFeatureTogglesUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: GuildFeatureTogglesCreateOrConnectWithoutGuildsInput
    upsert?: GuildFeatureTogglesUpsertWithoutGuildsInput
    disconnect?: GuildFeatureTogglesWhereInput | boolean
    delete?: GuildFeatureTogglesWhereInput | boolean
    connect?: GuildFeatureTogglesWhereUniqueInput
    update?: XOR<XOR<GuildFeatureTogglesUpdateToOneWithWhereWithoutGuildsInput, GuildFeatureTogglesUpdateWithoutGuildsInput>, GuildFeatureTogglesUncheckedUpdateWithoutGuildsInput>
  }

  export type TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<TwitchNotificationsCreateWithoutGuildsInput, TwitchNotificationsUncheckedCreateWithoutGuildsInput> | TwitchNotificationsCreateWithoutGuildsInput[] | TwitchNotificationsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: TwitchNotificationsCreateOrConnectWithoutGuildsInput | TwitchNotificationsCreateOrConnectWithoutGuildsInput[]
    upsert?: TwitchNotificationsUpsertWithWhereUniqueWithoutGuildsInput | TwitchNotificationsUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: TwitchNotificationsCreateManyGuildsInputEnvelope
    set?: TwitchNotificationsWhereUniqueInput | TwitchNotificationsWhereUniqueInput[]
    disconnect?: TwitchNotificationsWhereUniqueInput | TwitchNotificationsWhereUniqueInput[]
    delete?: TwitchNotificationsWhereUniqueInput | TwitchNotificationsWhereUniqueInput[]
    connect?: TwitchNotificationsWhereUniqueInput | TwitchNotificationsWhereUniqueInput[]
    update?: TwitchNotificationsUpdateWithWhereUniqueWithoutGuildsInput | TwitchNotificationsUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: TwitchNotificationsUpdateManyWithWhereWithoutGuildsInput | TwitchNotificationsUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: TwitchNotificationsScalarWhereInput | TwitchNotificationsScalarWhereInput[]
  }

  export type GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput = {
    create?: XOR<GuildWelcomeSetupsCreateWithoutGuildsInput, GuildWelcomeSetupsUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: GuildWelcomeSetupsCreateOrConnectWithoutGuildsInput
    upsert?: GuildWelcomeSetupsUpsertWithoutGuildsInput
    disconnect?: GuildWelcomeSetupsWhereInput | boolean
    delete?: GuildWelcomeSetupsWhereInput | boolean
    connect?: GuildWelcomeSetupsWhereUniqueInput
    update?: XOR<XOR<GuildWelcomeSetupsUpdateToOneWithWhereWithoutGuildsInput, GuildWelcomeSetupsUpdateWithoutGuildsInput>, GuildWelcomeSetupsUncheckedUpdateWithoutGuildsInput>
  }

  export type YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<YoutubeNotificationsCreateWithoutGuildsInput, YoutubeNotificationsUncheckedCreateWithoutGuildsInput> | YoutubeNotificationsCreateWithoutGuildsInput[] | YoutubeNotificationsUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: YoutubeNotificationsCreateOrConnectWithoutGuildsInput | YoutubeNotificationsCreateOrConnectWithoutGuildsInput[]
    upsert?: YoutubeNotificationsUpsertWithWhereUniqueWithoutGuildsInput | YoutubeNotificationsUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: YoutubeNotificationsCreateManyGuildsInputEnvelope
    set?: YoutubeNotificationsWhereUniqueInput | YoutubeNotificationsWhereUniqueInput[]
    disconnect?: YoutubeNotificationsWhereUniqueInput | YoutubeNotificationsWhereUniqueInput[]
    delete?: YoutubeNotificationsWhereUniqueInput | YoutubeNotificationsWhereUniqueInput[]
    connect?: YoutubeNotificationsWhereUniqueInput | YoutubeNotificationsWhereUniqueInput[]
    update?: YoutubeNotificationsUpdateWithWhereUniqueWithoutGuildsInput | YoutubeNotificationsUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: YoutubeNotificationsUpdateManyWithWhereWithoutGuildsInput | YoutubeNotificationsUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: YoutubeNotificationsScalarWhereInput | YoutubeNotificationsScalarWhereInput[]
  }

  export type GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<GuildLoggersCreateWithoutGuildsInput, GuildLoggersUncheckedCreateWithoutGuildsInput> | GuildLoggersCreateWithoutGuildsInput[] | GuildLoggersUncheckedCreateWithoutGuildsInput[]
    connectOrCreate?: GuildLoggersCreateOrConnectWithoutGuildsInput | GuildLoggersCreateOrConnectWithoutGuildsInput[]
    upsert?: GuildLoggersUpsertWithWhereUniqueWithoutGuildsInput | GuildLoggersUpsertWithWhereUniqueWithoutGuildsInput[]
    createMany?: GuildLoggersCreateManyGuildsInputEnvelope
    set?: GuildLoggersWhereUniqueInput | GuildLoggersWhereUniqueInput[]
    disconnect?: GuildLoggersWhereUniqueInput | GuildLoggersWhereUniqueInput[]
    delete?: GuildLoggersWhereUniqueInput | GuildLoggersWhereUniqueInput[]
    connect?: GuildLoggersWhereUniqueInput | GuildLoggersWhereUniqueInput[]
    update?: GuildLoggersUpdateWithWhereUniqueWithoutGuildsInput | GuildLoggersUpdateWithWhereUniqueWithoutGuildsInput[]
    updateMany?: GuildLoggersUpdateManyWithWhereWithoutGuildsInput | GuildLoggersUpdateManyWithWhereWithoutGuildsInput[]
    deleteMany?: GuildLoggersScalarWhereInput | GuildLoggersScalarWhereInput[]
  }

  export type AutoDeletesCreateWhitelistedMessagesInput = {
    set: string[]
  }

  export type AutoDeletesCreateWhitelistedRolesInput = {
    set: string[]
  }

  export type AutoDeletesCreateWhitelistedUsersInput = {
    set: string[]
  }

  export type GuildsCreateNestedOneWithoutAutoAutoDeletesInput = {
    create?: XOR<GuildsCreateWithoutAutoAutoDeletesInput, GuildsUncheckedCreateWithoutAutoAutoDeletesInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutAutoAutoDeletesInput
    connect?: GuildsWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
    unset?: boolean
  }

  export type AutoDeletesUpdateWhitelistedMessagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AutoDeletesUpdateWhitelistedRolesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AutoDeletesUpdateWhitelistedUsersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GuildsUpdateOneRequiredWithoutAutoAutoDeletesNestedInput = {
    create?: XOR<GuildsCreateWithoutAutoAutoDeletesInput, GuildsUncheckedCreateWithoutAutoAutoDeletesInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutAutoAutoDeletesInput
    upsert?: GuildsUpsertWithoutAutoAutoDeletesInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutAutoAutoDeletesInput, GuildsUpdateWithoutAutoAutoDeletesInput>, GuildsUncheckedUpdateWithoutAutoAutoDeletesInput>
  }

  export type AutoPublishCreateChannelsInput = {
    set: string[]
  }

  export type GuildsCreateNestedOneWithoutAutoPublishInput = {
    create?: XOR<GuildsCreateWithoutAutoPublishInput, GuildsUncheckedCreateWithoutAutoPublishInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutAutoPublishInput
    connect?: GuildsWhereUniqueInput
  }

  export type AutoPublishUpdateChannelsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GuildsUpdateOneRequiredWithoutAutoPublishNestedInput = {
    create?: XOR<GuildsCreateWithoutAutoPublishInput, GuildsUncheckedCreateWithoutAutoPublishInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutAutoPublishInput
    upsert?: GuildsUpsertWithoutAutoPublishInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutAutoPublishInput, GuildsUpdateWithoutAutoPublishInput>, GuildsUncheckedUpdateWithoutAutoPublishInput>
  }

  export type GuildsCreateNestedOneWithoutAutoReactsInput = {
    create?: XOR<GuildsCreateWithoutAutoReactsInput, GuildsUncheckedCreateWithoutAutoReactsInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutAutoReactsInput
    connect?: GuildsWhereUniqueInput
  }

  export type GuildsUpdateOneRequiredWithoutAutoReactsNestedInput = {
    create?: XOR<GuildsCreateWithoutAutoReactsInput, GuildsUncheckedCreateWithoutAutoReactsInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutAutoReactsInput
    upsert?: GuildsUpsertWithoutAutoReactsInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutAutoReactsInput, GuildsUpdateWithoutAutoReactsInput>, GuildsUncheckedUpdateWithoutAutoReactsInput>
  }

  export type GuildsCreateNestedOneWithoutAutoRolesInput = {
    create?: XOR<GuildsCreateWithoutAutoRolesInput, GuildsUncheckedCreateWithoutAutoRolesInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutAutoRolesInput
    connect?: GuildsWhereUniqueInput
  }

  export type GuildsUpdateOneRequiredWithoutAutoRolesNestedInput = {
    create?: XOR<GuildsCreateWithoutAutoRolesInput, GuildsUncheckedCreateWithoutAutoRolesInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutAutoRolesInput
    upsert?: GuildsUpsertWithoutAutoRolesInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutAutoRolesInput, GuildsUpdateWithoutAutoRolesInput>, GuildsUncheckedUpdateWithoutAutoRolesInput>
  }

  export type GuildBansCreateUserIdInput = {
    set: string[]
  }

  export type GuildsCreateNestedOneWithoutGuildBansInput = {
    create?: XOR<GuildsCreateWithoutGuildBansInput, GuildsUncheckedCreateWithoutGuildBansInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutGuildBansInput
    connect?: GuildsWhereUniqueInput
  }

  export type GuildBansUpdateUserIdInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type GuildsUpdateOneRequiredWithoutGuildBansNestedInput = {
    create?: XOR<GuildsCreateWithoutGuildBansInput, GuildsUncheckedCreateWithoutGuildBansInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutGuildBansInput
    upsert?: GuildsUpsertWithoutGuildBansInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutGuildBansInput, GuildsUpdateWithoutGuildBansInput>, GuildsUncheckedUpdateWithoutGuildBansInput>
  }

  export type ChatModerationsCreateWordsInput = {
    set: string[]
  }

  export type ChatModerationsCreateWhiteListRoleInput = {
    set: string[]
  }

  export type ChatModerationsCreateWhiteListChannelInput = {
    set: string[]
  }

  export type GuildsCreateNestedOneWithoutChatModerationsInput = {
    create?: XOR<GuildsCreateWithoutChatModerationsInput, GuildsUncheckedCreateWithoutChatModerationsInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutChatModerationsInput
    connect?: GuildsWhereUniqueInput
  }

  export type ChatModerationsUpdateWordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ChatModerationsUpdateWhiteListRoleInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ChatModerationsUpdateWhiteListChannelInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GuildsUpdateOneRequiredWithoutChatModerationsNestedInput = {
    create?: XOR<GuildsCreateWithoutChatModerationsInput, GuildsUncheckedCreateWithoutChatModerationsInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutChatModerationsInput
    upsert?: GuildsUpsertWithoutChatModerationsInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutChatModerationsInput, GuildsUpdateWithoutChatModerationsInput>, GuildsUncheckedUpdateWithoutChatModerationsInput>
  }

  export type ChannelLinksCreateWebhookUrlsInput = {
    set: string[]
  }

  export type SyncedChannelLinkMessagesCreateNestedManyWithoutChannelLinksInput = {
    create?: XOR<SyncedChannelLinkMessagesCreateWithoutChannelLinksInput, SyncedChannelLinkMessagesUncheckedCreateWithoutChannelLinksInput> | SyncedChannelLinkMessagesCreateWithoutChannelLinksInput[] | SyncedChannelLinkMessagesUncheckedCreateWithoutChannelLinksInput[]
    connectOrCreate?: SyncedChannelLinkMessagesCreateOrConnectWithoutChannelLinksInput | SyncedChannelLinkMessagesCreateOrConnectWithoutChannelLinksInput[]
    createMany?: SyncedChannelLinkMessagesCreateManyChannelLinksInputEnvelope
    connect?: SyncedChannelLinkMessagesWhereUniqueInput | SyncedChannelLinkMessagesWhereUniqueInput[]
  }

  export type GuildsCreateNestedOneWithoutChannelLinksInput = {
    create?: XOR<GuildsCreateWithoutChannelLinksInput, GuildsUncheckedCreateWithoutChannelLinksInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutChannelLinksInput
    connect?: GuildsWhereUniqueInput
  }

  export type SyncedChannelLinkMessagesUncheckedCreateNestedManyWithoutChannelLinksInput = {
    create?: XOR<SyncedChannelLinkMessagesCreateWithoutChannelLinksInput, SyncedChannelLinkMessagesUncheckedCreateWithoutChannelLinksInput> | SyncedChannelLinkMessagesCreateWithoutChannelLinksInput[] | SyncedChannelLinkMessagesUncheckedCreateWithoutChannelLinksInput[]
    connectOrCreate?: SyncedChannelLinkMessagesCreateOrConnectWithoutChannelLinksInput | SyncedChannelLinkMessagesCreateOrConnectWithoutChannelLinksInput[]
    createMany?: SyncedChannelLinkMessagesCreateManyChannelLinksInputEnvelope
    connect?: SyncedChannelLinkMessagesWhereUniqueInput | SyncedChannelLinkMessagesWhereUniqueInput[]
  }

  export type ChannelLinksUpdateWebhookUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SyncedChannelLinkMessagesUpdateManyWithoutChannelLinksNestedInput = {
    create?: XOR<SyncedChannelLinkMessagesCreateWithoutChannelLinksInput, SyncedChannelLinkMessagesUncheckedCreateWithoutChannelLinksInput> | SyncedChannelLinkMessagesCreateWithoutChannelLinksInput[] | SyncedChannelLinkMessagesUncheckedCreateWithoutChannelLinksInput[]
    connectOrCreate?: SyncedChannelLinkMessagesCreateOrConnectWithoutChannelLinksInput | SyncedChannelLinkMessagesCreateOrConnectWithoutChannelLinksInput[]
    upsert?: SyncedChannelLinkMessagesUpsertWithWhereUniqueWithoutChannelLinksInput | SyncedChannelLinkMessagesUpsertWithWhereUniqueWithoutChannelLinksInput[]
    createMany?: SyncedChannelLinkMessagesCreateManyChannelLinksInputEnvelope
    set?: SyncedChannelLinkMessagesWhereUniqueInput | SyncedChannelLinkMessagesWhereUniqueInput[]
    disconnect?: SyncedChannelLinkMessagesWhereUniqueInput | SyncedChannelLinkMessagesWhereUniqueInput[]
    delete?: SyncedChannelLinkMessagesWhereUniqueInput | SyncedChannelLinkMessagesWhereUniqueInput[]
    connect?: SyncedChannelLinkMessagesWhereUniqueInput | SyncedChannelLinkMessagesWhereUniqueInput[]
    update?: SyncedChannelLinkMessagesUpdateWithWhereUniqueWithoutChannelLinksInput | SyncedChannelLinkMessagesUpdateWithWhereUniqueWithoutChannelLinksInput[]
    updateMany?: SyncedChannelLinkMessagesUpdateManyWithWhereWithoutChannelLinksInput | SyncedChannelLinkMessagesUpdateManyWithWhereWithoutChannelLinksInput[]
    deleteMany?: SyncedChannelLinkMessagesScalarWhereInput | SyncedChannelLinkMessagesScalarWhereInput[]
  }

  export type GuildsUpdateOneRequiredWithoutChannelLinksNestedInput = {
    create?: XOR<GuildsCreateWithoutChannelLinksInput, GuildsUncheckedCreateWithoutChannelLinksInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutChannelLinksInput
    upsert?: GuildsUpsertWithoutChannelLinksInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutChannelLinksInput, GuildsUpdateWithoutChannelLinksInput>, GuildsUncheckedUpdateWithoutChannelLinksInput>
  }

  export type SyncedChannelLinkMessagesUncheckedUpdateManyWithoutChannelLinksNestedInput = {
    create?: XOR<SyncedChannelLinkMessagesCreateWithoutChannelLinksInput, SyncedChannelLinkMessagesUncheckedCreateWithoutChannelLinksInput> | SyncedChannelLinkMessagesCreateWithoutChannelLinksInput[] | SyncedChannelLinkMessagesUncheckedCreateWithoutChannelLinksInput[]
    connectOrCreate?: SyncedChannelLinkMessagesCreateOrConnectWithoutChannelLinksInput | SyncedChannelLinkMessagesCreateOrConnectWithoutChannelLinksInput[]
    upsert?: SyncedChannelLinkMessagesUpsertWithWhereUniqueWithoutChannelLinksInput | SyncedChannelLinkMessagesUpsertWithWhereUniqueWithoutChannelLinksInput[]
    createMany?: SyncedChannelLinkMessagesCreateManyChannelLinksInputEnvelope
    set?: SyncedChannelLinkMessagesWhereUniqueInput | SyncedChannelLinkMessagesWhereUniqueInput[]
    disconnect?: SyncedChannelLinkMessagesWhereUniqueInput | SyncedChannelLinkMessagesWhereUniqueInput[]
    delete?: SyncedChannelLinkMessagesWhereUniqueInput | SyncedChannelLinkMessagesWhereUniqueInput[]
    connect?: SyncedChannelLinkMessagesWhereUniqueInput | SyncedChannelLinkMessagesWhereUniqueInput[]
    update?: SyncedChannelLinkMessagesUpdateWithWhereUniqueWithoutChannelLinksInput | SyncedChannelLinkMessagesUpdateWithWhereUniqueWithoutChannelLinksInput[]
    updateMany?: SyncedChannelLinkMessagesUpdateManyWithWhereWithoutChannelLinksInput | SyncedChannelLinkMessagesUpdateManyWithWhereWithoutChannelLinksInput[]
    deleteMany?: SyncedChannelLinkMessagesScalarWhereInput | SyncedChannelLinkMessagesScalarWhereInput[]
  }

  export type ChannelLinksCreateNestedOneWithoutSyncedChannelLinkMessageInput = {
    create?: XOR<ChannelLinksCreateWithoutSyncedChannelLinkMessageInput, ChannelLinksUncheckedCreateWithoutSyncedChannelLinkMessageInput>
    connectOrCreate?: ChannelLinksCreateOrConnectWithoutSyncedChannelLinkMessageInput
    connect?: ChannelLinksWhereUniqueInput
  }

  export type ChannelLinksUpdateOneRequiredWithoutSyncedChannelLinkMessageNestedInput = {
    create?: XOR<ChannelLinksCreateWithoutSyncedChannelLinkMessageInput, ChannelLinksUncheckedCreateWithoutSyncedChannelLinkMessageInput>
    connectOrCreate?: ChannelLinksCreateOrConnectWithoutSyncedChannelLinkMessageInput
    upsert?: ChannelLinksUpsertWithoutSyncedChannelLinkMessageInput
    connect?: ChannelLinksWhereUniqueInput
    update?: XOR<XOR<ChannelLinksUpdateToOneWithWhereWithoutSyncedChannelLinkMessageInput, ChannelLinksUpdateWithoutSyncedChannelLinkMessageInput>, ChannelLinksUncheckedUpdateWithoutSyncedChannelLinkMessageInput>
  }

  export type DiscordAddonsCreateOnlyMediaInput = {
    set: string[]
  }

  export type DiscordAddonsCreateNoLinkEmbedsInput = {
    set: string[]
  }

  export type GuildsCreateNestedOneWithoutDiscordAddonsInput = {
    create?: XOR<GuildsCreateWithoutDiscordAddonsInput, GuildsUncheckedCreateWithoutDiscordAddonsInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutDiscordAddonsInput
    connect?: GuildsWhereUniqueInput
  }

  export type DiscordAddonsUpdateOnlyMediaInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DiscordAddonsUpdateNoLinkEmbedsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type GuildsUpdateOneRequiredWithoutDiscordAddonsNestedInput = {
    create?: XOR<GuildsCreateWithoutDiscordAddonsInput, GuildsUncheckedCreateWithoutDiscordAddonsInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutDiscordAddonsInput
    upsert?: GuildsUpsertWithoutDiscordAddonsInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutDiscordAddonsInput, GuildsUpdateWithoutDiscordAddonsInput>, GuildsUncheckedUpdateWithoutDiscordAddonsInput>
  }

  export type GiveawaysCreateWinnerIdsInput = {
    set: string[]
  }

  export type GiveawaysCreateEntrysInput = {
    set: string[]
  }

  export type GiveawaysCreateRequirementsInput = {
    set: string[]
  }

  export type GuildsCreateNestedOneWithoutGiveawaysInput = {
    create?: XOR<GuildsCreateWithoutGiveawaysInput, GuildsUncheckedCreateWithoutGiveawaysInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutGiveawaysInput
    connect?: GuildsWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type GiveawaysUpdateWinnerIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GiveawaysUpdateEntrysInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GiveawaysUpdateRequirementsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GuildsUpdateOneRequiredWithoutGiveawaysNestedInput = {
    create?: XOR<GuildsCreateWithoutGiveawaysInput, GuildsUncheckedCreateWithoutGiveawaysInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutGiveawaysInput
    upsert?: GuildsUpsertWithoutGiveawaysInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutGiveawaysInput, GuildsUpdateWithoutGiveawaysInput>, GuildsUncheckedUpdateWithoutGiveawaysInput>
  }

  export type TempVoiceChannelsCreateNestedManyWithoutTempVoicesInput = {
    create?: XOR<TempVoiceChannelsCreateWithoutTempVoicesInput, TempVoiceChannelsUncheckedCreateWithoutTempVoicesInput> | TempVoiceChannelsCreateWithoutTempVoicesInput[] | TempVoiceChannelsUncheckedCreateWithoutTempVoicesInput[]
    connectOrCreate?: TempVoiceChannelsCreateOrConnectWithoutTempVoicesInput | TempVoiceChannelsCreateOrConnectWithoutTempVoicesInput[]
    createMany?: TempVoiceChannelsCreateManyTempVoicesInputEnvelope
    connect?: TempVoiceChannelsWhereUniqueInput | TempVoiceChannelsWhereUniqueInput[]
  }

  export type GuildsCreateNestedOneWithoutTempVoicesInput = {
    create?: XOR<GuildsCreateWithoutTempVoicesInput, GuildsUncheckedCreateWithoutTempVoicesInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutTempVoicesInput
    connect?: GuildsWhereUniqueInput
  }

  export type TempVoiceChannelsUncheckedCreateNestedManyWithoutTempVoicesInput = {
    create?: XOR<TempVoiceChannelsCreateWithoutTempVoicesInput, TempVoiceChannelsUncheckedCreateWithoutTempVoicesInput> | TempVoiceChannelsCreateWithoutTempVoicesInput[] | TempVoiceChannelsUncheckedCreateWithoutTempVoicesInput[]
    connectOrCreate?: TempVoiceChannelsCreateOrConnectWithoutTempVoicesInput | TempVoiceChannelsCreateOrConnectWithoutTempVoicesInput[]
    createMany?: TempVoiceChannelsCreateManyTempVoicesInputEnvelope
    connect?: TempVoiceChannelsWhereUniqueInput | TempVoiceChannelsWhereUniqueInput[]
  }

  export type TempVoiceChannelsUpdateManyWithoutTempVoicesNestedInput = {
    create?: XOR<TempVoiceChannelsCreateWithoutTempVoicesInput, TempVoiceChannelsUncheckedCreateWithoutTempVoicesInput> | TempVoiceChannelsCreateWithoutTempVoicesInput[] | TempVoiceChannelsUncheckedCreateWithoutTempVoicesInput[]
    connectOrCreate?: TempVoiceChannelsCreateOrConnectWithoutTempVoicesInput | TempVoiceChannelsCreateOrConnectWithoutTempVoicesInput[]
    upsert?: TempVoiceChannelsUpsertWithWhereUniqueWithoutTempVoicesInput | TempVoiceChannelsUpsertWithWhereUniqueWithoutTempVoicesInput[]
    createMany?: TempVoiceChannelsCreateManyTempVoicesInputEnvelope
    set?: TempVoiceChannelsWhereUniqueInput | TempVoiceChannelsWhereUniqueInput[]
    disconnect?: TempVoiceChannelsWhereUniqueInput | TempVoiceChannelsWhereUniqueInput[]
    delete?: TempVoiceChannelsWhereUniqueInput | TempVoiceChannelsWhereUniqueInput[]
    connect?: TempVoiceChannelsWhereUniqueInput | TempVoiceChannelsWhereUniqueInput[]
    update?: TempVoiceChannelsUpdateWithWhereUniqueWithoutTempVoicesInput | TempVoiceChannelsUpdateWithWhereUniqueWithoutTempVoicesInput[]
    updateMany?: TempVoiceChannelsUpdateManyWithWhereWithoutTempVoicesInput | TempVoiceChannelsUpdateManyWithWhereWithoutTempVoicesInput[]
    deleteMany?: TempVoiceChannelsScalarWhereInput | TempVoiceChannelsScalarWhereInput[]
  }

  export type GuildsUpdateOneRequiredWithoutTempVoicesNestedInput = {
    create?: XOR<GuildsCreateWithoutTempVoicesInput, GuildsUncheckedCreateWithoutTempVoicesInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutTempVoicesInput
    upsert?: GuildsUpsertWithoutTempVoicesInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutTempVoicesInput, GuildsUpdateWithoutTempVoicesInput>, GuildsUncheckedUpdateWithoutTempVoicesInput>
  }

  export type TempVoiceChannelsUncheckedUpdateManyWithoutTempVoicesNestedInput = {
    create?: XOR<TempVoiceChannelsCreateWithoutTempVoicesInput, TempVoiceChannelsUncheckedCreateWithoutTempVoicesInput> | TempVoiceChannelsCreateWithoutTempVoicesInput[] | TempVoiceChannelsUncheckedCreateWithoutTempVoicesInput[]
    connectOrCreate?: TempVoiceChannelsCreateOrConnectWithoutTempVoicesInput | TempVoiceChannelsCreateOrConnectWithoutTempVoicesInput[]
    upsert?: TempVoiceChannelsUpsertWithWhereUniqueWithoutTempVoicesInput | TempVoiceChannelsUpsertWithWhereUniqueWithoutTempVoicesInput[]
    createMany?: TempVoiceChannelsCreateManyTempVoicesInputEnvelope
    set?: TempVoiceChannelsWhereUniqueInput | TempVoiceChannelsWhereUniqueInput[]
    disconnect?: TempVoiceChannelsWhereUniqueInput | TempVoiceChannelsWhereUniqueInput[]
    delete?: TempVoiceChannelsWhereUniqueInput | TempVoiceChannelsWhereUniqueInput[]
    connect?: TempVoiceChannelsWhereUniqueInput | TempVoiceChannelsWhereUniqueInput[]
    update?: TempVoiceChannelsUpdateWithWhereUniqueWithoutTempVoicesInput | TempVoiceChannelsUpdateWithWhereUniqueWithoutTempVoicesInput[]
    updateMany?: TempVoiceChannelsUpdateManyWithWhereWithoutTempVoicesInput | TempVoiceChannelsUpdateManyWithWhereWithoutTempVoicesInput[]
    deleteMany?: TempVoiceChannelsScalarWhereInput | TempVoiceChannelsScalarWhereInput[]
  }

  export type TempVoicesCreateNestedOneWithoutTempVoiceChannelsInput = {
    create?: XOR<TempVoicesCreateWithoutTempVoiceChannelsInput, TempVoicesUncheckedCreateWithoutTempVoiceChannelsInput>
    connectOrCreate?: TempVoicesCreateOrConnectWithoutTempVoiceChannelsInput
    connect?: TempVoicesWhereUniqueInput
  }

  export type TempVoicesUpdateOneRequiredWithoutTempVoiceChannelsNestedInput = {
    create?: XOR<TempVoicesCreateWithoutTempVoiceChannelsInput, TempVoicesUncheckedCreateWithoutTempVoiceChannelsInput>
    connectOrCreate?: TempVoicesCreateOrConnectWithoutTempVoiceChannelsInput
    upsert?: TempVoicesUpsertWithoutTempVoiceChannelsInput
    connect?: TempVoicesWhereUniqueInput
    update?: XOR<XOR<TempVoicesUpdateToOneWithWhereWithoutTempVoiceChannelsInput, TempVoicesUpdateWithoutTempVoiceChannelsInput>, TempVoicesUncheckedUpdateWithoutTempVoiceChannelsInput>
  }

  export type WelcomeLeaveImageDataNullableCreateEnvelopeInput = {
    set?: WelcomeLeaveImageDataCreateInput | null
  }

  export type WelcomeLeaveImageDataCreateInput = {
    Title: string
    Text: string
    Subtitle: string
    Background: string
    Theme: string
    Color: string
    Gradient: string
  }

  export type GuildsCreateNestedOneWithoutGuildLeaveSetupInput = {
    create?: XOR<GuildsCreateWithoutGuildLeaveSetupInput, GuildsUncheckedCreateWithoutGuildLeaveSetupInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutGuildLeaveSetupInput
    connect?: GuildsWhereUniqueInput
  }

  export type WelcomeLeaveImageDataNullableUpdateEnvelopeInput = {
    set?: WelcomeLeaveImageDataCreateInput | null
    upsert?: WelcomeLeaveImageDataUpsertInput
    unset?: boolean
  }

  export type GuildsUpdateOneRequiredWithoutGuildLeaveSetupNestedInput = {
    create?: XOR<GuildsCreateWithoutGuildLeaveSetupInput, GuildsUncheckedCreateWithoutGuildLeaveSetupInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutGuildLeaveSetupInput
    upsert?: GuildsUpsertWithoutGuildLeaveSetupInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutGuildLeaveSetupInput, GuildsUpdateWithoutGuildLeaveSetupInput>, GuildsUncheckedUpdateWithoutGuildLeaveSetupInput>
  }

  export type WelcomeLeaveImageDataCreateEnvelopeInput = {
    set?: WelcomeLeaveImageDataCreateInput
  }

  export type GuildsCreateNestedOneWithoutGuildWelcomeSetupInput = {
    create?: XOR<GuildsCreateWithoutGuildWelcomeSetupInput, GuildsUncheckedCreateWithoutGuildWelcomeSetupInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutGuildWelcomeSetupInput
    connect?: GuildsWhereUniqueInput
  }

  export type WelcomeLeaveImageDataUpdateEnvelopeInput = {
    set?: WelcomeLeaveImageDataCreateInput
    update?: WelcomeLeaveImageDataUpdateInput
  }

  export type GuildsUpdateOneRequiredWithoutGuildWelcomeSetupNestedInput = {
    create?: XOR<GuildsCreateWithoutGuildWelcomeSetupInput, GuildsUncheckedCreateWithoutGuildWelcomeSetupInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutGuildWelcomeSetupInput
    upsert?: GuildsUpsertWithoutGuildWelcomeSetupInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutGuildWelcomeSetupInput, GuildsUpdateWithoutGuildWelcomeSetupInput>, GuildsUncheckedUpdateWithoutGuildWelcomeSetupInput>
  }

  export type GuildsCreateNestedOneWithoutGuildLoggingInput = {
    create?: XOR<GuildsCreateWithoutGuildLoggingInput, GuildsUncheckedCreateWithoutGuildLoggingInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutGuildLoggingInput
    connect?: GuildsWhereUniqueInput
  }

  export type GuildsUpdateOneRequiredWithoutGuildLoggingNestedInput = {
    create?: XOR<GuildsCreateWithoutGuildLoggingInput, GuildsUncheckedCreateWithoutGuildLoggingInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutGuildLoggingInput
    upsert?: GuildsUpsertWithoutGuildLoggingInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutGuildLoggingInput, GuildsUpdateWithoutGuildLoggingInput>, GuildsUncheckedUpdateWithoutGuildLoggingInput>
  }

  export type GuildLoggersCreateNotesInput = {
    set: string[]
  }

  export type GuildsCreateNestedOneWithoutGuildLoggersInput = {
    create?: XOR<GuildsCreateWithoutGuildLoggersInput, GuildsUncheckedCreateWithoutGuildLoggersInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutGuildLoggersInput
    connect?: GuildsWhereUniqueInput
  }

  export type GuildLoggersUpdateNotesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GuildsUpdateOneRequiredWithoutGuildLoggersNestedInput = {
    create?: XOR<GuildsCreateWithoutGuildLoggersInput, GuildsUncheckedCreateWithoutGuildLoggersInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutGuildLoggersInput
    upsert?: GuildsUpsertWithoutGuildLoggersInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutGuildLoggersInput, GuildsUpdateWithoutGuildLoggersInput>, GuildsUncheckedUpdateWithoutGuildLoggersInput>
  }

  export type MessageTemplatesCreateOtherEmbedsInput = {
    set: string[]
  }

  export type GuildsCreateNestedOneWithoutMessageTemplatesInput = {
    create?: XOR<GuildsCreateWithoutMessageTemplatesInput, GuildsUncheckedCreateWithoutMessageTemplatesInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutMessageTemplatesInput
    connect?: GuildsWhereUniqueInput
  }

  export type MessageTemplatesUpdateOtherEmbedsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GuildsUpdateOneRequiredWithoutMessageTemplatesNestedInput = {
    create?: XOR<GuildsCreateWithoutMessageTemplatesInput, GuildsUncheckedCreateWithoutMessageTemplatesInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutMessageTemplatesInput
    upsert?: GuildsUpsertWithoutMessageTemplatesInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutMessageTemplatesInput, GuildsUpdateWithoutMessageTemplatesInput>, GuildsUncheckedUpdateWithoutMessageTemplatesInput>
  }

  export type PermissionDataListCreateEnvelopeInput = {
    set?: PermissionDataCreateInput | PermissionDataCreateInput[]
  }

  export type PermissionDataCreateInput = {
    RoleId: string
    Type: string
  }

  export type GuildsCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<GuildsCreateWithoutPermissionsInput, GuildsUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutPermissionsInput
    connect?: GuildsWhereUniqueInput
  }

  export type PermissionDataListUpdateEnvelopeInput = {
    set?: PermissionDataCreateInput | PermissionDataCreateInput[]
    push?: PermissionDataCreateInput | PermissionDataCreateInput[]
    updateMany?: PermissionDataUpdateManyInput
    deleteMany?: PermissionDataDeleteManyInput
  }

  export type GuildsUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<GuildsCreateWithoutPermissionsInput, GuildsUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutPermissionsInput
    upsert?: GuildsUpsertWithoutPermissionsInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutPermissionsInput, GuildsUpdateWithoutPermissionsInput>, GuildsUncheckedUpdateWithoutPermissionsInput>
  }

  export type ReactionRolesCreateRolesInput = {
    set: string[]
  }

  export type ReactionRoleButtonNullableCreateEnvelopeInput = {
    set?: ReactionRoleButtonCreateInput | null
  }

  export type ReactionRoleButtonCreateInput = {
    Emoji: string
    Type: string
    Label: string
  }

  export type ReactionRoleSelectmenuNullableCreateEnvelopeInput = {
    set?: ReactionRoleSelectmenuCreateInput | null
  }

  export type ReactionRoleSelectmenuCreateInput = {
    Emoji: string
    Label: string
    Description: string
  }

  export type GuildsCreateNestedOneWithoutReactionRoleInput = {
    create?: XOR<GuildsCreateWithoutReactionRoleInput, GuildsUncheckedCreateWithoutReactionRoleInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutReactionRoleInput
    connect?: GuildsWhereUniqueInput
  }

  export type ReactionRolesUpdateRolesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ReactionRoleButtonNullableUpdateEnvelopeInput = {
    set?: ReactionRoleButtonCreateInput | null
    upsert?: ReactionRoleButtonUpsertInput
    unset?: boolean
  }

  export type ReactionRoleSelectmenuNullableUpdateEnvelopeInput = {
    set?: ReactionRoleSelectmenuCreateInput | null
    upsert?: ReactionRoleSelectmenuUpsertInput
    unset?: boolean
  }

  export type GuildsUpdateOneRequiredWithoutReactionRoleNestedInput = {
    create?: XOR<GuildsCreateWithoutReactionRoleInput, GuildsUncheckedCreateWithoutReactionRoleInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutReactionRoleInput
    upsert?: GuildsUpsertWithoutReactionRoleInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutReactionRoleInput, GuildsUpdateWithoutReactionRoleInput>, GuildsUncheckedUpdateWithoutReactionRoleInput>
  }

  export type VerificationGatesCreateNestedManyWithoutVerificationGatesInput = {
    create?: XOR<VerificationGatesCreateWithoutVerificationGatesInput, VerificationGatesUncheckedCreateWithoutVerificationGatesInput> | VerificationGatesCreateWithoutVerificationGatesInput[] | VerificationGatesUncheckedCreateWithoutVerificationGatesInput[]
    connectOrCreate?: VerificationGatesCreateOrConnectWithoutVerificationGatesInput | VerificationGatesCreateOrConnectWithoutVerificationGatesInput[]
    createMany?: VerificationGatesCreateManyVerificationGatesInputEnvelope
    connect?: VerificationGatesWhereUniqueInput | VerificationGatesWhereUniqueInput[]
  }

  export type GuildsCreateNestedOneWithoutSecurityInput = {
    create?: XOR<GuildsCreateWithoutSecurityInput, GuildsUncheckedCreateWithoutSecurityInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutSecurityInput
    connect?: GuildsWhereUniqueInput
  }

  export type VerificationGatesUncheckedCreateNestedManyWithoutVerificationGatesInput = {
    create?: XOR<VerificationGatesCreateWithoutVerificationGatesInput, VerificationGatesUncheckedCreateWithoutVerificationGatesInput> | VerificationGatesCreateWithoutVerificationGatesInput[] | VerificationGatesUncheckedCreateWithoutVerificationGatesInput[]
    connectOrCreate?: VerificationGatesCreateOrConnectWithoutVerificationGatesInput | VerificationGatesCreateOrConnectWithoutVerificationGatesInput[]
    createMany?: VerificationGatesCreateManyVerificationGatesInputEnvelope
    connect?: VerificationGatesWhereUniqueInput | VerificationGatesWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type VerificationGatesUpdateManyWithoutVerificationGatesNestedInput = {
    create?: XOR<VerificationGatesCreateWithoutVerificationGatesInput, VerificationGatesUncheckedCreateWithoutVerificationGatesInput> | VerificationGatesCreateWithoutVerificationGatesInput[] | VerificationGatesUncheckedCreateWithoutVerificationGatesInput[]
    connectOrCreate?: VerificationGatesCreateOrConnectWithoutVerificationGatesInput | VerificationGatesCreateOrConnectWithoutVerificationGatesInput[]
    upsert?: VerificationGatesUpsertWithWhereUniqueWithoutVerificationGatesInput | VerificationGatesUpsertWithWhereUniqueWithoutVerificationGatesInput[]
    createMany?: VerificationGatesCreateManyVerificationGatesInputEnvelope
    set?: VerificationGatesWhereUniqueInput | VerificationGatesWhereUniqueInput[]
    disconnect?: VerificationGatesWhereUniqueInput | VerificationGatesWhereUniqueInput[]
    delete?: VerificationGatesWhereUniqueInput | VerificationGatesWhereUniqueInput[]
    connect?: VerificationGatesWhereUniqueInput | VerificationGatesWhereUniqueInput[]
    update?: VerificationGatesUpdateWithWhereUniqueWithoutVerificationGatesInput | VerificationGatesUpdateWithWhereUniqueWithoutVerificationGatesInput[]
    updateMany?: VerificationGatesUpdateManyWithWhereWithoutVerificationGatesInput | VerificationGatesUpdateManyWithWhereWithoutVerificationGatesInput[]
    deleteMany?: VerificationGatesScalarWhereInput | VerificationGatesScalarWhereInput[]
  }

  export type GuildsUpdateOneRequiredWithoutSecurityNestedInput = {
    create?: XOR<GuildsCreateWithoutSecurityInput, GuildsUncheckedCreateWithoutSecurityInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutSecurityInput
    upsert?: GuildsUpsertWithoutSecurityInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutSecurityInput, GuildsUpdateWithoutSecurityInput>, GuildsUncheckedUpdateWithoutSecurityInput>
  }

  export type VerificationGatesUncheckedUpdateManyWithoutVerificationGatesNestedInput = {
    create?: XOR<VerificationGatesCreateWithoutVerificationGatesInput, VerificationGatesUncheckedCreateWithoutVerificationGatesInput> | VerificationGatesCreateWithoutVerificationGatesInput[] | VerificationGatesUncheckedCreateWithoutVerificationGatesInput[]
    connectOrCreate?: VerificationGatesCreateOrConnectWithoutVerificationGatesInput | VerificationGatesCreateOrConnectWithoutVerificationGatesInput[]
    upsert?: VerificationGatesUpsertWithWhereUniqueWithoutVerificationGatesInput | VerificationGatesUpsertWithWhereUniqueWithoutVerificationGatesInput[]
    createMany?: VerificationGatesCreateManyVerificationGatesInputEnvelope
    set?: VerificationGatesWhereUniqueInput | VerificationGatesWhereUniqueInput[]
    disconnect?: VerificationGatesWhereUniqueInput | VerificationGatesWhereUniqueInput[]
    delete?: VerificationGatesWhereUniqueInput | VerificationGatesWhereUniqueInput[]
    connect?: VerificationGatesWhereUniqueInput | VerificationGatesWhereUniqueInput[]
    update?: VerificationGatesUpdateWithWhereUniqueWithoutVerificationGatesInput | VerificationGatesUpdateWithWhereUniqueWithoutVerificationGatesInput[]
    updateMany?: VerificationGatesUpdateManyWithWhereWithoutVerificationGatesInput | VerificationGatesUpdateManyWithWhereWithoutVerificationGatesInput[]
    deleteMany?: VerificationGatesScalarWhereInput | VerificationGatesScalarWhereInput[]
  }

  export type VerificationGatesCreateRolesInput = {
    set: string[]
  }

  export type VerificationGatesCreateVerifiedUsersInput = {
    set: string[]
  }

  export type VerificationGatesPermissionCreateNestedManyWithoutVerificationGatesInput = {
    create?: XOR<VerificationGatesPermissionCreateWithoutVerificationGatesInput, VerificationGatesPermissionUncheckedCreateWithoutVerificationGatesInput> | VerificationGatesPermissionCreateWithoutVerificationGatesInput[] | VerificationGatesPermissionUncheckedCreateWithoutVerificationGatesInput[]
    connectOrCreate?: VerificationGatesPermissionCreateOrConnectWithoutVerificationGatesInput | VerificationGatesPermissionCreateOrConnectWithoutVerificationGatesInput[]
    createMany?: VerificationGatesPermissionCreateManyVerificationGatesInputEnvelope
    connect?: VerificationGatesPermissionWhereUniqueInput | VerificationGatesPermissionWhereUniqueInput[]
  }

  export type SecuritysCreateNestedOneWithoutVerificationGatesInput = {
    create?: XOR<SecuritysCreateWithoutVerificationGatesInput, SecuritysUncheckedCreateWithoutVerificationGatesInput>
    connectOrCreate?: SecuritysCreateOrConnectWithoutVerificationGatesInput
    connect?: SecuritysWhereUniqueInput
  }

  export type VerificationGatesPermissionUncheckedCreateNestedManyWithoutVerificationGatesInput = {
    create?: XOR<VerificationGatesPermissionCreateWithoutVerificationGatesInput, VerificationGatesPermissionUncheckedCreateWithoutVerificationGatesInput> | VerificationGatesPermissionCreateWithoutVerificationGatesInput[] | VerificationGatesPermissionUncheckedCreateWithoutVerificationGatesInput[]
    connectOrCreate?: VerificationGatesPermissionCreateOrConnectWithoutVerificationGatesInput | VerificationGatesPermissionCreateOrConnectWithoutVerificationGatesInput[]
    createMany?: VerificationGatesPermissionCreateManyVerificationGatesInputEnvelope
    connect?: VerificationGatesPermissionWhereUniqueInput | VerificationGatesPermissionWhereUniqueInput[]
  }

  export type VerificationGatesUpdateRolesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type VerificationGatesUpdateVerifiedUsersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type VerificationGatesPermissionUpdateManyWithoutVerificationGatesNestedInput = {
    create?: XOR<VerificationGatesPermissionCreateWithoutVerificationGatesInput, VerificationGatesPermissionUncheckedCreateWithoutVerificationGatesInput> | VerificationGatesPermissionCreateWithoutVerificationGatesInput[] | VerificationGatesPermissionUncheckedCreateWithoutVerificationGatesInput[]
    connectOrCreate?: VerificationGatesPermissionCreateOrConnectWithoutVerificationGatesInput | VerificationGatesPermissionCreateOrConnectWithoutVerificationGatesInput[]
    upsert?: VerificationGatesPermissionUpsertWithWhereUniqueWithoutVerificationGatesInput | VerificationGatesPermissionUpsertWithWhereUniqueWithoutVerificationGatesInput[]
    createMany?: VerificationGatesPermissionCreateManyVerificationGatesInputEnvelope
    set?: VerificationGatesPermissionWhereUniqueInput | VerificationGatesPermissionWhereUniqueInput[]
    disconnect?: VerificationGatesPermissionWhereUniqueInput | VerificationGatesPermissionWhereUniqueInput[]
    delete?: VerificationGatesPermissionWhereUniqueInput | VerificationGatesPermissionWhereUniqueInput[]
    connect?: VerificationGatesPermissionWhereUniqueInput | VerificationGatesPermissionWhereUniqueInput[]
    update?: VerificationGatesPermissionUpdateWithWhereUniqueWithoutVerificationGatesInput | VerificationGatesPermissionUpdateWithWhereUniqueWithoutVerificationGatesInput[]
    updateMany?: VerificationGatesPermissionUpdateManyWithWhereWithoutVerificationGatesInput | VerificationGatesPermissionUpdateManyWithWhereWithoutVerificationGatesInput[]
    deleteMany?: VerificationGatesPermissionScalarWhereInput | VerificationGatesPermissionScalarWhereInput[]
  }

  export type SecuritysUpdateOneRequiredWithoutVerificationGatesNestedInput = {
    create?: XOR<SecuritysCreateWithoutVerificationGatesInput, SecuritysUncheckedCreateWithoutVerificationGatesInput>
    connectOrCreate?: SecuritysCreateOrConnectWithoutVerificationGatesInput
    upsert?: SecuritysUpsertWithoutVerificationGatesInput
    connect?: SecuritysWhereUniqueInput
    update?: XOR<XOR<SecuritysUpdateToOneWithWhereWithoutVerificationGatesInput, SecuritysUpdateWithoutVerificationGatesInput>, SecuritysUncheckedUpdateWithoutVerificationGatesInput>
  }

  export type VerificationGatesPermissionUncheckedUpdateManyWithoutVerificationGatesNestedInput = {
    create?: XOR<VerificationGatesPermissionCreateWithoutVerificationGatesInput, VerificationGatesPermissionUncheckedCreateWithoutVerificationGatesInput> | VerificationGatesPermissionCreateWithoutVerificationGatesInput[] | VerificationGatesPermissionUncheckedCreateWithoutVerificationGatesInput[]
    connectOrCreate?: VerificationGatesPermissionCreateOrConnectWithoutVerificationGatesInput | VerificationGatesPermissionCreateOrConnectWithoutVerificationGatesInput[]
    upsert?: VerificationGatesPermissionUpsertWithWhereUniqueWithoutVerificationGatesInput | VerificationGatesPermissionUpsertWithWhereUniqueWithoutVerificationGatesInput[]
    createMany?: VerificationGatesPermissionCreateManyVerificationGatesInputEnvelope
    set?: VerificationGatesPermissionWhereUniqueInput | VerificationGatesPermissionWhereUniqueInput[]
    disconnect?: VerificationGatesPermissionWhereUniqueInput | VerificationGatesPermissionWhereUniqueInput[]
    delete?: VerificationGatesPermissionWhereUniqueInput | VerificationGatesPermissionWhereUniqueInput[]
    connect?: VerificationGatesPermissionWhereUniqueInput | VerificationGatesPermissionWhereUniqueInput[]
    update?: VerificationGatesPermissionUpdateWithWhereUniqueWithoutVerificationGatesInput | VerificationGatesPermissionUpdateWithWhereUniqueWithoutVerificationGatesInput[]
    updateMany?: VerificationGatesPermissionUpdateManyWithWhereWithoutVerificationGatesInput | VerificationGatesPermissionUpdateManyWithWhereWithoutVerificationGatesInput[]
    deleteMany?: VerificationGatesPermissionScalarWhereInput | VerificationGatesPermissionScalarWhereInput[]
  }

  export type VerificationGatesPermissionCreatePermissionInput = {
    set: string[]
  }

  export type VerificationGatesCreateNestedOneWithoutChannelPermissionsInput = {
    create?: XOR<VerificationGatesCreateWithoutChannelPermissionsInput, VerificationGatesUncheckedCreateWithoutChannelPermissionsInput>
    connectOrCreate?: VerificationGatesCreateOrConnectWithoutChannelPermissionsInput
    connect?: VerificationGatesWhereUniqueInput
  }

  export type VerificationGatesPermissionUpdatePermissionInput = {
    set?: string[]
    push?: string | string[]
  }

  export type VerificationGatesUpdateOneRequiredWithoutChannelPermissionsNestedInput = {
    create?: XOR<VerificationGatesCreateWithoutChannelPermissionsInput, VerificationGatesUncheckedCreateWithoutChannelPermissionsInput>
    connectOrCreate?: VerificationGatesCreateOrConnectWithoutChannelPermissionsInput
    upsert?: VerificationGatesUpsertWithoutChannelPermissionsInput
    connect?: VerificationGatesWhereUniqueInput
    update?: XOR<XOR<VerificationGatesUpdateToOneWithWhereWithoutChannelPermissionsInput, VerificationGatesUpdateWithoutChannelPermissionsInput>, VerificationGatesUncheckedUpdateWithoutChannelPermissionsInput>
  }

  export type SpotifyNotificationsCreateLatestsInput = {
    set: string[]
  }

  export type SpotifyNotificationsCreatePingRolesInput = {
    set: string[]
  }

  export type GuildsCreateNestedOneWithoutSpotifyNotificationsInput = {
    create?: XOR<GuildsCreateWithoutSpotifyNotificationsInput, GuildsUncheckedCreateWithoutSpotifyNotificationsInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutSpotifyNotificationsInput
    connect?: GuildsWhereUniqueInput
  }

  export type SpotifyNotificationsUpdateLatestsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SpotifyNotificationsUpdatePingRolesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GuildsUpdateOneRequiredWithoutSpotifyNotificationsNestedInput = {
    create?: XOR<GuildsCreateWithoutSpotifyNotificationsInput, GuildsUncheckedCreateWithoutSpotifyNotificationsInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutSpotifyNotificationsInput
    upsert?: GuildsUpsertWithoutSpotifyNotificationsInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutSpotifyNotificationsInput, GuildsUpdateWithoutSpotifyNotificationsInput>, GuildsUncheckedUpdateWithoutSpotifyNotificationsInput>
  }

  export type TagsCreateFilterTextFromMessagesInput = {
    set: string[]
  }

  export type GuildsCreateNestedOneWithoutTagsInput = {
    create?: XOR<GuildsCreateWithoutTagsInput, GuildsUncheckedCreateWithoutTagsInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutTagsInput
    connect?: GuildsWhereUniqueInput
  }

  export type TagsUpdateFilterTextFromMessagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GuildsUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<GuildsCreateWithoutTagsInput, GuildsUncheckedCreateWithoutTagsInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutTagsInput
    upsert?: GuildsUpsertWithoutTagsInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutTagsInput, GuildsUpdateWithoutTagsInput>, GuildsUncheckedUpdateWithoutTagsInput>
  }

  export type TicketSetupsCreateHandlersInput = {
    set: string[]
  }

  export type TicketSetupsCreateHandlerWithShadowPingInput = {
    set: string[]
  }

  export type TicketSetupsCreateTicketBlacklistRolesInput = {
    set: string[]
  }

  export type TicketSetupsCreateRequiredRolesInput = {
    set: string[]
  }

  export type TicketModalDataCreateNestedManyWithoutTicketSetupInput = {
    create?: XOR<TicketModalDataCreateWithoutTicketSetupInput, TicketModalDataUncheckedCreateWithoutTicketSetupInput> | TicketModalDataCreateWithoutTicketSetupInput[] | TicketModalDataUncheckedCreateWithoutTicketSetupInput[]
    connectOrCreate?: TicketModalDataCreateOrConnectWithoutTicketSetupInput | TicketModalDataCreateOrConnectWithoutTicketSetupInput[]
    createMany?: TicketModalDataCreateManyTicketSetupInputEnvelope
    connect?: TicketModalDataWhereUniqueInput | TicketModalDataWhereUniqueInput[]
  }

  export type GuildsCreateNestedOneWithoutTicketSetupsInput = {
    create?: XOR<GuildsCreateWithoutTicketSetupsInput, GuildsUncheckedCreateWithoutTicketSetupsInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutTicketSetupsInput
    connect?: GuildsWhereUniqueInput
  }

  export type TicketsCreateNestedManyWithoutTicketSetupInput = {
    create?: XOR<TicketsCreateWithoutTicketSetupInput, TicketsUncheckedCreateWithoutTicketSetupInput> | TicketsCreateWithoutTicketSetupInput[] | TicketsUncheckedCreateWithoutTicketSetupInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutTicketSetupInput | TicketsCreateOrConnectWithoutTicketSetupInput[]
    createMany?: TicketsCreateManyTicketSetupInputEnvelope
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
  }

  export type TicketModalDataUncheckedCreateNestedManyWithoutTicketSetupInput = {
    create?: XOR<TicketModalDataCreateWithoutTicketSetupInput, TicketModalDataUncheckedCreateWithoutTicketSetupInput> | TicketModalDataCreateWithoutTicketSetupInput[] | TicketModalDataUncheckedCreateWithoutTicketSetupInput[]
    connectOrCreate?: TicketModalDataCreateOrConnectWithoutTicketSetupInput | TicketModalDataCreateOrConnectWithoutTicketSetupInput[]
    createMany?: TicketModalDataCreateManyTicketSetupInputEnvelope
    connect?: TicketModalDataWhereUniqueInput | TicketModalDataWhereUniqueInput[]
  }

  export type TicketsUncheckedCreateNestedManyWithoutTicketSetupInput = {
    create?: XOR<TicketsCreateWithoutTicketSetupInput, TicketsUncheckedCreateWithoutTicketSetupInput> | TicketsCreateWithoutTicketSetupInput[] | TicketsUncheckedCreateWithoutTicketSetupInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutTicketSetupInput | TicketsCreateOrConnectWithoutTicketSetupInput[]
    createMany?: TicketsCreateManyTicketSetupInputEnvelope
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
  }

  export type TicketSetupsUpdateHandlersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TicketSetupsUpdateHandlerWithShadowPingInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TicketSetupsUpdateTicketBlacklistRolesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TicketSetupsUpdateRequiredRolesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TicketModalDataUpdateManyWithoutTicketSetupNestedInput = {
    create?: XOR<TicketModalDataCreateWithoutTicketSetupInput, TicketModalDataUncheckedCreateWithoutTicketSetupInput> | TicketModalDataCreateWithoutTicketSetupInput[] | TicketModalDataUncheckedCreateWithoutTicketSetupInput[]
    connectOrCreate?: TicketModalDataCreateOrConnectWithoutTicketSetupInput | TicketModalDataCreateOrConnectWithoutTicketSetupInput[]
    upsert?: TicketModalDataUpsertWithWhereUniqueWithoutTicketSetupInput | TicketModalDataUpsertWithWhereUniqueWithoutTicketSetupInput[]
    createMany?: TicketModalDataCreateManyTicketSetupInputEnvelope
    set?: TicketModalDataWhereUniqueInput | TicketModalDataWhereUniqueInput[]
    disconnect?: TicketModalDataWhereUniqueInput | TicketModalDataWhereUniqueInput[]
    delete?: TicketModalDataWhereUniqueInput | TicketModalDataWhereUniqueInput[]
    connect?: TicketModalDataWhereUniqueInput | TicketModalDataWhereUniqueInput[]
    update?: TicketModalDataUpdateWithWhereUniqueWithoutTicketSetupInput | TicketModalDataUpdateWithWhereUniqueWithoutTicketSetupInput[]
    updateMany?: TicketModalDataUpdateManyWithWhereWithoutTicketSetupInput | TicketModalDataUpdateManyWithWhereWithoutTicketSetupInput[]
    deleteMany?: TicketModalDataScalarWhereInput | TicketModalDataScalarWhereInput[]
  }

  export type GuildsUpdateOneRequiredWithoutTicketSetupsNestedInput = {
    create?: XOR<GuildsCreateWithoutTicketSetupsInput, GuildsUncheckedCreateWithoutTicketSetupsInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutTicketSetupsInput
    upsert?: GuildsUpsertWithoutTicketSetupsInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutTicketSetupsInput, GuildsUpdateWithoutTicketSetupsInput>, GuildsUncheckedUpdateWithoutTicketSetupsInput>
  }

  export type TicketsUpdateManyWithoutTicketSetupNestedInput = {
    create?: XOR<TicketsCreateWithoutTicketSetupInput, TicketsUncheckedCreateWithoutTicketSetupInput> | TicketsCreateWithoutTicketSetupInput[] | TicketsUncheckedCreateWithoutTicketSetupInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutTicketSetupInput | TicketsCreateOrConnectWithoutTicketSetupInput[]
    upsert?: TicketsUpsertWithWhereUniqueWithoutTicketSetupInput | TicketsUpsertWithWhereUniqueWithoutTicketSetupInput[]
    createMany?: TicketsCreateManyTicketSetupInputEnvelope
    set?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    disconnect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    delete?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    update?: TicketsUpdateWithWhereUniqueWithoutTicketSetupInput | TicketsUpdateWithWhereUniqueWithoutTicketSetupInput[]
    updateMany?: TicketsUpdateManyWithWhereWithoutTicketSetupInput | TicketsUpdateManyWithWhereWithoutTicketSetupInput[]
    deleteMany?: TicketsScalarWhereInput | TicketsScalarWhereInput[]
  }

  export type TicketModalDataUncheckedUpdateManyWithoutTicketSetupNestedInput = {
    create?: XOR<TicketModalDataCreateWithoutTicketSetupInput, TicketModalDataUncheckedCreateWithoutTicketSetupInput> | TicketModalDataCreateWithoutTicketSetupInput[] | TicketModalDataUncheckedCreateWithoutTicketSetupInput[]
    connectOrCreate?: TicketModalDataCreateOrConnectWithoutTicketSetupInput | TicketModalDataCreateOrConnectWithoutTicketSetupInput[]
    upsert?: TicketModalDataUpsertWithWhereUniqueWithoutTicketSetupInput | TicketModalDataUpsertWithWhereUniqueWithoutTicketSetupInput[]
    createMany?: TicketModalDataCreateManyTicketSetupInputEnvelope
    set?: TicketModalDataWhereUniqueInput | TicketModalDataWhereUniqueInput[]
    disconnect?: TicketModalDataWhereUniqueInput | TicketModalDataWhereUniqueInput[]
    delete?: TicketModalDataWhereUniqueInput | TicketModalDataWhereUniqueInput[]
    connect?: TicketModalDataWhereUniqueInput | TicketModalDataWhereUniqueInput[]
    update?: TicketModalDataUpdateWithWhereUniqueWithoutTicketSetupInput | TicketModalDataUpdateWithWhereUniqueWithoutTicketSetupInput[]
    updateMany?: TicketModalDataUpdateManyWithWhereWithoutTicketSetupInput | TicketModalDataUpdateManyWithWhereWithoutTicketSetupInput[]
    deleteMany?: TicketModalDataScalarWhereInput | TicketModalDataScalarWhereInput[]
  }

  export type TicketsUncheckedUpdateManyWithoutTicketSetupNestedInput = {
    create?: XOR<TicketsCreateWithoutTicketSetupInput, TicketsUncheckedCreateWithoutTicketSetupInput> | TicketsCreateWithoutTicketSetupInput[] | TicketsUncheckedCreateWithoutTicketSetupInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutTicketSetupInput | TicketsCreateOrConnectWithoutTicketSetupInput[]
    upsert?: TicketsUpsertWithWhereUniqueWithoutTicketSetupInput | TicketsUpsertWithWhereUniqueWithoutTicketSetupInput[]
    createMany?: TicketsCreateManyTicketSetupInputEnvelope
    set?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    disconnect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    delete?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    update?: TicketsUpdateWithWhereUniqueWithoutTicketSetupInput | TicketsUpdateWithWhereUniqueWithoutTicketSetupInput[]
    updateMany?: TicketsUpdateManyWithWhereWithoutTicketSetupInput | TicketsUpdateManyWithWhereWithoutTicketSetupInput[]
    deleteMany?: TicketsScalarWhereInput | TicketsScalarWhereInput[]
  }

  export type TicketSetupsCreateNestedOneWithoutModalOptionsInput = {
    create?: XOR<TicketSetupsCreateWithoutModalOptionsInput, TicketSetupsUncheckedCreateWithoutModalOptionsInput>
    connectOrCreate?: TicketSetupsCreateOrConnectWithoutModalOptionsInput
    connect?: TicketSetupsWhereUniqueInput
  }

  export type TicketSetupsUpdateOneRequiredWithoutModalOptionsNestedInput = {
    create?: XOR<TicketSetupsCreateWithoutModalOptionsInput, TicketSetupsUncheckedCreateWithoutModalOptionsInput>
    connectOrCreate?: TicketSetupsCreateOrConnectWithoutModalOptionsInput
    upsert?: TicketSetupsUpsertWithoutModalOptionsInput
    connect?: TicketSetupsWhereUniqueInput
    update?: XOR<XOR<TicketSetupsUpdateToOneWithWhereWithoutModalOptionsInput, TicketSetupsUpdateWithoutModalOptionsInput>, TicketSetupsUncheckedUpdateWithoutModalOptionsInput>
  }

  export type TicketHandlersCreateAddedDiscordPermissionInput = {
    set: string[]
  }

  export type TicketHandlersCreateRemovedDiscordPermissionInput = {
    set: string[]
  }

  export type TicketHandlersUpdateAddedDiscordPermissionInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TicketHandlersUpdateRemovedDiscordPermissionInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TicketsCreateAddedMemberIdsInput = {
    set: string[]
  }

  export type TicketsCreateHandlersInput = {
    set: string[]
  }

  export type TicketsCreateTicketNotesInput = {
    set: string[]
  }

  export type TicketSetupsCreateNestedOneWithoutTicketsInput = {
    create?: XOR<TicketSetupsCreateWithoutTicketsInput, TicketSetupsUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: TicketSetupsCreateOrConnectWithoutTicketsInput
    connect?: TicketSetupsWhereUniqueInput
  }

  export type TicketFeedbackCreateNestedOneWithoutTicketInput = {
    create?: XOR<TicketFeedbackCreateWithoutTicketInput, TicketFeedbackUncheckedCreateWithoutTicketInput>
    connectOrCreate?: TicketFeedbackCreateOrConnectWithoutTicketInput
    connect?: TicketFeedbackWhereUniqueInput
  }

  export type TicketFeedbackUncheckedCreateNestedOneWithoutTicketInput = {
    create?: XOR<TicketFeedbackCreateWithoutTicketInput, TicketFeedbackUncheckedCreateWithoutTicketInput>
    connectOrCreate?: TicketFeedbackCreateOrConnectWithoutTicketInput
    connect?: TicketFeedbackWhereUniqueInput
  }

  export type TicketsUpdateAddedMemberIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TicketsUpdateHandlersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TicketsUpdateTicketNotesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TicketSetupsUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<TicketSetupsCreateWithoutTicketsInput, TicketSetupsUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: TicketSetupsCreateOrConnectWithoutTicketsInput
    upsert?: TicketSetupsUpsertWithoutTicketsInput
    connect?: TicketSetupsWhereUniqueInput
    update?: XOR<XOR<TicketSetupsUpdateToOneWithWhereWithoutTicketsInput, TicketSetupsUpdateWithoutTicketsInput>, TicketSetupsUncheckedUpdateWithoutTicketsInput>
  }

  export type TicketFeedbackUpdateOneWithoutTicketNestedInput = {
    create?: XOR<TicketFeedbackCreateWithoutTicketInput, TicketFeedbackUncheckedCreateWithoutTicketInput>
    connectOrCreate?: TicketFeedbackCreateOrConnectWithoutTicketInput
    upsert?: TicketFeedbackUpsertWithoutTicketInput
    disconnect?: TicketFeedbackWhereInput | boolean
    delete?: TicketFeedbackWhereInput | boolean
    connect?: TicketFeedbackWhereUniqueInput
    update?: XOR<XOR<TicketFeedbackUpdateToOneWithWhereWithoutTicketInput, TicketFeedbackUpdateWithoutTicketInput>, TicketFeedbackUncheckedUpdateWithoutTicketInput>
  }

  export type TicketFeedbackUncheckedUpdateOneWithoutTicketNestedInput = {
    create?: XOR<TicketFeedbackCreateWithoutTicketInput, TicketFeedbackUncheckedCreateWithoutTicketInput>
    connectOrCreate?: TicketFeedbackCreateOrConnectWithoutTicketInput
    upsert?: TicketFeedbackUpsertWithoutTicketInput
    disconnect?: TicketFeedbackWhereInput | boolean
    delete?: TicketFeedbackWhereInput | boolean
    connect?: TicketFeedbackWhereUniqueInput
    update?: XOR<XOR<TicketFeedbackUpdateToOneWithWhereWithoutTicketInput, TicketFeedbackUpdateWithoutTicketInput>, TicketFeedbackUncheckedUpdateWithoutTicketInput>
  }

  export type TicketsCreateNestedOneWithoutTicketFeedbackInput = {
    create?: XOR<TicketsCreateWithoutTicketFeedbackInput, TicketsUncheckedCreateWithoutTicketFeedbackInput>
    connectOrCreate?: TicketsCreateOrConnectWithoutTicketFeedbackInput
    connect?: TicketsWhereUniqueInput
  }

  export type TicketsUpdateOneRequiredWithoutTicketFeedbackNestedInput = {
    create?: XOR<TicketsCreateWithoutTicketFeedbackInput, TicketsUncheckedCreateWithoutTicketFeedbackInput>
    connectOrCreate?: TicketsCreateOrConnectWithoutTicketFeedbackInput
    upsert?: TicketsUpsertWithoutTicketFeedbackInput
    connect?: TicketsWhereUniqueInput
    update?: XOR<XOR<TicketsUpdateToOneWithWhereWithoutTicketFeedbackInput, TicketsUpdateWithoutTicketFeedbackInput>, TicketsUncheckedUpdateWithoutTicketFeedbackInput>
  }

  export type GuildsCreateNestedOneWithoutGuildFeatureToggleInput = {
    create?: XOR<GuildsCreateWithoutGuildFeatureToggleInput, GuildsUncheckedCreateWithoutGuildFeatureToggleInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutGuildFeatureToggleInput
    connect?: GuildsWhereUniqueInput
  }

  export type GuildsUpdateOneRequiredWithoutGuildFeatureToggleNestedInput = {
    create?: XOR<GuildsCreateWithoutGuildFeatureToggleInput, GuildsUncheckedCreateWithoutGuildFeatureToggleInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutGuildFeatureToggleInput
    upsert?: GuildsUpsertWithoutGuildFeatureToggleInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutGuildFeatureToggleInput, GuildsUpdateWithoutGuildFeatureToggleInput>, GuildsUncheckedUpdateWithoutGuildFeatureToggleInput>
  }

  export type TwitchNotificationsCreatePingRolesInput = {
    set: string[]
  }

  export type GuildsCreateNestedOneWithoutTwitchNotificationsInput = {
    create?: XOR<GuildsCreateWithoutTwitchNotificationsInput, GuildsUncheckedCreateWithoutTwitchNotificationsInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutTwitchNotificationsInput
    connect?: GuildsWhereUniqueInput
  }

  export type TwitchNotificationsUpdatePingRolesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GuildsUpdateOneRequiredWithoutTwitchNotificationsNestedInput = {
    create?: XOR<GuildsCreateWithoutTwitchNotificationsInput, GuildsUncheckedCreateWithoutTwitchNotificationsInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutTwitchNotificationsInput
    upsert?: GuildsUpsertWithoutTwitchNotificationsInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutTwitchNotificationsInput, GuildsUpdateWithoutTwitchNotificationsInput>, GuildsUncheckedUpdateWithoutTwitchNotificationsInput>
  }

  export type YoutubeNotificationsCreateLatestInput = {
    set: string[]
  }

  export type YoutubeNotificationsCreatePingRolesInput = {
    set: string[]
  }

  export type GuildsCreateNestedOneWithoutYoutubeNotificationsInput = {
    create?: XOR<GuildsCreateWithoutYoutubeNotificationsInput, GuildsUncheckedCreateWithoutYoutubeNotificationsInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutYoutubeNotificationsInput
    connect?: GuildsWhereUniqueInput
  }

  export type YoutubeNotificationsUpdateLatestInput = {
    set?: string[]
    push?: string | string[]
  }

  export type YoutubeNotificationsUpdatePingRolesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GuildsUpdateOneRequiredWithoutYoutubeNotificationsNestedInput = {
    create?: XOR<GuildsCreateWithoutYoutubeNotificationsInput, GuildsUncheckedCreateWithoutYoutubeNotificationsInput>
    connectOrCreate?: GuildsCreateOrConnectWithoutYoutubeNotificationsInput
    upsert?: GuildsUpsertWithoutYoutubeNotificationsInput
    connect?: GuildsWhereUniqueInput
    update?: XOR<XOR<GuildsUpdateToOneWithWhereWithoutYoutubeNotificationsInput, GuildsUpdateWithoutYoutubeNotificationsInput>, GuildsUncheckedUpdateWithoutYoutubeNotificationsInput>
  }

  export type ApisCreateNestedManyWithoutUsersInput = {
    create?: XOR<ApisCreateWithoutUsersInput, ApisUncheckedCreateWithoutUsersInput> | ApisCreateWithoutUsersInput[] | ApisUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ApisCreateOrConnectWithoutUsersInput | ApisCreateOrConnectWithoutUsersInput[]
    createMany?: ApisCreateManyUsersInputEnvelope
    connect?: ApisWhereUniqueInput | ApisWhereUniqueInput[]
  }

  export type GuildBackupsCreateNestedManyWithoutUsersInput = {
    create?: XOR<GuildBackupsCreateWithoutUsersInput, GuildBackupsUncheckedCreateWithoutUsersInput> | GuildBackupsCreateWithoutUsersInput[] | GuildBackupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: GuildBackupsCreateOrConnectWithoutUsersInput | GuildBackupsCreateOrConnectWithoutUsersInput[]
    createMany?: GuildBackupsCreateManyUsersInputEnvelope
    connect?: GuildBackupsWhereUniqueInput | GuildBackupsWhereUniqueInput[]
  }

  export type CustomersCreateNestedManyWithoutUsersInput = {
    create?: XOR<CustomersCreateWithoutUsersInput, CustomersUncheckedCreateWithoutUsersInput> | CustomersCreateWithoutUsersInput[] | CustomersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutUsersInput | CustomersCreateOrConnectWithoutUsersInput[]
    createMany?: CustomersCreateManyUsersInputEnvelope
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
  }

  export type DisBotUserNotificationsCreateNestedOneWithoutUsersInput = {
    create?: XOR<DisBotUserNotificationsCreateWithoutUsersInput, DisBotUserNotificationsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DisBotUserNotificationsCreateOrConnectWithoutUsersInput
    connect?: DisBotUserNotificationsWhereUniqueInput
  }

  export type VanitysCreateNestedManyWithoutUsersInput = {
    create?: XOR<VanitysCreateWithoutUsersInput, VanitysUncheckedCreateWithoutUsersInput> | VanitysCreateWithoutUsersInput[] | VanitysUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: VanitysCreateOrConnectWithoutUsersInput | VanitysCreateOrConnectWithoutUsersInput[]
    createMany?: VanitysCreateManyUsersInputEnvelope
    connect?: VanitysWhereUniqueInput | VanitysWhereUniqueInput[]
  }

  export type ApisUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ApisCreateWithoutUsersInput, ApisUncheckedCreateWithoutUsersInput> | ApisCreateWithoutUsersInput[] | ApisUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ApisCreateOrConnectWithoutUsersInput | ApisCreateOrConnectWithoutUsersInput[]
    createMany?: ApisCreateManyUsersInputEnvelope
    connect?: ApisWhereUniqueInput | ApisWhereUniqueInput[]
  }

  export type GuildBackupsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<GuildBackupsCreateWithoutUsersInput, GuildBackupsUncheckedCreateWithoutUsersInput> | GuildBackupsCreateWithoutUsersInput[] | GuildBackupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: GuildBackupsCreateOrConnectWithoutUsersInput | GuildBackupsCreateOrConnectWithoutUsersInput[]
    createMany?: GuildBackupsCreateManyUsersInputEnvelope
    connect?: GuildBackupsWhereUniqueInput | GuildBackupsWhereUniqueInput[]
  }

  export type CustomersUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<CustomersCreateWithoutUsersInput, CustomersUncheckedCreateWithoutUsersInput> | CustomersCreateWithoutUsersInput[] | CustomersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutUsersInput | CustomersCreateOrConnectWithoutUsersInput[]
    createMany?: CustomersCreateManyUsersInputEnvelope
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
  }

  export type DisBotUserNotificationsUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<DisBotUserNotificationsCreateWithoutUsersInput, DisBotUserNotificationsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DisBotUserNotificationsCreateOrConnectWithoutUsersInput
    connect?: DisBotUserNotificationsWhereUniqueInput
  }

  export type VanitysUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<VanitysCreateWithoutUsersInput, VanitysUncheckedCreateWithoutUsersInput> | VanitysCreateWithoutUsersInput[] | VanitysUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: VanitysCreateOrConnectWithoutUsersInput | VanitysCreateOrConnectWithoutUsersInput[]
    createMany?: VanitysCreateManyUsersInputEnvelope
    connect?: VanitysWhereUniqueInput | VanitysWhereUniqueInput[]
  }

  export type ApisUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ApisCreateWithoutUsersInput, ApisUncheckedCreateWithoutUsersInput> | ApisCreateWithoutUsersInput[] | ApisUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ApisCreateOrConnectWithoutUsersInput | ApisCreateOrConnectWithoutUsersInput[]
    upsert?: ApisUpsertWithWhereUniqueWithoutUsersInput | ApisUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ApisCreateManyUsersInputEnvelope
    set?: ApisWhereUniqueInput | ApisWhereUniqueInput[]
    disconnect?: ApisWhereUniqueInput | ApisWhereUniqueInput[]
    delete?: ApisWhereUniqueInput | ApisWhereUniqueInput[]
    connect?: ApisWhereUniqueInput | ApisWhereUniqueInput[]
    update?: ApisUpdateWithWhereUniqueWithoutUsersInput | ApisUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ApisUpdateManyWithWhereWithoutUsersInput | ApisUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ApisScalarWhereInput | ApisScalarWhereInput[]
  }

  export type GuildBackupsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<GuildBackupsCreateWithoutUsersInput, GuildBackupsUncheckedCreateWithoutUsersInput> | GuildBackupsCreateWithoutUsersInput[] | GuildBackupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: GuildBackupsCreateOrConnectWithoutUsersInput | GuildBackupsCreateOrConnectWithoutUsersInput[]
    upsert?: GuildBackupsUpsertWithWhereUniqueWithoutUsersInput | GuildBackupsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: GuildBackupsCreateManyUsersInputEnvelope
    set?: GuildBackupsWhereUniqueInput | GuildBackupsWhereUniqueInput[]
    disconnect?: GuildBackupsWhereUniqueInput | GuildBackupsWhereUniqueInput[]
    delete?: GuildBackupsWhereUniqueInput | GuildBackupsWhereUniqueInput[]
    connect?: GuildBackupsWhereUniqueInput | GuildBackupsWhereUniqueInput[]
    update?: GuildBackupsUpdateWithWhereUniqueWithoutUsersInput | GuildBackupsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: GuildBackupsUpdateManyWithWhereWithoutUsersInput | GuildBackupsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: GuildBackupsScalarWhereInput | GuildBackupsScalarWhereInput[]
  }

  export type CustomersUpdateManyWithoutUsersNestedInput = {
    create?: XOR<CustomersCreateWithoutUsersInput, CustomersUncheckedCreateWithoutUsersInput> | CustomersCreateWithoutUsersInput[] | CustomersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutUsersInput | CustomersCreateOrConnectWithoutUsersInput[]
    upsert?: CustomersUpsertWithWhereUniqueWithoutUsersInput | CustomersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: CustomersCreateManyUsersInputEnvelope
    set?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    disconnect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    delete?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    update?: CustomersUpdateWithWhereUniqueWithoutUsersInput | CustomersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: CustomersUpdateManyWithWhereWithoutUsersInput | CustomersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: CustomersScalarWhereInput | CustomersScalarWhereInput[]
  }

  export type DisBotUserNotificationsUpdateOneWithoutUsersNestedInput = {
    create?: XOR<DisBotUserNotificationsCreateWithoutUsersInput, DisBotUserNotificationsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DisBotUserNotificationsCreateOrConnectWithoutUsersInput
    upsert?: DisBotUserNotificationsUpsertWithoutUsersInput
    disconnect?: DisBotUserNotificationsWhereInput | boolean
    delete?: DisBotUserNotificationsWhereInput | boolean
    connect?: DisBotUserNotificationsWhereUniqueInput
    update?: XOR<XOR<DisBotUserNotificationsUpdateToOneWithWhereWithoutUsersInput, DisBotUserNotificationsUpdateWithoutUsersInput>, DisBotUserNotificationsUncheckedUpdateWithoutUsersInput>
  }

  export type VanitysUpdateManyWithoutUsersNestedInput = {
    create?: XOR<VanitysCreateWithoutUsersInput, VanitysUncheckedCreateWithoutUsersInput> | VanitysCreateWithoutUsersInput[] | VanitysUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: VanitysCreateOrConnectWithoutUsersInput | VanitysCreateOrConnectWithoutUsersInput[]
    upsert?: VanitysUpsertWithWhereUniqueWithoutUsersInput | VanitysUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: VanitysCreateManyUsersInputEnvelope
    set?: VanitysWhereUniqueInput | VanitysWhereUniqueInput[]
    disconnect?: VanitysWhereUniqueInput | VanitysWhereUniqueInput[]
    delete?: VanitysWhereUniqueInput | VanitysWhereUniqueInput[]
    connect?: VanitysWhereUniqueInput | VanitysWhereUniqueInput[]
    update?: VanitysUpdateWithWhereUniqueWithoutUsersInput | VanitysUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: VanitysUpdateManyWithWhereWithoutUsersInput | VanitysUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: VanitysScalarWhereInput | VanitysScalarWhereInput[]
  }

  export type ApisUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ApisCreateWithoutUsersInput, ApisUncheckedCreateWithoutUsersInput> | ApisCreateWithoutUsersInput[] | ApisUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ApisCreateOrConnectWithoutUsersInput | ApisCreateOrConnectWithoutUsersInput[]
    upsert?: ApisUpsertWithWhereUniqueWithoutUsersInput | ApisUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ApisCreateManyUsersInputEnvelope
    set?: ApisWhereUniqueInput | ApisWhereUniqueInput[]
    disconnect?: ApisWhereUniqueInput | ApisWhereUniqueInput[]
    delete?: ApisWhereUniqueInput | ApisWhereUniqueInput[]
    connect?: ApisWhereUniqueInput | ApisWhereUniqueInput[]
    update?: ApisUpdateWithWhereUniqueWithoutUsersInput | ApisUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ApisUpdateManyWithWhereWithoutUsersInput | ApisUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ApisScalarWhereInput | ApisScalarWhereInput[]
  }

  export type GuildBackupsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<GuildBackupsCreateWithoutUsersInput, GuildBackupsUncheckedCreateWithoutUsersInput> | GuildBackupsCreateWithoutUsersInput[] | GuildBackupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: GuildBackupsCreateOrConnectWithoutUsersInput | GuildBackupsCreateOrConnectWithoutUsersInput[]
    upsert?: GuildBackupsUpsertWithWhereUniqueWithoutUsersInput | GuildBackupsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: GuildBackupsCreateManyUsersInputEnvelope
    set?: GuildBackupsWhereUniqueInput | GuildBackupsWhereUniqueInput[]
    disconnect?: GuildBackupsWhereUniqueInput | GuildBackupsWhereUniqueInput[]
    delete?: GuildBackupsWhereUniqueInput | GuildBackupsWhereUniqueInput[]
    connect?: GuildBackupsWhereUniqueInput | GuildBackupsWhereUniqueInput[]
    update?: GuildBackupsUpdateWithWhereUniqueWithoutUsersInput | GuildBackupsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: GuildBackupsUpdateManyWithWhereWithoutUsersInput | GuildBackupsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: GuildBackupsScalarWhereInput | GuildBackupsScalarWhereInput[]
  }

  export type CustomersUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<CustomersCreateWithoutUsersInput, CustomersUncheckedCreateWithoutUsersInput> | CustomersCreateWithoutUsersInput[] | CustomersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutUsersInput | CustomersCreateOrConnectWithoutUsersInput[]
    upsert?: CustomersUpsertWithWhereUniqueWithoutUsersInput | CustomersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: CustomersCreateManyUsersInputEnvelope
    set?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    disconnect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    delete?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    update?: CustomersUpdateWithWhereUniqueWithoutUsersInput | CustomersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: CustomersUpdateManyWithWhereWithoutUsersInput | CustomersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: CustomersScalarWhereInput | CustomersScalarWhereInput[]
  }

  export type DisBotUserNotificationsUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<DisBotUserNotificationsCreateWithoutUsersInput, DisBotUserNotificationsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DisBotUserNotificationsCreateOrConnectWithoutUsersInput
    upsert?: DisBotUserNotificationsUpsertWithoutUsersInput
    disconnect?: DisBotUserNotificationsWhereInput | boolean
    delete?: DisBotUserNotificationsWhereInput | boolean
    connect?: DisBotUserNotificationsWhereUniqueInput
    update?: XOR<XOR<DisBotUserNotificationsUpdateToOneWithWhereWithoutUsersInput, DisBotUserNotificationsUpdateWithoutUsersInput>, DisBotUserNotificationsUncheckedUpdateWithoutUsersInput>
  }

  export type VanitysUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<VanitysCreateWithoutUsersInput, VanitysUncheckedCreateWithoutUsersInput> | VanitysCreateWithoutUsersInput[] | VanitysUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: VanitysCreateOrConnectWithoutUsersInput | VanitysCreateOrConnectWithoutUsersInput[]
    upsert?: VanitysUpsertWithWhereUniqueWithoutUsersInput | VanitysUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: VanitysCreateManyUsersInputEnvelope
    set?: VanitysWhereUniqueInput | VanitysWhereUniqueInput[]
    disconnect?: VanitysWhereUniqueInput | VanitysWhereUniqueInput[]
    delete?: VanitysWhereUniqueInput | VanitysWhereUniqueInput[]
    connect?: VanitysWhereUniqueInput | VanitysWhereUniqueInput[]
    update?: VanitysUpdateWithWhereUniqueWithoutUsersInput | VanitysUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: VanitysUpdateManyWithWhereWithoutUsersInput | VanitysUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: VanitysScalarWhereInput | VanitysScalarWhereInput[]
  }

  export type ApisCreateFlagsInput = {
    set: string[]
  }

  export type ApisCreateGuildsInput = {
    set: string[]
  }

  export type UsersCreateNestedOneWithoutApissInput = {
    create?: XOR<UsersCreateWithoutApissInput, UsersUncheckedCreateWithoutApissInput>
    connectOrCreate?: UsersCreateOrConnectWithoutApissInput
    connect?: UsersWhereUniqueInput
  }

  export type ApisUpdateFlagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ApisUpdateGuildsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UsersUpdateOneRequiredWithoutApissNestedInput = {
    create?: XOR<UsersCreateWithoutApissInput, UsersUncheckedCreateWithoutApissInput>
    connectOrCreate?: UsersCreateOrConnectWithoutApissInput
    upsert?: UsersUpsertWithoutApissInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutApissInput, UsersUpdateWithoutApissInput>, UsersUncheckedUpdateWithoutApissInput>
  }

  export type UsersCreateNestedOneWithoutGuildBackupsInput = {
    create?: XOR<UsersCreateWithoutGuildBackupsInput, UsersUncheckedCreateWithoutGuildBackupsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutGuildBackupsInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutGuildBackupsNestedInput = {
    create?: XOR<UsersCreateWithoutGuildBackupsInput, UsersUncheckedCreateWithoutGuildBackupsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutGuildBackupsInput
    upsert?: UsersUpsertWithoutGuildBackupsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutGuildBackupsInput, UsersUpdateWithoutGuildBackupsInput>, UsersUncheckedUpdateWithoutGuildBackupsInput>
  }

  export type BotStatusCreateEnvelopeInput = {
    set?: BotStatusCreateInput
  }

  export type BotStatusCreateInput = {
    Type: number
    Text: string
    Status: string
    URL: string
  }

  export type CustomersCreateGuildIdsInput = {
    set: string[]
  }

  export type UsersCreateNestedOneWithoutCustomersInput = {
    create?: XOR<UsersCreateWithoutCustomersInput, UsersUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCustomersInput
    connect?: UsersWhereUniqueInput
  }

  export type BotStatusUpdateEnvelopeInput = {
    set?: BotStatusCreateInput
    update?: BotStatusUpdateInput
  }

  export type CustomersUpdateGuildIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UsersUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<UsersCreateWithoutCustomersInput, UsersUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCustomersInput
    upsert?: UsersUpsertWithoutCustomersInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutCustomersInput, UsersUpdateWithoutCustomersInput>, UsersUncheckedUpdateWithoutCustomersInput>
  }

  export type VanityAnalyticsCreateNestedOneWithoutVanitysInput = {
    create?: XOR<VanityAnalyticsCreateWithoutVanitysInput, VanityAnalyticsUncheckedCreateWithoutVanitysInput>
    connectOrCreate?: VanityAnalyticsCreateOrConnectWithoutVanitysInput
    connect?: VanityAnalyticsWhereUniqueInput
  }

  export type VanityEmbedsCreateNestedOneWithoutVanitysInput = {
    create?: XOR<VanityEmbedsCreateWithoutVanitysInput, VanityEmbedsUncheckedCreateWithoutVanitysInput>
    connectOrCreate?: VanityEmbedsCreateOrConnectWithoutVanitysInput
    connect?: VanityEmbedsWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutVanitysInput = {
    create?: XOR<UsersCreateWithoutVanitysInput, UsersUncheckedCreateWithoutVanitysInput>
    connectOrCreate?: UsersCreateOrConnectWithoutVanitysInput
    connect?: UsersWhereUniqueInput
  }

  export type VanityAnalyticsUncheckedCreateNestedOneWithoutVanitysInput = {
    create?: XOR<VanityAnalyticsCreateWithoutVanitysInput, VanityAnalyticsUncheckedCreateWithoutVanitysInput>
    connectOrCreate?: VanityAnalyticsCreateOrConnectWithoutVanitysInput
    connect?: VanityAnalyticsWhereUniqueInput
  }

  export type VanityEmbedsUncheckedCreateNestedOneWithoutVanitysInput = {
    create?: XOR<VanityEmbedsCreateWithoutVanitysInput, VanityEmbedsUncheckedCreateWithoutVanitysInput>
    connectOrCreate?: VanityEmbedsCreateOrConnectWithoutVanitysInput
    connect?: VanityEmbedsWhereUniqueInput
  }

  export type VanityAnalyticsUpdateOneWithoutVanitysNestedInput = {
    create?: XOR<VanityAnalyticsCreateWithoutVanitysInput, VanityAnalyticsUncheckedCreateWithoutVanitysInput>
    connectOrCreate?: VanityAnalyticsCreateOrConnectWithoutVanitysInput
    upsert?: VanityAnalyticsUpsertWithoutVanitysInput
    disconnect?: VanityAnalyticsWhereInput | boolean
    delete?: VanityAnalyticsWhereInput | boolean
    connect?: VanityAnalyticsWhereUniqueInput
    update?: XOR<XOR<VanityAnalyticsUpdateToOneWithWhereWithoutVanitysInput, VanityAnalyticsUpdateWithoutVanitysInput>, VanityAnalyticsUncheckedUpdateWithoutVanitysInput>
  }

  export type VanityEmbedsUpdateOneWithoutVanitysNestedInput = {
    create?: XOR<VanityEmbedsCreateWithoutVanitysInput, VanityEmbedsUncheckedCreateWithoutVanitysInput>
    connectOrCreate?: VanityEmbedsCreateOrConnectWithoutVanitysInput
    upsert?: VanityEmbedsUpsertWithoutVanitysInput
    disconnect?: VanityEmbedsWhereInput | boolean
    delete?: VanityEmbedsWhereInput | boolean
    connect?: VanityEmbedsWhereUniqueInput
    update?: XOR<XOR<VanityEmbedsUpdateToOneWithWhereWithoutVanitysInput, VanityEmbedsUpdateWithoutVanitysInput>, VanityEmbedsUncheckedUpdateWithoutVanitysInput>
  }

  export type UsersUpdateOneRequiredWithoutVanitysNestedInput = {
    create?: XOR<UsersCreateWithoutVanitysInput, UsersUncheckedCreateWithoutVanitysInput>
    connectOrCreate?: UsersCreateOrConnectWithoutVanitysInput
    upsert?: UsersUpsertWithoutVanitysInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutVanitysInput, UsersUpdateWithoutVanitysInput>, UsersUncheckedUpdateWithoutVanitysInput>
  }

  export type VanityAnalyticsUncheckedUpdateOneWithoutVanitysNestedInput = {
    create?: XOR<VanityAnalyticsCreateWithoutVanitysInput, VanityAnalyticsUncheckedCreateWithoutVanitysInput>
    connectOrCreate?: VanityAnalyticsCreateOrConnectWithoutVanitysInput
    upsert?: VanityAnalyticsUpsertWithoutVanitysInput
    disconnect?: VanityAnalyticsWhereInput | boolean
    delete?: VanityAnalyticsWhereInput | boolean
    connect?: VanityAnalyticsWhereUniqueInput
    update?: XOR<XOR<VanityAnalyticsUpdateToOneWithWhereWithoutVanitysInput, VanityAnalyticsUpdateWithoutVanitysInput>, VanityAnalyticsUncheckedUpdateWithoutVanitysInput>
  }

  export type VanityEmbedsUncheckedUpdateOneWithoutVanitysNestedInput = {
    create?: XOR<VanityEmbedsCreateWithoutVanitysInput, VanityEmbedsUncheckedCreateWithoutVanitysInput>
    connectOrCreate?: VanityEmbedsCreateOrConnectWithoutVanitysInput
    upsert?: VanityEmbedsUpsertWithoutVanitysInput
    disconnect?: VanityEmbedsWhereInput | boolean
    delete?: VanityEmbedsWhereInput | boolean
    connect?: VanityEmbedsWhereUniqueInput
    update?: XOR<XOR<VanityEmbedsUpdateToOneWithWhereWithoutVanitysInput, VanityEmbedsUpdateWithoutVanitysInput>, VanityEmbedsUncheckedUpdateWithoutVanitysInput>
  }

  export type VanityEmbedAuthorsCreateNestedOneWithoutVanityEmbedsInput = {
    create?: XOR<VanityEmbedAuthorsCreateWithoutVanityEmbedsInput, VanityEmbedAuthorsUncheckedCreateWithoutVanityEmbedsInput>
    connectOrCreate?: VanityEmbedAuthorsCreateOrConnectWithoutVanityEmbedsInput
    connect?: VanityEmbedAuthorsWhereUniqueInput
  }

  export type VanitysCreateNestedOneWithoutEmbedInput = {
    create?: XOR<VanitysCreateWithoutEmbedInput, VanitysUncheckedCreateWithoutEmbedInput>
    connectOrCreate?: VanitysCreateOrConnectWithoutEmbedInput
    connect?: VanitysWhereUniqueInput
  }

  export type VanityEmbedAuthorsUncheckedCreateNestedOneWithoutVanityEmbedsInput = {
    create?: XOR<VanityEmbedAuthorsCreateWithoutVanityEmbedsInput, VanityEmbedAuthorsUncheckedCreateWithoutVanityEmbedsInput>
    connectOrCreate?: VanityEmbedAuthorsCreateOrConnectWithoutVanityEmbedsInput
    connect?: VanityEmbedAuthorsWhereUniqueInput
  }

  export type VanityEmbedAuthorsUpdateOneWithoutVanityEmbedsNestedInput = {
    create?: XOR<VanityEmbedAuthorsCreateWithoutVanityEmbedsInput, VanityEmbedAuthorsUncheckedCreateWithoutVanityEmbedsInput>
    connectOrCreate?: VanityEmbedAuthorsCreateOrConnectWithoutVanityEmbedsInput
    upsert?: VanityEmbedAuthorsUpsertWithoutVanityEmbedsInput
    disconnect?: VanityEmbedAuthorsWhereInput | boolean
    delete?: VanityEmbedAuthorsWhereInput | boolean
    connect?: VanityEmbedAuthorsWhereUniqueInput
    update?: XOR<XOR<VanityEmbedAuthorsUpdateToOneWithWhereWithoutVanityEmbedsInput, VanityEmbedAuthorsUpdateWithoutVanityEmbedsInput>, VanityEmbedAuthorsUncheckedUpdateWithoutVanityEmbedsInput>
  }

  export type VanitysUpdateOneRequiredWithoutEmbedNestedInput = {
    create?: XOR<VanitysCreateWithoutEmbedInput, VanitysUncheckedCreateWithoutEmbedInput>
    connectOrCreate?: VanitysCreateOrConnectWithoutEmbedInput
    upsert?: VanitysUpsertWithoutEmbedInput
    connect?: VanitysWhereUniqueInput
    update?: XOR<XOR<VanitysUpdateToOneWithWhereWithoutEmbedInput, VanitysUpdateWithoutEmbedInput>, VanitysUncheckedUpdateWithoutEmbedInput>
  }

  export type VanityEmbedAuthorsUncheckedUpdateOneWithoutVanityEmbedsNestedInput = {
    create?: XOR<VanityEmbedAuthorsCreateWithoutVanityEmbedsInput, VanityEmbedAuthorsUncheckedCreateWithoutVanityEmbedsInput>
    connectOrCreate?: VanityEmbedAuthorsCreateOrConnectWithoutVanityEmbedsInput
    upsert?: VanityEmbedAuthorsUpsertWithoutVanityEmbedsInput
    disconnect?: VanityEmbedAuthorsWhereInput | boolean
    delete?: VanityEmbedAuthorsWhereInput | boolean
    connect?: VanityEmbedAuthorsWhereUniqueInput
    update?: XOR<XOR<VanityEmbedAuthorsUpdateToOneWithWhereWithoutVanityEmbedsInput, VanityEmbedAuthorsUpdateWithoutVanityEmbedsInput>, VanityEmbedAuthorsUncheckedUpdateWithoutVanityEmbedsInput>
  }

  export type VanityEmbedsCreateNestedOneWithoutAuthorInput = {
    create?: XOR<VanityEmbedsCreateWithoutAuthorInput, VanityEmbedsUncheckedCreateWithoutAuthorInput>
    connectOrCreate?: VanityEmbedsCreateOrConnectWithoutAuthorInput
    connect?: VanityEmbedsWhereUniqueInput
  }

  export type VanityEmbedsUpdateOneRequiredWithoutAuthorNestedInput = {
    create?: XOR<VanityEmbedsCreateWithoutAuthorInput, VanityEmbedsUncheckedCreateWithoutAuthorInput>
    connectOrCreate?: VanityEmbedsCreateOrConnectWithoutAuthorInput
    upsert?: VanityEmbedsUpsertWithoutAuthorInput
    connect?: VanityEmbedsWhereUniqueInput
    update?: XOR<XOR<VanityEmbedsUpdateToOneWithWhereWithoutAuthorInput, VanityEmbedsUpdateWithoutAuthorInput>, VanityEmbedsUncheckedUpdateWithoutAuthorInput>
  }

  export type VanityAnalyticsCreateLoggedIPsInput = {
    set: string[]
  }

  export type AnalyticsLatest30DaysCreateNestedOneWithoutVanityAnalyticsInput = {
    create?: XOR<AnalyticsLatest30DaysCreateWithoutVanityAnalyticsInput, AnalyticsLatest30DaysUncheckedCreateWithoutVanityAnalyticsInput>
    connectOrCreate?: AnalyticsLatest30DaysCreateOrConnectWithoutVanityAnalyticsInput
    connect?: AnalyticsLatest30DaysWhereUniqueInput
  }

  export type VanitysCreateNestedOneWithoutAnalyticsInput = {
    create?: XOR<VanitysCreateWithoutAnalyticsInput, VanitysUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: VanitysCreateOrConnectWithoutAnalyticsInput
    connect?: VanitysWhereUniqueInput
  }

  export type AnalyticsLatest30DaysUncheckedCreateNestedOneWithoutVanityAnalyticsInput = {
    create?: XOR<AnalyticsLatest30DaysCreateWithoutVanityAnalyticsInput, AnalyticsLatest30DaysUncheckedCreateWithoutVanityAnalyticsInput>
    connectOrCreate?: AnalyticsLatest30DaysCreateOrConnectWithoutVanityAnalyticsInput
    connect?: AnalyticsLatest30DaysWhereUniqueInput
  }

  export type VanityAnalyticsUpdateLoggedIPsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AnalyticsLatest30DaysUpdateOneWithoutVanityAnalyticsNestedInput = {
    create?: XOR<AnalyticsLatest30DaysCreateWithoutVanityAnalyticsInput, AnalyticsLatest30DaysUncheckedCreateWithoutVanityAnalyticsInput>
    connectOrCreate?: AnalyticsLatest30DaysCreateOrConnectWithoutVanityAnalyticsInput
    upsert?: AnalyticsLatest30DaysUpsertWithoutVanityAnalyticsInput
    disconnect?: AnalyticsLatest30DaysWhereInput | boolean
    delete?: AnalyticsLatest30DaysWhereInput | boolean
    connect?: AnalyticsLatest30DaysWhereUniqueInput
    update?: XOR<XOR<AnalyticsLatest30DaysUpdateToOneWithWhereWithoutVanityAnalyticsInput, AnalyticsLatest30DaysUpdateWithoutVanityAnalyticsInput>, AnalyticsLatest30DaysUncheckedUpdateWithoutVanityAnalyticsInput>
  }

  export type VanitysUpdateOneRequiredWithoutAnalyticsNestedInput = {
    create?: XOR<VanitysCreateWithoutAnalyticsInput, VanitysUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: VanitysCreateOrConnectWithoutAnalyticsInput
    upsert?: VanitysUpsertWithoutAnalyticsInput
    connect?: VanitysWhereUniqueInput
    update?: XOR<XOR<VanitysUpdateToOneWithWhereWithoutAnalyticsInput, VanitysUpdateWithoutAnalyticsInput>, VanitysUncheckedUpdateWithoutAnalyticsInput>
  }

  export type AnalyticsLatest30DaysUncheckedUpdateOneWithoutVanityAnalyticsNestedInput = {
    create?: XOR<AnalyticsLatest30DaysCreateWithoutVanityAnalyticsInput, AnalyticsLatest30DaysUncheckedCreateWithoutVanityAnalyticsInput>
    connectOrCreate?: AnalyticsLatest30DaysCreateOrConnectWithoutVanityAnalyticsInput
    upsert?: AnalyticsLatest30DaysUpsertWithoutVanityAnalyticsInput
    disconnect?: AnalyticsLatest30DaysWhereInput | boolean
    delete?: AnalyticsLatest30DaysWhereInput | boolean
    connect?: AnalyticsLatest30DaysWhereUniqueInput
    update?: XOR<XOR<AnalyticsLatest30DaysUpdateToOneWithWhereWithoutVanityAnalyticsInput, AnalyticsLatest30DaysUpdateWithoutVanityAnalyticsInput>, AnalyticsLatest30DaysUncheckedUpdateWithoutVanityAnalyticsInput>
  }

  export type VanityAnalyticsCreateNestedOneWithoutLatest30DaysInput = {
    create?: XOR<VanityAnalyticsCreateWithoutLatest30DaysInput, VanityAnalyticsUncheckedCreateWithoutLatest30DaysInput>
    connectOrCreate?: VanityAnalyticsCreateOrConnectWithoutLatest30DaysInput
    connect?: VanityAnalyticsWhereUniqueInput
  }

  export type VanityAnalyticsUpdateOneRequiredWithoutLatest30DaysNestedInput = {
    create?: XOR<VanityAnalyticsCreateWithoutLatest30DaysInput, VanityAnalyticsUncheckedCreateWithoutLatest30DaysInput>
    connectOrCreate?: VanityAnalyticsCreateOrConnectWithoutLatest30DaysInput
    upsert?: VanityAnalyticsUpsertWithoutLatest30DaysInput
    connect?: VanityAnalyticsWhereUniqueInput
    update?: XOR<XOR<VanityAnalyticsUpdateToOneWithWhereWithoutLatest30DaysInput, VanityAnalyticsUpdateWithoutLatest30DaysInput>, VanityAnalyticsUncheckedUpdateWithoutLatest30DaysInput>
  }

  export type UsersCreateNestedOneWithoutDisBotUserNotificationsInput = {
    create?: XOR<UsersCreateWithoutDisBotUserNotificationsInput, UsersUncheckedCreateWithoutDisBotUserNotificationsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutDisBotUserNotificationsInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutDisBotUserNotificationsNestedInput = {
    create?: XOR<UsersCreateWithoutDisBotUserNotificationsInput, UsersUncheckedCreateWithoutDisBotUserNotificationsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutDisBotUserNotificationsInput
    upsert?: UsersUpsertWithoutDisBotUserNotificationsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutDisBotUserNotificationsInput, UsersUpdateWithoutDisBotUserNotificationsInput>, UsersUncheckedUpdateWithoutDisBotUserNotificationsInput>
  }

  export type DisbotsLogsListCreateEnvelopeInput = {
    set?: DisbotsLogsCreateInput | DisbotsLogsCreateInput[]
  }

  export type DisbotsLogsCreateInput = {
    Action: string
    BotType: string
    ChannelId: string
    GuildId: string
    Label: string
    Level: string
    Message: string
    MessageId: string
    Timestamp: string
    UUID: string
    UserId: string
  }

  export type DisbotsLogsListUpdateEnvelopeInput = {
    set?: DisbotsLogsCreateInput | DisbotsLogsCreateInput[]
    push?: DisbotsLogsCreateInput | DisbotsLogsCreateInput[]
    updateMany?: DisbotsLogsUpdateManyInput
    deleteMany?: DisbotsLogsDeleteManyInput
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type WelcomeLeaveImageDataWhereInput = {
    AND?: WelcomeLeaveImageDataWhereInput | WelcomeLeaveImageDataWhereInput[]
    OR?: WelcomeLeaveImageDataWhereInput[]
    NOT?: WelcomeLeaveImageDataWhereInput | WelcomeLeaveImageDataWhereInput[]
    Title?: StringFilter<"WelcomeLeaveImageData"> | string
    Text?: StringFilter<"WelcomeLeaveImageData"> | string
    Subtitle?: StringFilter<"WelcomeLeaveImageData"> | string
    Background?: StringFilter<"WelcomeLeaveImageData"> | string
    Theme?: StringFilter<"WelcomeLeaveImageData"> | string
    Color?: StringFilter<"WelcomeLeaveImageData"> | string
    Gradient?: StringFilter<"WelcomeLeaveImageData"> | string
  }

  export type PermissionDataWhereInput = {
    AND?: PermissionDataWhereInput | PermissionDataWhereInput[]
    OR?: PermissionDataWhereInput[]
    NOT?: PermissionDataWhereInput | PermissionDataWhereInput[]
    RoleId?: StringFilter<"PermissionData"> | string
    Type?: StringFilter<"PermissionData"> | string
  }

  export type ReactionRoleButtonWhereInput = {
    AND?: ReactionRoleButtonWhereInput | ReactionRoleButtonWhereInput[]
    OR?: ReactionRoleButtonWhereInput[]
    NOT?: ReactionRoleButtonWhereInput | ReactionRoleButtonWhereInput[]
    Emoji?: StringFilter<"ReactionRoleButton"> | string
    Type?: StringFilter<"ReactionRoleButton"> | string
    Label?: StringFilter<"ReactionRoleButton"> | string
  }

  export type ReactionRoleSelectmenuWhereInput = {
    AND?: ReactionRoleSelectmenuWhereInput | ReactionRoleSelectmenuWhereInput[]
    OR?: ReactionRoleSelectmenuWhereInput[]
    NOT?: ReactionRoleSelectmenuWhereInput | ReactionRoleSelectmenuWhereInput[]
    Emoji?: StringFilter<"ReactionRoleSelectmenu"> | string
    Label?: StringFilter<"ReactionRoleSelectmenu"> | string
    Description?: StringFilter<"ReactionRoleSelectmenu"> | string
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type BotStatusWhereInput = {
    AND?: BotStatusWhereInput | BotStatusWhereInput[]
    OR?: BotStatusWhereInput[]
    NOT?: BotStatusWhereInput | BotStatusWhereInput[]
    Type?: IntFilter<"BotStatus"> | number
    Text?: StringFilter<"BotStatus"> | string
    Status?: StringFilter<"BotStatus"> | string
    URL?: StringFilter<"BotStatus"> | string
  }

  export type DisbotsLogsWhereInput = {
    AND?: DisbotsLogsWhereInput | DisbotsLogsWhereInput[]
    OR?: DisbotsLogsWhereInput[]
    NOT?: DisbotsLogsWhereInput | DisbotsLogsWhereInput[]
    Action?: StringFilter<"DisbotsLogs"> | string
    BotType?: StringFilter<"DisbotsLogs"> | string
    ChannelId?: StringFilter<"DisbotsLogs"> | string
    GuildId?: StringFilter<"DisbotsLogs"> | string
    Label?: StringFilter<"DisbotsLogs"> | string
    Level?: StringFilter<"DisbotsLogs"> | string
    Message?: StringFilter<"DisbotsLogs"> | string
    MessageId?: StringFilter<"DisbotsLogs"> | string
    Timestamp?: StringFilter<"DisbotsLogs"> | string
    UUID?: StringFilter<"DisbotsLogs"> | string
    UserId?: StringFilter<"DisbotsLogs"> | string
  }

  export type AutoDeletesCreateWithoutGuildsInput = {
    id?: string
    ChannelId?: string | null
    IsActive?: boolean | null
    Time?: string | null
    UUID?: string | null
    WhitelistedMessages?: AutoDeletesCreateWhitelistedMessagesInput | string[]
    WhitelistedRoles?: AutoDeletesCreateWhitelistedRolesInput | string[]
    WhitelistedUsers?: AutoDeletesCreateWhitelistedUsersInput | string[]
  }

  export type AutoDeletesUncheckedCreateWithoutGuildsInput = {
    id?: string
    ChannelId?: string | null
    IsActive?: boolean | null
    Time?: string | null
    UUID?: string | null
    WhitelistedMessages?: AutoDeletesCreateWhitelistedMessagesInput | string[]
    WhitelistedRoles?: AutoDeletesCreateWhitelistedRolesInput | string[]
    WhitelistedUsers?: AutoDeletesCreateWhitelistedUsersInput | string[]
  }

  export type AutoDeletesCreateOrConnectWithoutGuildsInput = {
    where: AutoDeletesWhereUniqueInput
    create: XOR<AutoDeletesCreateWithoutGuildsInput, AutoDeletesUncheckedCreateWithoutGuildsInput>
  }

  export type AutoDeletesCreateManyGuildsInputEnvelope = {
    data: AutoDeletesCreateManyGuildsInput | AutoDeletesCreateManyGuildsInput[]
  }

  export type AutoPublishCreateWithoutGuildsInput = {
    id?: string
    Channels?: AutoPublishCreateChannelsInput | string[]
  }

  export type AutoPublishUncheckedCreateWithoutGuildsInput = {
    id?: string
    Channels?: AutoPublishCreateChannelsInput | string[]
  }

  export type AutoPublishCreateOrConnectWithoutGuildsInput = {
    where: AutoPublishWhereUniqueInput
    create: XOR<AutoPublishCreateWithoutGuildsInput, AutoPublishUncheckedCreateWithoutGuildsInput>
  }

  export type AutoReactsCreateWithoutGuildsInput = {
    id?: string
    ChannelId: string
    Emoji: string
  }

  export type AutoReactsUncheckedCreateWithoutGuildsInput = {
    id?: string
    ChannelId: string
    Emoji: string
  }

  export type AutoReactsCreateOrConnectWithoutGuildsInput = {
    where: AutoReactsWhereUniqueInput
    create: XOR<AutoReactsCreateWithoutGuildsInput, AutoReactsUncheckedCreateWithoutGuildsInput>
  }

  export type AutoReactsCreateManyGuildsInputEnvelope = {
    data: AutoReactsCreateManyGuildsInput | AutoReactsCreateManyGuildsInput[]
  }

  export type AutoRolesCreateWithoutGuildsInput = {
    id?: string
    RoleId: string
  }

  export type AutoRolesUncheckedCreateWithoutGuildsInput = {
    id?: string
    RoleId: string
  }

  export type AutoRolesCreateOrConnectWithoutGuildsInput = {
    where: AutoRolesWhereUniqueInput
    create: XOR<AutoRolesCreateWithoutGuildsInput, AutoRolesUncheckedCreateWithoutGuildsInput>
  }

  export type AutoRolesCreateManyGuildsInputEnvelope = {
    data: AutoRolesCreateManyGuildsInput | AutoRolesCreateManyGuildsInput[]
  }

  export type GuildBansCreateWithoutGuildsInput = {
    id?: string
    UUID: string
    Time?: string | null
    UserId?: GuildBansCreateUserIdInput | string[]
    Reason?: string | null
    ModeratorId?: string | null
    DmMessage?: string | null
    Banned?: boolean | null
    CreatedAt?: Date | string | null
  }

  export type GuildBansUncheckedCreateWithoutGuildsInput = {
    id?: string
    UUID: string
    Time?: string | null
    UserId?: GuildBansCreateUserIdInput | string[]
    Reason?: string | null
    ModeratorId?: string | null
    DmMessage?: string | null
    Banned?: boolean | null
    CreatedAt?: Date | string | null
  }

  export type GuildBansCreateOrConnectWithoutGuildsInput = {
    where: GuildBansWhereUniqueInput
    create: XOR<GuildBansCreateWithoutGuildsInput, GuildBansUncheckedCreateWithoutGuildsInput>
  }

  export type GuildBansCreateManyGuildsInputEnvelope = {
    data: GuildBansCreateManyGuildsInput | GuildBansCreateManyGuildsInput[]
  }

  export type ChatModerationsCreateWithoutGuildsInput = {
    id?: string
    LogChannelId: string
    Words?: ChatModerationsCreateWordsInput | string[]
    WhiteListRole?: ChatModerationsCreateWhiteListRoleInput | string[]
    WhiteListChannel?: ChatModerationsCreateWhiteListChannelInput | string[]
  }

  export type ChatModerationsUncheckedCreateWithoutGuildsInput = {
    id?: string
    LogChannelId: string
    Words?: ChatModerationsCreateWordsInput | string[]
    WhiteListRole?: ChatModerationsCreateWhiteListRoleInput | string[]
    WhiteListChannel?: ChatModerationsCreateWhiteListChannelInput | string[]
  }

  export type ChatModerationsCreateOrConnectWithoutGuildsInput = {
    where: ChatModerationsWhereUniqueInput
    create: XOR<ChatModerationsCreateWithoutGuildsInput, ChatModerationsUncheckedCreateWithoutGuildsInput>
  }

  export type ChannelLinksCreateWithoutGuildsInput = {
    id?: string
    UUID: string
    ChannelId: string
    WebhookUrls?: ChannelLinksCreateWebhookUrlsInput | string[]
    SyncedChannelLinkMessage?: SyncedChannelLinkMessagesCreateNestedManyWithoutChannelLinksInput
  }

  export type ChannelLinksUncheckedCreateWithoutGuildsInput = {
    id?: string
    UUID: string
    ChannelId: string
    WebhookUrls?: ChannelLinksCreateWebhookUrlsInput | string[]
    SyncedChannelLinkMessage?: SyncedChannelLinkMessagesUncheckedCreateNestedManyWithoutChannelLinksInput
  }

  export type ChannelLinksCreateOrConnectWithoutGuildsInput = {
    where: ChannelLinksWhereUniqueInput
    create: XOR<ChannelLinksCreateWithoutGuildsInput, ChannelLinksUncheckedCreateWithoutGuildsInput>
  }

  export type ChannelLinksCreateManyGuildsInputEnvelope = {
    data: ChannelLinksCreateManyGuildsInput | ChannelLinksCreateManyGuildsInput[]
  }

  export type DiscordAddonsCreateWithoutGuildsInput = {
    id?: string
    OnlyMedia?: DiscordAddonsCreateOnlyMediaInput | string[]
    NoLinkEmbeds?: DiscordAddonsCreateNoLinkEmbedsInput | string[]
    InvitesPaused: boolean
  }

  export type DiscordAddonsUncheckedCreateWithoutGuildsInput = {
    id?: string
    OnlyMedia?: DiscordAddonsCreateOnlyMediaInput | string[]
    NoLinkEmbeds?: DiscordAddonsCreateNoLinkEmbedsInput | string[]
    InvitesPaused: boolean
  }

  export type DiscordAddonsCreateOrConnectWithoutGuildsInput = {
    where: DiscordAddonsWhereUniqueInput
    create: XOR<DiscordAddonsCreateWithoutGuildsInput, DiscordAddonsUncheckedCreateWithoutGuildsInput>
  }

  export type GiveawaysCreateWithoutGuildsInput = {
    id?: string
    UUID: string
    MessageId: string
    ChannelId?: string | null
    Prize: string
    Winners: number
    Time: string
    CreatedAt: Date | string
    Ended: boolean
    EndedAt?: Date | string | null
    EndedBy?: string | null
    Paused: boolean
    EndedMessage?: string | null
    Rerolled: boolean
    WinnerIds?: GiveawaysCreateWinnerIdsInput | string[]
    WinnerMessageTemplate?: string | null
    HostedBy: string
    MessageTemplate?: string | null
    Content?: string | null
    Entrys?: GiveawaysCreateEntrysInput | string[]
    Requirements?: GiveawaysCreateRequirementsInput | string[]
  }

  export type GiveawaysUncheckedCreateWithoutGuildsInput = {
    id?: string
    UUID: string
    MessageId: string
    ChannelId?: string | null
    Prize: string
    Winners: number
    Time: string
    CreatedAt: Date | string
    Ended: boolean
    EndedAt?: Date | string | null
    EndedBy?: string | null
    Paused: boolean
    EndedMessage?: string | null
    Rerolled: boolean
    WinnerIds?: GiveawaysCreateWinnerIdsInput | string[]
    WinnerMessageTemplate?: string | null
    HostedBy: string
    MessageTemplate?: string | null
    Content?: string | null
    Entrys?: GiveawaysCreateEntrysInput | string[]
    Requirements?: GiveawaysCreateRequirementsInput | string[]
  }

  export type GiveawaysCreateOrConnectWithoutGuildsInput = {
    where: GiveawaysWhereUniqueInput
    create: XOR<GiveawaysCreateWithoutGuildsInput, GiveawaysUncheckedCreateWithoutGuildsInput>
  }

  export type GiveawaysCreateManyGuildsInputEnvelope = {
    data: GiveawaysCreateManyGuildsInput | GiveawaysCreateManyGuildsInput[]
  }

  export type TempVoicesCreateWithoutGuildsInput = {
    id?: string
    UUID: string
    Name: string
    JointoCreateChannel: string
    JointoCreateCategory: string
    Manage: boolean
    PresetLimit: number
    TempVoiceChannels?: TempVoiceChannelsCreateNestedManyWithoutTempVoicesInput
  }

  export type TempVoicesUncheckedCreateWithoutGuildsInput = {
    id?: string
    UUID: string
    Name: string
    JointoCreateChannel: string
    JointoCreateCategory: string
    Manage: boolean
    PresetLimit: number
    TempVoiceChannels?: TempVoiceChannelsUncheckedCreateNestedManyWithoutTempVoicesInput
  }

  export type TempVoicesCreateOrConnectWithoutGuildsInput = {
    where: TempVoicesWhereUniqueInput
    create: XOR<TempVoicesCreateWithoutGuildsInput, TempVoicesUncheckedCreateWithoutGuildsInput>
  }

  export type TempVoicesCreateManyGuildsInputEnvelope = {
    data: TempVoicesCreateManyGuildsInput | TempVoicesCreateManyGuildsInput[]
  }

  export type GuildLeaveSetupsCreateWithoutGuildsInput = {
    id?: string
    MessageTemplateId?: string | null
    ChannelId: string
    Image?: boolean | null
    ImageData?: XOR<WelcomeLeaveImageDataNullableCreateEnvelopeInput, WelcomeLeaveImageDataCreateInput> | null
  }

  export type GuildLeaveSetupsUncheckedCreateWithoutGuildsInput = {
    id?: string
    MessageTemplateId?: string | null
    ChannelId: string
    Image?: boolean | null
    ImageData?: XOR<WelcomeLeaveImageDataNullableCreateEnvelopeInput, WelcomeLeaveImageDataCreateInput> | null
  }

  export type GuildLeaveSetupsCreateOrConnectWithoutGuildsInput = {
    where: GuildLeaveSetupsWhereUniqueInput
    create: XOR<GuildLeaveSetupsCreateWithoutGuildsInput, GuildLeaveSetupsUncheckedCreateWithoutGuildsInput>
  }

  export type GuildLoggingsCreateWithoutGuildsInput = {
    id?: string
    AutoMod?: string | null
    Channel?: string | null
    Emoji?: string | null
    Guild?: string | null
    Integration?: string | null
    Invite?: string | null
    Member?: string | null
    Message?: string | null
    Moderation?: string | null
    Reaction?: string | null
    Role?: string | null
    SoundBoard?: string | null
    Sticker?: string | null
    Thread?: string | null
    Voice?: string | null
    Webhook?: string | null
    Ban?: string | null
    Kick?: string | null
    Poll?: string | null
    Stage?: string | null
    Event?: string | null
  }

  export type GuildLoggingsUncheckedCreateWithoutGuildsInput = {
    id?: string
    AutoMod?: string | null
    Channel?: string | null
    Emoji?: string | null
    Guild?: string | null
    Integration?: string | null
    Invite?: string | null
    Member?: string | null
    Message?: string | null
    Moderation?: string | null
    Reaction?: string | null
    Role?: string | null
    SoundBoard?: string | null
    Sticker?: string | null
    Thread?: string | null
    Voice?: string | null
    Webhook?: string | null
    Ban?: string | null
    Kick?: string | null
    Poll?: string | null
    Stage?: string | null
    Event?: string | null
  }

  export type GuildLoggingsCreateOrConnectWithoutGuildsInput = {
    where: GuildLoggingsWhereUniqueInput
    create: XOR<GuildLoggingsCreateWithoutGuildsInput, GuildLoggingsUncheckedCreateWithoutGuildsInput>
  }

  export type MessageTemplatesCreateWithoutGuildsInput = {
    id?: string
    Content?: string | null
    EmbedJSON?: string | null
    OtherEmbeds?: MessageTemplatesCreateOtherEmbedsInput | string[]
    Name: string
  }

  export type MessageTemplatesUncheckedCreateWithoutGuildsInput = {
    id?: string
    Content?: string | null
    EmbedJSON?: string | null
    OtherEmbeds?: MessageTemplatesCreateOtherEmbedsInput | string[]
    Name: string
  }

  export type MessageTemplatesCreateOrConnectWithoutGuildsInput = {
    where: MessageTemplatesWhereUniqueInput
    create: XOR<MessageTemplatesCreateWithoutGuildsInput, MessageTemplatesUncheckedCreateWithoutGuildsInput>
  }

  export type MessageTemplatesCreateManyGuildsInputEnvelope = {
    data: MessageTemplatesCreateManyGuildsInput | MessageTemplatesCreateManyGuildsInput[]
  }

  export type PermissionsCreateWithoutGuildsInput = {
    id?: string
    Permissions?: XOR<PermissionDataListCreateEnvelopeInput, PermissionDataCreateInput> | PermissionDataCreateInput[]
  }

  export type PermissionsUncheckedCreateWithoutGuildsInput = {
    id?: string
    Permissions?: XOR<PermissionDataListCreateEnvelopeInput, PermissionDataCreateInput> | PermissionDataCreateInput[]
  }

  export type PermissionsCreateOrConnectWithoutGuildsInput = {
    where: PermissionsWhereUniqueInput
    create: XOR<PermissionsCreateWithoutGuildsInput, PermissionsUncheckedCreateWithoutGuildsInput>
  }

  export type ReactionRolesCreateWithoutGuildsInput = {
    id?: string
    UUID: string
    Roles?: ReactionRolesCreateRolesInput | string[]
    MessageId?: string | null
    ChannelId?: string | null
    AddMessage?: string | null
    RemoveMessage?: string | null
    Button?: XOR<ReactionRoleButtonNullableCreateEnvelopeInput, ReactionRoleButtonCreateInput> | null
    SelectMenu?: XOR<ReactionRoleSelectmenuNullableCreateEnvelopeInput, ReactionRoleSelectmenuCreateInput> | null
    Emoji?: string | null
  }

  export type ReactionRolesUncheckedCreateWithoutGuildsInput = {
    id?: string
    UUID: string
    Roles?: ReactionRolesCreateRolesInput | string[]
    MessageId?: string | null
    ChannelId?: string | null
    AddMessage?: string | null
    RemoveMessage?: string | null
    Button?: XOR<ReactionRoleButtonNullableCreateEnvelopeInput, ReactionRoleButtonCreateInput> | null
    SelectMenu?: XOR<ReactionRoleSelectmenuNullableCreateEnvelopeInput, ReactionRoleSelectmenuCreateInput> | null
    Emoji?: string | null
  }

  export type ReactionRolesCreateOrConnectWithoutGuildsInput = {
    where: ReactionRolesWhereUniqueInput
    create: XOR<ReactionRolesCreateWithoutGuildsInput, ReactionRolesUncheckedCreateWithoutGuildsInput>
  }

  export type ReactionRolesCreateManyGuildsInputEnvelope = {
    data: ReactionRolesCreateManyGuildsInput | ReactionRolesCreateManyGuildsInput[]
  }

  export type SecuritysCreateWithoutGuildsInput = {
    id?: string
    InviteLoggingActive?: string | null
    MaxAccountAge?: number | null
    VerificationGates?: VerificationGatesCreateNestedManyWithoutVerificationGatesInput
  }

  export type SecuritysUncheckedCreateWithoutGuildsInput = {
    id?: string
    InviteLoggingActive?: string | null
    MaxAccountAge?: number | null
    VerificationGates?: VerificationGatesUncheckedCreateNestedManyWithoutVerificationGatesInput
  }

  export type SecuritysCreateOrConnectWithoutGuildsInput = {
    where: SecuritysWhereUniqueInput
    create: XOR<SecuritysCreateWithoutGuildsInput, SecuritysUncheckedCreateWithoutGuildsInput>
  }

  export type SpotifyNotificationsCreateWithoutGuildsInput = {
    id?: string
    ShowId: string
    ChannelId: string
    Latests?: SpotifyNotificationsCreateLatestsInput | string[]
    MessageTemplateId: string
    PingRoles?: SpotifyNotificationsCreatePingRolesInput | string[]
    UUID: string
  }

  export type SpotifyNotificationsUncheckedCreateWithoutGuildsInput = {
    id?: string
    ShowId: string
    ChannelId: string
    Latests?: SpotifyNotificationsCreateLatestsInput | string[]
    MessageTemplateId: string
    PingRoles?: SpotifyNotificationsCreatePingRolesInput | string[]
    UUID: string
  }

  export type SpotifyNotificationsCreateOrConnectWithoutGuildsInput = {
    where: SpotifyNotificationsWhereUniqueInput
    create: XOR<SpotifyNotificationsCreateWithoutGuildsInput, SpotifyNotificationsUncheckedCreateWithoutGuildsInput>
  }

  export type SpotifyNotificationsCreateManyGuildsInputEnvelope = {
    data: SpotifyNotificationsCreateManyGuildsInput | SpotifyNotificationsCreateManyGuildsInput[]
  }

  export type TagsCreateWithoutGuildsInput = {
    id?: string
    UUID: string
    TagId: string
    MessageId: string
    IsShlashCommand: boolean
    ShlashCommandId: string
    IsTextInputCommand: boolean
    IsEnabled: boolean
    PermissionRoleId?: string | null
    CommandDescription?: string | null
    FilterTextFromMessages?: TagsCreateFilterTextFromMessagesInput | string[]
  }

  export type TagsUncheckedCreateWithoutGuildsInput = {
    id?: string
    UUID: string
    TagId: string
    MessageId: string
    IsShlashCommand: boolean
    ShlashCommandId: string
    IsTextInputCommand: boolean
    IsEnabled: boolean
    PermissionRoleId?: string | null
    CommandDescription?: string | null
    FilterTextFromMessages?: TagsCreateFilterTextFromMessagesInput | string[]
  }

  export type TagsCreateOrConnectWithoutGuildsInput = {
    where: TagsWhereUniqueInput
    create: XOR<TagsCreateWithoutGuildsInput, TagsUncheckedCreateWithoutGuildsInput>
  }

  export type TagsCreateManyGuildsInputEnvelope = {
    data: TagsCreateManyGuildsInput | TagsCreateManyGuildsInput[]
  }

  export type TicketSetupsCreateWithoutGuildsInput = {
    id?: string
    CategoryId?: string | null
    Handlers?: TicketSetupsCreateHandlersInput | string[]
    HandlerWithShadowPing?: TicketSetupsCreateHandlerWithShadowPingInput | string[]
    CustomId: string
    TicketChannelName?: string | null
    ChannelType?: number | null
    MessageTempleateId?: string | null
    TicketBlacklistRoles?: TicketSetupsCreateTicketBlacklistRolesInput | string[]
    TranscriptChannelId?: string | null
    HasModal?: boolean | null
    UserDMWhenCloseMessageTemplateId?: string | null
    TicketLimit?: number | null
    WithTicketFeedback?: boolean | null
    TicketFeedbackChannelId?: string | null
    ModalTitle?: string | null
    TicketCreationCooldownPerUser?: number | null
    AutoCloseAfterInactivity?: number | null
    AutoAssignHandler?: string | null
    AutoReplyMessageTemplateId?: string | null
    RequiredRoles?: TicketSetupsCreateRequiredRolesInput | string[]
    OpenTicketWithCommand?: boolean | null
    SlashCommandId?: string | null
    TextCommandName?: string | null
    SendTranscriptToUser?: boolean | null
    ModalOptions?: TicketModalDataCreateNestedManyWithoutTicketSetupInput
    Tickets?: TicketsCreateNestedManyWithoutTicketSetupInput
  }

  export type TicketSetupsUncheckedCreateWithoutGuildsInput = {
    id?: string
    CategoryId?: string | null
    Handlers?: TicketSetupsCreateHandlersInput | string[]
    HandlerWithShadowPing?: TicketSetupsCreateHandlerWithShadowPingInput | string[]
    CustomId: string
    TicketChannelName?: string | null
    ChannelType?: number | null
    MessageTempleateId?: string | null
    TicketBlacklistRoles?: TicketSetupsCreateTicketBlacklistRolesInput | string[]
    TranscriptChannelId?: string | null
    HasModal?: boolean | null
    UserDMWhenCloseMessageTemplateId?: string | null
    TicketLimit?: number | null
    WithTicketFeedback?: boolean | null
    TicketFeedbackChannelId?: string | null
    ModalTitle?: string | null
    TicketCreationCooldownPerUser?: number | null
    AutoCloseAfterInactivity?: number | null
    AutoAssignHandler?: string | null
    AutoReplyMessageTemplateId?: string | null
    RequiredRoles?: TicketSetupsCreateRequiredRolesInput | string[]
    OpenTicketWithCommand?: boolean | null
    SlashCommandId?: string | null
    TextCommandName?: string | null
    SendTranscriptToUser?: boolean | null
    ModalOptions?: TicketModalDataUncheckedCreateNestedManyWithoutTicketSetupInput
    Tickets?: TicketsUncheckedCreateNestedManyWithoutTicketSetupInput
  }

  export type TicketSetupsCreateOrConnectWithoutGuildsInput = {
    where: TicketSetupsWhereUniqueInput
    create: XOR<TicketSetupsCreateWithoutGuildsInput, TicketSetupsUncheckedCreateWithoutGuildsInput>
  }

  export type TicketSetupsCreateManyGuildsInputEnvelope = {
    data: TicketSetupsCreateManyGuildsInput | TicketSetupsCreateManyGuildsInput[]
  }

  export type GuildFeatureTogglesCreateWithoutGuildsInput = {
    id?: string
    LevelEnabled?: boolean
    WecomeEnabled?: boolean
    LeaveEnabled?: boolean
    AutoreactEnabled?: boolean
    AutopublishEnabled?: boolean
    ConnectionsEnabled?: boolean
    ChatfilterEnabled?: boolean
    AutorolesEnabled?: boolean
    LoggingEnabled?: boolean
    TwitchEnabled?: boolean
    YoutubeEnabled?: boolean
    SpotifyEnabled?: boolean
  }

  export type GuildFeatureTogglesUncheckedCreateWithoutGuildsInput = {
    id?: string
    LevelEnabled?: boolean
    WecomeEnabled?: boolean
    LeaveEnabled?: boolean
    AutoreactEnabled?: boolean
    AutopublishEnabled?: boolean
    ConnectionsEnabled?: boolean
    ChatfilterEnabled?: boolean
    AutorolesEnabled?: boolean
    LoggingEnabled?: boolean
    TwitchEnabled?: boolean
    YoutubeEnabled?: boolean
    SpotifyEnabled?: boolean
  }

  export type GuildFeatureTogglesCreateOrConnectWithoutGuildsInput = {
    where: GuildFeatureTogglesWhereUniqueInput
    create: XOR<GuildFeatureTogglesCreateWithoutGuildsInput, GuildFeatureTogglesUncheckedCreateWithoutGuildsInput>
  }

  export type TwitchNotificationsCreateWithoutGuildsInput = {
    id?: string
    UUID: string
    TwitchChannelName: string
    ChannelId: string
    Live: boolean
    MessageTemplateId: string
    PingRoles?: TwitchNotificationsCreatePingRolesInput | string[]
  }

  export type TwitchNotificationsUncheckedCreateWithoutGuildsInput = {
    id?: string
    UUID: string
    TwitchChannelName: string
    ChannelId: string
    Live: boolean
    MessageTemplateId: string
    PingRoles?: TwitchNotificationsCreatePingRolesInput | string[]
  }

  export type TwitchNotificationsCreateOrConnectWithoutGuildsInput = {
    where: TwitchNotificationsWhereUniqueInput
    create: XOR<TwitchNotificationsCreateWithoutGuildsInput, TwitchNotificationsUncheckedCreateWithoutGuildsInput>
  }

  export type TwitchNotificationsCreateManyGuildsInputEnvelope = {
    data: TwitchNotificationsCreateManyGuildsInput | TwitchNotificationsCreateManyGuildsInput[]
  }

  export type GuildWelcomeSetupsCreateWithoutGuildsInput = {
    id?: string
    MessageTemplateId: string
    ChannelId: string
    Image: boolean
    ImageData: XOR<WelcomeLeaveImageDataCreateEnvelopeInput, WelcomeLeaveImageDataCreateInput>
  }

  export type GuildWelcomeSetupsUncheckedCreateWithoutGuildsInput = {
    id?: string
    MessageTemplateId: string
    ChannelId: string
    Image: boolean
    ImageData: XOR<WelcomeLeaveImageDataCreateEnvelopeInput, WelcomeLeaveImageDataCreateInput>
  }

  export type GuildWelcomeSetupsCreateOrConnectWithoutGuildsInput = {
    where: GuildWelcomeSetupsWhereUniqueInput
    create: XOR<GuildWelcomeSetupsCreateWithoutGuildsInput, GuildWelcomeSetupsUncheckedCreateWithoutGuildsInput>
  }

  export type YoutubeNotificationsCreateWithoutGuildsInput = {
    id?: string
    YoutubeChannelId: string
    ChannelId: string
    Latest?: YoutubeNotificationsCreateLatestInput | string[]
    MessageTemplateId: string
    PingRoles?: YoutubeNotificationsCreatePingRolesInput | string[]
    UUID: string
  }

  export type YoutubeNotificationsUncheckedCreateWithoutGuildsInput = {
    id?: string
    YoutubeChannelId: string
    ChannelId: string
    Latest?: YoutubeNotificationsCreateLatestInput | string[]
    MessageTemplateId: string
    PingRoles?: YoutubeNotificationsCreatePingRolesInput | string[]
    UUID: string
  }

  export type YoutubeNotificationsCreateOrConnectWithoutGuildsInput = {
    where: YoutubeNotificationsWhereUniqueInput
    create: XOR<YoutubeNotificationsCreateWithoutGuildsInput, YoutubeNotificationsUncheckedCreateWithoutGuildsInput>
  }

  export type YoutubeNotificationsCreateManyGuildsInputEnvelope = {
    data: YoutubeNotificationsCreateManyGuildsInput | YoutubeNotificationsCreateManyGuildsInput[]
  }

  export type GuildLoggersCreateWithoutGuildsInput = {
    id?: string
    UUID: string
    Notes?: GuildLoggersCreateNotesInput | string[]
    LogMessage: string
    LogJSON: string
  }

  export type GuildLoggersUncheckedCreateWithoutGuildsInput = {
    id?: string
    UUID: string
    Notes?: GuildLoggersCreateNotesInput | string[]
    LogMessage: string
    LogJSON: string
  }

  export type GuildLoggersCreateOrConnectWithoutGuildsInput = {
    where: GuildLoggersWhereUniqueInput
    create: XOR<GuildLoggersCreateWithoutGuildsInput, GuildLoggersUncheckedCreateWithoutGuildsInput>
  }

  export type GuildLoggersCreateManyGuildsInputEnvelope = {
    data: GuildLoggersCreateManyGuildsInput | GuildLoggersCreateManyGuildsInput[]
  }

  export type AutoDeletesUpsertWithWhereUniqueWithoutGuildsInput = {
    where: AutoDeletesWhereUniqueInput
    update: XOR<AutoDeletesUpdateWithoutGuildsInput, AutoDeletesUncheckedUpdateWithoutGuildsInput>
    create: XOR<AutoDeletesCreateWithoutGuildsInput, AutoDeletesUncheckedCreateWithoutGuildsInput>
  }

  export type AutoDeletesUpdateWithWhereUniqueWithoutGuildsInput = {
    where: AutoDeletesWhereUniqueInput
    data: XOR<AutoDeletesUpdateWithoutGuildsInput, AutoDeletesUncheckedUpdateWithoutGuildsInput>
  }

  export type AutoDeletesUpdateManyWithWhereWithoutGuildsInput = {
    where: AutoDeletesScalarWhereInput
    data: XOR<AutoDeletesUpdateManyMutationInput, AutoDeletesUncheckedUpdateManyWithoutGuildsInput>
  }

  export type AutoDeletesScalarWhereInput = {
    AND?: AutoDeletesScalarWhereInput | AutoDeletesScalarWhereInput[]
    OR?: AutoDeletesScalarWhereInput[]
    NOT?: AutoDeletesScalarWhereInput | AutoDeletesScalarWhereInput[]
    id?: StringFilter<"AutoDeletes"> | string
    ChannelId?: StringNullableFilter<"AutoDeletes"> | string | null
    IsActive?: BoolNullableFilter<"AutoDeletes"> | boolean | null
    Time?: StringNullableFilter<"AutoDeletes"> | string | null
    UUID?: StringNullableFilter<"AutoDeletes"> | string | null
    WhitelistedMessages?: StringNullableListFilter<"AutoDeletes">
    WhitelistedRoles?: StringNullableListFilter<"AutoDeletes">
    WhitelistedUsers?: StringNullableListFilter<"AutoDeletes">
    GuildId?: StringFilter<"AutoDeletes"> | string
  }

  export type AutoPublishUpsertWithoutGuildsInput = {
    update: XOR<AutoPublishUpdateWithoutGuildsInput, AutoPublishUncheckedUpdateWithoutGuildsInput>
    create: XOR<AutoPublishCreateWithoutGuildsInput, AutoPublishUncheckedCreateWithoutGuildsInput>
    where?: AutoPublishWhereInput
  }

  export type AutoPublishUpdateToOneWithWhereWithoutGuildsInput = {
    where?: AutoPublishWhereInput
    data: XOR<AutoPublishUpdateWithoutGuildsInput, AutoPublishUncheckedUpdateWithoutGuildsInput>
  }

  export type AutoPublishUpdateWithoutGuildsInput = {
    Channels?: AutoPublishUpdateChannelsInput | string[]
  }

  export type AutoPublishUncheckedUpdateWithoutGuildsInput = {
    Channels?: AutoPublishUpdateChannelsInput | string[]
  }

  export type AutoReactsUpsertWithWhereUniqueWithoutGuildsInput = {
    where: AutoReactsWhereUniqueInput
    update: XOR<AutoReactsUpdateWithoutGuildsInput, AutoReactsUncheckedUpdateWithoutGuildsInput>
    create: XOR<AutoReactsCreateWithoutGuildsInput, AutoReactsUncheckedCreateWithoutGuildsInput>
  }

  export type AutoReactsUpdateWithWhereUniqueWithoutGuildsInput = {
    where: AutoReactsWhereUniqueInput
    data: XOR<AutoReactsUpdateWithoutGuildsInput, AutoReactsUncheckedUpdateWithoutGuildsInput>
  }

  export type AutoReactsUpdateManyWithWhereWithoutGuildsInput = {
    where: AutoReactsScalarWhereInput
    data: XOR<AutoReactsUpdateManyMutationInput, AutoReactsUncheckedUpdateManyWithoutGuildsInput>
  }

  export type AutoReactsScalarWhereInput = {
    AND?: AutoReactsScalarWhereInput | AutoReactsScalarWhereInput[]
    OR?: AutoReactsScalarWhereInput[]
    NOT?: AutoReactsScalarWhereInput | AutoReactsScalarWhereInput[]
    id?: StringFilter<"AutoReacts"> | string
    ChannelId?: StringFilter<"AutoReacts"> | string
    Emoji?: StringFilter<"AutoReacts"> | string
    GuildId?: StringFilter<"AutoReacts"> | string
  }

  export type AutoRolesUpsertWithWhereUniqueWithoutGuildsInput = {
    where: AutoRolesWhereUniqueInput
    update: XOR<AutoRolesUpdateWithoutGuildsInput, AutoRolesUncheckedUpdateWithoutGuildsInput>
    create: XOR<AutoRolesCreateWithoutGuildsInput, AutoRolesUncheckedCreateWithoutGuildsInput>
  }

  export type AutoRolesUpdateWithWhereUniqueWithoutGuildsInput = {
    where: AutoRolesWhereUniqueInput
    data: XOR<AutoRolesUpdateWithoutGuildsInput, AutoRolesUncheckedUpdateWithoutGuildsInput>
  }

  export type AutoRolesUpdateManyWithWhereWithoutGuildsInput = {
    where: AutoRolesScalarWhereInput
    data: XOR<AutoRolesUpdateManyMutationInput, AutoRolesUncheckedUpdateManyWithoutGuildsInput>
  }

  export type AutoRolesScalarWhereInput = {
    AND?: AutoRolesScalarWhereInput | AutoRolesScalarWhereInput[]
    OR?: AutoRolesScalarWhereInput[]
    NOT?: AutoRolesScalarWhereInput | AutoRolesScalarWhereInput[]
    id?: StringFilter<"AutoRoles"> | string
    RoleId?: StringFilter<"AutoRoles"> | string
    GuildId?: StringFilter<"AutoRoles"> | string
  }

  export type GuildBansUpsertWithWhereUniqueWithoutGuildsInput = {
    where: GuildBansWhereUniqueInput
    update: XOR<GuildBansUpdateWithoutGuildsInput, GuildBansUncheckedUpdateWithoutGuildsInput>
    create: XOR<GuildBansCreateWithoutGuildsInput, GuildBansUncheckedCreateWithoutGuildsInput>
  }

  export type GuildBansUpdateWithWhereUniqueWithoutGuildsInput = {
    where: GuildBansWhereUniqueInput
    data: XOR<GuildBansUpdateWithoutGuildsInput, GuildBansUncheckedUpdateWithoutGuildsInput>
  }

  export type GuildBansUpdateManyWithWhereWithoutGuildsInput = {
    where: GuildBansScalarWhereInput
    data: XOR<GuildBansUpdateManyMutationInput, GuildBansUncheckedUpdateManyWithoutGuildsInput>
  }

  export type GuildBansScalarWhereInput = {
    AND?: GuildBansScalarWhereInput | GuildBansScalarWhereInput[]
    OR?: GuildBansScalarWhereInput[]
    NOT?: GuildBansScalarWhereInput | GuildBansScalarWhereInput[]
    id?: StringFilter<"GuildBans"> | string
    UUID?: StringFilter<"GuildBans"> | string
    Time?: StringNullableFilter<"GuildBans"> | string | null
    UserId?: StringNullableListFilter<"GuildBans">
    Reason?: StringNullableFilter<"GuildBans"> | string | null
    ModeratorId?: StringNullableFilter<"GuildBans"> | string | null
    DmMessage?: StringNullableFilter<"GuildBans"> | string | null
    Banned?: BoolNullableFilter<"GuildBans"> | boolean | null
    CreatedAt?: DateTimeNullableFilter<"GuildBans"> | Date | string | null
    GuildId?: StringFilter<"GuildBans"> | string
  }

  export type ChatModerationsUpsertWithoutGuildsInput = {
    update: XOR<ChatModerationsUpdateWithoutGuildsInput, ChatModerationsUncheckedUpdateWithoutGuildsInput>
    create: XOR<ChatModerationsCreateWithoutGuildsInput, ChatModerationsUncheckedCreateWithoutGuildsInput>
    where?: ChatModerationsWhereInput
  }

  export type ChatModerationsUpdateToOneWithWhereWithoutGuildsInput = {
    where?: ChatModerationsWhereInput
    data: XOR<ChatModerationsUpdateWithoutGuildsInput, ChatModerationsUncheckedUpdateWithoutGuildsInput>
  }

  export type ChatModerationsUpdateWithoutGuildsInput = {
    LogChannelId?: StringFieldUpdateOperationsInput | string
    Words?: ChatModerationsUpdateWordsInput | string[]
    WhiteListRole?: ChatModerationsUpdateWhiteListRoleInput | string[]
    WhiteListChannel?: ChatModerationsUpdateWhiteListChannelInput | string[]
  }

  export type ChatModerationsUncheckedUpdateWithoutGuildsInput = {
    LogChannelId?: StringFieldUpdateOperationsInput | string
    Words?: ChatModerationsUpdateWordsInput | string[]
    WhiteListRole?: ChatModerationsUpdateWhiteListRoleInput | string[]
    WhiteListChannel?: ChatModerationsUpdateWhiteListChannelInput | string[]
  }

  export type ChannelLinksUpsertWithWhereUniqueWithoutGuildsInput = {
    where: ChannelLinksWhereUniqueInput
    update: XOR<ChannelLinksUpdateWithoutGuildsInput, ChannelLinksUncheckedUpdateWithoutGuildsInput>
    create: XOR<ChannelLinksCreateWithoutGuildsInput, ChannelLinksUncheckedCreateWithoutGuildsInput>
  }

  export type ChannelLinksUpdateWithWhereUniqueWithoutGuildsInput = {
    where: ChannelLinksWhereUniqueInput
    data: XOR<ChannelLinksUpdateWithoutGuildsInput, ChannelLinksUncheckedUpdateWithoutGuildsInput>
  }

  export type ChannelLinksUpdateManyWithWhereWithoutGuildsInput = {
    where: ChannelLinksScalarWhereInput
    data: XOR<ChannelLinksUpdateManyMutationInput, ChannelLinksUncheckedUpdateManyWithoutGuildsInput>
  }

  export type ChannelLinksScalarWhereInput = {
    AND?: ChannelLinksScalarWhereInput | ChannelLinksScalarWhereInput[]
    OR?: ChannelLinksScalarWhereInput[]
    NOT?: ChannelLinksScalarWhereInput | ChannelLinksScalarWhereInput[]
    id?: StringFilter<"ChannelLinks"> | string
    UUID?: StringFilter<"ChannelLinks"> | string
    ChannelId?: StringFilter<"ChannelLinks"> | string
    WebhookUrls?: StringNullableListFilter<"ChannelLinks">
    GuildId?: StringFilter<"ChannelLinks"> | string
  }

  export type DiscordAddonsUpsertWithoutGuildsInput = {
    update: XOR<DiscordAddonsUpdateWithoutGuildsInput, DiscordAddonsUncheckedUpdateWithoutGuildsInput>
    create: XOR<DiscordAddonsCreateWithoutGuildsInput, DiscordAddonsUncheckedCreateWithoutGuildsInput>
    where?: DiscordAddonsWhereInput
  }

  export type DiscordAddonsUpdateToOneWithWhereWithoutGuildsInput = {
    where?: DiscordAddonsWhereInput
    data: XOR<DiscordAddonsUpdateWithoutGuildsInput, DiscordAddonsUncheckedUpdateWithoutGuildsInput>
  }

  export type DiscordAddonsUpdateWithoutGuildsInput = {
    OnlyMedia?: DiscordAddonsUpdateOnlyMediaInput | string[]
    NoLinkEmbeds?: DiscordAddonsUpdateNoLinkEmbedsInput | string[]
    InvitesPaused?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DiscordAddonsUncheckedUpdateWithoutGuildsInput = {
    OnlyMedia?: DiscordAddonsUpdateOnlyMediaInput | string[]
    NoLinkEmbeds?: DiscordAddonsUpdateNoLinkEmbedsInput | string[]
    InvitesPaused?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GiveawaysUpsertWithWhereUniqueWithoutGuildsInput = {
    where: GiveawaysWhereUniqueInput
    update: XOR<GiveawaysUpdateWithoutGuildsInput, GiveawaysUncheckedUpdateWithoutGuildsInput>
    create: XOR<GiveawaysCreateWithoutGuildsInput, GiveawaysUncheckedCreateWithoutGuildsInput>
  }

  export type GiveawaysUpdateWithWhereUniqueWithoutGuildsInput = {
    where: GiveawaysWhereUniqueInput
    data: XOR<GiveawaysUpdateWithoutGuildsInput, GiveawaysUncheckedUpdateWithoutGuildsInput>
  }

  export type GiveawaysUpdateManyWithWhereWithoutGuildsInput = {
    where: GiveawaysScalarWhereInput
    data: XOR<GiveawaysUpdateManyMutationInput, GiveawaysUncheckedUpdateManyWithoutGuildsInput>
  }

  export type GiveawaysScalarWhereInput = {
    AND?: GiveawaysScalarWhereInput | GiveawaysScalarWhereInput[]
    OR?: GiveawaysScalarWhereInput[]
    NOT?: GiveawaysScalarWhereInput | GiveawaysScalarWhereInput[]
    id?: StringFilter<"Giveaways"> | string
    UUID?: StringFilter<"Giveaways"> | string
    MessageId?: StringFilter<"Giveaways"> | string
    ChannelId?: StringNullableFilter<"Giveaways"> | string | null
    Prize?: StringFilter<"Giveaways"> | string
    Winners?: IntFilter<"Giveaways"> | number
    Time?: StringFilter<"Giveaways"> | string
    CreatedAt?: DateTimeFilter<"Giveaways"> | Date | string
    Ended?: BoolFilter<"Giveaways"> | boolean
    EndedAt?: DateTimeNullableFilter<"Giveaways"> | Date | string | null
    EndedBy?: StringNullableFilter<"Giveaways"> | string | null
    Paused?: BoolFilter<"Giveaways"> | boolean
    EndedMessage?: StringNullableFilter<"Giveaways"> | string | null
    Rerolled?: BoolFilter<"Giveaways"> | boolean
    WinnerIds?: StringNullableListFilter<"Giveaways">
    WinnerMessageTemplate?: StringNullableFilter<"Giveaways"> | string | null
    HostedBy?: StringFilter<"Giveaways"> | string
    MessageTemplate?: StringNullableFilter<"Giveaways"> | string | null
    Content?: StringNullableFilter<"Giveaways"> | string | null
    Entrys?: StringNullableListFilter<"Giveaways">
    Requirements?: StringNullableListFilter<"Giveaways">
    GuildId?: StringFilter<"Giveaways"> | string
  }

  export type TempVoicesUpsertWithWhereUniqueWithoutGuildsInput = {
    where: TempVoicesWhereUniqueInput
    update: XOR<TempVoicesUpdateWithoutGuildsInput, TempVoicesUncheckedUpdateWithoutGuildsInput>
    create: XOR<TempVoicesCreateWithoutGuildsInput, TempVoicesUncheckedCreateWithoutGuildsInput>
  }

  export type TempVoicesUpdateWithWhereUniqueWithoutGuildsInput = {
    where: TempVoicesWhereUniqueInput
    data: XOR<TempVoicesUpdateWithoutGuildsInput, TempVoicesUncheckedUpdateWithoutGuildsInput>
  }

  export type TempVoicesUpdateManyWithWhereWithoutGuildsInput = {
    where: TempVoicesScalarWhereInput
    data: XOR<TempVoicesUpdateManyMutationInput, TempVoicesUncheckedUpdateManyWithoutGuildsInput>
  }

  export type TempVoicesScalarWhereInput = {
    AND?: TempVoicesScalarWhereInput | TempVoicesScalarWhereInput[]
    OR?: TempVoicesScalarWhereInput[]
    NOT?: TempVoicesScalarWhereInput | TempVoicesScalarWhereInput[]
    id?: StringFilter<"TempVoices"> | string
    UUID?: StringFilter<"TempVoices"> | string
    Name?: StringFilter<"TempVoices"> | string
    JointoCreateChannel?: StringFilter<"TempVoices"> | string
    JointoCreateCategory?: StringFilter<"TempVoices"> | string
    Manage?: BoolFilter<"TempVoices"> | boolean
    PresetLimit?: IntFilter<"TempVoices"> | number
    GuildId?: StringFilter<"TempVoices"> | string
  }

  export type GuildLeaveSetupsUpsertWithoutGuildsInput = {
    update: XOR<GuildLeaveSetupsUpdateWithoutGuildsInput, GuildLeaveSetupsUncheckedUpdateWithoutGuildsInput>
    create: XOR<GuildLeaveSetupsCreateWithoutGuildsInput, GuildLeaveSetupsUncheckedCreateWithoutGuildsInput>
    where?: GuildLeaveSetupsWhereInput
  }

  export type GuildLeaveSetupsUpdateToOneWithWhereWithoutGuildsInput = {
    where?: GuildLeaveSetupsWhereInput
    data: XOR<GuildLeaveSetupsUpdateWithoutGuildsInput, GuildLeaveSetupsUncheckedUpdateWithoutGuildsInput>
  }

  export type GuildLeaveSetupsUpdateWithoutGuildsInput = {
    MessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelId?: StringFieldUpdateOperationsInput | string
    Image?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ImageData?: XOR<WelcomeLeaveImageDataNullableUpdateEnvelopeInput, WelcomeLeaveImageDataCreateInput> | null
  }

  export type GuildLeaveSetupsUncheckedUpdateWithoutGuildsInput = {
    MessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelId?: StringFieldUpdateOperationsInput | string
    Image?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ImageData?: XOR<WelcomeLeaveImageDataNullableUpdateEnvelopeInput, WelcomeLeaveImageDataCreateInput> | null
  }

  export type GuildLoggingsUpsertWithoutGuildsInput = {
    update: XOR<GuildLoggingsUpdateWithoutGuildsInput, GuildLoggingsUncheckedUpdateWithoutGuildsInput>
    create: XOR<GuildLoggingsCreateWithoutGuildsInput, GuildLoggingsUncheckedCreateWithoutGuildsInput>
    where?: GuildLoggingsWhereInput
  }

  export type GuildLoggingsUpdateToOneWithWhereWithoutGuildsInput = {
    where?: GuildLoggingsWhereInput
    data: XOR<GuildLoggingsUpdateWithoutGuildsInput, GuildLoggingsUncheckedUpdateWithoutGuildsInput>
  }

  export type GuildLoggingsUpdateWithoutGuildsInput = {
    AutoMod?: NullableStringFieldUpdateOperationsInput | string | null
    Channel?: NullableStringFieldUpdateOperationsInput | string | null
    Emoji?: NullableStringFieldUpdateOperationsInput | string | null
    Guild?: NullableStringFieldUpdateOperationsInput | string | null
    Integration?: NullableStringFieldUpdateOperationsInput | string | null
    Invite?: NullableStringFieldUpdateOperationsInput | string | null
    Member?: NullableStringFieldUpdateOperationsInput | string | null
    Message?: NullableStringFieldUpdateOperationsInput | string | null
    Moderation?: NullableStringFieldUpdateOperationsInput | string | null
    Reaction?: NullableStringFieldUpdateOperationsInput | string | null
    Role?: NullableStringFieldUpdateOperationsInput | string | null
    SoundBoard?: NullableStringFieldUpdateOperationsInput | string | null
    Sticker?: NullableStringFieldUpdateOperationsInput | string | null
    Thread?: NullableStringFieldUpdateOperationsInput | string | null
    Voice?: NullableStringFieldUpdateOperationsInput | string | null
    Webhook?: NullableStringFieldUpdateOperationsInput | string | null
    Ban?: NullableStringFieldUpdateOperationsInput | string | null
    Kick?: NullableStringFieldUpdateOperationsInput | string | null
    Poll?: NullableStringFieldUpdateOperationsInput | string | null
    Stage?: NullableStringFieldUpdateOperationsInput | string | null
    Event?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GuildLoggingsUncheckedUpdateWithoutGuildsInput = {
    AutoMod?: NullableStringFieldUpdateOperationsInput | string | null
    Channel?: NullableStringFieldUpdateOperationsInput | string | null
    Emoji?: NullableStringFieldUpdateOperationsInput | string | null
    Guild?: NullableStringFieldUpdateOperationsInput | string | null
    Integration?: NullableStringFieldUpdateOperationsInput | string | null
    Invite?: NullableStringFieldUpdateOperationsInput | string | null
    Member?: NullableStringFieldUpdateOperationsInput | string | null
    Message?: NullableStringFieldUpdateOperationsInput | string | null
    Moderation?: NullableStringFieldUpdateOperationsInput | string | null
    Reaction?: NullableStringFieldUpdateOperationsInput | string | null
    Role?: NullableStringFieldUpdateOperationsInput | string | null
    SoundBoard?: NullableStringFieldUpdateOperationsInput | string | null
    Sticker?: NullableStringFieldUpdateOperationsInput | string | null
    Thread?: NullableStringFieldUpdateOperationsInput | string | null
    Voice?: NullableStringFieldUpdateOperationsInput | string | null
    Webhook?: NullableStringFieldUpdateOperationsInput | string | null
    Ban?: NullableStringFieldUpdateOperationsInput | string | null
    Kick?: NullableStringFieldUpdateOperationsInput | string | null
    Poll?: NullableStringFieldUpdateOperationsInput | string | null
    Stage?: NullableStringFieldUpdateOperationsInput | string | null
    Event?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageTemplatesUpsertWithWhereUniqueWithoutGuildsInput = {
    where: MessageTemplatesWhereUniqueInput
    update: XOR<MessageTemplatesUpdateWithoutGuildsInput, MessageTemplatesUncheckedUpdateWithoutGuildsInput>
    create: XOR<MessageTemplatesCreateWithoutGuildsInput, MessageTemplatesUncheckedCreateWithoutGuildsInput>
  }

  export type MessageTemplatesUpdateWithWhereUniqueWithoutGuildsInput = {
    where: MessageTemplatesWhereUniqueInput
    data: XOR<MessageTemplatesUpdateWithoutGuildsInput, MessageTemplatesUncheckedUpdateWithoutGuildsInput>
  }

  export type MessageTemplatesUpdateManyWithWhereWithoutGuildsInput = {
    where: MessageTemplatesScalarWhereInput
    data: XOR<MessageTemplatesUpdateManyMutationInput, MessageTemplatesUncheckedUpdateManyWithoutGuildsInput>
  }

  export type MessageTemplatesScalarWhereInput = {
    AND?: MessageTemplatesScalarWhereInput | MessageTemplatesScalarWhereInput[]
    OR?: MessageTemplatesScalarWhereInput[]
    NOT?: MessageTemplatesScalarWhereInput | MessageTemplatesScalarWhereInput[]
    id?: StringFilter<"MessageTemplates"> | string
    Content?: StringNullableFilter<"MessageTemplates"> | string | null
    EmbedJSON?: StringNullableFilter<"MessageTemplates"> | string | null
    OtherEmbeds?: StringNullableListFilter<"MessageTemplates">
    Name?: StringFilter<"MessageTemplates"> | string
    GuildId?: StringFilter<"MessageTemplates"> | string
  }

  export type PermissionsUpsertWithoutGuildsInput = {
    update: XOR<PermissionsUpdateWithoutGuildsInput, PermissionsUncheckedUpdateWithoutGuildsInput>
    create: XOR<PermissionsCreateWithoutGuildsInput, PermissionsUncheckedCreateWithoutGuildsInput>
    where?: PermissionsWhereInput
  }

  export type PermissionsUpdateToOneWithWhereWithoutGuildsInput = {
    where?: PermissionsWhereInput
    data: XOR<PermissionsUpdateWithoutGuildsInput, PermissionsUncheckedUpdateWithoutGuildsInput>
  }

  export type PermissionsUpdateWithoutGuildsInput = {
    Permissions?: XOR<PermissionDataListUpdateEnvelopeInput, PermissionDataCreateInput> | PermissionDataCreateInput[]
  }

  export type PermissionsUncheckedUpdateWithoutGuildsInput = {
    Permissions?: XOR<PermissionDataListUpdateEnvelopeInput, PermissionDataCreateInput> | PermissionDataCreateInput[]
  }

  export type ReactionRolesUpsertWithWhereUniqueWithoutGuildsInput = {
    where: ReactionRolesWhereUniqueInput
    update: XOR<ReactionRolesUpdateWithoutGuildsInput, ReactionRolesUncheckedUpdateWithoutGuildsInput>
    create: XOR<ReactionRolesCreateWithoutGuildsInput, ReactionRolesUncheckedCreateWithoutGuildsInput>
  }

  export type ReactionRolesUpdateWithWhereUniqueWithoutGuildsInput = {
    where: ReactionRolesWhereUniqueInput
    data: XOR<ReactionRolesUpdateWithoutGuildsInput, ReactionRolesUncheckedUpdateWithoutGuildsInput>
  }

  export type ReactionRolesUpdateManyWithWhereWithoutGuildsInput = {
    where: ReactionRolesScalarWhereInput
    data: XOR<ReactionRolesUpdateManyMutationInput, ReactionRolesUncheckedUpdateManyWithoutGuildsInput>
  }

  export type ReactionRolesScalarWhereInput = {
    AND?: ReactionRolesScalarWhereInput | ReactionRolesScalarWhereInput[]
    OR?: ReactionRolesScalarWhereInput[]
    NOT?: ReactionRolesScalarWhereInput | ReactionRolesScalarWhereInput[]
    id?: StringFilter<"ReactionRoles"> | string
    UUID?: StringFilter<"ReactionRoles"> | string
    Roles?: StringNullableListFilter<"ReactionRoles">
    MessageId?: StringNullableFilter<"ReactionRoles"> | string | null
    ChannelId?: StringNullableFilter<"ReactionRoles"> | string | null
    AddMessage?: StringNullableFilter<"ReactionRoles"> | string | null
    RemoveMessage?: StringNullableFilter<"ReactionRoles"> | string | null
    Emoji?: StringNullableFilter<"ReactionRoles"> | string | null
    GuildId?: StringFilter<"ReactionRoles"> | string
  }

  export type SecuritysUpsertWithoutGuildsInput = {
    update: XOR<SecuritysUpdateWithoutGuildsInput, SecuritysUncheckedUpdateWithoutGuildsInput>
    create: XOR<SecuritysCreateWithoutGuildsInput, SecuritysUncheckedCreateWithoutGuildsInput>
    where?: SecuritysWhereInput
  }

  export type SecuritysUpdateToOneWithWhereWithoutGuildsInput = {
    where?: SecuritysWhereInput
    data: XOR<SecuritysUpdateWithoutGuildsInput, SecuritysUncheckedUpdateWithoutGuildsInput>
  }

  export type SecuritysUpdateWithoutGuildsInput = {
    InviteLoggingActive?: NullableStringFieldUpdateOperationsInput | string | null
    MaxAccountAge?: NullableIntFieldUpdateOperationsInput | number | null
    VerificationGates?: VerificationGatesUpdateManyWithoutVerificationGatesNestedInput
  }

  export type SecuritysUncheckedUpdateWithoutGuildsInput = {
    InviteLoggingActive?: NullableStringFieldUpdateOperationsInput | string | null
    MaxAccountAge?: NullableIntFieldUpdateOperationsInput | number | null
    VerificationGates?: VerificationGatesUncheckedUpdateManyWithoutVerificationGatesNestedInput
  }

  export type SpotifyNotificationsUpsertWithWhereUniqueWithoutGuildsInput = {
    where: SpotifyNotificationsWhereUniqueInput
    update: XOR<SpotifyNotificationsUpdateWithoutGuildsInput, SpotifyNotificationsUncheckedUpdateWithoutGuildsInput>
    create: XOR<SpotifyNotificationsCreateWithoutGuildsInput, SpotifyNotificationsUncheckedCreateWithoutGuildsInput>
  }

  export type SpotifyNotificationsUpdateWithWhereUniqueWithoutGuildsInput = {
    where: SpotifyNotificationsWhereUniqueInput
    data: XOR<SpotifyNotificationsUpdateWithoutGuildsInput, SpotifyNotificationsUncheckedUpdateWithoutGuildsInput>
  }

  export type SpotifyNotificationsUpdateManyWithWhereWithoutGuildsInput = {
    where: SpotifyNotificationsScalarWhereInput
    data: XOR<SpotifyNotificationsUpdateManyMutationInput, SpotifyNotificationsUncheckedUpdateManyWithoutGuildsInput>
  }

  export type SpotifyNotificationsScalarWhereInput = {
    AND?: SpotifyNotificationsScalarWhereInput | SpotifyNotificationsScalarWhereInput[]
    OR?: SpotifyNotificationsScalarWhereInput[]
    NOT?: SpotifyNotificationsScalarWhereInput | SpotifyNotificationsScalarWhereInput[]
    id?: StringFilter<"SpotifyNotifications"> | string
    ShowId?: StringFilter<"SpotifyNotifications"> | string
    ChannelId?: StringFilter<"SpotifyNotifications"> | string
    Latests?: StringNullableListFilter<"SpotifyNotifications">
    MessageTemplateId?: StringFilter<"SpotifyNotifications"> | string
    PingRoles?: StringNullableListFilter<"SpotifyNotifications">
    UUID?: StringFilter<"SpotifyNotifications"> | string
    GuildId?: StringFilter<"SpotifyNotifications"> | string
  }

  export type TagsUpsertWithWhereUniqueWithoutGuildsInput = {
    where: TagsWhereUniqueInput
    update: XOR<TagsUpdateWithoutGuildsInput, TagsUncheckedUpdateWithoutGuildsInput>
    create: XOR<TagsCreateWithoutGuildsInput, TagsUncheckedCreateWithoutGuildsInput>
  }

  export type TagsUpdateWithWhereUniqueWithoutGuildsInput = {
    where: TagsWhereUniqueInput
    data: XOR<TagsUpdateWithoutGuildsInput, TagsUncheckedUpdateWithoutGuildsInput>
  }

  export type TagsUpdateManyWithWhereWithoutGuildsInput = {
    where: TagsScalarWhereInput
    data: XOR<TagsUpdateManyMutationInput, TagsUncheckedUpdateManyWithoutGuildsInput>
  }

  export type TagsScalarWhereInput = {
    AND?: TagsScalarWhereInput | TagsScalarWhereInput[]
    OR?: TagsScalarWhereInput[]
    NOT?: TagsScalarWhereInput | TagsScalarWhereInput[]
    id?: StringFilter<"Tags"> | string
    UUID?: StringFilter<"Tags"> | string
    TagId?: StringFilter<"Tags"> | string
    MessageId?: StringFilter<"Tags"> | string
    IsShlashCommand?: BoolFilter<"Tags"> | boolean
    ShlashCommandId?: StringFilter<"Tags"> | string
    IsTextInputCommand?: BoolFilter<"Tags"> | boolean
    IsEnabled?: BoolFilter<"Tags"> | boolean
    PermissionRoleId?: StringNullableFilter<"Tags"> | string | null
    CommandDescription?: StringNullableFilter<"Tags"> | string | null
    FilterTextFromMessages?: StringNullableListFilter<"Tags">
    GuildId?: StringFilter<"Tags"> | string
  }

  export type TicketSetupsUpsertWithWhereUniqueWithoutGuildsInput = {
    where: TicketSetupsWhereUniqueInput
    update: XOR<TicketSetupsUpdateWithoutGuildsInput, TicketSetupsUncheckedUpdateWithoutGuildsInput>
    create: XOR<TicketSetupsCreateWithoutGuildsInput, TicketSetupsUncheckedCreateWithoutGuildsInput>
  }

  export type TicketSetupsUpdateWithWhereUniqueWithoutGuildsInput = {
    where: TicketSetupsWhereUniqueInput
    data: XOR<TicketSetupsUpdateWithoutGuildsInput, TicketSetupsUncheckedUpdateWithoutGuildsInput>
  }

  export type TicketSetupsUpdateManyWithWhereWithoutGuildsInput = {
    where: TicketSetupsScalarWhereInput
    data: XOR<TicketSetupsUpdateManyMutationInput, TicketSetupsUncheckedUpdateManyWithoutGuildsInput>
  }

  export type TicketSetupsScalarWhereInput = {
    AND?: TicketSetupsScalarWhereInput | TicketSetupsScalarWhereInput[]
    OR?: TicketSetupsScalarWhereInput[]
    NOT?: TicketSetupsScalarWhereInput | TicketSetupsScalarWhereInput[]
    id?: StringFilter<"TicketSetups"> | string
    CategoryId?: StringNullableFilter<"TicketSetups"> | string | null
    Handlers?: StringNullableListFilter<"TicketSetups">
    HandlerWithShadowPing?: StringNullableListFilter<"TicketSetups">
    CustomId?: StringFilter<"TicketSetups"> | string
    TicketChannelName?: StringNullableFilter<"TicketSetups"> | string | null
    ChannelType?: IntNullableFilter<"TicketSetups"> | number | null
    MessageTempleateId?: StringNullableFilter<"TicketSetups"> | string | null
    TicketBlacklistRoles?: StringNullableListFilter<"TicketSetups">
    TranscriptChannelId?: StringNullableFilter<"TicketSetups"> | string | null
    HasModal?: BoolNullableFilter<"TicketSetups"> | boolean | null
    UserDMWhenCloseMessageTemplateId?: StringNullableFilter<"TicketSetups"> | string | null
    TicketLimit?: IntNullableFilter<"TicketSetups"> | number | null
    WithTicketFeedback?: BoolNullableFilter<"TicketSetups"> | boolean | null
    TicketFeedbackChannelId?: StringNullableFilter<"TicketSetups"> | string | null
    ModalTitle?: StringNullableFilter<"TicketSetups"> | string | null
    TicketCreationCooldownPerUser?: IntNullableFilter<"TicketSetups"> | number | null
    AutoCloseAfterInactivity?: IntNullableFilter<"TicketSetups"> | number | null
    AutoAssignHandler?: StringNullableFilter<"TicketSetups"> | string | null
    AutoReplyMessageTemplateId?: StringNullableFilter<"TicketSetups"> | string | null
    RequiredRoles?: StringNullableListFilter<"TicketSetups">
    OpenTicketWithCommand?: BoolNullableFilter<"TicketSetups"> | boolean | null
    SlashCommandId?: StringNullableFilter<"TicketSetups"> | string | null
    TextCommandName?: StringNullableFilter<"TicketSetups"> | string | null
    SendTranscriptToUser?: BoolNullableFilter<"TicketSetups"> | boolean | null
    GuildId?: StringFilter<"TicketSetups"> | string
  }

  export type GuildFeatureTogglesUpsertWithoutGuildsInput = {
    update: XOR<GuildFeatureTogglesUpdateWithoutGuildsInput, GuildFeatureTogglesUncheckedUpdateWithoutGuildsInput>
    create: XOR<GuildFeatureTogglesCreateWithoutGuildsInput, GuildFeatureTogglesUncheckedCreateWithoutGuildsInput>
    where?: GuildFeatureTogglesWhereInput
  }

  export type GuildFeatureTogglesUpdateToOneWithWhereWithoutGuildsInput = {
    where?: GuildFeatureTogglesWhereInput
    data: XOR<GuildFeatureTogglesUpdateWithoutGuildsInput, GuildFeatureTogglesUncheckedUpdateWithoutGuildsInput>
  }

  export type GuildFeatureTogglesUpdateWithoutGuildsInput = {
    LevelEnabled?: BoolFieldUpdateOperationsInput | boolean
    WecomeEnabled?: BoolFieldUpdateOperationsInput | boolean
    LeaveEnabled?: BoolFieldUpdateOperationsInput | boolean
    AutoreactEnabled?: BoolFieldUpdateOperationsInput | boolean
    AutopublishEnabled?: BoolFieldUpdateOperationsInput | boolean
    ConnectionsEnabled?: BoolFieldUpdateOperationsInput | boolean
    ChatfilterEnabled?: BoolFieldUpdateOperationsInput | boolean
    AutorolesEnabled?: BoolFieldUpdateOperationsInput | boolean
    LoggingEnabled?: BoolFieldUpdateOperationsInput | boolean
    TwitchEnabled?: BoolFieldUpdateOperationsInput | boolean
    YoutubeEnabled?: BoolFieldUpdateOperationsInput | boolean
    SpotifyEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GuildFeatureTogglesUncheckedUpdateWithoutGuildsInput = {
    LevelEnabled?: BoolFieldUpdateOperationsInput | boolean
    WecomeEnabled?: BoolFieldUpdateOperationsInput | boolean
    LeaveEnabled?: BoolFieldUpdateOperationsInput | boolean
    AutoreactEnabled?: BoolFieldUpdateOperationsInput | boolean
    AutopublishEnabled?: BoolFieldUpdateOperationsInput | boolean
    ConnectionsEnabled?: BoolFieldUpdateOperationsInput | boolean
    ChatfilterEnabled?: BoolFieldUpdateOperationsInput | boolean
    AutorolesEnabled?: BoolFieldUpdateOperationsInput | boolean
    LoggingEnabled?: BoolFieldUpdateOperationsInput | boolean
    TwitchEnabled?: BoolFieldUpdateOperationsInput | boolean
    YoutubeEnabled?: BoolFieldUpdateOperationsInput | boolean
    SpotifyEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TwitchNotificationsUpsertWithWhereUniqueWithoutGuildsInput = {
    where: TwitchNotificationsWhereUniqueInput
    update: XOR<TwitchNotificationsUpdateWithoutGuildsInput, TwitchNotificationsUncheckedUpdateWithoutGuildsInput>
    create: XOR<TwitchNotificationsCreateWithoutGuildsInput, TwitchNotificationsUncheckedCreateWithoutGuildsInput>
  }

  export type TwitchNotificationsUpdateWithWhereUniqueWithoutGuildsInput = {
    where: TwitchNotificationsWhereUniqueInput
    data: XOR<TwitchNotificationsUpdateWithoutGuildsInput, TwitchNotificationsUncheckedUpdateWithoutGuildsInput>
  }

  export type TwitchNotificationsUpdateManyWithWhereWithoutGuildsInput = {
    where: TwitchNotificationsScalarWhereInput
    data: XOR<TwitchNotificationsUpdateManyMutationInput, TwitchNotificationsUncheckedUpdateManyWithoutGuildsInput>
  }

  export type TwitchNotificationsScalarWhereInput = {
    AND?: TwitchNotificationsScalarWhereInput | TwitchNotificationsScalarWhereInput[]
    OR?: TwitchNotificationsScalarWhereInput[]
    NOT?: TwitchNotificationsScalarWhereInput | TwitchNotificationsScalarWhereInput[]
    id?: StringFilter<"TwitchNotifications"> | string
    UUID?: StringFilter<"TwitchNotifications"> | string
    TwitchChannelName?: StringFilter<"TwitchNotifications"> | string
    ChannelId?: StringFilter<"TwitchNotifications"> | string
    Live?: BoolFilter<"TwitchNotifications"> | boolean
    MessageTemplateId?: StringFilter<"TwitchNotifications"> | string
    PingRoles?: StringNullableListFilter<"TwitchNotifications">
    GuildId?: StringFilter<"TwitchNotifications"> | string
  }

  export type GuildWelcomeSetupsUpsertWithoutGuildsInput = {
    update: XOR<GuildWelcomeSetupsUpdateWithoutGuildsInput, GuildWelcomeSetupsUncheckedUpdateWithoutGuildsInput>
    create: XOR<GuildWelcomeSetupsCreateWithoutGuildsInput, GuildWelcomeSetupsUncheckedCreateWithoutGuildsInput>
    where?: GuildWelcomeSetupsWhereInput
  }

  export type GuildWelcomeSetupsUpdateToOneWithWhereWithoutGuildsInput = {
    where?: GuildWelcomeSetupsWhereInput
    data: XOR<GuildWelcomeSetupsUpdateWithoutGuildsInput, GuildWelcomeSetupsUncheckedUpdateWithoutGuildsInput>
  }

  export type GuildWelcomeSetupsUpdateWithoutGuildsInput = {
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Image?: BoolFieldUpdateOperationsInput | boolean
    ImageData?: XOR<WelcomeLeaveImageDataUpdateEnvelopeInput, WelcomeLeaveImageDataCreateInput>
  }

  export type GuildWelcomeSetupsUncheckedUpdateWithoutGuildsInput = {
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Image?: BoolFieldUpdateOperationsInput | boolean
    ImageData?: XOR<WelcomeLeaveImageDataUpdateEnvelopeInput, WelcomeLeaveImageDataCreateInput>
  }

  export type YoutubeNotificationsUpsertWithWhereUniqueWithoutGuildsInput = {
    where: YoutubeNotificationsWhereUniqueInput
    update: XOR<YoutubeNotificationsUpdateWithoutGuildsInput, YoutubeNotificationsUncheckedUpdateWithoutGuildsInput>
    create: XOR<YoutubeNotificationsCreateWithoutGuildsInput, YoutubeNotificationsUncheckedCreateWithoutGuildsInput>
  }

  export type YoutubeNotificationsUpdateWithWhereUniqueWithoutGuildsInput = {
    where: YoutubeNotificationsWhereUniqueInput
    data: XOR<YoutubeNotificationsUpdateWithoutGuildsInput, YoutubeNotificationsUncheckedUpdateWithoutGuildsInput>
  }

  export type YoutubeNotificationsUpdateManyWithWhereWithoutGuildsInput = {
    where: YoutubeNotificationsScalarWhereInput
    data: XOR<YoutubeNotificationsUpdateManyMutationInput, YoutubeNotificationsUncheckedUpdateManyWithoutGuildsInput>
  }

  export type YoutubeNotificationsScalarWhereInput = {
    AND?: YoutubeNotificationsScalarWhereInput | YoutubeNotificationsScalarWhereInput[]
    OR?: YoutubeNotificationsScalarWhereInput[]
    NOT?: YoutubeNotificationsScalarWhereInput | YoutubeNotificationsScalarWhereInput[]
    id?: StringFilter<"YoutubeNotifications"> | string
    YoutubeChannelId?: StringFilter<"YoutubeNotifications"> | string
    ChannelId?: StringFilter<"YoutubeNotifications"> | string
    Latest?: StringNullableListFilter<"YoutubeNotifications">
    MessageTemplateId?: StringFilter<"YoutubeNotifications"> | string
    PingRoles?: StringNullableListFilter<"YoutubeNotifications">
    UUID?: StringFilter<"YoutubeNotifications"> | string
    GuildId?: StringFilter<"YoutubeNotifications"> | string
  }

  export type GuildLoggersUpsertWithWhereUniqueWithoutGuildsInput = {
    where: GuildLoggersWhereUniqueInput
    update: XOR<GuildLoggersUpdateWithoutGuildsInput, GuildLoggersUncheckedUpdateWithoutGuildsInput>
    create: XOR<GuildLoggersCreateWithoutGuildsInput, GuildLoggersUncheckedCreateWithoutGuildsInput>
  }

  export type GuildLoggersUpdateWithWhereUniqueWithoutGuildsInput = {
    where: GuildLoggersWhereUniqueInput
    data: XOR<GuildLoggersUpdateWithoutGuildsInput, GuildLoggersUncheckedUpdateWithoutGuildsInput>
  }

  export type GuildLoggersUpdateManyWithWhereWithoutGuildsInput = {
    where: GuildLoggersScalarWhereInput
    data: XOR<GuildLoggersUpdateManyMutationInput, GuildLoggersUncheckedUpdateManyWithoutGuildsInput>
  }

  export type GuildLoggersScalarWhereInput = {
    AND?: GuildLoggersScalarWhereInput | GuildLoggersScalarWhereInput[]
    OR?: GuildLoggersScalarWhereInput[]
    NOT?: GuildLoggersScalarWhereInput | GuildLoggersScalarWhereInput[]
    id?: StringFilter<"GuildLoggers"> | string
    UUID?: StringFilter<"GuildLoggers"> | string
    Notes?: StringNullableListFilter<"GuildLoggers">
    LogMessage?: StringFilter<"GuildLoggers"> | string
    LogJSON?: StringFilter<"GuildLoggers"> | string
    GuildId?: StringFilter<"GuildLoggers"> | string
  }

  export type GuildsCreateWithoutAutoAutoDeletesInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutAutoAutoDeletesInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutAutoAutoDeletesInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutAutoAutoDeletesInput, GuildsUncheckedCreateWithoutAutoAutoDeletesInput>
  }

  export type GuildsUpsertWithoutAutoAutoDeletesInput = {
    update: XOR<GuildsUpdateWithoutAutoAutoDeletesInput, GuildsUncheckedUpdateWithoutAutoAutoDeletesInput>
    create: XOR<GuildsCreateWithoutAutoAutoDeletesInput, GuildsUncheckedCreateWithoutAutoAutoDeletesInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutAutoAutoDeletesInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutAutoAutoDeletesInput, GuildsUncheckedUpdateWithoutAutoAutoDeletesInput>
  }

  export type GuildsUpdateWithoutAutoAutoDeletesInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutAutoAutoDeletesInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsCreateWithoutAutoPublishInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutAutoPublishInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutAutoPublishInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutAutoPublishInput, GuildsUncheckedCreateWithoutAutoPublishInput>
  }

  export type GuildsUpsertWithoutAutoPublishInput = {
    update: XOR<GuildsUpdateWithoutAutoPublishInput, GuildsUncheckedUpdateWithoutAutoPublishInput>
    create: XOR<GuildsCreateWithoutAutoPublishInput, GuildsUncheckedCreateWithoutAutoPublishInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutAutoPublishInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutAutoPublishInput, GuildsUncheckedUpdateWithoutAutoPublishInput>
  }

  export type GuildsUpdateWithoutAutoPublishInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutAutoPublishInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsCreateWithoutAutoReactsInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutAutoReactsInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutAutoReactsInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutAutoReactsInput, GuildsUncheckedCreateWithoutAutoReactsInput>
  }

  export type GuildsUpsertWithoutAutoReactsInput = {
    update: XOR<GuildsUpdateWithoutAutoReactsInput, GuildsUncheckedUpdateWithoutAutoReactsInput>
    create: XOR<GuildsCreateWithoutAutoReactsInput, GuildsUncheckedCreateWithoutAutoReactsInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutAutoReactsInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutAutoReactsInput, GuildsUncheckedUpdateWithoutAutoReactsInput>
  }

  export type GuildsUpdateWithoutAutoReactsInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutAutoReactsInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsCreateWithoutAutoRolesInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutAutoRolesInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutAutoRolesInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutAutoRolesInput, GuildsUncheckedCreateWithoutAutoRolesInput>
  }

  export type GuildsUpsertWithoutAutoRolesInput = {
    update: XOR<GuildsUpdateWithoutAutoRolesInput, GuildsUncheckedUpdateWithoutAutoRolesInput>
    create: XOR<GuildsCreateWithoutAutoRolesInput, GuildsUncheckedCreateWithoutAutoRolesInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutAutoRolesInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutAutoRolesInput, GuildsUncheckedUpdateWithoutAutoRolesInput>
  }

  export type GuildsUpdateWithoutAutoRolesInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutAutoRolesInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsCreateWithoutGuildBansInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutGuildBansInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutGuildBansInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutGuildBansInput, GuildsUncheckedCreateWithoutGuildBansInput>
  }

  export type GuildsUpsertWithoutGuildBansInput = {
    update: XOR<GuildsUpdateWithoutGuildBansInput, GuildsUncheckedUpdateWithoutGuildBansInput>
    create: XOR<GuildsCreateWithoutGuildBansInput, GuildsUncheckedCreateWithoutGuildBansInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutGuildBansInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutGuildBansInput, GuildsUncheckedUpdateWithoutGuildBansInput>
  }

  export type GuildsUpdateWithoutGuildBansInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutGuildBansInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsCreateWithoutChatModerationsInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutChatModerationsInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutChatModerationsInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutChatModerationsInput, GuildsUncheckedCreateWithoutChatModerationsInput>
  }

  export type GuildsUpsertWithoutChatModerationsInput = {
    update: XOR<GuildsUpdateWithoutChatModerationsInput, GuildsUncheckedUpdateWithoutChatModerationsInput>
    create: XOR<GuildsCreateWithoutChatModerationsInput, GuildsUncheckedCreateWithoutChatModerationsInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutChatModerationsInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutChatModerationsInput, GuildsUncheckedUpdateWithoutChatModerationsInput>
  }

  export type GuildsUpdateWithoutChatModerationsInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutChatModerationsInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type SyncedChannelLinkMessagesCreateWithoutChannelLinksInput = {
    id?: string
    GuildId: string
    UserMessageId: string
    WebhookMessageId: string
    WebhookURL: string
    ChannelId: string
  }

  export type SyncedChannelLinkMessagesUncheckedCreateWithoutChannelLinksInput = {
    id?: string
    GuildId: string
    UserMessageId: string
    WebhookMessageId: string
    WebhookURL: string
    ChannelId: string
  }

  export type SyncedChannelLinkMessagesCreateOrConnectWithoutChannelLinksInput = {
    where: SyncedChannelLinkMessagesWhereUniqueInput
    create: XOR<SyncedChannelLinkMessagesCreateWithoutChannelLinksInput, SyncedChannelLinkMessagesUncheckedCreateWithoutChannelLinksInput>
  }

  export type SyncedChannelLinkMessagesCreateManyChannelLinksInputEnvelope = {
    data: SyncedChannelLinkMessagesCreateManyChannelLinksInput | SyncedChannelLinkMessagesCreateManyChannelLinksInput[]
  }

  export type GuildsCreateWithoutChannelLinksInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutChannelLinksInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutChannelLinksInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutChannelLinksInput, GuildsUncheckedCreateWithoutChannelLinksInput>
  }

  export type SyncedChannelLinkMessagesUpsertWithWhereUniqueWithoutChannelLinksInput = {
    where: SyncedChannelLinkMessagesWhereUniqueInput
    update: XOR<SyncedChannelLinkMessagesUpdateWithoutChannelLinksInput, SyncedChannelLinkMessagesUncheckedUpdateWithoutChannelLinksInput>
    create: XOR<SyncedChannelLinkMessagesCreateWithoutChannelLinksInput, SyncedChannelLinkMessagesUncheckedCreateWithoutChannelLinksInput>
  }

  export type SyncedChannelLinkMessagesUpdateWithWhereUniqueWithoutChannelLinksInput = {
    where: SyncedChannelLinkMessagesWhereUniqueInput
    data: XOR<SyncedChannelLinkMessagesUpdateWithoutChannelLinksInput, SyncedChannelLinkMessagesUncheckedUpdateWithoutChannelLinksInput>
  }

  export type SyncedChannelLinkMessagesUpdateManyWithWhereWithoutChannelLinksInput = {
    where: SyncedChannelLinkMessagesScalarWhereInput
    data: XOR<SyncedChannelLinkMessagesUpdateManyMutationInput, SyncedChannelLinkMessagesUncheckedUpdateManyWithoutChannelLinksInput>
  }

  export type SyncedChannelLinkMessagesScalarWhereInput = {
    AND?: SyncedChannelLinkMessagesScalarWhereInput | SyncedChannelLinkMessagesScalarWhereInput[]
    OR?: SyncedChannelLinkMessagesScalarWhereInput[]
    NOT?: SyncedChannelLinkMessagesScalarWhereInput | SyncedChannelLinkMessagesScalarWhereInput[]
    id?: StringFilter<"SyncedChannelLinkMessages"> | string
    GuildId?: StringFilter<"SyncedChannelLinkMessages"> | string
    UserMessageId?: StringFilter<"SyncedChannelLinkMessages"> | string
    WebhookMessageId?: StringFilter<"SyncedChannelLinkMessages"> | string
    WebhookURL?: StringFilter<"SyncedChannelLinkMessages"> | string
    ChannelId?: StringFilter<"SyncedChannelLinkMessages"> | string
    ChannelLinkId?: StringFilter<"SyncedChannelLinkMessages"> | string
  }

  export type GuildsUpsertWithoutChannelLinksInput = {
    update: XOR<GuildsUpdateWithoutChannelLinksInput, GuildsUncheckedUpdateWithoutChannelLinksInput>
    create: XOR<GuildsCreateWithoutChannelLinksInput, GuildsUncheckedCreateWithoutChannelLinksInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutChannelLinksInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutChannelLinksInput, GuildsUncheckedUpdateWithoutChannelLinksInput>
  }

  export type GuildsUpdateWithoutChannelLinksInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutChannelLinksInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type ChannelLinksCreateWithoutSyncedChannelLinkMessageInput = {
    id?: string
    UUID: string
    ChannelId: string
    WebhookUrls?: ChannelLinksCreateWebhookUrlsInput | string[]
    Guilds: GuildsCreateNestedOneWithoutChannelLinksInput
  }

  export type ChannelLinksUncheckedCreateWithoutSyncedChannelLinkMessageInput = {
    id?: string
    UUID: string
    ChannelId: string
    WebhookUrls?: ChannelLinksCreateWebhookUrlsInput | string[]
    GuildId: string
  }

  export type ChannelLinksCreateOrConnectWithoutSyncedChannelLinkMessageInput = {
    where: ChannelLinksWhereUniqueInput
    create: XOR<ChannelLinksCreateWithoutSyncedChannelLinkMessageInput, ChannelLinksUncheckedCreateWithoutSyncedChannelLinkMessageInput>
  }

  export type ChannelLinksUpsertWithoutSyncedChannelLinkMessageInput = {
    update: XOR<ChannelLinksUpdateWithoutSyncedChannelLinkMessageInput, ChannelLinksUncheckedUpdateWithoutSyncedChannelLinkMessageInput>
    create: XOR<ChannelLinksCreateWithoutSyncedChannelLinkMessageInput, ChannelLinksUncheckedCreateWithoutSyncedChannelLinkMessageInput>
    where?: ChannelLinksWhereInput
  }

  export type ChannelLinksUpdateToOneWithWhereWithoutSyncedChannelLinkMessageInput = {
    where?: ChannelLinksWhereInput
    data: XOR<ChannelLinksUpdateWithoutSyncedChannelLinkMessageInput, ChannelLinksUncheckedUpdateWithoutSyncedChannelLinkMessageInput>
  }

  export type ChannelLinksUpdateWithoutSyncedChannelLinkMessageInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    WebhookUrls?: ChannelLinksUpdateWebhookUrlsInput | string[]
    Guilds?: GuildsUpdateOneRequiredWithoutChannelLinksNestedInput
  }

  export type ChannelLinksUncheckedUpdateWithoutSyncedChannelLinkMessageInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    WebhookUrls?: ChannelLinksUpdateWebhookUrlsInput | string[]
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type GuildsCreateWithoutDiscordAddonsInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutDiscordAddonsInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutDiscordAddonsInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutDiscordAddonsInput, GuildsUncheckedCreateWithoutDiscordAddonsInput>
  }

  export type GuildsUpsertWithoutDiscordAddonsInput = {
    update: XOR<GuildsUpdateWithoutDiscordAddonsInput, GuildsUncheckedUpdateWithoutDiscordAddonsInput>
    create: XOR<GuildsCreateWithoutDiscordAddonsInput, GuildsUncheckedCreateWithoutDiscordAddonsInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutDiscordAddonsInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutDiscordAddonsInput, GuildsUncheckedUpdateWithoutDiscordAddonsInput>
  }

  export type GuildsUpdateWithoutDiscordAddonsInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutDiscordAddonsInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsCreateWithoutGiveawaysInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutGiveawaysInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutGiveawaysInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutGiveawaysInput, GuildsUncheckedCreateWithoutGiveawaysInput>
  }

  export type GuildsUpsertWithoutGiveawaysInput = {
    update: XOR<GuildsUpdateWithoutGiveawaysInput, GuildsUncheckedUpdateWithoutGiveawaysInput>
    create: XOR<GuildsCreateWithoutGiveawaysInput, GuildsUncheckedCreateWithoutGiveawaysInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutGiveawaysInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutGiveawaysInput, GuildsUncheckedUpdateWithoutGiveawaysInput>
  }

  export type GuildsUpdateWithoutGiveawaysInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutGiveawaysInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type TempVoiceChannelsCreateWithoutTempVoicesInput = {
    id?: string
    GuildId: string
    ChannelId: string
    OwnerId: string
  }

  export type TempVoiceChannelsUncheckedCreateWithoutTempVoicesInput = {
    id?: string
    GuildId: string
    ChannelId: string
    OwnerId: string
  }

  export type TempVoiceChannelsCreateOrConnectWithoutTempVoicesInput = {
    where: TempVoiceChannelsWhereUniqueInput
    create: XOR<TempVoiceChannelsCreateWithoutTempVoicesInput, TempVoiceChannelsUncheckedCreateWithoutTempVoicesInput>
  }

  export type TempVoiceChannelsCreateManyTempVoicesInputEnvelope = {
    data: TempVoiceChannelsCreateManyTempVoicesInput | TempVoiceChannelsCreateManyTempVoicesInput[]
  }

  export type GuildsCreateWithoutTempVoicesInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutTempVoicesInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutTempVoicesInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutTempVoicesInput, GuildsUncheckedCreateWithoutTempVoicesInput>
  }

  export type TempVoiceChannelsUpsertWithWhereUniqueWithoutTempVoicesInput = {
    where: TempVoiceChannelsWhereUniqueInput
    update: XOR<TempVoiceChannelsUpdateWithoutTempVoicesInput, TempVoiceChannelsUncheckedUpdateWithoutTempVoicesInput>
    create: XOR<TempVoiceChannelsCreateWithoutTempVoicesInput, TempVoiceChannelsUncheckedCreateWithoutTempVoicesInput>
  }

  export type TempVoiceChannelsUpdateWithWhereUniqueWithoutTempVoicesInput = {
    where: TempVoiceChannelsWhereUniqueInput
    data: XOR<TempVoiceChannelsUpdateWithoutTempVoicesInput, TempVoiceChannelsUncheckedUpdateWithoutTempVoicesInput>
  }

  export type TempVoiceChannelsUpdateManyWithWhereWithoutTempVoicesInput = {
    where: TempVoiceChannelsScalarWhereInput
    data: XOR<TempVoiceChannelsUpdateManyMutationInput, TempVoiceChannelsUncheckedUpdateManyWithoutTempVoicesInput>
  }

  export type TempVoiceChannelsScalarWhereInput = {
    AND?: TempVoiceChannelsScalarWhereInput | TempVoiceChannelsScalarWhereInput[]
    OR?: TempVoiceChannelsScalarWhereInput[]
    NOT?: TempVoiceChannelsScalarWhereInput | TempVoiceChannelsScalarWhereInput[]
    id?: StringFilter<"TempVoiceChannels"> | string
    GuildId?: StringFilter<"TempVoiceChannels"> | string
    ChannelId?: StringFilter<"TempVoiceChannels"> | string
    OwnerId?: StringFilter<"TempVoiceChannels"> | string
    TempVoiceId?: StringFilter<"TempVoiceChannels"> | string
  }

  export type GuildsUpsertWithoutTempVoicesInput = {
    update: XOR<GuildsUpdateWithoutTempVoicesInput, GuildsUncheckedUpdateWithoutTempVoicesInput>
    create: XOR<GuildsCreateWithoutTempVoicesInput, GuildsUncheckedCreateWithoutTempVoicesInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutTempVoicesInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutTempVoicesInput, GuildsUncheckedUpdateWithoutTempVoicesInput>
  }

  export type GuildsUpdateWithoutTempVoicesInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutTempVoicesInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type TempVoicesCreateWithoutTempVoiceChannelsInput = {
    id?: string
    UUID: string
    Name: string
    JointoCreateChannel: string
    JointoCreateCategory: string
    Manage: boolean
    PresetLimit: number
    Guilds: GuildsCreateNestedOneWithoutTempVoicesInput
  }

  export type TempVoicesUncheckedCreateWithoutTempVoiceChannelsInput = {
    id?: string
    UUID: string
    Name: string
    JointoCreateChannel: string
    JointoCreateCategory: string
    Manage: boolean
    PresetLimit: number
    GuildId: string
  }

  export type TempVoicesCreateOrConnectWithoutTempVoiceChannelsInput = {
    where: TempVoicesWhereUniqueInput
    create: XOR<TempVoicesCreateWithoutTempVoiceChannelsInput, TempVoicesUncheckedCreateWithoutTempVoiceChannelsInput>
  }

  export type TempVoicesUpsertWithoutTempVoiceChannelsInput = {
    update: XOR<TempVoicesUpdateWithoutTempVoiceChannelsInput, TempVoicesUncheckedUpdateWithoutTempVoiceChannelsInput>
    create: XOR<TempVoicesCreateWithoutTempVoiceChannelsInput, TempVoicesUncheckedCreateWithoutTempVoiceChannelsInput>
    where?: TempVoicesWhereInput
  }

  export type TempVoicesUpdateToOneWithWhereWithoutTempVoiceChannelsInput = {
    where?: TempVoicesWhereInput
    data: XOR<TempVoicesUpdateWithoutTempVoiceChannelsInput, TempVoicesUncheckedUpdateWithoutTempVoiceChannelsInput>
  }

  export type TempVoicesUpdateWithoutTempVoiceChannelsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    JointoCreateChannel?: StringFieldUpdateOperationsInput | string
    JointoCreateCategory?: StringFieldUpdateOperationsInput | string
    Manage?: BoolFieldUpdateOperationsInput | boolean
    PresetLimit?: IntFieldUpdateOperationsInput | number
    Guilds?: GuildsUpdateOneRequiredWithoutTempVoicesNestedInput
  }

  export type TempVoicesUncheckedUpdateWithoutTempVoiceChannelsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    JointoCreateChannel?: StringFieldUpdateOperationsInput | string
    JointoCreateCategory?: StringFieldUpdateOperationsInput | string
    Manage?: BoolFieldUpdateOperationsInput | boolean
    PresetLimit?: IntFieldUpdateOperationsInput | number
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type GuildsCreateWithoutGuildLeaveSetupInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutGuildLeaveSetupInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutGuildLeaveSetupInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutGuildLeaveSetupInput, GuildsUncheckedCreateWithoutGuildLeaveSetupInput>
  }

  export type WelcomeLeaveImageDataUpsertInput = {
    set: WelcomeLeaveImageDataCreateInput | null
    update: WelcomeLeaveImageDataUpdateInput
  }

  export type GuildsUpsertWithoutGuildLeaveSetupInput = {
    update: XOR<GuildsUpdateWithoutGuildLeaveSetupInput, GuildsUncheckedUpdateWithoutGuildLeaveSetupInput>
    create: XOR<GuildsCreateWithoutGuildLeaveSetupInput, GuildsUncheckedCreateWithoutGuildLeaveSetupInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutGuildLeaveSetupInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutGuildLeaveSetupInput, GuildsUncheckedUpdateWithoutGuildLeaveSetupInput>
  }

  export type GuildsUpdateWithoutGuildLeaveSetupInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutGuildLeaveSetupInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsCreateWithoutGuildWelcomeSetupInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutGuildWelcomeSetupInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutGuildWelcomeSetupInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutGuildWelcomeSetupInput, GuildsUncheckedCreateWithoutGuildWelcomeSetupInput>
  }

  export type WelcomeLeaveImageDataUpdateInput = {
    Title?: StringFieldUpdateOperationsInput | string
    Text?: StringFieldUpdateOperationsInput | string
    Subtitle?: StringFieldUpdateOperationsInput | string
    Background?: StringFieldUpdateOperationsInput | string
    Theme?: StringFieldUpdateOperationsInput | string
    Color?: StringFieldUpdateOperationsInput | string
    Gradient?: StringFieldUpdateOperationsInput | string
  }

  export type GuildsUpsertWithoutGuildWelcomeSetupInput = {
    update: XOR<GuildsUpdateWithoutGuildWelcomeSetupInput, GuildsUncheckedUpdateWithoutGuildWelcomeSetupInput>
    create: XOR<GuildsCreateWithoutGuildWelcomeSetupInput, GuildsUncheckedCreateWithoutGuildWelcomeSetupInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutGuildWelcomeSetupInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutGuildWelcomeSetupInput, GuildsUncheckedUpdateWithoutGuildWelcomeSetupInput>
  }

  export type GuildsUpdateWithoutGuildWelcomeSetupInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutGuildWelcomeSetupInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsCreateWithoutGuildLoggingInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutGuildLoggingInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutGuildLoggingInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutGuildLoggingInput, GuildsUncheckedCreateWithoutGuildLoggingInput>
  }

  export type GuildsUpsertWithoutGuildLoggingInput = {
    update: XOR<GuildsUpdateWithoutGuildLoggingInput, GuildsUncheckedUpdateWithoutGuildLoggingInput>
    create: XOR<GuildsCreateWithoutGuildLoggingInput, GuildsUncheckedCreateWithoutGuildLoggingInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutGuildLoggingInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutGuildLoggingInput, GuildsUncheckedUpdateWithoutGuildLoggingInput>
  }

  export type GuildsUpdateWithoutGuildLoggingInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutGuildLoggingInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsCreateWithoutGuildLoggersInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutGuildLoggersInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutGuildLoggersInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutGuildLoggersInput, GuildsUncheckedCreateWithoutGuildLoggersInput>
  }

  export type GuildsUpsertWithoutGuildLoggersInput = {
    update: XOR<GuildsUpdateWithoutGuildLoggersInput, GuildsUncheckedUpdateWithoutGuildLoggersInput>
    create: XOR<GuildsCreateWithoutGuildLoggersInput, GuildsUncheckedCreateWithoutGuildLoggersInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutGuildLoggersInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutGuildLoggersInput, GuildsUncheckedUpdateWithoutGuildLoggersInput>
  }

  export type GuildsUpdateWithoutGuildLoggersInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutGuildLoggersInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsCreateWithoutMessageTemplatesInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutMessageTemplatesInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutMessageTemplatesInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutMessageTemplatesInput, GuildsUncheckedCreateWithoutMessageTemplatesInput>
  }

  export type GuildsUpsertWithoutMessageTemplatesInput = {
    update: XOR<GuildsUpdateWithoutMessageTemplatesInput, GuildsUncheckedUpdateWithoutMessageTemplatesInput>
    create: XOR<GuildsCreateWithoutMessageTemplatesInput, GuildsUncheckedCreateWithoutMessageTemplatesInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutMessageTemplatesInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutMessageTemplatesInput, GuildsUncheckedUpdateWithoutMessageTemplatesInput>
  }

  export type GuildsUpdateWithoutMessageTemplatesInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutMessageTemplatesInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsCreateWithoutPermissionsInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutPermissionsInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutPermissionsInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutPermissionsInput, GuildsUncheckedCreateWithoutPermissionsInput>
  }

  export type PermissionDataUpdateManyInput = {
    where: PermissionDataWhereInput
    data: PermissionDataUpdateInput
  }

  export type PermissionDataDeleteManyInput = {
    where: PermissionDataWhereInput
  }

  export type GuildsUpsertWithoutPermissionsInput = {
    update: XOR<GuildsUpdateWithoutPermissionsInput, GuildsUncheckedUpdateWithoutPermissionsInput>
    create: XOR<GuildsCreateWithoutPermissionsInput, GuildsUncheckedCreateWithoutPermissionsInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutPermissionsInput, GuildsUncheckedUpdateWithoutPermissionsInput>
  }

  export type GuildsUpdateWithoutPermissionsInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutPermissionsInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsCreateWithoutReactionRoleInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutReactionRoleInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutReactionRoleInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutReactionRoleInput, GuildsUncheckedCreateWithoutReactionRoleInput>
  }

  export type ReactionRoleButtonUpsertInput = {
    set: ReactionRoleButtonCreateInput | null
    update: ReactionRoleButtonUpdateInput
  }

  export type ReactionRoleSelectmenuUpsertInput = {
    set: ReactionRoleSelectmenuCreateInput | null
    update: ReactionRoleSelectmenuUpdateInput
  }

  export type GuildsUpsertWithoutReactionRoleInput = {
    update: XOR<GuildsUpdateWithoutReactionRoleInput, GuildsUncheckedUpdateWithoutReactionRoleInput>
    create: XOR<GuildsCreateWithoutReactionRoleInput, GuildsUncheckedCreateWithoutReactionRoleInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutReactionRoleInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutReactionRoleInput, GuildsUncheckedUpdateWithoutReactionRoleInput>
  }

  export type GuildsUpdateWithoutReactionRoleInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutReactionRoleInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type VerificationGatesCreateWithoutVerificationGatesInput = {
    id?: string
    UUID: string
    ChannelId: string
    MessageId: string
    Action?: string | null
    ActionType?: string | null
    Roles?: VerificationGatesCreateRolesInput | string[]
    VerifiedUsers?: VerificationGatesCreateVerifiedUsersInput | string[]
    CreatedAt: Date | string
    Active?: boolean | null
    ChannelPermissions?: VerificationGatesPermissionCreateNestedManyWithoutVerificationGatesInput
  }

  export type VerificationGatesUncheckedCreateWithoutVerificationGatesInput = {
    id?: string
    UUID: string
    ChannelId: string
    MessageId: string
    Action?: string | null
    ActionType?: string | null
    Roles?: VerificationGatesCreateRolesInput | string[]
    VerifiedUsers?: VerificationGatesCreateVerifiedUsersInput | string[]
    CreatedAt: Date | string
    Active?: boolean | null
    ChannelPermissions?: VerificationGatesPermissionUncheckedCreateNestedManyWithoutVerificationGatesInput
  }

  export type VerificationGatesCreateOrConnectWithoutVerificationGatesInput = {
    where: VerificationGatesWhereUniqueInput
    create: XOR<VerificationGatesCreateWithoutVerificationGatesInput, VerificationGatesUncheckedCreateWithoutVerificationGatesInput>
  }

  export type VerificationGatesCreateManyVerificationGatesInputEnvelope = {
    data: VerificationGatesCreateManyVerificationGatesInput | VerificationGatesCreateManyVerificationGatesInput[]
  }

  export type GuildsCreateWithoutSecurityInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutSecurityInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutSecurityInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutSecurityInput, GuildsUncheckedCreateWithoutSecurityInput>
  }

  export type VerificationGatesUpsertWithWhereUniqueWithoutVerificationGatesInput = {
    where: VerificationGatesWhereUniqueInput
    update: XOR<VerificationGatesUpdateWithoutVerificationGatesInput, VerificationGatesUncheckedUpdateWithoutVerificationGatesInput>
    create: XOR<VerificationGatesCreateWithoutVerificationGatesInput, VerificationGatesUncheckedCreateWithoutVerificationGatesInput>
  }

  export type VerificationGatesUpdateWithWhereUniqueWithoutVerificationGatesInput = {
    where: VerificationGatesWhereUniqueInput
    data: XOR<VerificationGatesUpdateWithoutVerificationGatesInput, VerificationGatesUncheckedUpdateWithoutVerificationGatesInput>
  }

  export type VerificationGatesUpdateManyWithWhereWithoutVerificationGatesInput = {
    where: VerificationGatesScalarWhereInput
    data: XOR<VerificationGatesUpdateManyMutationInput, VerificationGatesUncheckedUpdateManyWithoutVerificationGatesInput>
  }

  export type VerificationGatesScalarWhereInput = {
    AND?: VerificationGatesScalarWhereInput | VerificationGatesScalarWhereInput[]
    OR?: VerificationGatesScalarWhereInput[]
    NOT?: VerificationGatesScalarWhereInput | VerificationGatesScalarWhereInput[]
    id?: StringFilter<"VerificationGates"> | string
    UUID?: StringFilter<"VerificationGates"> | string
    ChannelId?: StringFilter<"VerificationGates"> | string
    MessageId?: StringFilter<"VerificationGates"> | string
    Action?: StringNullableFilter<"VerificationGates"> | string | null
    ActionType?: StringNullableFilter<"VerificationGates"> | string | null
    Roles?: StringNullableListFilter<"VerificationGates">
    VerifiedUsers?: StringNullableListFilter<"VerificationGates">
    CreatedAt?: DateTimeFilter<"VerificationGates"> | Date | string
    Active?: BoolNullableFilter<"VerificationGates"> | boolean | null
    SecurityId?: StringFilter<"VerificationGates"> | string
  }

  export type GuildsUpsertWithoutSecurityInput = {
    update: XOR<GuildsUpdateWithoutSecurityInput, GuildsUncheckedUpdateWithoutSecurityInput>
    create: XOR<GuildsCreateWithoutSecurityInput, GuildsUncheckedCreateWithoutSecurityInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutSecurityInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutSecurityInput, GuildsUncheckedUpdateWithoutSecurityInput>
  }

  export type GuildsUpdateWithoutSecurityInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutSecurityInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type VerificationGatesPermissionCreateWithoutVerificationGatesInput = {
    id?: string
    Permission?: VerificationGatesPermissionCreatePermissionInput | string[]
    ChannelId: string
  }

  export type VerificationGatesPermissionUncheckedCreateWithoutVerificationGatesInput = {
    id?: string
    Permission?: VerificationGatesPermissionCreatePermissionInput | string[]
    ChannelId: string
  }

  export type VerificationGatesPermissionCreateOrConnectWithoutVerificationGatesInput = {
    where: VerificationGatesPermissionWhereUniqueInput
    create: XOR<VerificationGatesPermissionCreateWithoutVerificationGatesInput, VerificationGatesPermissionUncheckedCreateWithoutVerificationGatesInput>
  }

  export type VerificationGatesPermissionCreateManyVerificationGatesInputEnvelope = {
    data: VerificationGatesPermissionCreateManyVerificationGatesInput | VerificationGatesPermissionCreateManyVerificationGatesInput[]
  }

  export type SecuritysCreateWithoutVerificationGatesInput = {
    id?: string
    InviteLoggingActive?: string | null
    MaxAccountAge?: number | null
    Guilds: GuildsCreateNestedOneWithoutSecurityInput
  }

  export type SecuritysUncheckedCreateWithoutVerificationGatesInput = {
    id?: string
    InviteLoggingActive?: string | null
    MaxAccountAge?: number | null
    GuildId: string
  }

  export type SecuritysCreateOrConnectWithoutVerificationGatesInput = {
    where: SecuritysWhereUniqueInput
    create: XOR<SecuritysCreateWithoutVerificationGatesInput, SecuritysUncheckedCreateWithoutVerificationGatesInput>
  }

  export type VerificationGatesPermissionUpsertWithWhereUniqueWithoutVerificationGatesInput = {
    where: VerificationGatesPermissionWhereUniqueInput
    update: XOR<VerificationGatesPermissionUpdateWithoutVerificationGatesInput, VerificationGatesPermissionUncheckedUpdateWithoutVerificationGatesInput>
    create: XOR<VerificationGatesPermissionCreateWithoutVerificationGatesInput, VerificationGatesPermissionUncheckedCreateWithoutVerificationGatesInput>
  }

  export type VerificationGatesPermissionUpdateWithWhereUniqueWithoutVerificationGatesInput = {
    where: VerificationGatesPermissionWhereUniqueInput
    data: XOR<VerificationGatesPermissionUpdateWithoutVerificationGatesInput, VerificationGatesPermissionUncheckedUpdateWithoutVerificationGatesInput>
  }

  export type VerificationGatesPermissionUpdateManyWithWhereWithoutVerificationGatesInput = {
    where: VerificationGatesPermissionScalarWhereInput
    data: XOR<VerificationGatesPermissionUpdateManyMutationInput, VerificationGatesPermissionUncheckedUpdateManyWithoutVerificationGatesInput>
  }

  export type VerificationGatesPermissionScalarWhereInput = {
    AND?: VerificationGatesPermissionScalarWhereInput | VerificationGatesPermissionScalarWhereInput[]
    OR?: VerificationGatesPermissionScalarWhereInput[]
    NOT?: VerificationGatesPermissionScalarWhereInput | VerificationGatesPermissionScalarWhereInput[]
    id?: StringFilter<"VerificationGatesPermission"> | string
    Permission?: StringNullableListFilter<"VerificationGatesPermission">
    ChannelId?: StringFilter<"VerificationGatesPermission"> | string
    VerificationGateId?: StringFilter<"VerificationGatesPermission"> | string
  }

  export type SecuritysUpsertWithoutVerificationGatesInput = {
    update: XOR<SecuritysUpdateWithoutVerificationGatesInput, SecuritysUncheckedUpdateWithoutVerificationGatesInput>
    create: XOR<SecuritysCreateWithoutVerificationGatesInput, SecuritysUncheckedCreateWithoutVerificationGatesInput>
    where?: SecuritysWhereInput
  }

  export type SecuritysUpdateToOneWithWhereWithoutVerificationGatesInput = {
    where?: SecuritysWhereInput
    data: XOR<SecuritysUpdateWithoutVerificationGatesInput, SecuritysUncheckedUpdateWithoutVerificationGatesInput>
  }

  export type SecuritysUpdateWithoutVerificationGatesInput = {
    InviteLoggingActive?: NullableStringFieldUpdateOperationsInput | string | null
    MaxAccountAge?: NullableIntFieldUpdateOperationsInput | number | null
    Guilds?: GuildsUpdateOneRequiredWithoutSecurityNestedInput
  }

  export type SecuritysUncheckedUpdateWithoutVerificationGatesInput = {
    InviteLoggingActive?: NullableStringFieldUpdateOperationsInput | string | null
    MaxAccountAge?: NullableIntFieldUpdateOperationsInput | number | null
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationGatesCreateWithoutChannelPermissionsInput = {
    id?: string
    UUID: string
    ChannelId: string
    MessageId: string
    Action?: string | null
    ActionType?: string | null
    Roles?: VerificationGatesCreateRolesInput | string[]
    VerifiedUsers?: VerificationGatesCreateVerifiedUsersInput | string[]
    CreatedAt: Date | string
    Active?: boolean | null
    VerificationGates: SecuritysCreateNestedOneWithoutVerificationGatesInput
  }

  export type VerificationGatesUncheckedCreateWithoutChannelPermissionsInput = {
    id?: string
    UUID: string
    ChannelId: string
    MessageId: string
    Action?: string | null
    ActionType?: string | null
    Roles?: VerificationGatesCreateRolesInput | string[]
    VerifiedUsers?: VerificationGatesCreateVerifiedUsersInput | string[]
    CreatedAt: Date | string
    Active?: boolean | null
    SecurityId: string
  }

  export type VerificationGatesCreateOrConnectWithoutChannelPermissionsInput = {
    where: VerificationGatesWhereUniqueInput
    create: XOR<VerificationGatesCreateWithoutChannelPermissionsInput, VerificationGatesUncheckedCreateWithoutChannelPermissionsInput>
  }

  export type VerificationGatesUpsertWithoutChannelPermissionsInput = {
    update: XOR<VerificationGatesUpdateWithoutChannelPermissionsInput, VerificationGatesUncheckedUpdateWithoutChannelPermissionsInput>
    create: XOR<VerificationGatesCreateWithoutChannelPermissionsInput, VerificationGatesUncheckedCreateWithoutChannelPermissionsInput>
    where?: VerificationGatesWhereInput
  }

  export type VerificationGatesUpdateToOneWithWhereWithoutChannelPermissionsInput = {
    where?: VerificationGatesWhereInput
    data: XOR<VerificationGatesUpdateWithoutChannelPermissionsInput, VerificationGatesUncheckedUpdateWithoutChannelPermissionsInput>
  }

  export type VerificationGatesUpdateWithoutChannelPermissionsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    Action?: NullableStringFieldUpdateOperationsInput | string | null
    ActionType?: NullableStringFieldUpdateOperationsInput | string | null
    Roles?: VerificationGatesUpdateRolesInput | string[]
    VerifiedUsers?: VerificationGatesUpdateVerifiedUsersInput | string[]
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    VerificationGates?: SecuritysUpdateOneRequiredWithoutVerificationGatesNestedInput
  }

  export type VerificationGatesUncheckedUpdateWithoutChannelPermissionsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    Action?: NullableStringFieldUpdateOperationsInput | string | null
    ActionType?: NullableStringFieldUpdateOperationsInput | string | null
    Roles?: VerificationGatesUpdateRolesInput | string[]
    VerifiedUsers?: VerificationGatesUpdateVerifiedUsersInput | string[]
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SecurityId?: StringFieldUpdateOperationsInput | string
  }

  export type GuildsCreateWithoutSpotifyNotificationsInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutSpotifyNotificationsInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutSpotifyNotificationsInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutSpotifyNotificationsInput, GuildsUncheckedCreateWithoutSpotifyNotificationsInput>
  }

  export type GuildsUpsertWithoutSpotifyNotificationsInput = {
    update: XOR<GuildsUpdateWithoutSpotifyNotificationsInput, GuildsUncheckedUpdateWithoutSpotifyNotificationsInput>
    create: XOR<GuildsCreateWithoutSpotifyNotificationsInput, GuildsUncheckedCreateWithoutSpotifyNotificationsInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutSpotifyNotificationsInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutSpotifyNotificationsInput, GuildsUncheckedUpdateWithoutSpotifyNotificationsInput>
  }

  export type GuildsUpdateWithoutSpotifyNotificationsInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutSpotifyNotificationsInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsCreateWithoutTagsInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutTagsInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutTagsInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutTagsInput, GuildsUncheckedCreateWithoutTagsInput>
  }

  export type GuildsUpsertWithoutTagsInput = {
    update: XOR<GuildsUpdateWithoutTagsInput, GuildsUncheckedUpdateWithoutTagsInput>
    create: XOR<GuildsCreateWithoutTagsInput, GuildsUncheckedCreateWithoutTagsInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutTagsInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutTagsInput, GuildsUncheckedUpdateWithoutTagsInput>
  }

  export type GuildsUpdateWithoutTagsInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutTagsInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type TicketModalDataCreateWithoutTicketSetupInput = {
    id?: string
    Name: string
    Placeholder: string
    Type: number
  }

  export type TicketModalDataUncheckedCreateWithoutTicketSetupInput = {
    id?: string
    Name: string
    Placeholder: string
    Type: number
  }

  export type TicketModalDataCreateOrConnectWithoutTicketSetupInput = {
    where: TicketModalDataWhereUniqueInput
    create: XOR<TicketModalDataCreateWithoutTicketSetupInput, TicketModalDataUncheckedCreateWithoutTicketSetupInput>
  }

  export type TicketModalDataCreateManyTicketSetupInputEnvelope = {
    data: TicketModalDataCreateManyTicketSetupInput | TicketModalDataCreateManyTicketSetupInput[]
  }

  export type GuildsCreateWithoutTicketSetupsInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutTicketSetupsInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutTicketSetupsInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutTicketSetupsInput, GuildsUncheckedCreateWithoutTicketSetupsInput>
  }

  export type TicketsCreateWithoutTicketSetupInput = {
    id?: string
    TicketId: string
    GuildId: string
    ChannelId?: string | null
    ThreadId?: string | null
    IsClaimed?: boolean | null
    IsArchived?: boolean | null
    ArchiveMessageId?: string | null
    UserWhoHasClaimedId?: string | null
    IsLooked?: boolean | null
    TicketOwnerId: string
    AddedMemberIds?: TicketsCreateAddedMemberIdsInput | string[]
    Handlers?: TicketsCreateHandlersInput | string[]
    TranscriptChannelId: string
    TranscriptHTML?: string | null
    TicketNotes?: TicketsCreateTicketNotesInput | string[]
    TicketFeedback?: TicketFeedbackCreateNestedOneWithoutTicketInput
  }

  export type TicketsUncheckedCreateWithoutTicketSetupInput = {
    id?: string
    TicketId: string
    GuildId: string
    ChannelId?: string | null
    ThreadId?: string | null
    IsClaimed?: boolean | null
    IsArchived?: boolean | null
    ArchiveMessageId?: string | null
    UserWhoHasClaimedId?: string | null
    IsLooked?: boolean | null
    TicketOwnerId: string
    AddedMemberIds?: TicketsCreateAddedMemberIdsInput | string[]
    Handlers?: TicketsCreateHandlersInput | string[]
    TranscriptChannelId: string
    TranscriptHTML?: string | null
    TicketNotes?: TicketsCreateTicketNotesInput | string[]
    TicketFeedback?: TicketFeedbackUncheckedCreateNestedOneWithoutTicketInput
  }

  export type TicketsCreateOrConnectWithoutTicketSetupInput = {
    where: TicketsWhereUniqueInput
    create: XOR<TicketsCreateWithoutTicketSetupInput, TicketsUncheckedCreateWithoutTicketSetupInput>
  }

  export type TicketsCreateManyTicketSetupInputEnvelope = {
    data: TicketsCreateManyTicketSetupInput | TicketsCreateManyTicketSetupInput[]
  }

  export type TicketModalDataUpsertWithWhereUniqueWithoutTicketSetupInput = {
    where: TicketModalDataWhereUniqueInput
    update: XOR<TicketModalDataUpdateWithoutTicketSetupInput, TicketModalDataUncheckedUpdateWithoutTicketSetupInput>
    create: XOR<TicketModalDataCreateWithoutTicketSetupInput, TicketModalDataUncheckedCreateWithoutTicketSetupInput>
  }

  export type TicketModalDataUpdateWithWhereUniqueWithoutTicketSetupInput = {
    where: TicketModalDataWhereUniqueInput
    data: XOR<TicketModalDataUpdateWithoutTicketSetupInput, TicketModalDataUncheckedUpdateWithoutTicketSetupInput>
  }

  export type TicketModalDataUpdateManyWithWhereWithoutTicketSetupInput = {
    where: TicketModalDataScalarWhereInput
    data: XOR<TicketModalDataUpdateManyMutationInput, TicketModalDataUncheckedUpdateManyWithoutTicketSetupInput>
  }

  export type TicketModalDataScalarWhereInput = {
    AND?: TicketModalDataScalarWhereInput | TicketModalDataScalarWhereInput[]
    OR?: TicketModalDataScalarWhereInput[]
    NOT?: TicketModalDataScalarWhereInput | TicketModalDataScalarWhereInput[]
    id?: StringFilter<"TicketModalData"> | string
    Name?: StringFilter<"TicketModalData"> | string
    Placeholder?: StringFilter<"TicketModalData"> | string
    Type?: IntFilter<"TicketModalData"> | number
    TicketSetupId?: StringFilter<"TicketModalData"> | string
  }

  export type GuildsUpsertWithoutTicketSetupsInput = {
    update: XOR<GuildsUpdateWithoutTicketSetupsInput, GuildsUncheckedUpdateWithoutTicketSetupsInput>
    create: XOR<GuildsCreateWithoutTicketSetupsInput, GuildsUncheckedCreateWithoutTicketSetupsInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutTicketSetupsInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutTicketSetupsInput, GuildsUncheckedUpdateWithoutTicketSetupsInput>
  }

  export type GuildsUpdateWithoutTicketSetupsInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutTicketSetupsInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type TicketsUpsertWithWhereUniqueWithoutTicketSetupInput = {
    where: TicketsWhereUniqueInput
    update: XOR<TicketsUpdateWithoutTicketSetupInput, TicketsUncheckedUpdateWithoutTicketSetupInput>
    create: XOR<TicketsCreateWithoutTicketSetupInput, TicketsUncheckedCreateWithoutTicketSetupInput>
  }

  export type TicketsUpdateWithWhereUniqueWithoutTicketSetupInput = {
    where: TicketsWhereUniqueInput
    data: XOR<TicketsUpdateWithoutTicketSetupInput, TicketsUncheckedUpdateWithoutTicketSetupInput>
  }

  export type TicketsUpdateManyWithWhereWithoutTicketSetupInput = {
    where: TicketsScalarWhereInput
    data: XOR<TicketsUpdateManyMutationInput, TicketsUncheckedUpdateManyWithoutTicketSetupInput>
  }

  export type TicketsScalarWhereInput = {
    AND?: TicketsScalarWhereInput | TicketsScalarWhereInput[]
    OR?: TicketsScalarWhereInput[]
    NOT?: TicketsScalarWhereInput | TicketsScalarWhereInput[]
    id?: StringFilter<"Tickets"> | string
    TicketId?: StringFilter<"Tickets"> | string
    GuildId?: StringFilter<"Tickets"> | string
    ChannelId?: StringNullableFilter<"Tickets"> | string | null
    ThreadId?: StringNullableFilter<"Tickets"> | string | null
    IsClaimed?: BoolNullableFilter<"Tickets"> | boolean | null
    IsArchived?: BoolNullableFilter<"Tickets"> | boolean | null
    ArchiveMessageId?: StringNullableFilter<"Tickets"> | string | null
    UserWhoHasClaimedId?: StringNullableFilter<"Tickets"> | string | null
    IsLooked?: BoolNullableFilter<"Tickets"> | boolean | null
    TicketOwnerId?: StringFilter<"Tickets"> | string
    AddedMemberIds?: StringNullableListFilter<"Tickets">
    Handlers?: StringNullableListFilter<"Tickets">
    TranscriptChannelId?: StringFilter<"Tickets"> | string
    TranscriptHTML?: StringNullableFilter<"Tickets"> | string | null
    TicketNotes?: StringNullableListFilter<"Tickets">
    TicketSetupId?: StringFilter<"Tickets"> | string
  }

  export type TicketSetupsCreateWithoutModalOptionsInput = {
    id?: string
    CategoryId?: string | null
    Handlers?: TicketSetupsCreateHandlersInput | string[]
    HandlerWithShadowPing?: TicketSetupsCreateHandlerWithShadowPingInput | string[]
    CustomId: string
    TicketChannelName?: string | null
    ChannelType?: number | null
    MessageTempleateId?: string | null
    TicketBlacklistRoles?: TicketSetupsCreateTicketBlacklistRolesInput | string[]
    TranscriptChannelId?: string | null
    HasModal?: boolean | null
    UserDMWhenCloseMessageTemplateId?: string | null
    TicketLimit?: number | null
    WithTicketFeedback?: boolean | null
    TicketFeedbackChannelId?: string | null
    ModalTitle?: string | null
    TicketCreationCooldownPerUser?: number | null
    AutoCloseAfterInactivity?: number | null
    AutoAssignHandler?: string | null
    AutoReplyMessageTemplateId?: string | null
    RequiredRoles?: TicketSetupsCreateRequiredRolesInput | string[]
    OpenTicketWithCommand?: boolean | null
    SlashCommandId?: string | null
    TextCommandName?: string | null
    SendTranscriptToUser?: boolean | null
    Guilds: GuildsCreateNestedOneWithoutTicketSetupsInput
    Tickets?: TicketsCreateNestedManyWithoutTicketSetupInput
  }

  export type TicketSetupsUncheckedCreateWithoutModalOptionsInput = {
    id?: string
    CategoryId?: string | null
    Handlers?: TicketSetupsCreateHandlersInput | string[]
    HandlerWithShadowPing?: TicketSetupsCreateHandlerWithShadowPingInput | string[]
    CustomId: string
    TicketChannelName?: string | null
    ChannelType?: number | null
    MessageTempleateId?: string | null
    TicketBlacklistRoles?: TicketSetupsCreateTicketBlacklistRolesInput | string[]
    TranscriptChannelId?: string | null
    HasModal?: boolean | null
    UserDMWhenCloseMessageTemplateId?: string | null
    TicketLimit?: number | null
    WithTicketFeedback?: boolean | null
    TicketFeedbackChannelId?: string | null
    ModalTitle?: string | null
    TicketCreationCooldownPerUser?: number | null
    AutoCloseAfterInactivity?: number | null
    AutoAssignHandler?: string | null
    AutoReplyMessageTemplateId?: string | null
    RequiredRoles?: TicketSetupsCreateRequiredRolesInput | string[]
    OpenTicketWithCommand?: boolean | null
    SlashCommandId?: string | null
    TextCommandName?: string | null
    SendTranscriptToUser?: boolean | null
    GuildId: string
    Tickets?: TicketsUncheckedCreateNestedManyWithoutTicketSetupInput
  }

  export type TicketSetupsCreateOrConnectWithoutModalOptionsInput = {
    where: TicketSetupsWhereUniqueInput
    create: XOR<TicketSetupsCreateWithoutModalOptionsInput, TicketSetupsUncheckedCreateWithoutModalOptionsInput>
  }

  export type TicketSetupsUpsertWithoutModalOptionsInput = {
    update: XOR<TicketSetupsUpdateWithoutModalOptionsInput, TicketSetupsUncheckedUpdateWithoutModalOptionsInput>
    create: XOR<TicketSetupsCreateWithoutModalOptionsInput, TicketSetupsUncheckedCreateWithoutModalOptionsInput>
    where?: TicketSetupsWhereInput
  }

  export type TicketSetupsUpdateToOneWithWhereWithoutModalOptionsInput = {
    where?: TicketSetupsWhereInput
    data: XOR<TicketSetupsUpdateWithoutModalOptionsInput, TicketSetupsUncheckedUpdateWithoutModalOptionsInput>
  }

  export type TicketSetupsUpdateWithoutModalOptionsInput = {
    CategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    Handlers?: TicketSetupsUpdateHandlersInput | string[]
    HandlerWithShadowPing?: TicketSetupsUpdateHandlerWithShadowPingInput | string[]
    CustomId?: StringFieldUpdateOperationsInput | string
    TicketChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelType?: NullableIntFieldUpdateOperationsInput | number | null
    MessageTempleateId?: NullableStringFieldUpdateOperationsInput | string | null
    TicketBlacklistRoles?: TicketSetupsUpdateTicketBlacklistRolesInput | string[]
    TranscriptChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    HasModal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UserDMWhenCloseMessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    TicketLimit?: NullableIntFieldUpdateOperationsInput | number | null
    WithTicketFeedback?: NullableBoolFieldUpdateOperationsInput | boolean | null
    TicketFeedbackChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    ModalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    TicketCreationCooldownPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    AutoCloseAfterInactivity?: NullableIntFieldUpdateOperationsInput | number | null
    AutoAssignHandler?: NullableStringFieldUpdateOperationsInput | string | null
    AutoReplyMessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    RequiredRoles?: TicketSetupsUpdateRequiredRolesInput | string[]
    OpenTicketWithCommand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SlashCommandId?: NullableStringFieldUpdateOperationsInput | string | null
    TextCommandName?: NullableStringFieldUpdateOperationsInput | string | null
    SendTranscriptToUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Guilds?: GuildsUpdateOneRequiredWithoutTicketSetupsNestedInput
    Tickets?: TicketsUpdateManyWithoutTicketSetupNestedInput
  }

  export type TicketSetupsUncheckedUpdateWithoutModalOptionsInput = {
    CategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    Handlers?: TicketSetupsUpdateHandlersInput | string[]
    HandlerWithShadowPing?: TicketSetupsUpdateHandlerWithShadowPingInput | string[]
    CustomId?: StringFieldUpdateOperationsInput | string
    TicketChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelType?: NullableIntFieldUpdateOperationsInput | number | null
    MessageTempleateId?: NullableStringFieldUpdateOperationsInput | string | null
    TicketBlacklistRoles?: TicketSetupsUpdateTicketBlacklistRolesInput | string[]
    TranscriptChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    HasModal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UserDMWhenCloseMessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    TicketLimit?: NullableIntFieldUpdateOperationsInput | number | null
    WithTicketFeedback?: NullableBoolFieldUpdateOperationsInput | boolean | null
    TicketFeedbackChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    ModalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    TicketCreationCooldownPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    AutoCloseAfterInactivity?: NullableIntFieldUpdateOperationsInput | number | null
    AutoAssignHandler?: NullableStringFieldUpdateOperationsInput | string | null
    AutoReplyMessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    RequiredRoles?: TicketSetupsUpdateRequiredRolesInput | string[]
    OpenTicketWithCommand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SlashCommandId?: NullableStringFieldUpdateOperationsInput | string | null
    TextCommandName?: NullableStringFieldUpdateOperationsInput | string | null
    SendTranscriptToUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    GuildId?: StringFieldUpdateOperationsInput | string
    Tickets?: TicketsUncheckedUpdateManyWithoutTicketSetupNestedInput
  }

  export type TicketSetupsCreateWithoutTicketsInput = {
    id?: string
    CategoryId?: string | null
    Handlers?: TicketSetupsCreateHandlersInput | string[]
    HandlerWithShadowPing?: TicketSetupsCreateHandlerWithShadowPingInput | string[]
    CustomId: string
    TicketChannelName?: string | null
    ChannelType?: number | null
    MessageTempleateId?: string | null
    TicketBlacklistRoles?: TicketSetupsCreateTicketBlacklistRolesInput | string[]
    TranscriptChannelId?: string | null
    HasModal?: boolean | null
    UserDMWhenCloseMessageTemplateId?: string | null
    TicketLimit?: number | null
    WithTicketFeedback?: boolean | null
    TicketFeedbackChannelId?: string | null
    ModalTitle?: string | null
    TicketCreationCooldownPerUser?: number | null
    AutoCloseAfterInactivity?: number | null
    AutoAssignHandler?: string | null
    AutoReplyMessageTemplateId?: string | null
    RequiredRoles?: TicketSetupsCreateRequiredRolesInput | string[]
    OpenTicketWithCommand?: boolean | null
    SlashCommandId?: string | null
    TextCommandName?: string | null
    SendTranscriptToUser?: boolean | null
    ModalOptions?: TicketModalDataCreateNestedManyWithoutTicketSetupInput
    Guilds: GuildsCreateNestedOneWithoutTicketSetupsInput
  }

  export type TicketSetupsUncheckedCreateWithoutTicketsInput = {
    id?: string
    CategoryId?: string | null
    Handlers?: TicketSetupsCreateHandlersInput | string[]
    HandlerWithShadowPing?: TicketSetupsCreateHandlerWithShadowPingInput | string[]
    CustomId: string
    TicketChannelName?: string | null
    ChannelType?: number | null
    MessageTempleateId?: string | null
    TicketBlacklistRoles?: TicketSetupsCreateTicketBlacklistRolesInput | string[]
    TranscriptChannelId?: string | null
    HasModal?: boolean | null
    UserDMWhenCloseMessageTemplateId?: string | null
    TicketLimit?: number | null
    WithTicketFeedback?: boolean | null
    TicketFeedbackChannelId?: string | null
    ModalTitle?: string | null
    TicketCreationCooldownPerUser?: number | null
    AutoCloseAfterInactivity?: number | null
    AutoAssignHandler?: string | null
    AutoReplyMessageTemplateId?: string | null
    RequiredRoles?: TicketSetupsCreateRequiredRolesInput | string[]
    OpenTicketWithCommand?: boolean | null
    SlashCommandId?: string | null
    TextCommandName?: string | null
    SendTranscriptToUser?: boolean | null
    GuildId: string
    ModalOptions?: TicketModalDataUncheckedCreateNestedManyWithoutTicketSetupInput
  }

  export type TicketSetupsCreateOrConnectWithoutTicketsInput = {
    where: TicketSetupsWhereUniqueInput
    create: XOR<TicketSetupsCreateWithoutTicketsInput, TicketSetupsUncheckedCreateWithoutTicketsInput>
  }

  export type TicketFeedbackCreateWithoutTicketInput = {
    id?: string
    Rating: number
    Comment?: string | null
    SubmittedAt?: Date | string
  }

  export type TicketFeedbackUncheckedCreateWithoutTicketInput = {
    id?: string
    Rating: number
    Comment?: string | null
    SubmittedAt?: Date | string
  }

  export type TicketFeedbackCreateOrConnectWithoutTicketInput = {
    where: TicketFeedbackWhereUniqueInput
    create: XOR<TicketFeedbackCreateWithoutTicketInput, TicketFeedbackUncheckedCreateWithoutTicketInput>
  }

  export type TicketSetupsUpsertWithoutTicketsInput = {
    update: XOR<TicketSetupsUpdateWithoutTicketsInput, TicketSetupsUncheckedUpdateWithoutTicketsInput>
    create: XOR<TicketSetupsCreateWithoutTicketsInput, TicketSetupsUncheckedCreateWithoutTicketsInput>
    where?: TicketSetupsWhereInput
  }

  export type TicketSetupsUpdateToOneWithWhereWithoutTicketsInput = {
    where?: TicketSetupsWhereInput
    data: XOR<TicketSetupsUpdateWithoutTicketsInput, TicketSetupsUncheckedUpdateWithoutTicketsInput>
  }

  export type TicketSetupsUpdateWithoutTicketsInput = {
    CategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    Handlers?: TicketSetupsUpdateHandlersInput | string[]
    HandlerWithShadowPing?: TicketSetupsUpdateHandlerWithShadowPingInput | string[]
    CustomId?: StringFieldUpdateOperationsInput | string
    TicketChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelType?: NullableIntFieldUpdateOperationsInput | number | null
    MessageTempleateId?: NullableStringFieldUpdateOperationsInput | string | null
    TicketBlacklistRoles?: TicketSetupsUpdateTicketBlacklistRolesInput | string[]
    TranscriptChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    HasModal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UserDMWhenCloseMessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    TicketLimit?: NullableIntFieldUpdateOperationsInput | number | null
    WithTicketFeedback?: NullableBoolFieldUpdateOperationsInput | boolean | null
    TicketFeedbackChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    ModalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    TicketCreationCooldownPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    AutoCloseAfterInactivity?: NullableIntFieldUpdateOperationsInput | number | null
    AutoAssignHandler?: NullableStringFieldUpdateOperationsInput | string | null
    AutoReplyMessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    RequiredRoles?: TicketSetupsUpdateRequiredRolesInput | string[]
    OpenTicketWithCommand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SlashCommandId?: NullableStringFieldUpdateOperationsInput | string | null
    TextCommandName?: NullableStringFieldUpdateOperationsInput | string | null
    SendTranscriptToUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ModalOptions?: TicketModalDataUpdateManyWithoutTicketSetupNestedInput
    Guilds?: GuildsUpdateOneRequiredWithoutTicketSetupsNestedInput
  }

  export type TicketSetupsUncheckedUpdateWithoutTicketsInput = {
    CategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    Handlers?: TicketSetupsUpdateHandlersInput | string[]
    HandlerWithShadowPing?: TicketSetupsUpdateHandlerWithShadowPingInput | string[]
    CustomId?: StringFieldUpdateOperationsInput | string
    TicketChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelType?: NullableIntFieldUpdateOperationsInput | number | null
    MessageTempleateId?: NullableStringFieldUpdateOperationsInput | string | null
    TicketBlacklistRoles?: TicketSetupsUpdateTicketBlacklistRolesInput | string[]
    TranscriptChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    HasModal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UserDMWhenCloseMessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    TicketLimit?: NullableIntFieldUpdateOperationsInput | number | null
    WithTicketFeedback?: NullableBoolFieldUpdateOperationsInput | boolean | null
    TicketFeedbackChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    ModalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    TicketCreationCooldownPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    AutoCloseAfterInactivity?: NullableIntFieldUpdateOperationsInput | number | null
    AutoAssignHandler?: NullableStringFieldUpdateOperationsInput | string | null
    AutoReplyMessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    RequiredRoles?: TicketSetupsUpdateRequiredRolesInput | string[]
    OpenTicketWithCommand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SlashCommandId?: NullableStringFieldUpdateOperationsInput | string | null
    TextCommandName?: NullableStringFieldUpdateOperationsInput | string | null
    SendTranscriptToUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    GuildId?: StringFieldUpdateOperationsInput | string
    ModalOptions?: TicketModalDataUncheckedUpdateManyWithoutTicketSetupNestedInput
  }

  export type TicketFeedbackUpsertWithoutTicketInput = {
    update: XOR<TicketFeedbackUpdateWithoutTicketInput, TicketFeedbackUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketFeedbackCreateWithoutTicketInput, TicketFeedbackUncheckedCreateWithoutTicketInput>
    where?: TicketFeedbackWhereInput
  }

  export type TicketFeedbackUpdateToOneWithWhereWithoutTicketInput = {
    where?: TicketFeedbackWhereInput
    data: XOR<TicketFeedbackUpdateWithoutTicketInput, TicketFeedbackUncheckedUpdateWithoutTicketInput>
  }

  export type TicketFeedbackUpdateWithoutTicketInput = {
    Rating?: IntFieldUpdateOperationsInput | number
    Comment?: NullableStringFieldUpdateOperationsInput | string | null
    SubmittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketFeedbackUncheckedUpdateWithoutTicketInput = {
    Rating?: IntFieldUpdateOperationsInput | number
    Comment?: NullableStringFieldUpdateOperationsInput | string | null
    SubmittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketsCreateWithoutTicketFeedbackInput = {
    id?: string
    TicketId: string
    GuildId: string
    ChannelId?: string | null
    ThreadId?: string | null
    IsClaimed?: boolean | null
    IsArchived?: boolean | null
    ArchiveMessageId?: string | null
    UserWhoHasClaimedId?: string | null
    IsLooked?: boolean | null
    TicketOwnerId: string
    AddedMemberIds?: TicketsCreateAddedMemberIdsInput | string[]
    Handlers?: TicketsCreateHandlersInput | string[]
    TranscriptChannelId: string
    TranscriptHTML?: string | null
    TicketNotes?: TicketsCreateTicketNotesInput | string[]
    TicketSetup: TicketSetupsCreateNestedOneWithoutTicketsInput
  }

  export type TicketsUncheckedCreateWithoutTicketFeedbackInput = {
    id?: string
    TicketId: string
    GuildId: string
    ChannelId?: string | null
    ThreadId?: string | null
    IsClaimed?: boolean | null
    IsArchived?: boolean | null
    ArchiveMessageId?: string | null
    UserWhoHasClaimedId?: string | null
    IsLooked?: boolean | null
    TicketOwnerId: string
    AddedMemberIds?: TicketsCreateAddedMemberIdsInput | string[]
    Handlers?: TicketsCreateHandlersInput | string[]
    TranscriptChannelId: string
    TranscriptHTML?: string | null
    TicketNotes?: TicketsCreateTicketNotesInput | string[]
    TicketSetupId: string
  }

  export type TicketsCreateOrConnectWithoutTicketFeedbackInput = {
    where: TicketsWhereUniqueInput
    create: XOR<TicketsCreateWithoutTicketFeedbackInput, TicketsUncheckedCreateWithoutTicketFeedbackInput>
  }

  export type TicketsUpsertWithoutTicketFeedbackInput = {
    update: XOR<TicketsUpdateWithoutTicketFeedbackInput, TicketsUncheckedUpdateWithoutTicketFeedbackInput>
    create: XOR<TicketsCreateWithoutTicketFeedbackInput, TicketsUncheckedCreateWithoutTicketFeedbackInput>
    where?: TicketsWhereInput
  }

  export type TicketsUpdateToOneWithWhereWithoutTicketFeedbackInput = {
    where?: TicketsWhereInput
    data: XOR<TicketsUpdateWithoutTicketFeedbackInput, TicketsUncheckedUpdateWithoutTicketFeedbackInput>
  }

  export type TicketsUpdateWithoutTicketFeedbackInput = {
    TicketId?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    ThreadId?: NullableStringFieldUpdateOperationsInput | string | null
    IsClaimed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsArchived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ArchiveMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    UserWhoHasClaimedId?: NullableStringFieldUpdateOperationsInput | string | null
    IsLooked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    TicketOwnerId?: StringFieldUpdateOperationsInput | string
    AddedMemberIds?: TicketsUpdateAddedMemberIdsInput | string[]
    Handlers?: TicketsUpdateHandlersInput | string[]
    TranscriptChannelId?: StringFieldUpdateOperationsInput | string
    TranscriptHTML?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNotes?: TicketsUpdateTicketNotesInput | string[]
    TicketSetup?: TicketSetupsUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type TicketsUncheckedUpdateWithoutTicketFeedbackInput = {
    TicketId?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    ThreadId?: NullableStringFieldUpdateOperationsInput | string | null
    IsClaimed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsArchived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ArchiveMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    UserWhoHasClaimedId?: NullableStringFieldUpdateOperationsInput | string | null
    IsLooked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    TicketOwnerId?: StringFieldUpdateOperationsInput | string
    AddedMemberIds?: TicketsUpdateAddedMemberIdsInput | string[]
    Handlers?: TicketsUpdateHandlersInput | string[]
    TranscriptChannelId?: StringFieldUpdateOperationsInput | string
    TranscriptHTML?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNotes?: TicketsUpdateTicketNotesInput | string[]
    TicketSetupId?: StringFieldUpdateOperationsInput | string
  }

  export type GuildsCreateWithoutGuildFeatureToggleInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutGuildFeatureToggleInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutGuildFeatureToggleInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutGuildFeatureToggleInput, GuildsUncheckedCreateWithoutGuildFeatureToggleInput>
  }

  export type GuildsUpsertWithoutGuildFeatureToggleInput = {
    update: XOR<GuildsUpdateWithoutGuildFeatureToggleInput, GuildsUncheckedUpdateWithoutGuildFeatureToggleInput>
    create: XOR<GuildsCreateWithoutGuildFeatureToggleInput, GuildsUncheckedCreateWithoutGuildFeatureToggleInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutGuildFeatureToggleInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutGuildFeatureToggleInput, GuildsUncheckedUpdateWithoutGuildFeatureToggleInput>
  }

  export type GuildsUpdateWithoutGuildFeatureToggleInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutGuildFeatureToggleInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsCreateWithoutTwitchNotificationsInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutTwitchNotificationsInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutTwitchNotificationsInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutTwitchNotificationsInput, GuildsUncheckedCreateWithoutTwitchNotificationsInput>
  }

  export type GuildsUpsertWithoutTwitchNotificationsInput = {
    update: XOR<GuildsUpdateWithoutTwitchNotificationsInput, GuildsUncheckedUpdateWithoutTwitchNotificationsInput>
    create: XOR<GuildsCreateWithoutTwitchNotificationsInput, GuildsUncheckedCreateWithoutTwitchNotificationsInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutTwitchNotificationsInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutTwitchNotificationsInput, GuildsUncheckedUpdateWithoutTwitchNotificationsInput>
  }

  export type GuildsUpdateWithoutTwitchNotificationsInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutTwitchNotificationsInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    YoutubeNotifications?: YoutubeNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsCreateWithoutYoutubeNotificationsInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesCreateNestedManyWithoutGuildsInput
    Security?: SecuritysCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsCreateNestedManyWithoutGuildsInput
    Tags?: TagsCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsCreateNestedOneWithoutGuildsInput
    GuildLoggers?: GuildLoggersCreateNestedManyWithoutGuildsInput
  }

  export type GuildsUncheckedCreateWithoutYoutubeNotificationsInput = {
    id?: string
    GuildId: string
    GuildName: string
    GuildOwner: string
    AutoAutoDeletes?: AutoDeletesUncheckedCreateNestedManyWithoutGuildsInput
    AutoPublish?: AutoPublishUncheckedCreateNestedOneWithoutGuildsInput
    AutoReacts?: AutoReactsUncheckedCreateNestedManyWithoutGuildsInput
    AutoRoles?: AutoRolesUncheckedCreateNestedManyWithoutGuildsInput
    GuildBans?: GuildBansUncheckedCreateNestedManyWithoutGuildsInput
    ChatModerations?: ChatModerationsUncheckedCreateNestedOneWithoutGuildsInput
    ChannelLinks?: ChannelLinksUncheckedCreateNestedManyWithoutGuildsInput
    DiscordAddons?: DiscordAddonsUncheckedCreateNestedOneWithoutGuildsInput
    Giveaways?: GiveawaysUncheckedCreateNestedManyWithoutGuildsInput
    TempVoices?: TempVoicesUncheckedCreateNestedManyWithoutGuildsInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLogging?: GuildLoggingsUncheckedCreateNestedOneWithoutGuildsInput
    MessageTemplates?: MessageTemplatesUncheckedCreateNestedManyWithoutGuildsInput
    Permissions?: PermissionsUncheckedCreateNestedOneWithoutGuildsInput
    ReactionRole?: ReactionRolesUncheckedCreateNestedManyWithoutGuildsInput
    Security?: SecuritysUncheckedCreateNestedOneWithoutGuildsInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutGuildsInput
    TicketSetups?: TicketSetupsUncheckedCreateNestedManyWithoutGuildsInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedCreateNestedOneWithoutGuildsInput
    TwitchNotifications?: TwitchNotificationsUncheckedCreateNestedManyWithoutGuildsInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedCreateNestedOneWithoutGuildsInput
    GuildLoggers?: GuildLoggersUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type GuildsCreateOrConnectWithoutYoutubeNotificationsInput = {
    where: GuildsWhereUniqueInput
    create: XOR<GuildsCreateWithoutYoutubeNotificationsInput, GuildsUncheckedCreateWithoutYoutubeNotificationsInput>
  }

  export type GuildsUpsertWithoutYoutubeNotificationsInput = {
    update: XOR<GuildsUpdateWithoutYoutubeNotificationsInput, GuildsUncheckedUpdateWithoutYoutubeNotificationsInput>
    create: XOR<GuildsCreateWithoutYoutubeNotificationsInput, GuildsUncheckedCreateWithoutYoutubeNotificationsInput>
    where?: GuildsWhereInput
  }

  export type GuildsUpdateToOneWithWhereWithoutYoutubeNotificationsInput = {
    where?: GuildsWhereInput
    data: XOR<GuildsUpdateWithoutYoutubeNotificationsInput, GuildsUncheckedUpdateWithoutYoutubeNotificationsInput>
  }

  export type GuildsUpdateWithoutYoutubeNotificationsInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUpdateOneWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUpdateManyWithoutGuildsNestedInput
  }

  export type GuildsUncheckedUpdateWithoutYoutubeNotificationsInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    GuildName?: StringFieldUpdateOperationsInput | string
    GuildOwner?: StringFieldUpdateOperationsInput | string
    AutoAutoDeletes?: AutoDeletesUncheckedUpdateManyWithoutGuildsNestedInput
    AutoPublish?: AutoPublishUncheckedUpdateOneWithoutGuildsNestedInput
    AutoReacts?: AutoReactsUncheckedUpdateManyWithoutGuildsNestedInput
    AutoRoles?: AutoRolesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildBans?: GuildBansUncheckedUpdateManyWithoutGuildsNestedInput
    ChatModerations?: ChatModerationsUncheckedUpdateOneWithoutGuildsNestedInput
    ChannelLinks?: ChannelLinksUncheckedUpdateManyWithoutGuildsNestedInput
    DiscordAddons?: DiscordAddonsUncheckedUpdateOneWithoutGuildsNestedInput
    Giveaways?: GiveawaysUncheckedUpdateManyWithoutGuildsNestedInput
    TempVoices?: TempVoicesUncheckedUpdateManyWithoutGuildsNestedInput
    GuildLeaveSetup?: GuildLeaveSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLogging?: GuildLoggingsUncheckedUpdateOneWithoutGuildsNestedInput
    MessageTemplates?: MessageTemplatesUncheckedUpdateManyWithoutGuildsNestedInput
    Permissions?: PermissionsUncheckedUpdateOneWithoutGuildsNestedInput
    ReactionRole?: ReactionRolesUncheckedUpdateManyWithoutGuildsNestedInput
    Security?: SecuritysUncheckedUpdateOneWithoutGuildsNestedInput
    SpotifyNotifications?: SpotifyNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutGuildsNestedInput
    TicketSetups?: TicketSetupsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildFeatureToggle?: GuildFeatureTogglesUncheckedUpdateOneWithoutGuildsNestedInput
    TwitchNotifications?: TwitchNotificationsUncheckedUpdateManyWithoutGuildsNestedInput
    GuildWelcomeSetup?: GuildWelcomeSetupsUncheckedUpdateOneWithoutGuildsNestedInput
    GuildLoggers?: GuildLoggersUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type ApisCreateWithoutUsersInput = {
    id?: string
    Flags?: ApisCreateFlagsInput | string[]
    Guilds?: ApisCreateGuildsInput | string[]
    Key: string
  }

  export type ApisUncheckedCreateWithoutUsersInput = {
    id?: string
    Flags?: ApisCreateFlagsInput | string[]
    Guilds?: ApisCreateGuildsInput | string[]
    Key: string
  }

  export type ApisCreateOrConnectWithoutUsersInput = {
    where: ApisWhereUniqueInput
    create: XOR<ApisCreateWithoutUsersInput, ApisUncheckedCreateWithoutUsersInput>
  }

  export type ApisCreateManyUsersInputEnvelope = {
    data: ApisCreateManyUsersInput | ApisCreateManyUsersInput[]
  }

  export type GuildBackupsCreateWithoutUsersInput = {
    id?: string
    BackupJSON: InputJsonValue
    CreatedAt: Date | string
    UUID: string
    Name: string
    GuildId: string
  }

  export type GuildBackupsUncheckedCreateWithoutUsersInput = {
    id?: string
    BackupJSON: InputJsonValue
    CreatedAt: Date | string
    UUID: string
    Name: string
    GuildId: string
  }

  export type GuildBackupsCreateOrConnectWithoutUsersInput = {
    where: GuildBackupsWhereUniqueInput
    create: XOR<GuildBackupsCreateWithoutUsersInput, GuildBackupsUncheckedCreateWithoutUsersInput>
  }

  export type GuildBackupsCreateManyUsersInputEnvelope = {
    data: GuildBackupsCreateManyUsersInput | GuildBackupsCreateManyUsersInput[]
  }

  export type CustomersCreateWithoutUsersInput = {
    id?: string
    ExternalUUID: string
    RealUUID: string
    Application: string
    BotStatus: XOR<BotStatusCreateEnvelopeInput, BotStatusCreateInput>
    DisplayName: string
    GuildIds?: CustomersCreateGuildIdsInput | string[]
    ServerPort: string
    WSAPI: string
  }

  export type CustomersUncheckedCreateWithoutUsersInput = {
    id?: string
    ExternalUUID: string
    RealUUID: string
    Application: string
    BotStatus: XOR<BotStatusCreateEnvelopeInput, BotStatusCreateInput>
    DisplayName: string
    GuildIds?: CustomersCreateGuildIdsInput | string[]
    ServerPort: string
    WSAPI: string
  }

  export type CustomersCreateOrConnectWithoutUsersInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutUsersInput, CustomersUncheckedCreateWithoutUsersInput>
  }

  export type CustomersCreateManyUsersInputEnvelope = {
    data: CustomersCreateManyUsersInput | CustomersCreateManyUsersInput[]
  }

  export type DisBotUserNotificationsCreateWithoutUsersInput = {
    id?: string
    Updates: boolean
    Status: boolean
    Announcements: boolean
    Customer: boolean
  }

  export type DisBotUserNotificationsUncheckedCreateWithoutUsersInput = {
    id?: string
    Updates: boolean
    Status: boolean
    Announcements: boolean
    Customer: boolean
  }

  export type DisBotUserNotificationsCreateOrConnectWithoutUsersInput = {
    where: DisBotUserNotificationsWhereUniqueInput
    create: XOR<DisBotUserNotificationsCreateWithoutUsersInput, DisBotUserNotificationsUncheckedCreateWithoutUsersInput>
  }

  export type VanitysCreateWithoutUsersInput = {
    id?: string
    UUID: string
    Slug: string
    Host: string
    GuildId: string
    Invite: string
    CreatedAt: Date | string
    Analytics?: VanityAnalyticsCreateNestedOneWithoutVanitysInput
    Embed?: VanityEmbedsCreateNestedOneWithoutVanitysInput
  }

  export type VanitysUncheckedCreateWithoutUsersInput = {
    id?: string
    UUID: string
    Slug: string
    Host: string
    GuildId: string
    Invite: string
    CreatedAt: Date | string
    Analytics?: VanityAnalyticsUncheckedCreateNestedOneWithoutVanitysInput
    Embed?: VanityEmbedsUncheckedCreateNestedOneWithoutVanitysInput
  }

  export type VanitysCreateOrConnectWithoutUsersInput = {
    where: VanitysWhereUniqueInput
    create: XOR<VanitysCreateWithoutUsersInput, VanitysUncheckedCreateWithoutUsersInput>
  }

  export type VanitysCreateManyUsersInputEnvelope = {
    data: VanitysCreateManyUsersInput | VanitysCreateManyUsersInput[]
  }

  export type ApisUpsertWithWhereUniqueWithoutUsersInput = {
    where: ApisWhereUniqueInput
    update: XOR<ApisUpdateWithoutUsersInput, ApisUncheckedUpdateWithoutUsersInput>
    create: XOR<ApisCreateWithoutUsersInput, ApisUncheckedCreateWithoutUsersInput>
  }

  export type ApisUpdateWithWhereUniqueWithoutUsersInput = {
    where: ApisWhereUniqueInput
    data: XOR<ApisUpdateWithoutUsersInput, ApisUncheckedUpdateWithoutUsersInput>
  }

  export type ApisUpdateManyWithWhereWithoutUsersInput = {
    where: ApisScalarWhereInput
    data: XOR<ApisUpdateManyMutationInput, ApisUncheckedUpdateManyWithoutUsersInput>
  }

  export type ApisScalarWhereInput = {
    AND?: ApisScalarWhereInput | ApisScalarWhereInput[]
    OR?: ApisScalarWhereInput[]
    NOT?: ApisScalarWhereInput | ApisScalarWhereInput[]
    id?: StringFilter<"Apis"> | string
    Flags?: StringNullableListFilter<"Apis">
    Guilds?: StringNullableListFilter<"Apis">
    Key?: StringFilter<"Apis"> | string
    UserId?: StringFilter<"Apis"> | string
  }

  export type GuildBackupsUpsertWithWhereUniqueWithoutUsersInput = {
    where: GuildBackupsWhereUniqueInput
    update: XOR<GuildBackupsUpdateWithoutUsersInput, GuildBackupsUncheckedUpdateWithoutUsersInput>
    create: XOR<GuildBackupsCreateWithoutUsersInput, GuildBackupsUncheckedCreateWithoutUsersInput>
  }

  export type GuildBackupsUpdateWithWhereUniqueWithoutUsersInput = {
    where: GuildBackupsWhereUniqueInput
    data: XOR<GuildBackupsUpdateWithoutUsersInput, GuildBackupsUncheckedUpdateWithoutUsersInput>
  }

  export type GuildBackupsUpdateManyWithWhereWithoutUsersInput = {
    where: GuildBackupsScalarWhereInput
    data: XOR<GuildBackupsUpdateManyMutationInput, GuildBackupsUncheckedUpdateManyWithoutUsersInput>
  }

  export type GuildBackupsScalarWhereInput = {
    AND?: GuildBackupsScalarWhereInput | GuildBackupsScalarWhereInput[]
    OR?: GuildBackupsScalarWhereInput[]
    NOT?: GuildBackupsScalarWhereInput | GuildBackupsScalarWhereInput[]
    id?: StringFilter<"GuildBackups"> | string
    BackupJSON?: JsonFilter<"GuildBackups">
    CreatedAt?: DateTimeFilter<"GuildBackups"> | Date | string
    UUID?: StringFilter<"GuildBackups"> | string
    Name?: StringFilter<"GuildBackups"> | string
    GuildId?: StringFilter<"GuildBackups"> | string
    UserId?: StringFilter<"GuildBackups"> | string
  }

  export type CustomersUpsertWithWhereUniqueWithoutUsersInput = {
    where: CustomersWhereUniqueInput
    update: XOR<CustomersUpdateWithoutUsersInput, CustomersUncheckedUpdateWithoutUsersInput>
    create: XOR<CustomersCreateWithoutUsersInput, CustomersUncheckedCreateWithoutUsersInput>
  }

  export type CustomersUpdateWithWhereUniqueWithoutUsersInput = {
    where: CustomersWhereUniqueInput
    data: XOR<CustomersUpdateWithoutUsersInput, CustomersUncheckedUpdateWithoutUsersInput>
  }

  export type CustomersUpdateManyWithWhereWithoutUsersInput = {
    where: CustomersScalarWhereInput
    data: XOR<CustomersUpdateManyMutationInput, CustomersUncheckedUpdateManyWithoutUsersInput>
  }

  export type CustomersScalarWhereInput = {
    AND?: CustomersScalarWhereInput | CustomersScalarWhereInput[]
    OR?: CustomersScalarWhereInput[]
    NOT?: CustomersScalarWhereInput | CustomersScalarWhereInput[]
    id?: StringFilter<"Customers"> | string
    ExternalUUID?: StringFilter<"Customers"> | string
    RealUUID?: StringFilter<"Customers"> | string
    Application?: StringFilter<"Customers"> | string
    DisplayName?: StringFilter<"Customers"> | string
    GuildIds?: StringNullableListFilter<"Customers">
    ServerPort?: StringFilter<"Customers"> | string
    WSAPI?: StringFilter<"Customers"> | string
    UserId?: StringFilter<"Customers"> | string
  }

  export type DisBotUserNotificationsUpsertWithoutUsersInput = {
    update: XOR<DisBotUserNotificationsUpdateWithoutUsersInput, DisBotUserNotificationsUncheckedUpdateWithoutUsersInput>
    create: XOR<DisBotUserNotificationsCreateWithoutUsersInput, DisBotUserNotificationsUncheckedCreateWithoutUsersInput>
    where?: DisBotUserNotificationsWhereInput
  }

  export type DisBotUserNotificationsUpdateToOneWithWhereWithoutUsersInput = {
    where?: DisBotUserNotificationsWhereInput
    data: XOR<DisBotUserNotificationsUpdateWithoutUsersInput, DisBotUserNotificationsUncheckedUpdateWithoutUsersInput>
  }

  export type DisBotUserNotificationsUpdateWithoutUsersInput = {
    Updates?: BoolFieldUpdateOperationsInput | boolean
    Status?: BoolFieldUpdateOperationsInput | boolean
    Announcements?: BoolFieldUpdateOperationsInput | boolean
    Customer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DisBotUserNotificationsUncheckedUpdateWithoutUsersInput = {
    Updates?: BoolFieldUpdateOperationsInput | boolean
    Status?: BoolFieldUpdateOperationsInput | boolean
    Announcements?: BoolFieldUpdateOperationsInput | boolean
    Customer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VanitysUpsertWithWhereUniqueWithoutUsersInput = {
    where: VanitysWhereUniqueInput
    update: XOR<VanitysUpdateWithoutUsersInput, VanitysUncheckedUpdateWithoutUsersInput>
    create: XOR<VanitysCreateWithoutUsersInput, VanitysUncheckedCreateWithoutUsersInput>
  }

  export type VanitysUpdateWithWhereUniqueWithoutUsersInput = {
    where: VanitysWhereUniqueInput
    data: XOR<VanitysUpdateWithoutUsersInput, VanitysUncheckedUpdateWithoutUsersInput>
  }

  export type VanitysUpdateManyWithWhereWithoutUsersInput = {
    where: VanitysScalarWhereInput
    data: XOR<VanitysUpdateManyMutationInput, VanitysUncheckedUpdateManyWithoutUsersInput>
  }

  export type VanitysScalarWhereInput = {
    AND?: VanitysScalarWhereInput | VanitysScalarWhereInput[]
    OR?: VanitysScalarWhereInput[]
    NOT?: VanitysScalarWhereInput | VanitysScalarWhereInput[]
    id?: StringFilter<"Vanitys"> | string
    UUID?: StringFilter<"Vanitys"> | string
    Slug?: StringFilter<"Vanitys"> | string
    Host?: StringFilter<"Vanitys"> | string
    GuildId?: StringFilter<"Vanitys"> | string
    Invite?: StringFilter<"Vanitys"> | string
    CreatedAt?: DateTimeFilter<"Vanitys"> | Date | string
    UserId?: StringFilter<"Vanitys"> | string
  }

  export type UsersCreateWithoutApissInput = {
    id?: string
    Username: string
    UserId: string
    Votes?: number
    GloablVotes?: number
    CustomerBots?: number
    BackupCount?: number
    GuildBackups?: GuildBackupsCreateNestedManyWithoutUsersInput
    Customers?: CustomersCreateNestedManyWithoutUsersInput
    DisBotUserNotifications?: DisBotUserNotificationsCreateNestedOneWithoutUsersInput
    Vanitys?: VanitysCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutApissInput = {
    id?: string
    Username: string
    UserId: string
    Votes?: number
    GloablVotes?: number
    CustomerBots?: number
    BackupCount?: number
    GuildBackups?: GuildBackupsUncheckedCreateNestedManyWithoutUsersInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutUsersInput
    DisBotUserNotifications?: DisBotUserNotificationsUncheckedCreateNestedOneWithoutUsersInput
    Vanitys?: VanitysUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutApissInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutApissInput, UsersUncheckedCreateWithoutApissInput>
  }

  export type UsersUpsertWithoutApissInput = {
    update: XOR<UsersUpdateWithoutApissInput, UsersUncheckedUpdateWithoutApissInput>
    create: XOR<UsersCreateWithoutApissInput, UsersUncheckedCreateWithoutApissInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutApissInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutApissInput, UsersUncheckedUpdateWithoutApissInput>
  }

  export type UsersUpdateWithoutApissInput = {
    Username?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    Votes?: IntFieldUpdateOperationsInput | number
    GloablVotes?: IntFieldUpdateOperationsInput | number
    CustomerBots?: IntFieldUpdateOperationsInput | number
    BackupCount?: IntFieldUpdateOperationsInput | number
    GuildBackups?: GuildBackupsUpdateManyWithoutUsersNestedInput
    Customers?: CustomersUpdateManyWithoutUsersNestedInput
    DisBotUserNotifications?: DisBotUserNotificationsUpdateOneWithoutUsersNestedInput
    Vanitys?: VanitysUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutApissInput = {
    Username?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    Votes?: IntFieldUpdateOperationsInput | number
    GloablVotes?: IntFieldUpdateOperationsInput | number
    CustomerBots?: IntFieldUpdateOperationsInput | number
    BackupCount?: IntFieldUpdateOperationsInput | number
    GuildBackups?: GuildBackupsUncheckedUpdateManyWithoutUsersNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutUsersNestedInput
    DisBotUserNotifications?: DisBotUserNotificationsUncheckedUpdateOneWithoutUsersNestedInput
    Vanitys?: VanitysUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateWithoutGuildBackupsInput = {
    id?: string
    Username: string
    UserId: string
    Votes?: number
    GloablVotes?: number
    CustomerBots?: number
    BackupCount?: number
    Apiss?: ApisCreateNestedManyWithoutUsersInput
    Customers?: CustomersCreateNestedManyWithoutUsersInput
    DisBotUserNotifications?: DisBotUserNotificationsCreateNestedOneWithoutUsersInput
    Vanitys?: VanitysCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutGuildBackupsInput = {
    id?: string
    Username: string
    UserId: string
    Votes?: number
    GloablVotes?: number
    CustomerBots?: number
    BackupCount?: number
    Apiss?: ApisUncheckedCreateNestedManyWithoutUsersInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutUsersInput
    DisBotUserNotifications?: DisBotUserNotificationsUncheckedCreateNestedOneWithoutUsersInput
    Vanitys?: VanitysUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutGuildBackupsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutGuildBackupsInput, UsersUncheckedCreateWithoutGuildBackupsInput>
  }

  export type UsersUpsertWithoutGuildBackupsInput = {
    update: XOR<UsersUpdateWithoutGuildBackupsInput, UsersUncheckedUpdateWithoutGuildBackupsInput>
    create: XOR<UsersCreateWithoutGuildBackupsInput, UsersUncheckedCreateWithoutGuildBackupsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutGuildBackupsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutGuildBackupsInput, UsersUncheckedUpdateWithoutGuildBackupsInput>
  }

  export type UsersUpdateWithoutGuildBackupsInput = {
    Username?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    Votes?: IntFieldUpdateOperationsInput | number
    GloablVotes?: IntFieldUpdateOperationsInput | number
    CustomerBots?: IntFieldUpdateOperationsInput | number
    BackupCount?: IntFieldUpdateOperationsInput | number
    Apiss?: ApisUpdateManyWithoutUsersNestedInput
    Customers?: CustomersUpdateManyWithoutUsersNestedInput
    DisBotUserNotifications?: DisBotUserNotificationsUpdateOneWithoutUsersNestedInput
    Vanitys?: VanitysUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutGuildBackupsInput = {
    Username?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    Votes?: IntFieldUpdateOperationsInput | number
    GloablVotes?: IntFieldUpdateOperationsInput | number
    CustomerBots?: IntFieldUpdateOperationsInput | number
    BackupCount?: IntFieldUpdateOperationsInput | number
    Apiss?: ApisUncheckedUpdateManyWithoutUsersNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutUsersNestedInput
    DisBotUserNotifications?: DisBotUserNotificationsUncheckedUpdateOneWithoutUsersNestedInput
    Vanitys?: VanitysUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateWithoutCustomersInput = {
    id?: string
    Username: string
    UserId: string
    Votes?: number
    GloablVotes?: number
    CustomerBots?: number
    BackupCount?: number
    Apiss?: ApisCreateNestedManyWithoutUsersInput
    GuildBackups?: GuildBackupsCreateNestedManyWithoutUsersInput
    DisBotUserNotifications?: DisBotUserNotificationsCreateNestedOneWithoutUsersInput
    Vanitys?: VanitysCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutCustomersInput = {
    id?: string
    Username: string
    UserId: string
    Votes?: number
    GloablVotes?: number
    CustomerBots?: number
    BackupCount?: number
    Apiss?: ApisUncheckedCreateNestedManyWithoutUsersInput
    GuildBackups?: GuildBackupsUncheckedCreateNestedManyWithoutUsersInput
    DisBotUserNotifications?: DisBotUserNotificationsUncheckedCreateNestedOneWithoutUsersInput
    Vanitys?: VanitysUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutCustomersInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutCustomersInput, UsersUncheckedCreateWithoutCustomersInput>
  }

  export type BotStatusUpdateInput = {
    Type?: IntFieldUpdateOperationsInput | number
    Text?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    URL?: StringFieldUpdateOperationsInput | string
  }

  export type UsersUpsertWithoutCustomersInput = {
    update: XOR<UsersUpdateWithoutCustomersInput, UsersUncheckedUpdateWithoutCustomersInput>
    create: XOR<UsersCreateWithoutCustomersInput, UsersUncheckedCreateWithoutCustomersInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutCustomersInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutCustomersInput, UsersUncheckedUpdateWithoutCustomersInput>
  }

  export type UsersUpdateWithoutCustomersInput = {
    Username?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    Votes?: IntFieldUpdateOperationsInput | number
    GloablVotes?: IntFieldUpdateOperationsInput | number
    CustomerBots?: IntFieldUpdateOperationsInput | number
    BackupCount?: IntFieldUpdateOperationsInput | number
    Apiss?: ApisUpdateManyWithoutUsersNestedInput
    GuildBackups?: GuildBackupsUpdateManyWithoutUsersNestedInput
    DisBotUserNotifications?: DisBotUserNotificationsUpdateOneWithoutUsersNestedInput
    Vanitys?: VanitysUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutCustomersInput = {
    Username?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    Votes?: IntFieldUpdateOperationsInput | number
    GloablVotes?: IntFieldUpdateOperationsInput | number
    CustomerBots?: IntFieldUpdateOperationsInput | number
    BackupCount?: IntFieldUpdateOperationsInput | number
    Apiss?: ApisUncheckedUpdateManyWithoutUsersNestedInput
    GuildBackups?: GuildBackupsUncheckedUpdateManyWithoutUsersNestedInput
    DisBotUserNotifications?: DisBotUserNotificationsUncheckedUpdateOneWithoutUsersNestedInput
    Vanitys?: VanitysUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type VanityAnalyticsCreateWithoutVanitysInput = {
    id?: string
    Click: number
    TrackInviteWithLog?: string | null
    TrackMessageId?: string | null
    Update?: Date | string | null
    UniqueClick?: number | null
    JoinedWithCode?: number | null
    LoggedIPs?: VanityAnalyticsCreateLoggedIPsInput | string[]
    Latest30Days?: AnalyticsLatest30DaysCreateNestedOneWithoutVanityAnalyticsInput
  }

  export type VanityAnalyticsUncheckedCreateWithoutVanitysInput = {
    id?: string
    Click: number
    TrackInviteWithLog?: string | null
    TrackMessageId?: string | null
    Update?: Date | string | null
    UniqueClick?: number | null
    JoinedWithCode?: number | null
    LoggedIPs?: VanityAnalyticsCreateLoggedIPsInput | string[]
    Latest30Days?: AnalyticsLatest30DaysUncheckedCreateNestedOneWithoutVanityAnalyticsInput
  }

  export type VanityAnalyticsCreateOrConnectWithoutVanitysInput = {
    where: VanityAnalyticsWhereUniqueInput
    create: XOR<VanityAnalyticsCreateWithoutVanitysInput, VanityAnalyticsUncheckedCreateWithoutVanitysInput>
  }

  export type VanityEmbedsCreateWithoutVanitysInput = {
    id?: string
    Title: string
    Description: string
    Color: string
    ImageUrl: string
    ThumbnailUrl: string
    Author?: VanityEmbedAuthorsCreateNestedOneWithoutVanityEmbedsInput
  }

  export type VanityEmbedsUncheckedCreateWithoutVanitysInput = {
    id?: string
    Title: string
    Description: string
    Color: string
    ImageUrl: string
    ThumbnailUrl: string
    Author?: VanityEmbedAuthorsUncheckedCreateNestedOneWithoutVanityEmbedsInput
  }

  export type VanityEmbedsCreateOrConnectWithoutVanitysInput = {
    where: VanityEmbedsWhereUniqueInput
    create: XOR<VanityEmbedsCreateWithoutVanitysInput, VanityEmbedsUncheckedCreateWithoutVanitysInput>
  }

  export type UsersCreateWithoutVanitysInput = {
    id?: string
    Username: string
    UserId: string
    Votes?: number
    GloablVotes?: number
    CustomerBots?: number
    BackupCount?: number
    Apiss?: ApisCreateNestedManyWithoutUsersInput
    GuildBackups?: GuildBackupsCreateNestedManyWithoutUsersInput
    Customers?: CustomersCreateNestedManyWithoutUsersInput
    DisBotUserNotifications?: DisBotUserNotificationsCreateNestedOneWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutVanitysInput = {
    id?: string
    Username: string
    UserId: string
    Votes?: number
    GloablVotes?: number
    CustomerBots?: number
    BackupCount?: number
    Apiss?: ApisUncheckedCreateNestedManyWithoutUsersInput
    GuildBackups?: GuildBackupsUncheckedCreateNestedManyWithoutUsersInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutUsersInput
    DisBotUserNotifications?: DisBotUserNotificationsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutVanitysInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutVanitysInput, UsersUncheckedCreateWithoutVanitysInput>
  }

  export type VanityAnalyticsUpsertWithoutVanitysInput = {
    update: XOR<VanityAnalyticsUpdateWithoutVanitysInput, VanityAnalyticsUncheckedUpdateWithoutVanitysInput>
    create: XOR<VanityAnalyticsCreateWithoutVanitysInput, VanityAnalyticsUncheckedCreateWithoutVanitysInput>
    where?: VanityAnalyticsWhereInput
  }

  export type VanityAnalyticsUpdateToOneWithWhereWithoutVanitysInput = {
    where?: VanityAnalyticsWhereInput
    data: XOR<VanityAnalyticsUpdateWithoutVanitysInput, VanityAnalyticsUncheckedUpdateWithoutVanitysInput>
  }

  export type VanityAnalyticsUpdateWithoutVanitysInput = {
    Click?: IntFieldUpdateOperationsInput | number
    TrackInviteWithLog?: NullableStringFieldUpdateOperationsInput | string | null
    TrackMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    Update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UniqueClick?: NullableIntFieldUpdateOperationsInput | number | null
    JoinedWithCode?: NullableIntFieldUpdateOperationsInput | number | null
    LoggedIPs?: VanityAnalyticsUpdateLoggedIPsInput | string[]
    Latest30Days?: AnalyticsLatest30DaysUpdateOneWithoutVanityAnalyticsNestedInput
  }

  export type VanityAnalyticsUncheckedUpdateWithoutVanitysInput = {
    Click?: IntFieldUpdateOperationsInput | number
    TrackInviteWithLog?: NullableStringFieldUpdateOperationsInput | string | null
    TrackMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    Update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UniqueClick?: NullableIntFieldUpdateOperationsInput | number | null
    JoinedWithCode?: NullableIntFieldUpdateOperationsInput | number | null
    LoggedIPs?: VanityAnalyticsUpdateLoggedIPsInput | string[]
    Latest30Days?: AnalyticsLatest30DaysUncheckedUpdateOneWithoutVanityAnalyticsNestedInput
  }

  export type VanityEmbedsUpsertWithoutVanitysInput = {
    update: XOR<VanityEmbedsUpdateWithoutVanitysInput, VanityEmbedsUncheckedUpdateWithoutVanitysInput>
    create: XOR<VanityEmbedsCreateWithoutVanitysInput, VanityEmbedsUncheckedCreateWithoutVanitysInput>
    where?: VanityEmbedsWhereInput
  }

  export type VanityEmbedsUpdateToOneWithWhereWithoutVanitysInput = {
    where?: VanityEmbedsWhereInput
    data: XOR<VanityEmbedsUpdateWithoutVanitysInput, VanityEmbedsUncheckedUpdateWithoutVanitysInput>
  }

  export type VanityEmbedsUpdateWithoutVanitysInput = {
    Title?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Color?: StringFieldUpdateOperationsInput | string
    ImageUrl?: StringFieldUpdateOperationsInput | string
    ThumbnailUrl?: StringFieldUpdateOperationsInput | string
    Author?: VanityEmbedAuthorsUpdateOneWithoutVanityEmbedsNestedInput
  }

  export type VanityEmbedsUncheckedUpdateWithoutVanitysInput = {
    Title?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Color?: StringFieldUpdateOperationsInput | string
    ImageUrl?: StringFieldUpdateOperationsInput | string
    ThumbnailUrl?: StringFieldUpdateOperationsInput | string
    Author?: VanityEmbedAuthorsUncheckedUpdateOneWithoutVanityEmbedsNestedInput
  }

  export type UsersUpsertWithoutVanitysInput = {
    update: XOR<UsersUpdateWithoutVanitysInput, UsersUncheckedUpdateWithoutVanitysInput>
    create: XOR<UsersCreateWithoutVanitysInput, UsersUncheckedCreateWithoutVanitysInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutVanitysInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutVanitysInput, UsersUncheckedUpdateWithoutVanitysInput>
  }

  export type UsersUpdateWithoutVanitysInput = {
    Username?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    Votes?: IntFieldUpdateOperationsInput | number
    GloablVotes?: IntFieldUpdateOperationsInput | number
    CustomerBots?: IntFieldUpdateOperationsInput | number
    BackupCount?: IntFieldUpdateOperationsInput | number
    Apiss?: ApisUpdateManyWithoutUsersNestedInput
    GuildBackups?: GuildBackupsUpdateManyWithoutUsersNestedInput
    Customers?: CustomersUpdateManyWithoutUsersNestedInput
    DisBotUserNotifications?: DisBotUserNotificationsUpdateOneWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutVanitysInput = {
    Username?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    Votes?: IntFieldUpdateOperationsInput | number
    GloablVotes?: IntFieldUpdateOperationsInput | number
    CustomerBots?: IntFieldUpdateOperationsInput | number
    BackupCount?: IntFieldUpdateOperationsInput | number
    Apiss?: ApisUncheckedUpdateManyWithoutUsersNestedInput
    GuildBackups?: GuildBackupsUncheckedUpdateManyWithoutUsersNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutUsersNestedInput
    DisBotUserNotifications?: DisBotUserNotificationsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type VanityEmbedAuthorsCreateWithoutVanityEmbedsInput = {
    id?: string
    Name: string
    URL: string
    IconURL: string
  }

  export type VanityEmbedAuthorsUncheckedCreateWithoutVanityEmbedsInput = {
    id?: string
    Name: string
    URL: string
    IconURL: string
  }

  export type VanityEmbedAuthorsCreateOrConnectWithoutVanityEmbedsInput = {
    where: VanityEmbedAuthorsWhereUniqueInput
    create: XOR<VanityEmbedAuthorsCreateWithoutVanityEmbedsInput, VanityEmbedAuthorsUncheckedCreateWithoutVanityEmbedsInput>
  }

  export type VanitysCreateWithoutEmbedInput = {
    id?: string
    UUID: string
    Slug: string
    Host: string
    GuildId: string
    Invite: string
    CreatedAt: Date | string
    Analytics?: VanityAnalyticsCreateNestedOneWithoutVanitysInput
    Users: UsersCreateNestedOneWithoutVanitysInput
  }

  export type VanitysUncheckedCreateWithoutEmbedInput = {
    id?: string
    UUID: string
    Slug: string
    Host: string
    GuildId: string
    Invite: string
    CreatedAt: Date | string
    UserId: string
    Analytics?: VanityAnalyticsUncheckedCreateNestedOneWithoutVanitysInput
  }

  export type VanitysCreateOrConnectWithoutEmbedInput = {
    where: VanitysWhereUniqueInput
    create: XOR<VanitysCreateWithoutEmbedInput, VanitysUncheckedCreateWithoutEmbedInput>
  }

  export type VanityEmbedAuthorsUpsertWithoutVanityEmbedsInput = {
    update: XOR<VanityEmbedAuthorsUpdateWithoutVanityEmbedsInput, VanityEmbedAuthorsUncheckedUpdateWithoutVanityEmbedsInput>
    create: XOR<VanityEmbedAuthorsCreateWithoutVanityEmbedsInput, VanityEmbedAuthorsUncheckedCreateWithoutVanityEmbedsInput>
    where?: VanityEmbedAuthorsWhereInput
  }

  export type VanityEmbedAuthorsUpdateToOneWithWhereWithoutVanityEmbedsInput = {
    where?: VanityEmbedAuthorsWhereInput
    data: XOR<VanityEmbedAuthorsUpdateWithoutVanityEmbedsInput, VanityEmbedAuthorsUncheckedUpdateWithoutVanityEmbedsInput>
  }

  export type VanityEmbedAuthorsUpdateWithoutVanityEmbedsInput = {
    Name?: StringFieldUpdateOperationsInput | string
    URL?: StringFieldUpdateOperationsInput | string
    IconURL?: StringFieldUpdateOperationsInput | string
  }

  export type VanityEmbedAuthorsUncheckedUpdateWithoutVanityEmbedsInput = {
    Name?: StringFieldUpdateOperationsInput | string
    URL?: StringFieldUpdateOperationsInput | string
    IconURL?: StringFieldUpdateOperationsInput | string
  }

  export type VanitysUpsertWithoutEmbedInput = {
    update: XOR<VanitysUpdateWithoutEmbedInput, VanitysUncheckedUpdateWithoutEmbedInput>
    create: XOR<VanitysCreateWithoutEmbedInput, VanitysUncheckedCreateWithoutEmbedInput>
    where?: VanitysWhereInput
  }

  export type VanitysUpdateToOneWithWhereWithoutEmbedInput = {
    where?: VanitysWhereInput
    data: XOR<VanitysUpdateWithoutEmbedInput, VanitysUncheckedUpdateWithoutEmbedInput>
  }

  export type VanitysUpdateWithoutEmbedInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Slug?: StringFieldUpdateOperationsInput | string
    Host?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    Invite?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Analytics?: VanityAnalyticsUpdateOneWithoutVanitysNestedInput
    Users?: UsersUpdateOneRequiredWithoutVanitysNestedInput
  }

  export type VanitysUncheckedUpdateWithoutEmbedInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Slug?: StringFieldUpdateOperationsInput | string
    Host?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    Invite?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: StringFieldUpdateOperationsInput | string
    Analytics?: VanityAnalyticsUncheckedUpdateOneWithoutVanitysNestedInput
  }

  export type VanityEmbedsCreateWithoutAuthorInput = {
    id?: string
    Title: string
    Description: string
    Color: string
    ImageUrl: string
    ThumbnailUrl: string
    Vanitys: VanitysCreateNestedOneWithoutEmbedInput
  }

  export type VanityEmbedsUncheckedCreateWithoutAuthorInput = {
    id?: string
    Title: string
    Description: string
    Color: string
    ImageUrl: string
    ThumbnailUrl: string
    VanityId: string
  }

  export type VanityEmbedsCreateOrConnectWithoutAuthorInput = {
    where: VanityEmbedsWhereUniqueInput
    create: XOR<VanityEmbedsCreateWithoutAuthorInput, VanityEmbedsUncheckedCreateWithoutAuthorInput>
  }

  export type VanityEmbedsUpsertWithoutAuthorInput = {
    update: XOR<VanityEmbedsUpdateWithoutAuthorInput, VanityEmbedsUncheckedUpdateWithoutAuthorInput>
    create: XOR<VanityEmbedsCreateWithoutAuthorInput, VanityEmbedsUncheckedCreateWithoutAuthorInput>
    where?: VanityEmbedsWhereInput
  }

  export type VanityEmbedsUpdateToOneWithWhereWithoutAuthorInput = {
    where?: VanityEmbedsWhereInput
    data: XOR<VanityEmbedsUpdateWithoutAuthorInput, VanityEmbedsUncheckedUpdateWithoutAuthorInput>
  }

  export type VanityEmbedsUpdateWithoutAuthorInput = {
    Title?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Color?: StringFieldUpdateOperationsInput | string
    ImageUrl?: StringFieldUpdateOperationsInput | string
    ThumbnailUrl?: StringFieldUpdateOperationsInput | string
    Vanitys?: VanitysUpdateOneRequiredWithoutEmbedNestedInput
  }

  export type VanityEmbedsUncheckedUpdateWithoutAuthorInput = {
    Title?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Color?: StringFieldUpdateOperationsInput | string
    ImageUrl?: StringFieldUpdateOperationsInput | string
    ThumbnailUrl?: StringFieldUpdateOperationsInput | string
    VanityId?: StringFieldUpdateOperationsInput | string
  }

  export type AnalyticsLatest30DaysCreateWithoutVanityAnalyticsInput = {
    id?: string
    Click?: number | null
    UniqueClick?: number | null
    Date?: Date | string | null
    JoinedWithCode?: number | null
  }

  export type AnalyticsLatest30DaysUncheckedCreateWithoutVanityAnalyticsInput = {
    id?: string
    Click?: number | null
    UniqueClick?: number | null
    Date?: Date | string | null
    JoinedWithCode?: number | null
  }

  export type AnalyticsLatest30DaysCreateOrConnectWithoutVanityAnalyticsInput = {
    where: AnalyticsLatest30DaysWhereUniqueInput
    create: XOR<AnalyticsLatest30DaysCreateWithoutVanityAnalyticsInput, AnalyticsLatest30DaysUncheckedCreateWithoutVanityAnalyticsInput>
  }

  export type VanitysCreateWithoutAnalyticsInput = {
    id?: string
    UUID: string
    Slug: string
    Host: string
    GuildId: string
    Invite: string
    CreatedAt: Date | string
    Embed?: VanityEmbedsCreateNestedOneWithoutVanitysInput
    Users: UsersCreateNestedOneWithoutVanitysInput
  }

  export type VanitysUncheckedCreateWithoutAnalyticsInput = {
    id?: string
    UUID: string
    Slug: string
    Host: string
    GuildId: string
    Invite: string
    CreatedAt: Date | string
    UserId: string
    Embed?: VanityEmbedsUncheckedCreateNestedOneWithoutVanitysInput
  }

  export type VanitysCreateOrConnectWithoutAnalyticsInput = {
    where: VanitysWhereUniqueInput
    create: XOR<VanitysCreateWithoutAnalyticsInput, VanitysUncheckedCreateWithoutAnalyticsInput>
  }

  export type AnalyticsLatest30DaysUpsertWithoutVanityAnalyticsInput = {
    update: XOR<AnalyticsLatest30DaysUpdateWithoutVanityAnalyticsInput, AnalyticsLatest30DaysUncheckedUpdateWithoutVanityAnalyticsInput>
    create: XOR<AnalyticsLatest30DaysCreateWithoutVanityAnalyticsInput, AnalyticsLatest30DaysUncheckedCreateWithoutVanityAnalyticsInput>
    where?: AnalyticsLatest30DaysWhereInput
  }

  export type AnalyticsLatest30DaysUpdateToOneWithWhereWithoutVanityAnalyticsInput = {
    where?: AnalyticsLatest30DaysWhereInput
    data: XOR<AnalyticsLatest30DaysUpdateWithoutVanityAnalyticsInput, AnalyticsLatest30DaysUncheckedUpdateWithoutVanityAnalyticsInput>
  }

  export type AnalyticsLatest30DaysUpdateWithoutVanityAnalyticsInput = {
    Click?: NullableIntFieldUpdateOperationsInput | number | null
    UniqueClick?: NullableIntFieldUpdateOperationsInput | number | null
    Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JoinedWithCode?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AnalyticsLatest30DaysUncheckedUpdateWithoutVanityAnalyticsInput = {
    Click?: NullableIntFieldUpdateOperationsInput | number | null
    UniqueClick?: NullableIntFieldUpdateOperationsInput | number | null
    Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JoinedWithCode?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VanitysUpsertWithoutAnalyticsInput = {
    update: XOR<VanitysUpdateWithoutAnalyticsInput, VanitysUncheckedUpdateWithoutAnalyticsInput>
    create: XOR<VanitysCreateWithoutAnalyticsInput, VanitysUncheckedCreateWithoutAnalyticsInput>
    where?: VanitysWhereInput
  }

  export type VanitysUpdateToOneWithWhereWithoutAnalyticsInput = {
    where?: VanitysWhereInput
    data: XOR<VanitysUpdateWithoutAnalyticsInput, VanitysUncheckedUpdateWithoutAnalyticsInput>
  }

  export type VanitysUpdateWithoutAnalyticsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Slug?: StringFieldUpdateOperationsInput | string
    Host?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    Invite?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Embed?: VanityEmbedsUpdateOneWithoutVanitysNestedInput
    Users?: UsersUpdateOneRequiredWithoutVanitysNestedInput
  }

  export type VanitysUncheckedUpdateWithoutAnalyticsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Slug?: StringFieldUpdateOperationsInput | string
    Host?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    Invite?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: StringFieldUpdateOperationsInput | string
    Embed?: VanityEmbedsUncheckedUpdateOneWithoutVanitysNestedInput
  }

  export type VanityAnalyticsCreateWithoutLatest30DaysInput = {
    id?: string
    Click: number
    TrackInviteWithLog?: string | null
    TrackMessageId?: string | null
    Update?: Date | string | null
    UniqueClick?: number | null
    JoinedWithCode?: number | null
    LoggedIPs?: VanityAnalyticsCreateLoggedIPsInput | string[]
    Vanitys: VanitysCreateNestedOneWithoutAnalyticsInput
  }

  export type VanityAnalyticsUncheckedCreateWithoutLatest30DaysInput = {
    id?: string
    Click: number
    TrackInviteWithLog?: string | null
    TrackMessageId?: string | null
    Update?: Date | string | null
    UniqueClick?: number | null
    JoinedWithCode?: number | null
    LoggedIPs?: VanityAnalyticsCreateLoggedIPsInput | string[]
    VanityId: string
  }

  export type VanityAnalyticsCreateOrConnectWithoutLatest30DaysInput = {
    where: VanityAnalyticsWhereUniqueInput
    create: XOR<VanityAnalyticsCreateWithoutLatest30DaysInput, VanityAnalyticsUncheckedCreateWithoutLatest30DaysInput>
  }

  export type VanityAnalyticsUpsertWithoutLatest30DaysInput = {
    update: XOR<VanityAnalyticsUpdateWithoutLatest30DaysInput, VanityAnalyticsUncheckedUpdateWithoutLatest30DaysInput>
    create: XOR<VanityAnalyticsCreateWithoutLatest30DaysInput, VanityAnalyticsUncheckedCreateWithoutLatest30DaysInput>
    where?: VanityAnalyticsWhereInput
  }

  export type VanityAnalyticsUpdateToOneWithWhereWithoutLatest30DaysInput = {
    where?: VanityAnalyticsWhereInput
    data: XOR<VanityAnalyticsUpdateWithoutLatest30DaysInput, VanityAnalyticsUncheckedUpdateWithoutLatest30DaysInput>
  }

  export type VanityAnalyticsUpdateWithoutLatest30DaysInput = {
    Click?: IntFieldUpdateOperationsInput | number
    TrackInviteWithLog?: NullableStringFieldUpdateOperationsInput | string | null
    TrackMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    Update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UniqueClick?: NullableIntFieldUpdateOperationsInput | number | null
    JoinedWithCode?: NullableIntFieldUpdateOperationsInput | number | null
    LoggedIPs?: VanityAnalyticsUpdateLoggedIPsInput | string[]
    Vanitys?: VanitysUpdateOneRequiredWithoutAnalyticsNestedInput
  }

  export type VanityAnalyticsUncheckedUpdateWithoutLatest30DaysInput = {
    Click?: IntFieldUpdateOperationsInput | number
    TrackInviteWithLog?: NullableStringFieldUpdateOperationsInput | string | null
    TrackMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    Update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UniqueClick?: NullableIntFieldUpdateOperationsInput | number | null
    JoinedWithCode?: NullableIntFieldUpdateOperationsInput | number | null
    LoggedIPs?: VanityAnalyticsUpdateLoggedIPsInput | string[]
    VanityId?: StringFieldUpdateOperationsInput | string
  }

  export type UsersCreateWithoutDisBotUserNotificationsInput = {
    id?: string
    Username: string
    UserId: string
    Votes?: number
    GloablVotes?: number
    CustomerBots?: number
    BackupCount?: number
    Apiss?: ApisCreateNestedManyWithoutUsersInput
    GuildBackups?: GuildBackupsCreateNestedManyWithoutUsersInput
    Customers?: CustomersCreateNestedManyWithoutUsersInput
    Vanitys?: VanitysCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutDisBotUserNotificationsInput = {
    id?: string
    Username: string
    UserId: string
    Votes?: number
    GloablVotes?: number
    CustomerBots?: number
    BackupCount?: number
    Apiss?: ApisUncheckedCreateNestedManyWithoutUsersInput
    GuildBackups?: GuildBackupsUncheckedCreateNestedManyWithoutUsersInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutUsersInput
    Vanitys?: VanitysUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutDisBotUserNotificationsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutDisBotUserNotificationsInput, UsersUncheckedCreateWithoutDisBotUserNotificationsInput>
  }

  export type UsersUpsertWithoutDisBotUserNotificationsInput = {
    update: XOR<UsersUpdateWithoutDisBotUserNotificationsInput, UsersUncheckedUpdateWithoutDisBotUserNotificationsInput>
    create: XOR<UsersCreateWithoutDisBotUserNotificationsInput, UsersUncheckedCreateWithoutDisBotUserNotificationsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutDisBotUserNotificationsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutDisBotUserNotificationsInput, UsersUncheckedUpdateWithoutDisBotUserNotificationsInput>
  }

  export type UsersUpdateWithoutDisBotUserNotificationsInput = {
    Username?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    Votes?: IntFieldUpdateOperationsInput | number
    GloablVotes?: IntFieldUpdateOperationsInput | number
    CustomerBots?: IntFieldUpdateOperationsInput | number
    BackupCount?: IntFieldUpdateOperationsInput | number
    Apiss?: ApisUpdateManyWithoutUsersNestedInput
    GuildBackups?: GuildBackupsUpdateManyWithoutUsersNestedInput
    Customers?: CustomersUpdateManyWithoutUsersNestedInput
    Vanitys?: VanitysUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutDisBotUserNotificationsInput = {
    Username?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    Votes?: IntFieldUpdateOperationsInput | number
    GloablVotes?: IntFieldUpdateOperationsInput | number
    CustomerBots?: IntFieldUpdateOperationsInput | number
    BackupCount?: IntFieldUpdateOperationsInput | number
    Apiss?: ApisUncheckedUpdateManyWithoutUsersNestedInput
    GuildBackups?: GuildBackupsUncheckedUpdateManyWithoutUsersNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutUsersNestedInput
    Vanitys?: VanitysUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type DisbotsLogsUpdateManyInput = {
    where: DisbotsLogsWhereInput
    data: DisbotsLogsUpdateInput
  }

  export type DisbotsLogsDeleteManyInput = {
    where: DisbotsLogsWhereInput
  }

  export type AutoDeletesCreateManyGuildsInput = {
    id?: string
    ChannelId?: string | null
    IsActive?: boolean | null
    Time?: string | null
    UUID?: string | null
    WhitelistedMessages?: AutoDeletesCreateWhitelistedMessagesInput | string[]
    WhitelistedRoles?: AutoDeletesCreateWhitelistedRolesInput | string[]
    WhitelistedUsers?: AutoDeletesCreateWhitelistedUsersInput | string[]
  }

  export type AutoReactsCreateManyGuildsInput = {
    id?: string
    ChannelId: string
    Emoji: string
  }

  export type AutoRolesCreateManyGuildsInput = {
    id?: string
    RoleId: string
  }

  export type GuildBansCreateManyGuildsInput = {
    id?: string
    UUID: string
    Time?: string | null
    UserId?: GuildBansCreateUserIdInput | string[]
    Reason?: string | null
    ModeratorId?: string | null
    DmMessage?: string | null
    Banned?: boolean | null
    CreatedAt?: Date | string | null
  }

  export type ChannelLinksCreateManyGuildsInput = {
    id?: string
    UUID: string
    ChannelId: string
    WebhookUrls?: ChannelLinksCreateWebhookUrlsInput | string[]
  }

  export type GiveawaysCreateManyGuildsInput = {
    id?: string
    UUID: string
    MessageId: string
    ChannelId?: string | null
    Prize: string
    Winners: number
    Time: string
    CreatedAt: Date | string
    Ended: boolean
    EndedAt?: Date | string | null
    EndedBy?: string | null
    Paused: boolean
    EndedMessage?: string | null
    Rerolled: boolean
    WinnerIds?: GiveawaysCreateWinnerIdsInput | string[]
    WinnerMessageTemplate?: string | null
    HostedBy: string
    MessageTemplate?: string | null
    Content?: string | null
    Entrys?: GiveawaysCreateEntrysInput | string[]
    Requirements?: GiveawaysCreateRequirementsInput | string[]
  }

  export type TempVoicesCreateManyGuildsInput = {
    id?: string
    UUID: string
    Name: string
    JointoCreateChannel: string
    JointoCreateCategory: string
    Manage: boolean
    PresetLimit: number
  }

  export type MessageTemplatesCreateManyGuildsInput = {
    id?: string
    Content?: string | null
    EmbedJSON?: string | null
    OtherEmbeds?: MessageTemplatesCreateOtherEmbedsInput | string[]
    Name: string
  }

  export type ReactionRolesCreateManyGuildsInput = {
    id?: string
    UUID: string
    Roles?: ReactionRolesCreateRolesInput | string[]
    MessageId?: string | null
    ChannelId?: string | null
    AddMessage?: string | null
    RemoveMessage?: string | null
    Button?: XOR<ReactionRoleButtonNullableCreateEnvelopeInput, ReactionRoleButtonCreateInput> | null
    SelectMenu?: XOR<ReactionRoleSelectmenuNullableCreateEnvelopeInput, ReactionRoleSelectmenuCreateInput> | null
    Emoji?: string | null
  }

  export type SpotifyNotificationsCreateManyGuildsInput = {
    id?: string
    ShowId: string
    ChannelId: string
    Latests?: SpotifyNotificationsCreateLatestsInput | string[]
    MessageTemplateId: string
    PingRoles?: SpotifyNotificationsCreatePingRolesInput | string[]
    UUID: string
  }

  export type TagsCreateManyGuildsInput = {
    id?: string
    UUID: string
    TagId: string
    MessageId: string
    IsShlashCommand: boolean
    ShlashCommandId: string
    IsTextInputCommand: boolean
    IsEnabled: boolean
    PermissionRoleId?: string | null
    CommandDescription?: string | null
    FilterTextFromMessages?: TagsCreateFilterTextFromMessagesInput | string[]
  }

  export type TicketSetupsCreateManyGuildsInput = {
    id?: string
    CategoryId?: string | null
    Handlers?: TicketSetupsCreateHandlersInput | string[]
    HandlerWithShadowPing?: TicketSetupsCreateHandlerWithShadowPingInput | string[]
    CustomId: string
    TicketChannelName?: string | null
    ChannelType?: number | null
    MessageTempleateId?: string | null
    TicketBlacklistRoles?: TicketSetupsCreateTicketBlacklistRolesInput | string[]
    TranscriptChannelId?: string | null
    HasModal?: boolean | null
    UserDMWhenCloseMessageTemplateId?: string | null
    TicketLimit?: number | null
    WithTicketFeedback?: boolean | null
    TicketFeedbackChannelId?: string | null
    ModalTitle?: string | null
    TicketCreationCooldownPerUser?: number | null
    AutoCloseAfterInactivity?: number | null
    AutoAssignHandler?: string | null
    AutoReplyMessageTemplateId?: string | null
    RequiredRoles?: TicketSetupsCreateRequiredRolesInput | string[]
    OpenTicketWithCommand?: boolean | null
    SlashCommandId?: string | null
    TextCommandName?: string | null
    SendTranscriptToUser?: boolean | null
  }

  export type TwitchNotificationsCreateManyGuildsInput = {
    id?: string
    UUID: string
    TwitchChannelName: string
    ChannelId: string
    Live: boolean
    MessageTemplateId: string
    PingRoles?: TwitchNotificationsCreatePingRolesInput | string[]
  }

  export type YoutubeNotificationsCreateManyGuildsInput = {
    id?: string
    YoutubeChannelId: string
    ChannelId: string
    Latest?: YoutubeNotificationsCreateLatestInput | string[]
    MessageTemplateId: string
    PingRoles?: YoutubeNotificationsCreatePingRolesInput | string[]
    UUID: string
  }

  export type GuildLoggersCreateManyGuildsInput = {
    id?: string
    UUID: string
    Notes?: GuildLoggersCreateNotesInput | string[]
    LogMessage: string
    LogJSON: string
  }

  export type AutoDeletesUpdateWithoutGuildsInput = {
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Time?: NullableStringFieldUpdateOperationsInput | string | null
    UUID?: NullableStringFieldUpdateOperationsInput | string | null
    WhitelistedMessages?: AutoDeletesUpdateWhitelistedMessagesInput | string[]
    WhitelistedRoles?: AutoDeletesUpdateWhitelistedRolesInput | string[]
    WhitelistedUsers?: AutoDeletesUpdateWhitelistedUsersInput | string[]
  }

  export type AutoDeletesUncheckedUpdateWithoutGuildsInput = {
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Time?: NullableStringFieldUpdateOperationsInput | string | null
    UUID?: NullableStringFieldUpdateOperationsInput | string | null
    WhitelistedMessages?: AutoDeletesUpdateWhitelistedMessagesInput | string[]
    WhitelistedRoles?: AutoDeletesUpdateWhitelistedRolesInput | string[]
    WhitelistedUsers?: AutoDeletesUpdateWhitelistedUsersInput | string[]
  }

  export type AutoDeletesUncheckedUpdateManyWithoutGuildsInput = {
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Time?: NullableStringFieldUpdateOperationsInput | string | null
    UUID?: NullableStringFieldUpdateOperationsInput | string | null
    WhitelistedMessages?: AutoDeletesUpdateWhitelistedMessagesInput | string[]
    WhitelistedRoles?: AutoDeletesUpdateWhitelistedRolesInput | string[]
    WhitelistedUsers?: AutoDeletesUpdateWhitelistedUsersInput | string[]
  }

  export type AutoReactsUpdateWithoutGuildsInput = {
    ChannelId?: StringFieldUpdateOperationsInput | string
    Emoji?: StringFieldUpdateOperationsInput | string
  }

  export type AutoReactsUncheckedUpdateWithoutGuildsInput = {
    ChannelId?: StringFieldUpdateOperationsInput | string
    Emoji?: StringFieldUpdateOperationsInput | string
  }

  export type AutoReactsUncheckedUpdateManyWithoutGuildsInput = {
    ChannelId?: StringFieldUpdateOperationsInput | string
    Emoji?: StringFieldUpdateOperationsInput | string
  }

  export type AutoRolesUpdateWithoutGuildsInput = {
    RoleId?: StringFieldUpdateOperationsInput | string
  }

  export type AutoRolesUncheckedUpdateWithoutGuildsInput = {
    RoleId?: StringFieldUpdateOperationsInput | string
  }

  export type AutoRolesUncheckedUpdateManyWithoutGuildsInput = {
    RoleId?: StringFieldUpdateOperationsInput | string
  }

  export type GuildBansUpdateWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Time?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: GuildBansUpdateUserIdInput | string[]
    Reason?: NullableStringFieldUpdateOperationsInput | string | null
    ModeratorId?: NullableStringFieldUpdateOperationsInput | string | null
    DmMessage?: NullableStringFieldUpdateOperationsInput | string | null
    Banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GuildBansUncheckedUpdateWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Time?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: GuildBansUpdateUserIdInput | string[]
    Reason?: NullableStringFieldUpdateOperationsInput | string | null
    ModeratorId?: NullableStringFieldUpdateOperationsInput | string | null
    DmMessage?: NullableStringFieldUpdateOperationsInput | string | null
    Banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GuildBansUncheckedUpdateManyWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Time?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: GuildBansUpdateUserIdInput | string[]
    Reason?: NullableStringFieldUpdateOperationsInput | string | null
    ModeratorId?: NullableStringFieldUpdateOperationsInput | string | null
    DmMessage?: NullableStringFieldUpdateOperationsInput | string | null
    Banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelLinksUpdateWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    WebhookUrls?: ChannelLinksUpdateWebhookUrlsInput | string[]
    SyncedChannelLinkMessage?: SyncedChannelLinkMessagesUpdateManyWithoutChannelLinksNestedInput
  }

  export type ChannelLinksUncheckedUpdateWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    WebhookUrls?: ChannelLinksUpdateWebhookUrlsInput | string[]
    SyncedChannelLinkMessage?: SyncedChannelLinkMessagesUncheckedUpdateManyWithoutChannelLinksNestedInput
  }

  export type ChannelLinksUncheckedUpdateManyWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    WebhookUrls?: ChannelLinksUpdateWebhookUrlsInput | string[]
  }

  export type GiveawaysUpdateWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    Prize?: StringFieldUpdateOperationsInput | string
    Winners?: IntFieldUpdateOperationsInput | number
    Time?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ended?: BoolFieldUpdateOperationsInput | boolean
    EndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndedBy?: NullableStringFieldUpdateOperationsInput | string | null
    Paused?: BoolFieldUpdateOperationsInput | boolean
    EndedMessage?: NullableStringFieldUpdateOperationsInput | string | null
    Rerolled?: BoolFieldUpdateOperationsInput | boolean
    WinnerIds?: GiveawaysUpdateWinnerIdsInput | string[]
    WinnerMessageTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    HostedBy?: StringFieldUpdateOperationsInput | string
    MessageTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    Entrys?: GiveawaysUpdateEntrysInput | string[]
    Requirements?: GiveawaysUpdateRequirementsInput | string[]
  }

  export type GiveawaysUncheckedUpdateWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    Prize?: StringFieldUpdateOperationsInput | string
    Winners?: IntFieldUpdateOperationsInput | number
    Time?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ended?: BoolFieldUpdateOperationsInput | boolean
    EndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndedBy?: NullableStringFieldUpdateOperationsInput | string | null
    Paused?: BoolFieldUpdateOperationsInput | boolean
    EndedMessage?: NullableStringFieldUpdateOperationsInput | string | null
    Rerolled?: BoolFieldUpdateOperationsInput | boolean
    WinnerIds?: GiveawaysUpdateWinnerIdsInput | string[]
    WinnerMessageTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    HostedBy?: StringFieldUpdateOperationsInput | string
    MessageTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    Entrys?: GiveawaysUpdateEntrysInput | string[]
    Requirements?: GiveawaysUpdateRequirementsInput | string[]
  }

  export type GiveawaysUncheckedUpdateManyWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    Prize?: StringFieldUpdateOperationsInput | string
    Winners?: IntFieldUpdateOperationsInput | number
    Time?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ended?: BoolFieldUpdateOperationsInput | boolean
    EndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndedBy?: NullableStringFieldUpdateOperationsInput | string | null
    Paused?: BoolFieldUpdateOperationsInput | boolean
    EndedMessage?: NullableStringFieldUpdateOperationsInput | string | null
    Rerolled?: BoolFieldUpdateOperationsInput | boolean
    WinnerIds?: GiveawaysUpdateWinnerIdsInput | string[]
    WinnerMessageTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    HostedBy?: StringFieldUpdateOperationsInput | string
    MessageTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    Entrys?: GiveawaysUpdateEntrysInput | string[]
    Requirements?: GiveawaysUpdateRequirementsInput | string[]
  }

  export type TempVoicesUpdateWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    JointoCreateChannel?: StringFieldUpdateOperationsInput | string
    JointoCreateCategory?: StringFieldUpdateOperationsInput | string
    Manage?: BoolFieldUpdateOperationsInput | boolean
    PresetLimit?: IntFieldUpdateOperationsInput | number
    TempVoiceChannels?: TempVoiceChannelsUpdateManyWithoutTempVoicesNestedInput
  }

  export type TempVoicesUncheckedUpdateWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    JointoCreateChannel?: StringFieldUpdateOperationsInput | string
    JointoCreateCategory?: StringFieldUpdateOperationsInput | string
    Manage?: BoolFieldUpdateOperationsInput | boolean
    PresetLimit?: IntFieldUpdateOperationsInput | number
    TempVoiceChannels?: TempVoiceChannelsUncheckedUpdateManyWithoutTempVoicesNestedInput
  }

  export type TempVoicesUncheckedUpdateManyWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    JointoCreateChannel?: StringFieldUpdateOperationsInput | string
    JointoCreateCategory?: StringFieldUpdateOperationsInput | string
    Manage?: BoolFieldUpdateOperationsInput | boolean
    PresetLimit?: IntFieldUpdateOperationsInput | number
  }

  export type MessageTemplatesUpdateWithoutGuildsInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    EmbedJSON?: NullableStringFieldUpdateOperationsInput | string | null
    OtherEmbeds?: MessageTemplatesUpdateOtherEmbedsInput | string[]
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type MessageTemplatesUncheckedUpdateWithoutGuildsInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    EmbedJSON?: NullableStringFieldUpdateOperationsInput | string | null
    OtherEmbeds?: MessageTemplatesUpdateOtherEmbedsInput | string[]
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type MessageTemplatesUncheckedUpdateManyWithoutGuildsInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    EmbedJSON?: NullableStringFieldUpdateOperationsInput | string | null
    OtherEmbeds?: MessageTemplatesUpdateOtherEmbedsInput | string[]
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type ReactionRolesUpdateWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Roles?: ReactionRolesUpdateRolesInput | string[]
    MessageId?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    AddMessage?: NullableStringFieldUpdateOperationsInput | string | null
    RemoveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    Button?: XOR<ReactionRoleButtonNullableUpdateEnvelopeInput, ReactionRoleButtonCreateInput> | null
    SelectMenu?: XOR<ReactionRoleSelectmenuNullableUpdateEnvelopeInput, ReactionRoleSelectmenuCreateInput> | null
    Emoji?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReactionRolesUncheckedUpdateWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Roles?: ReactionRolesUpdateRolesInput | string[]
    MessageId?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    AddMessage?: NullableStringFieldUpdateOperationsInput | string | null
    RemoveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    Button?: XOR<ReactionRoleButtonNullableUpdateEnvelopeInput, ReactionRoleButtonCreateInput> | null
    SelectMenu?: XOR<ReactionRoleSelectmenuNullableUpdateEnvelopeInput, ReactionRoleSelectmenuCreateInput> | null
    Emoji?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReactionRolesUncheckedUpdateManyWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Roles?: ReactionRolesUpdateRolesInput | string[]
    MessageId?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    AddMessage?: NullableStringFieldUpdateOperationsInput | string | null
    RemoveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    Button?: XOR<ReactionRoleButtonNullableUpdateEnvelopeInput, ReactionRoleButtonCreateInput> | null
    SelectMenu?: XOR<ReactionRoleSelectmenuNullableUpdateEnvelopeInput, ReactionRoleSelectmenuCreateInput> | null
    Emoji?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpotifyNotificationsUpdateWithoutGuildsInput = {
    ShowId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Latests?: SpotifyNotificationsUpdateLatestsInput | string[]
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    PingRoles?: SpotifyNotificationsUpdatePingRolesInput | string[]
    UUID?: StringFieldUpdateOperationsInput | string
  }

  export type SpotifyNotificationsUncheckedUpdateWithoutGuildsInput = {
    ShowId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Latests?: SpotifyNotificationsUpdateLatestsInput | string[]
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    PingRoles?: SpotifyNotificationsUpdatePingRolesInput | string[]
    UUID?: StringFieldUpdateOperationsInput | string
  }

  export type SpotifyNotificationsUncheckedUpdateManyWithoutGuildsInput = {
    ShowId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Latests?: SpotifyNotificationsUpdateLatestsInput | string[]
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    PingRoles?: SpotifyNotificationsUpdatePingRolesInput | string[]
    UUID?: StringFieldUpdateOperationsInput | string
  }

  export type TagsUpdateWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    TagId?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    IsShlashCommand?: BoolFieldUpdateOperationsInput | boolean
    ShlashCommandId?: StringFieldUpdateOperationsInput | string
    IsTextInputCommand?: BoolFieldUpdateOperationsInput | boolean
    IsEnabled?: BoolFieldUpdateOperationsInput | boolean
    PermissionRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    CommandDescription?: NullableStringFieldUpdateOperationsInput | string | null
    FilterTextFromMessages?: TagsUpdateFilterTextFromMessagesInput | string[]
  }

  export type TagsUncheckedUpdateWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    TagId?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    IsShlashCommand?: BoolFieldUpdateOperationsInput | boolean
    ShlashCommandId?: StringFieldUpdateOperationsInput | string
    IsTextInputCommand?: BoolFieldUpdateOperationsInput | boolean
    IsEnabled?: BoolFieldUpdateOperationsInput | boolean
    PermissionRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    CommandDescription?: NullableStringFieldUpdateOperationsInput | string | null
    FilterTextFromMessages?: TagsUpdateFilterTextFromMessagesInput | string[]
  }

  export type TagsUncheckedUpdateManyWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    TagId?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    IsShlashCommand?: BoolFieldUpdateOperationsInput | boolean
    ShlashCommandId?: StringFieldUpdateOperationsInput | string
    IsTextInputCommand?: BoolFieldUpdateOperationsInput | boolean
    IsEnabled?: BoolFieldUpdateOperationsInput | boolean
    PermissionRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    CommandDescription?: NullableStringFieldUpdateOperationsInput | string | null
    FilterTextFromMessages?: TagsUpdateFilterTextFromMessagesInput | string[]
  }

  export type TicketSetupsUpdateWithoutGuildsInput = {
    CategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    Handlers?: TicketSetupsUpdateHandlersInput | string[]
    HandlerWithShadowPing?: TicketSetupsUpdateHandlerWithShadowPingInput | string[]
    CustomId?: StringFieldUpdateOperationsInput | string
    TicketChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelType?: NullableIntFieldUpdateOperationsInput | number | null
    MessageTempleateId?: NullableStringFieldUpdateOperationsInput | string | null
    TicketBlacklistRoles?: TicketSetupsUpdateTicketBlacklistRolesInput | string[]
    TranscriptChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    HasModal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UserDMWhenCloseMessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    TicketLimit?: NullableIntFieldUpdateOperationsInput | number | null
    WithTicketFeedback?: NullableBoolFieldUpdateOperationsInput | boolean | null
    TicketFeedbackChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    ModalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    TicketCreationCooldownPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    AutoCloseAfterInactivity?: NullableIntFieldUpdateOperationsInput | number | null
    AutoAssignHandler?: NullableStringFieldUpdateOperationsInput | string | null
    AutoReplyMessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    RequiredRoles?: TicketSetupsUpdateRequiredRolesInput | string[]
    OpenTicketWithCommand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SlashCommandId?: NullableStringFieldUpdateOperationsInput | string | null
    TextCommandName?: NullableStringFieldUpdateOperationsInput | string | null
    SendTranscriptToUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ModalOptions?: TicketModalDataUpdateManyWithoutTicketSetupNestedInput
    Tickets?: TicketsUpdateManyWithoutTicketSetupNestedInput
  }

  export type TicketSetupsUncheckedUpdateWithoutGuildsInput = {
    CategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    Handlers?: TicketSetupsUpdateHandlersInput | string[]
    HandlerWithShadowPing?: TicketSetupsUpdateHandlerWithShadowPingInput | string[]
    CustomId?: StringFieldUpdateOperationsInput | string
    TicketChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelType?: NullableIntFieldUpdateOperationsInput | number | null
    MessageTempleateId?: NullableStringFieldUpdateOperationsInput | string | null
    TicketBlacklistRoles?: TicketSetupsUpdateTicketBlacklistRolesInput | string[]
    TranscriptChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    HasModal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UserDMWhenCloseMessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    TicketLimit?: NullableIntFieldUpdateOperationsInput | number | null
    WithTicketFeedback?: NullableBoolFieldUpdateOperationsInput | boolean | null
    TicketFeedbackChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    ModalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    TicketCreationCooldownPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    AutoCloseAfterInactivity?: NullableIntFieldUpdateOperationsInput | number | null
    AutoAssignHandler?: NullableStringFieldUpdateOperationsInput | string | null
    AutoReplyMessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    RequiredRoles?: TicketSetupsUpdateRequiredRolesInput | string[]
    OpenTicketWithCommand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SlashCommandId?: NullableStringFieldUpdateOperationsInput | string | null
    TextCommandName?: NullableStringFieldUpdateOperationsInput | string | null
    SendTranscriptToUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ModalOptions?: TicketModalDataUncheckedUpdateManyWithoutTicketSetupNestedInput
    Tickets?: TicketsUncheckedUpdateManyWithoutTicketSetupNestedInput
  }

  export type TicketSetupsUncheckedUpdateManyWithoutGuildsInput = {
    CategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    Handlers?: TicketSetupsUpdateHandlersInput | string[]
    HandlerWithShadowPing?: TicketSetupsUpdateHandlerWithShadowPingInput | string[]
    CustomId?: StringFieldUpdateOperationsInput | string
    TicketChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    ChannelType?: NullableIntFieldUpdateOperationsInput | number | null
    MessageTempleateId?: NullableStringFieldUpdateOperationsInput | string | null
    TicketBlacklistRoles?: TicketSetupsUpdateTicketBlacklistRolesInput | string[]
    TranscriptChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    HasModal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UserDMWhenCloseMessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    TicketLimit?: NullableIntFieldUpdateOperationsInput | number | null
    WithTicketFeedback?: NullableBoolFieldUpdateOperationsInput | boolean | null
    TicketFeedbackChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    ModalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    TicketCreationCooldownPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    AutoCloseAfterInactivity?: NullableIntFieldUpdateOperationsInput | number | null
    AutoAssignHandler?: NullableStringFieldUpdateOperationsInput | string | null
    AutoReplyMessageTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    RequiredRoles?: TicketSetupsUpdateRequiredRolesInput | string[]
    OpenTicketWithCommand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SlashCommandId?: NullableStringFieldUpdateOperationsInput | string | null
    TextCommandName?: NullableStringFieldUpdateOperationsInput | string | null
    SendTranscriptToUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TwitchNotificationsUpdateWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    TwitchChannelName?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Live?: BoolFieldUpdateOperationsInput | boolean
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    PingRoles?: TwitchNotificationsUpdatePingRolesInput | string[]
  }

  export type TwitchNotificationsUncheckedUpdateWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    TwitchChannelName?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Live?: BoolFieldUpdateOperationsInput | boolean
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    PingRoles?: TwitchNotificationsUpdatePingRolesInput | string[]
  }

  export type TwitchNotificationsUncheckedUpdateManyWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    TwitchChannelName?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Live?: BoolFieldUpdateOperationsInput | boolean
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    PingRoles?: TwitchNotificationsUpdatePingRolesInput | string[]
  }

  export type YoutubeNotificationsUpdateWithoutGuildsInput = {
    YoutubeChannelId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Latest?: YoutubeNotificationsUpdateLatestInput | string[]
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    PingRoles?: YoutubeNotificationsUpdatePingRolesInput | string[]
    UUID?: StringFieldUpdateOperationsInput | string
  }

  export type YoutubeNotificationsUncheckedUpdateWithoutGuildsInput = {
    YoutubeChannelId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Latest?: YoutubeNotificationsUpdateLatestInput | string[]
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    PingRoles?: YoutubeNotificationsUpdatePingRolesInput | string[]
    UUID?: StringFieldUpdateOperationsInput | string
  }

  export type YoutubeNotificationsUncheckedUpdateManyWithoutGuildsInput = {
    YoutubeChannelId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    Latest?: YoutubeNotificationsUpdateLatestInput | string[]
    MessageTemplateId?: StringFieldUpdateOperationsInput | string
    PingRoles?: YoutubeNotificationsUpdatePingRolesInput | string[]
    UUID?: StringFieldUpdateOperationsInput | string
  }

  export type GuildLoggersUpdateWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Notes?: GuildLoggersUpdateNotesInput | string[]
    LogMessage?: StringFieldUpdateOperationsInput | string
    LogJSON?: StringFieldUpdateOperationsInput | string
  }

  export type GuildLoggersUncheckedUpdateWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Notes?: GuildLoggersUpdateNotesInput | string[]
    LogMessage?: StringFieldUpdateOperationsInput | string
    LogJSON?: StringFieldUpdateOperationsInput | string
  }

  export type GuildLoggersUncheckedUpdateManyWithoutGuildsInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Notes?: GuildLoggersUpdateNotesInput | string[]
    LogMessage?: StringFieldUpdateOperationsInput | string
    LogJSON?: StringFieldUpdateOperationsInput | string
  }

  export type SyncedChannelLinkMessagesCreateManyChannelLinksInput = {
    id?: string
    GuildId: string
    UserMessageId: string
    WebhookMessageId: string
    WebhookURL: string
    ChannelId: string
  }

  export type SyncedChannelLinkMessagesUpdateWithoutChannelLinksInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    UserMessageId?: StringFieldUpdateOperationsInput | string
    WebhookMessageId?: StringFieldUpdateOperationsInput | string
    WebhookURL?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
  }

  export type SyncedChannelLinkMessagesUncheckedUpdateWithoutChannelLinksInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    UserMessageId?: StringFieldUpdateOperationsInput | string
    WebhookMessageId?: StringFieldUpdateOperationsInput | string
    WebhookURL?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
  }

  export type SyncedChannelLinkMessagesUncheckedUpdateManyWithoutChannelLinksInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    UserMessageId?: StringFieldUpdateOperationsInput | string
    WebhookMessageId?: StringFieldUpdateOperationsInput | string
    WebhookURL?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
  }

  export type TempVoiceChannelsCreateManyTempVoicesInput = {
    id?: string
    GuildId: string
    ChannelId: string
    OwnerId: string
  }

  export type TempVoiceChannelsUpdateWithoutTempVoicesInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    OwnerId?: StringFieldUpdateOperationsInput | string
  }

  export type TempVoiceChannelsUncheckedUpdateWithoutTempVoicesInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    OwnerId?: StringFieldUpdateOperationsInput | string
  }

  export type TempVoiceChannelsUncheckedUpdateManyWithoutTempVoicesInput = {
    GuildId?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    OwnerId?: StringFieldUpdateOperationsInput | string
  }

  export type PermissionDataUpdateInput = {
    RoleId?: StringFieldUpdateOperationsInput | string
    Type?: StringFieldUpdateOperationsInput | string
  }

  export type ReactionRoleButtonUpdateInput = {
    Emoji?: StringFieldUpdateOperationsInput | string
    Type?: StringFieldUpdateOperationsInput | string
    Label?: StringFieldUpdateOperationsInput | string
  }

  export type ReactionRoleSelectmenuUpdateInput = {
    Emoji?: StringFieldUpdateOperationsInput | string
    Label?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationGatesCreateManyVerificationGatesInput = {
    id?: string
    UUID: string
    ChannelId: string
    MessageId: string
    Action?: string | null
    ActionType?: string | null
    Roles?: VerificationGatesCreateRolesInput | string[]
    VerifiedUsers?: VerificationGatesCreateVerifiedUsersInput | string[]
    CreatedAt: Date | string
    Active?: boolean | null
  }

  export type VerificationGatesUpdateWithoutVerificationGatesInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    Action?: NullableStringFieldUpdateOperationsInput | string | null
    ActionType?: NullableStringFieldUpdateOperationsInput | string | null
    Roles?: VerificationGatesUpdateRolesInput | string[]
    VerifiedUsers?: VerificationGatesUpdateVerifiedUsersInput | string[]
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ChannelPermissions?: VerificationGatesPermissionUpdateManyWithoutVerificationGatesNestedInput
  }

  export type VerificationGatesUncheckedUpdateWithoutVerificationGatesInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    Action?: NullableStringFieldUpdateOperationsInput | string | null
    ActionType?: NullableStringFieldUpdateOperationsInput | string | null
    Roles?: VerificationGatesUpdateRolesInput | string[]
    VerifiedUsers?: VerificationGatesUpdateVerifiedUsersInput | string[]
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ChannelPermissions?: VerificationGatesPermissionUncheckedUpdateManyWithoutVerificationGatesNestedInput
  }

  export type VerificationGatesUncheckedUpdateManyWithoutVerificationGatesInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    Action?: NullableStringFieldUpdateOperationsInput | string | null
    ActionType?: NullableStringFieldUpdateOperationsInput | string | null
    Roles?: VerificationGatesUpdateRolesInput | string[]
    VerifiedUsers?: VerificationGatesUpdateVerifiedUsersInput | string[]
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type VerificationGatesPermissionCreateManyVerificationGatesInput = {
    id?: string
    Permission?: VerificationGatesPermissionCreatePermissionInput | string[]
    ChannelId: string
  }

  export type VerificationGatesPermissionUpdateWithoutVerificationGatesInput = {
    Permission?: VerificationGatesPermissionUpdatePermissionInput | string[]
    ChannelId?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationGatesPermissionUncheckedUpdateWithoutVerificationGatesInput = {
    Permission?: VerificationGatesPermissionUpdatePermissionInput | string[]
    ChannelId?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationGatesPermissionUncheckedUpdateManyWithoutVerificationGatesInput = {
    Permission?: VerificationGatesPermissionUpdatePermissionInput | string[]
    ChannelId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketModalDataCreateManyTicketSetupInput = {
    id?: string
    Name: string
    Placeholder: string
    Type: number
  }

  export type TicketsCreateManyTicketSetupInput = {
    id?: string
    TicketId: string
    GuildId: string
    ChannelId?: string | null
    ThreadId?: string | null
    IsClaimed?: boolean | null
    IsArchived?: boolean | null
    ArchiveMessageId?: string | null
    UserWhoHasClaimedId?: string | null
    IsLooked?: boolean | null
    TicketOwnerId: string
    AddedMemberIds?: TicketsCreateAddedMemberIdsInput | string[]
    Handlers?: TicketsCreateHandlersInput | string[]
    TranscriptChannelId: string
    TranscriptHTML?: string | null
    TicketNotes?: TicketsCreateTicketNotesInput | string[]
  }

  export type TicketModalDataUpdateWithoutTicketSetupInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Placeholder?: StringFieldUpdateOperationsInput | string
    Type?: IntFieldUpdateOperationsInput | number
  }

  export type TicketModalDataUncheckedUpdateWithoutTicketSetupInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Placeholder?: StringFieldUpdateOperationsInput | string
    Type?: IntFieldUpdateOperationsInput | number
  }

  export type TicketModalDataUncheckedUpdateManyWithoutTicketSetupInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Placeholder?: StringFieldUpdateOperationsInput | string
    Type?: IntFieldUpdateOperationsInput | number
  }

  export type TicketsUpdateWithoutTicketSetupInput = {
    TicketId?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    ThreadId?: NullableStringFieldUpdateOperationsInput | string | null
    IsClaimed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsArchived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ArchiveMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    UserWhoHasClaimedId?: NullableStringFieldUpdateOperationsInput | string | null
    IsLooked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    TicketOwnerId?: StringFieldUpdateOperationsInput | string
    AddedMemberIds?: TicketsUpdateAddedMemberIdsInput | string[]
    Handlers?: TicketsUpdateHandlersInput | string[]
    TranscriptChannelId?: StringFieldUpdateOperationsInput | string
    TranscriptHTML?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNotes?: TicketsUpdateTicketNotesInput | string[]
    TicketFeedback?: TicketFeedbackUpdateOneWithoutTicketNestedInput
  }

  export type TicketsUncheckedUpdateWithoutTicketSetupInput = {
    TicketId?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    ThreadId?: NullableStringFieldUpdateOperationsInput | string | null
    IsClaimed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsArchived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ArchiveMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    UserWhoHasClaimedId?: NullableStringFieldUpdateOperationsInput | string | null
    IsLooked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    TicketOwnerId?: StringFieldUpdateOperationsInput | string
    AddedMemberIds?: TicketsUpdateAddedMemberIdsInput | string[]
    Handlers?: TicketsUpdateHandlersInput | string[]
    TranscriptChannelId?: StringFieldUpdateOperationsInput | string
    TranscriptHTML?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNotes?: TicketsUpdateTicketNotesInput | string[]
    TicketFeedback?: TicketFeedbackUncheckedUpdateOneWithoutTicketNestedInput
  }

  export type TicketsUncheckedUpdateManyWithoutTicketSetupInput = {
    TicketId?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    ChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    ThreadId?: NullableStringFieldUpdateOperationsInput | string | null
    IsClaimed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsArchived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ArchiveMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    UserWhoHasClaimedId?: NullableStringFieldUpdateOperationsInput | string | null
    IsLooked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    TicketOwnerId?: StringFieldUpdateOperationsInput | string
    AddedMemberIds?: TicketsUpdateAddedMemberIdsInput | string[]
    Handlers?: TicketsUpdateHandlersInput | string[]
    TranscriptChannelId?: StringFieldUpdateOperationsInput | string
    TranscriptHTML?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNotes?: TicketsUpdateTicketNotesInput | string[]
  }

  export type ApisCreateManyUsersInput = {
    id?: string
    Flags?: ApisCreateFlagsInput | string[]
    Guilds?: ApisCreateGuildsInput | string[]
    Key: string
  }

  export type GuildBackupsCreateManyUsersInput = {
    id?: string
    BackupJSON: InputJsonValue
    CreatedAt: Date | string
    UUID: string
    Name: string
    GuildId: string
  }

  export type CustomersCreateManyUsersInput = {
    id?: string
    ExternalUUID: string
    RealUUID: string
    Application: string
    BotStatus: XOR<BotStatusCreateEnvelopeInput, BotStatusCreateInput>
    DisplayName: string
    GuildIds?: CustomersCreateGuildIdsInput | string[]
    ServerPort: string
    WSAPI: string
  }

  export type VanitysCreateManyUsersInput = {
    id?: string
    UUID: string
    Slug: string
    Host: string
    GuildId: string
    Invite: string
    CreatedAt: Date | string
  }

  export type ApisUpdateWithoutUsersInput = {
    Flags?: ApisUpdateFlagsInput | string[]
    Guilds?: ApisUpdateGuildsInput | string[]
    Key?: StringFieldUpdateOperationsInput | string
  }

  export type ApisUncheckedUpdateWithoutUsersInput = {
    Flags?: ApisUpdateFlagsInput | string[]
    Guilds?: ApisUpdateGuildsInput | string[]
    Key?: StringFieldUpdateOperationsInput | string
  }

  export type ApisUncheckedUpdateManyWithoutUsersInput = {
    Flags?: ApisUpdateFlagsInput | string[]
    Guilds?: ApisUpdateGuildsInput | string[]
    Key?: StringFieldUpdateOperationsInput | string
  }

  export type GuildBackupsUpdateWithoutUsersInput = {
    BackupJSON?: InputJsonValue | InputJsonValue
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UUID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type GuildBackupsUncheckedUpdateWithoutUsersInput = {
    BackupJSON?: InputJsonValue | InputJsonValue
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UUID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type GuildBackupsUncheckedUpdateManyWithoutUsersInput = {
    BackupJSON?: InputJsonValue | InputJsonValue
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UUID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
  }

  export type CustomersUpdateWithoutUsersInput = {
    ExternalUUID?: StringFieldUpdateOperationsInput | string
    RealUUID?: StringFieldUpdateOperationsInput | string
    Application?: StringFieldUpdateOperationsInput | string
    BotStatus?: XOR<BotStatusUpdateEnvelopeInput, BotStatusCreateInput>
    DisplayName?: StringFieldUpdateOperationsInput | string
    GuildIds?: CustomersUpdateGuildIdsInput | string[]
    ServerPort?: StringFieldUpdateOperationsInput | string
    WSAPI?: StringFieldUpdateOperationsInput | string
  }

  export type CustomersUncheckedUpdateWithoutUsersInput = {
    ExternalUUID?: StringFieldUpdateOperationsInput | string
    RealUUID?: StringFieldUpdateOperationsInput | string
    Application?: StringFieldUpdateOperationsInput | string
    BotStatus?: XOR<BotStatusUpdateEnvelopeInput, BotStatusCreateInput>
    DisplayName?: StringFieldUpdateOperationsInput | string
    GuildIds?: CustomersUpdateGuildIdsInput | string[]
    ServerPort?: StringFieldUpdateOperationsInput | string
    WSAPI?: StringFieldUpdateOperationsInput | string
  }

  export type CustomersUncheckedUpdateManyWithoutUsersInput = {
    ExternalUUID?: StringFieldUpdateOperationsInput | string
    RealUUID?: StringFieldUpdateOperationsInput | string
    Application?: StringFieldUpdateOperationsInput | string
    BotStatus?: XOR<BotStatusUpdateEnvelopeInput, BotStatusCreateInput>
    DisplayName?: StringFieldUpdateOperationsInput | string
    GuildIds?: CustomersUpdateGuildIdsInput | string[]
    ServerPort?: StringFieldUpdateOperationsInput | string
    WSAPI?: StringFieldUpdateOperationsInput | string
  }

  export type VanitysUpdateWithoutUsersInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Slug?: StringFieldUpdateOperationsInput | string
    Host?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    Invite?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Analytics?: VanityAnalyticsUpdateOneWithoutVanitysNestedInput
    Embed?: VanityEmbedsUpdateOneWithoutVanitysNestedInput
  }

  export type VanitysUncheckedUpdateWithoutUsersInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Slug?: StringFieldUpdateOperationsInput | string
    Host?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    Invite?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Analytics?: VanityAnalyticsUncheckedUpdateOneWithoutVanitysNestedInput
    Embed?: VanityEmbedsUncheckedUpdateOneWithoutVanitysNestedInput
  }

  export type VanitysUncheckedUpdateManyWithoutUsersInput = {
    UUID?: StringFieldUpdateOperationsInput | string
    Slug?: StringFieldUpdateOperationsInput | string
    Host?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    Invite?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisbotsLogsUpdateInput = {
    Action?: StringFieldUpdateOperationsInput | string
    BotType?: StringFieldUpdateOperationsInput | string
    ChannelId?: StringFieldUpdateOperationsInput | string
    GuildId?: StringFieldUpdateOperationsInput | string
    Label?: StringFieldUpdateOperationsInput | string
    Level?: StringFieldUpdateOperationsInput | string
    Message?: StringFieldUpdateOperationsInput | string
    MessageId?: StringFieldUpdateOperationsInput | string
    Timestamp?: StringFieldUpdateOperationsInput | string
    UUID?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}